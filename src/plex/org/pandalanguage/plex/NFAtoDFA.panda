package org.pandalanguage.plex

uses org.pandalanguage.plex.AcceptState
uses org.pandalanguage.plex.NFA
uses org.pandalanguage.plex.RemappedState
uses org.pandalanguage.plex.runtime.DFA

class DFAStateLabel {
    def states:List<Int>

    constructor(states:List<Int>) {
        self.states := states
    }

    @override
    function hash():Int {
        var result := 0
        for s in states
            result ~~= s
        return result
    }

    @override
    function =(raw:Object):Bit {
        var other := raw->(DFAStateLabel)
        if other.states.length != states.length
            return false
        for i in 0 .. states.length {
            if other.states[i] != states[i]
                return false
        }
        return true
    }

    @override
    function ->>():String {
        var result := "<"->>(MutableString)
        for i, s in states {
            if i > 0
                result.append(", ")
            result.append(s)
        }
        result.append(">")
        return result->>(String)
    }
}

class DFAState {
    def id:Int
    def label:DFAStateLabel
    var scanned:Bit

    constructor(id:Int, label:DFAStateLabel) {
        self.id := id
        self.label := label
    }

    @override
    function ->>():String {
        def result := class.name->>(MutableString)
        result.append("<")
        result.append(id)
        result.append(", ")
        result.append(label)
        result.append(">")
        return result->>(String)
    }
}

class NFAtoDFA {
    var nfa:NFA
    def states := new HashMap<DFAStateLabel, DFAState>()
    def transitions := new Array<List<Int>>()
    def accepts := new Array<Int>()

    constructor(nfa:NFA) {
        self.nfa := nfa
    }

    method getState(label:DFAStateLabel):DFAState {
        var result := states[label]
        if result = null {
            result := new DFAState(states.length, label)
            states[label] := result
        }
        return result
    }

    method add(nfaState:Int, states:List<Int>) {
        def state := nfa.states[nfaState]
        if state-?>(RemappedState) {
            def next := state->(RemappedState).states
            for n in next
                add(n, states)
        }
        else {
            for s in states {
                if s = nfaState
                    return
            }
            states.add(nfaState)
        }
    }

    method addTransition(c:Char, start:Int, next:Int) {
        while transitions.length <= c->(Int)
            transitions.add(new Array<Int>())
        var a := transitions[c->(Int)]
        while a.length <= start
            a.add(-1)
        assert a[start] = -1
        a[start] := next
    }

    @private
    @class
    @limited
    method swap(a:List<Object>, i1:Int, i2:Int) {
        def tmp := a[i1]
        a[i1] := a[i2]
        a[i2] := tmp
    }

    @private
    @class
    @limited
    method sort(a:List<Object>, left:Int, right:Int, 
            greater:(Object, Object)=>(Bit)) {
        if left >= right
            return
        def pivotIndex := left + (right - left) // 2
        def pivot := a[pivotIndex]
        swap(a, right, pivotIndex)
        var storeIndex := left
        for i in left ... right - 1 {
            if !greater(a[i], pivot) {
                swap(a, i, storeIndex)
                storeIndex += 1
            }
        }
        swap(a, storeIndex, right)
        sort(a, left, storeIndex - 1, greater)
        sort(a, storeIndex + 1, right, greater)
    }

    ============================================================================
    Quick and dirty naive quicksort, until generics are done and ListView can be 
    sorted natively.
    ============================================================================
    @class
    @limited
    method sort(a:List<Object>, greater:(Object, Object)=>(Bit)) {
        sort(a, 0, a.length - 1, greater)
    }    

    @class
    @limited
    -- FIXME replace this with real sort when it's available
    method sort(a:List<Int>) {
        def objects := new Array<Object>()
        for i in a
            objects.add(i)
        sort(objects, (x, y) => x->(Int) > y->(Int))
        a.clear()
        for i in objects
            a.add(i->(Int))
    }

    method scanState(state:DFAState) {
        state.scanned := true
        for c in 9->(Char) ... 127->(Char)  {
            def next := new Array<Int>()
            var bestAccept := Int32.MAX
            for idx in state.label.states {
                def nfaState := nfa.states[idx]
                if nfaState.accept(c) {
                    outer: for nextState in nfaState.next {
                        if nfa.states[nextState]-?>(AcceptState) {
                            bestAccept := bestAccept.min(
                                    nfa.states[nextState]->(AcceptState).token)
                        }
                        add(nextState, next)
                    }
                }
            }

            sort(next)
            def nextState := getState(new DFAStateLabel(next))
            addTransition(c, state.id, nextState.id)
            if bestAccept < Int32.MAX {
                while accepts.length <= nextState.id
                    accepts.add(-1)
                accepts[nextState.id] := bestAccept
            }
            if !nextState.scanned
                scanState(nextState)
        }
    }

    method createDFA():DFA {
        -- create state 0, the "reject" state
        getState(new DFAStateLabel(new Array<Int>()))
        -- map DFA states to the set of NFA states each represents
        def startStates := new Array<Int>()
        for i in 0 .. nfa.startStates.length
            startStates.add(nfa.startStates[i])
        sort(startStates)
        -- state 1 is the start state
        def start := getState(new DFAStateLabel(startStates))
        scanState(start)

        def outTransitions := new Array<ImmutableArray<Int>>()
        for t in transitions {
            outTransitions.add(new ImmutableArray<Int>(t))
        }
        return new DFA(new ImmutableArray<ImmutableArray<Int>>(outTransitions), 
                new ImmutableArray<Int>(accepts))
    }
}