package org.pandalanguage.plex

uses org.pandalanguage.plex.runtime.DFA

====================================================================================================
A simple lexical analyzer generator for Panda, used to build pandac's lexer.
====================================================================================================
class PLex {
    def tokens := HashMap<String, Regex>()

    method process(input:InputStream, rawOut:OutputStream) {
        def out := IndentedOutputStream(rawOut)
        def nfa := NFA()
        out.printLine("package org.pandalanguage.pandac.parser")
        out.printLine()
        out.printLine("uses panda.unsafe.Pointer")
        out.printLine("uses org.pandalanguage.plex.runtime.DFA")
        out.printLine("uses org.pandalanguage.plex.runtime.Position")
        out.printLine()
        out.printLine("class TokenKind { -- FIXME use choice")
        out.level += 1
        var offset := 0
        out.printLine("constant EOF := 0")
        offset += 1
        out.printLine("constant SHIFTRIGHT := 1")
        offset += 1
        for line in input.lines() {
            line := line.trimmed()
            if line.contains(":=") {
                def id := line[line.start() .. line.indexOf(":=")].trimmed()
                def pattern := line[line.offset(line.indexOf(":="), 2) .. line.end()].trimmed()
                def regex:Regex
                if pattern.startsWith('"') {
                    regex := Regex(escape(pattern[pattern.next(pattern.start()) ..
                            pattern.previous(pattern.end())]))
                }
                else {
                    assert pattern.startsWith("/") & pattern.endsWith("/")
                    regex := Regex(pattern[pattern.next(pattern.start()) ..
                            pattern.previous(pattern.end())])
                }
                out.printLine("constant \{id} := \{tokens.get_count() + 2}")
                def states := regex.addToNFA(nfa, nfa.addState(AcceptState(tokens.get_count() +
                        offset)))
                for s in states {
                    nfa.addStartState(s)
                }
                tokens[id] := regex
            }
            else {
                assert line.utf8().get_count() = 0, "error parsing '\{line}'"
            }
        }
        out.printLine()
        out.level -= 1
        out.printLine("}")

        out.printLine()
        writeToken(out)
        out.printLine()

        def dfa := NFAtoDFA(nfa).createDFA()
        writeLexer(dfa, out)
        tokens.clear()
    }

    function escape(s:String):String {
        def result := MutableString()
        for c in s.utf8() {
            if "+*?|.()[]".contains(c) {
                result.append("\\")
            }
            result.append(c)
        }
        return result.convert()
    }

    method writeToken(out:IndentedOutputStream) {
        out.printLine("class Token : Immutable {")
        out.level += 1
        out.printLine("def kind:Int")
        out.printLine("def text:String")
        out.printLine("def position:Position")
        out.printLine()
        out.printLine("init(kind:Int, text:String, position:Position) {")
        out.level += 1
        out.printLine("self.kind := kind")
        out.printLine("self.text := text")
        out.printLine("self.position := position")
        out.level -= 1
        out.printLine("}")
        out.printLine()
        out.printLine("@override")
        out.printLine("function convert():String {")
        out.level += 1
        out.printLine("return text")
        out.level -= 1
        out.printLine("}")
        out.level -= 1
        out.printLine("}")
    }

    method writeLexer(dfa:DFA, out:IndentedOutputStream) {
        out.printLine("class Lexer {")
        out.level += 1
        out.printLine("def file:String")
        out.printLine()
        out.printLine("def dfa:DFA")
        out.printLine()
        out.printLine("init(file:String, input:InputStream) {")
        out.printLine("    self.file := file")
        out.printLine("    dfa := DFA(input, \{dfa.stateCount}, getTransitions(), " +
                "\{dfa.acceptCount}, getAccepts())")
        out.printLine("}")
        out.printLine()
        writeStateTable(dfa, out)
        out.printLine()
        out.printLine("method next():Token {")
        out.level += 1
        out.printLine("def raw := dfa.next()")
        out.printLine("return Token(raw.kind, raw.text, Position(file, raw.startLine, " +
                "raw.startColumn))")
        out.level -= 1
        out.printLine("}")
        out.level -= 1
        out.printLine("}")
    }

    method writeStateTable(dfa:DFA, out:IndentedOutputStream) {
        out.printLine("@class")
        out.printLine("function alloc(count:Int, fill:Int):Pointer<Int> {")
        out.printLine("    def result := Pointer<Int>.alloc(count)")
        out.printLine("    for i in 0 .. count {")
        out.printLine("        result[i] := fill")
        out.printLine("    }")
        out.printLine("    return result")
        out.printLine("}")
        out.printLine()
        out.printLine("@class")
        out.printLine("function getTransitions():Pointer<Pointer<Int>> {")
        out.level += 1
        out.printLine("def result := Pointer<Pointer<Int>>.alloc(\{DFA.END_CHAR + 1})")
        for i in 0 ... DFA.END_CHAR.convert()->Int {
            def a := dfa.transitions[i]
            def counts := Array<Int>(dfa.stateCount)
            for j in 0 .. dfa.stateCount {
                counts.add(0)
            }
            var maxIndex := 0
            for j in 0 .. dfa.stateCount {
                counts[a[j]] += 1
                if counts[a[j]] > counts[maxIndex] {
                    maxIndex := a[j]
                }
            }
            def fill := maxIndex
            out.printLine("result[\{i}] := alloc(\{dfa.stateCount}, \{fill})")
            for j in 0 .. dfa.stateCount {
                if a[j] != fill {
                    out.printLine("result[\{i}][\{j}] := \{a[j]}")
                }
            }
        }
        out.printLine("return result")
        out.level -= 1
        out.printLine("}")
        out.printLine()
        out.printLine("@class")
        out.printLine("function getAccepts():Pointer<Int> {")
        out.level += 1
        out.printLine("def result := Pointer<Int>.alloc(\{dfa.acceptCount})")
        for i in 0 .. dfa.acceptCount {
            out.printLine("result[\{i}] := \{dfa.accepts[i]}")
        }
        out.printLine("return result")
        out.level -= 1
        out.printLine("}")
    }

    @class
    method main() {
        def src := File("../src/plex/Panda.plex")
        def dst := File("org/pandalanguage/pandac/parser/Lexer.panda")
        dst.parent().createDirectories()
        PLex().process(src.openInputStream(), dst.openOutputStream())
    }
}