package panda.core

uses panda.unsafe.Pointer

---------------
-- IMPORTANT --
------------------------------------------------------------------------------
-- String and MutableString are assumed to have a compatible memory layout! --
-- See MutableString.finish().                                              --
------------------------------------------------------------------------------

@final
class MutableString {
    @private
    constant DEFAULT_SIZE := 32

    @private
    var data:Pointer<Char8>

    @private
    var length:Int

    @private
    var maxLength:Int

    -- for binary compatibility with String
    @private
    var dummy:String?

    init() {
        init(DEFAULT_SIZE)
    }

    init(s:String) {
        length := s._length
        maxLength := length + DEFAULT_SIZE
        data := Pointer<Char8>.alloc(maxLength)
        for i in 0 .. s._length {
            data[i] := s.data[i]
        }
    }

    init(capacity:Int) {
        length := 0
        maxLength := capacity
        data := Pointer<Char8>.alloc(maxLength)
    }

    @override
    @private
    method cleanup() {
        data.destroy()
    }

    method append(c:Char8) {
        ensureCapacity(length + 1)
        data[length] := c
        length += 1
    }

    method append(c:Char32) {
        def value := c.value
        if value < 0x80 {
            ensureCapacity(length + 1)
            data[length] := Char8(UInt8(value->builtin_uint8))
            length += 1
        }
        else if value < 0x800 {
            ensureCapacity(length + 2)
            data[length + 0] := Char8(UInt8((value >> 6 || 0b11000000)->builtin_uint8))
            data[length + 1] := Char8(UInt8((value && 0b111111 || 0b10000000)->builtin_uint8))
            length += 2
        }
        else if value < 0x10000 {
            ensureCapacity(length + 3)
            data[length + 0] := Char8(UInt8((value >> 12 || 0b11100000)->builtin_uint8))
            data[length + 1] := Char8(UInt8((value >> 6 && 0b111111 || 0b10000000)->builtin_uint8))
            data[length + 2] := Char8(UInt8((value && 0b111111 || 0b10000000)->builtin_uint8))
            length += 3
        }
        else {
            ensureCapacity(length + 4)
            data[length + 0] := Char8(UInt8((value >> 18 || 0b11110000)->builtin_uint8))
            data[length + 1] := Char8(UInt8((value >> 12 && 0b111111 || 0b10000000)->builtin_uint8))
            data[length + 2] := Char8(UInt8((value >> 6 && 0b111111 || 0b10000000)->builtin_uint8))
            data[length + 3] := Char8(UInt8((value && 0b111111 || 0b10000000)->builtin_uint8))
            length += 4
        }
    }

    method append(s:String) {
        ensureCapacity(length + s._length)
        for i in 0 .. s._length {
            data[length + i] := s.data[i]
        }
        length += s._length
    }

    method append(chars:Pointer<Char8>, offset:Int, count:Int) {
        ensureCapacity(length + count)
        for i in 0 .. count {
            data[length + i] := chars[offset + i]
        }
        length += count
    }

    method append(o:Object) {
        append(o.convert()->String)
    }

    @private
    method ensureCapacity(newSize:Int) {
        if maxLength >= newSize {
            return
        }
        while maxLength < newSize {
            maxLength *= 2
        }
        data := data.realloc(maxLength)
    }

    method clear() {
        data := data.realloc(DEFAULT_SIZE)
        length := 0
        maxLength := DEFAULT_SIZE
    }

    ================================================================================================
    Returns an immutable copy of this `MutableString`. Typically it is better to use [finish()] for
    performance reasons, as that does not make a copy.
    ================================================================================================
    @override
    function convert():String {
        def result := Pointer<Char8>.alloc(length)
        for i in 0 .. length {
            result[i] := data[i]
        }
        return String(result, length)
    }

    ================================================================================================
    Invalidates this `MutableString` and returns its contents as an immutable `String`. This is
    generally preferable to [convert()], as it does not copy the string's contents. Interacting in
    any way with a `MutableString` after `finish`ing will cause precondition violations.
    ================================================================================================
    method finish():String {
        -- FIXME this transformation is only safe at -S0
        data := data.realloc(length)
        maxLength := 0 -- maxLength and hash live at the same address, zero the hash
        self.$class := "".$class
        return self->Object->String
--        maxLength := -1
--        return String(data, length)
    }
}