package panda.core

uses panda.unsafe.Pointer

@final
class MutableString {
    @private
    constant DEFAULT_SIZE := 32

    @private
    var data:Pointer<Char8>

    @private
    var length:Int

    @private
    var maxLength:Int

    init() {
        init(DEFAULT_SIZE)
    }

    init(s:String) {
        length := 0
        maxLength := length + DEFAULT_SIZE
        data := Pointer<Char8>.alloc(maxLength)
        append(s)
    }

    init(capacity:Int) {
        length := 0
        maxLength := capacity
        data := Pointer<Char8>.alloc(maxLength)
    }

    @override
    @private
    method cleanup() {
        data.destroy()
    }

    method append(c:Char8) {
        ensureCapacity(length + 1)
        data[length] := c
        length += 1
    }

    method append(c:Char32) {
        def value := c.value
        if value < 0x80 {
            ensureCapacity(length + 1)
            data[length] := Char8(UInt8(value->builtin_uint8))
            length += 1
        }
        else if value < 0x800 {
            ensureCapacity(length + 2)
            data[length + 0] := Char8(UInt8((value >> 6 || 0b11000000)->builtin_uint8))
            data[length + 1] := Char8(UInt8((value && 0b111111 || 0b10000000)->builtin_uint8))
            length += 2
        }
        else if value < 0x10000 {
            ensureCapacity(length + 3)
            data[length + 0] := Char8(UInt8((value >> 12 || 0b11100000)->builtin_uint8))
            data[length + 1] := Char8(UInt8((value >> 6 && 0b111111 || 0b10000000)->builtin_uint8))
            data[length + 2] := Char8(UInt8((value && 0b111111 || 0b10000000)->builtin_uint8))
            length += 3
        }
        else {
            ensureCapacity(length + 4)
            data[length + 0] := Char8(UInt8((value >> 18 || 0b11110000)->builtin_uint8))
            data[length + 1] := Char8(UInt8((value >> 12 && 0b111111 || 0b10000000)->builtin_uint8))
            data[length + 2] := Char8(UInt8((value >> 6 && 0b111111 || 0b10000000)->builtin_uint8))
            data[length + 3] := Char8(UInt8((value && 0b111111 || 0b10000000)->builtin_uint8))
            length += 4
        }
    }

    method append(s:String) {
        ensureCapacity(length + s._length)
        for i in 0 .. s._length {
            data[length + i] := s.data[i]
        }
        length += s._length
    }

    method append(chars:Pointer<Char8>, offset:Int, count:Int) {
        ensureCapacity(length + count)
        for i in 0 .. count {
            data[length + i] := chars[offset + i]
        }
        length += count
    }

    method append(o:Object) {
        append(o.convert()->String)
    }

    @private
    method ensureCapacity(newSize:Int) {
        if maxLength >= newSize {
            return
        }
        while maxLength < newSize {
            maxLength *= 2
        }
        data := data.realloc(maxLength)
    }

    method clear() {
        if valid() {
            data := data.realloc(DEFAULT_SIZE)
        }
        else {
            data := Pointer<Char8>.alloc(DEFAULT_SIZE)
        }
        length := 0
        maxLength := DEFAULT_SIZE
    }

    ================================================================================================
    Returns an immutable copy of this `MutableString`. Typically it is better to use [finish()] for
    performance reasons, as that does not make a copy.
    ================================================================================================
    @override
    function convert():String {
        def result := Pointer<Char8>.alloc(length)
        for i in 0 .. length {
            result[i] := data[i]
        }
        return String(result, length)
    }

    ================================================================================================
    Invalidates this `MutableString` and returns its contents as an immutable `String`. This is
    generally preferable to [convert()], as it does not copy the string's contents. Interacting with
    a `MutableString` after `finish`ing it, without first issuing a [clear()], violates its
    preconditions.
    ================================================================================================
    method finish():String {
        def result := String(data, length)
        maxLength := -1
        return result
    }

    function valid():Bit {
        return maxLength >= 0
    }
}