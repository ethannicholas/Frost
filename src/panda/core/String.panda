package panda.core

class String {
    @private
    init(data:Pointer<Char8>, size:Int) {
        self.data := data
        self.size := size
    }

    @override
    function convert():String {
        return self
    }

    @override
    @private
    method cleanup() {
        data.destroy()
    }

    function startsWith(other:String):Bit {
        if size < other.size {
            return false
        }
        for i in 0 .. other.size {
            if data[i] != other.data[i] {
                return false
            }
        }
        return true
    }

    function endsWith(other:String):Bit {
        if size < other.size {
            return false
        }
        for i in 0 .. other.size {
            if data[size - other.size + i] != other.data[i] {
                return false
            }
        }
        return true
    }

    function +(other:String):String {
        def result := Pointer<Char8>.alloc(size + other.size)
        for i in 0 .. size {
            result[i] := data[i]
        }
        for i in 0 .. other.size {
            result[size + i] := other.data[i]
        }
        return String(result, size + other.size)
    }

    function +(other:Object):String {
        return self + other.convert()->String
    }

    @class
    function +(o:Object, s:String):String {
        return o.convert() + s
    }

    function =(other:String):Bit {
        if size != other.size {
            return false
        }
        for i in 0 .. size {
            if data[i]->Char8 != other.data[i]->Char8 {
                return false
            }
        }
        return true
    }

    function [](r:Range<Int?>):String {
        def step:Int
        if r.step != null {
            step := r.step
        }
        else {
            step := 1
        }

        def start:Int
        if r.start != null {
            start := r.start
        }
        else if step > 0 {
            start := 0
        }
        else {
            start := size - 1
        }

        def end:Int
        if r.end != null {
            end := r.end
            if r.inclusive {
                if step > 0 {
                    end += 1
                }
                else {
                    end -= 1
                }
            }
        }
        else if step > 0 {
            end := size
        }
        else {
            end := -1
        }

        def count:Int
        if step = 1 {
            count := end - start
        }
        else {
            count := 0
            for i in start .. end by step {
                count += 1
            }
        }
        def slice := Pointer<Char8>.alloc(count)
        var index := 0
        for i in start .. end by step {
            -- FIXME need range assert
            slice[index] := data[i]
            index += 1
        }
        return String(slice, count)
    }

    function hash():Int {
        return 0
    }

    @private
    def data:Pointer<Char8>

    @private
    def size:Int
}