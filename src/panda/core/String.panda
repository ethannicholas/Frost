package panda.core

uses panda.unsafe.Pointer

class String : Immutable {
    class Index : Value {
        @private
        def str:String

        @private
        def value:Int

        @private
        init(str:String, value:Int) {
            self.str := str
            self.value := value
        }

        function +(i:Int):Index {
            if i < 0 {
                return self - (-i)
            }
            var remaining := i
            var newValue := value
            while newValue < str.length - 1 & remaining > 0 {
                newValue += 1
                while str.data[newValue].convert()->Int8[7] {
                    newValue += 1
                }
                remaining -= 1
            }
        }

        function -(i:Int):Index {
            if i < 0 {
                return self + (-i)
            }
            var remaining := i
            var newValue := value
            while newValue > 0 & remaining > 0 {
                newValue -= 1
                while str.data[newValue].convert()->Int8[7] {
                    newValue -= 1
                }
                remaining -= 1
            }
        }
    }

    @private
    class UTF8List (ListView<Char8>) {
        def str:String

        init(str:String) {
            self.str := str
        }

        @override
        function [](index:Int):Char8 {
            return str.data[index]
        }

        @override
        function get_count():Int {
            return str.length
        }

        @override
        function iterator():Iterator<Char8> {
            return UTF8Iterator(str)
        }
    }

    @private
    class UTF8Iterator (Iterator<Char8>) {
        var index := 0

        def str:String

        init(str:String) {
            self.str := str
        }

        @override
        function get_done():Bit {
            return index = str.length
        }

        @override
        function next():Char8 {
            index += 1
            return str.data[index - 1]
        }
    }

    @private
    class UTF16Iterator (Iterator<Char16>) {
        var index := 0

        def str:String

        init(str:String) {
            self.str := str
        }

        @override
        function get_done():Bit {
            return index = str.length
        }

        @override
        function next():Char16 {
            index += 1
            return Char16(1)
        }
    }

    @private
    class UTF32Iterator (Iterator<Char32>) {
        var index := 0

        def str:String

        init(str:String) {
            self.str := str
        }

        @override
        function get_done():Bit {
            return index = str.length
        }

        @override
        function next():Char32 {
            index += 1
            return Char32(1)
        }
    }
    @private
    def data:Pointer<Char8>

    @private
    def length:Int

    @private
    init(data:Pointer<Char8>, length:Int) {
        self.data := data
        self.length := length
    }

    @override
    function convert():String {
        return self
    }

    @override
    @private
    method cleanup() {
        data.destroy()
    }

    function utf8():ListView<Char8> {
        return UTF8List(self)
    }

    function utf16():Iterator<Char16> {
        return UTF16Iterator(self)
    }

    function utf32():Iterator<Char32> {
        return UTF32Iterator(self)
    }

    function startsWith(other:String):Bit {
        if length < other.length {
            return false
        }
        for i in 0 .. other.length {
            if data[i] != other.data[i] {
                return false
            }
        }
        return true
    }

    function endsWith(other:String):Bit {
        if length < other.length {
            return false
        }
        for i in 0 .. other.length {
            if data[length - other.length + i] != other.data[i] {
                return false
            }
        }
        return true
    }

    function +(other:String):String {
        def result := Pointer<Char8>.alloc(length + other.length)
        for i in 0 .. length {
            result[i] := data[i]
        }
        for i in 0 .. other.length {
            result[length + i] := other.data[i]
        }
        return String(result, length + other.length)
    }

    function +(other:Object):String {
        return self + other.convert()->String
    }

    function *(count:Int):String {
        def result := MutableString()
        for i in 0 .. count {
            result.append(self)
        }
        return result.convert()
    }

    @class
    function +(o:Object, s:String):String {
        return o.convert() + s
    }

    @override
    function =(o:Object):Bit {
        -- FIXME need to check o's class
        def other := o->String
        if length != other.length {
            return false
        }
        for i in 0 .. length {
            if data[i]->Char8 != other.data[i]->Char8 {
                return false
            }
        }
        return true
    }

    function [](r:Range<Index?>):String {
        def step:Int
        if r.step != null {
            step := r.step
        }
        else {
            step := 1
        }

        def start:Int
        if r.start != null {
            start := r.start.value
        }
        else if step > 0 {
            start := 0
        }
        else {
            start := length - 1
        }

        def end:Int
        if r.end != null {
            end := r.end.value
            if r.inclusive {
                if step > 0 {
                    end += 1
                }
                else {
                    end -= 1
                }
            }
        }
        else if step > 0 {
            end := length
        }
        else {
            end := -1
        }

        def count:Int
        if step = 1 {
            count := end - start
        }
        else {
            count := 0
            for i in start .. end by step {
                count += 1
            }
        }
        def slice := Pointer<Char8>.alloc(count)
        var index := 0
        for i in start .. end by step {
            assert index >= 0 & index < length
            slice[index] := data[i]
            index += 1
        }
        return String(slice, count)
    }

    ================================================================================================
    Returns the index of the first occurrence of the string `s` within this string, or `null` if not
    found.

    @param s the string to search for
    @returns the index of the match, or `null` if not found
    ================================================================================================
    function indexOf(s:String):Index? {
        return indexOf(s, Index(self, 0))
    }

    ================================================================================================
    Returns the index of the first occurrence of the string `s` within this string, starting from
    the specified `index`, or `null` if not found.

    @param s the string to search for
    @param start the index to begin searching from
    @returns the index of the match, or `null` if not found
    ================================================================================================
    function indexOf(s:String, start:Index):Index? {
        if length < s.length {
            return null
        }
        outer: for i in start.value ... length - s.length {
            for j in 0 .. s.length {
                if data[i + j] != s.data[j] {
                    continue outer
                }
            }
            return Index(self, i)
        }
        return null
    }

    ================================================================================================
    Splits this string into tokens separated by a delimiter. For instance,
    `"This is a long string".split(" ")` yields `"This"`, `"is"`, `"a"`, `"long"`, and `"string"`.

    @param delimiter the token delimiter
    @returns the split tokens
    ================================================================================================
    function split(delimiter:String):Array<String> {
        return split(delimiter, Int.MAX)
    }

    ================================================================================================
    Splits this string into tokens separated by a delimiter. At most `maxResults` results will be
    returned; any additional delimiters beyond that point will be ignored. For instance,
    `"This is a long string".split(" ", 3)` yields `"This"`, `"is"`, and `"a long string"`.

    @param delimiter the token delimiter
    @param maxResults the maximum number of results to return
    @returns the split tokens
    ================================================================================================
    function split(delimiter:String, maxResults:Int):Array<String> {
        def result := Array<String>()
        var index := Index(self, 0)
        loop {
            def nextIndex:Index?
            if delimiter.length = 0 {
                nextIndex := index + 1
            }
            else {
                nextIndex := indexOf(delimiter, index)
            }
            if nextIndex = null | result.count = maxResults - 1 {
                result.add(self[index..])
                break
            }
            result.add(self[index .. nextIndex])
            index := nextIndex + delimiter.length
        }
        return result
    }

    ================================================================================================
    Converts this string to a number. The string must be a sequence of decimal digits, optionally
    preceded by a minus sign (`-`), whose numeric representation can fit into an `Int64`. Returns
    `null` if the conversion fails.

    @returns this string converted to a number, or `null`
    ================================================================================================
    function convert():Int64? {
        if length = 0 {
            return null
        }
        var result:Int64 := 0
        var start:Int
        if data[0] = Char8(45) {
            start := 1
        }
        else {
            start := 0
        }
        for i in start .. length {
            def digit := Int64(data[i].value->builtin_int64) - 48
            if digit < 0 | digit > 9 {
                return null
            }
            result := result * 10 + digit
        }
        if data[0] = Char8(45) {
            result := -result
        }
        return result
    }

    @override
    function hash():Int {
        var result := 0
        for i in 0 .. length {
            result := result * 101 + Int64(data[i].value->builtin_int64)
        }
        return result
    }
}