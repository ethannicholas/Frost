package panda.core

uses panda.unsafe.Pointer

====================================================================================================
An immutable sequence of Unicode characters.
====================================================================================================
class String : Immutable (Key<String>) {
    ================================================================================================
    Represents the position of a character within a String.
    ================================================================================================
    class Index : Value (Key<Index>) {
        @private
        def value:Int

        @private
        init(value:Int) {
            self.value := value
        }

        @override
        function =(other:Index):Bit {
            return value = other.value
        }

        @override
        function !=(other:Index):Bit {
            return !(self = other)
        }

        @override
        function hash():Int {
            return value
        }
    }

    @private
    class UTF8List (ListView<Char8>) {
        def str:String

        init(str:String) {
            self.str := str
        }

        @override
        function [](index:Int):Char8 {
            return str.data[index]
        }

        @override
        function get_count():Int {
            return str._length
        }

        @override
        function iterator():Iterator<Char8> {
            return UTF8Iterator(str)
        }
    }

    @private
    class UTF8Iterator (Iterator<Char8>) {
        var index := 0

        def str:String

        init(str:String) {
            self.str := str
        }

        @override
        function get_done():Bit {
            return index = str._length
        }

        @override
        function next():Char8 {
            index += 1
            return str.data[index - 1]
        }
    }

    @private
    class UTF16Iterator (Iterator<Char16>) {
        var index := 0

        def str:String

        init(str:String) {
            self.str := str
        }

        @override
        function get_done():Bit {
            return index = str._length
        }

        @override
        function next():Char16 {
            index += 1
            return Char16(1)
        }
    }

    @private
    class UTF32Iterator (Iterator<Char32>) {
        var index := 0

        def str:String

        init(str:String) {
            self.str := str
        }

        @override
        function get_done():Bit {
            return index = str._length
        }

        @override
        function next():Char32 {
            index += 1
            return Char32(1)
        }
    }
    @private
    def data:Pointer<Char8>

    @private
    def _length:Int

    @private
    init(data:Pointer<Char8>, length:Int) {
        self.data := data
        _length := length
    }

    init(chars:ListView<Char8>) {
        _length := chars.get_count()
        data := Pointer<Char8>.alloc(_length)
        for i in 0 .. _length {
            data[i] := chars[i]
        }
    }

    @override
    function convert():String {
        return self
    }

    @override
    @private
    method cleanup() {
        data.destroy()
    }

    function utf8():ListView<Char8> {
        return UTF8List(self)
    }

    function utf16():Iterator<Char16> {
        return UTF16Iterator(self)
    }

    function utf32():Iterator<Char32> {
        return UTF32Iterator(self)
    }

    function startsWith(other:String):Bit {
        if _length < other._length {
            return false
        }
        for i in 0 .. other._length {
            if data[i] != other.data[i] {
                return false
            }
        }
        return true
    }

    function endsWith(other:String):Bit {
        if _length < other._length {
            return false
        }
        for i in 0 .. other._length {
            if data[_length - other._length + i] != other.data[i] {
                return false
            }
        }
        return true
    }

    ============================================================================
    Returns a copy of this string with leading and trailing whitespace
    characters removed.

    @returns a trimmed version of this string
    ============================================================================
    function trimmed():String {
        if _length = 0 {
            return self
        }
        var start := 0
        while start < _length & data[start].isWhitespace() {
            start += 1
        }

        var end := _length - 1
        while end >= start & data[end].isWhitespace() {
            end -= 1
        }

        return self[Index(start) ... Index(end)]
    }

    function +(other:String):String {
        def result := Pointer<Char8>.alloc(_length + other._length)
        for i in 0 .. _length {
            result[i] := data[i]
        }
        for i in 0 .. other._length {
            result[_length + i] := other.data[i]
        }
        return String(result, _length + other._length)
    }

    function +(other:Object):String {
        return self + other.convert()->String
    }

    function *(count:Int):String {
        def result := MutableString()
        for i in 0 .. count {
            result.append(self)
        }
        return result.convert()
    }

    @class
    function +(o:Object, s:String):String {
        return o.convert() + s
    }

    @override
    function =(other:String):Bit {
        if _length != other._length {
            return false
        }
        for i in 0 .. _length {
            if data[i]->Char8 != other.data[i]->Char8 {
                return false
            }
        }
        return true
    }

    @override
    function !=(other:String):Bit {
        return !(self = other)
    }

    function [](index:Index):Char32 {
        def idx := index.value
        def c := data[idx]
        var result:Int32 := c.convert()
        if c.value->builtin_int64 && 0xFF < 0b11000000 {
            return Char32(result)
        }
        if c.value->builtin_int64 && 0xFF < 0b11100000 {
            assert idx + 1 < _length
            result := result && 0b11111 << 6 + data[idx + 1].convert()->Int32 && 0b111111
            return Char32(result)
        }
        if c.value->builtin_int64 && 0xFF < 0b11110000 {
            assert idx + 2 < _length
            result := result && 0b1111 << 12 + data[idx + 1].convert()->Int32 && 0b111111 << 6 +
                    data[idx + 2].convert()->Int32 && 0b111111
            return Char32(result)
        }
        assert idx + 3 < _length
        result := result && 0b111 << 18 + data[idx + 1].convert()->Int32 && 0b111111 << 12 +
                data[idx + 2].convert()->Int32 && 0b111111 << 6 +
                data[idx + 3].convert()->Int32 && 0b111111
        return Char32(result)
    }

    ================================================================================================
    Returns a substring of a string. The `Range.step` value is interpreted in terms of Unicode
    codepoints: that is, `s[... by 2]` will return a `String` consisting of every other Unicode
    codepoint in `s`. As some Unicode characters consist of more than one codepoint (e.g. when using
    combining diacriticals, Emoji skin tone modifiers, or Emoji flags), this will mangle such
    characters when the step is not `1`.
    ================================================================================================
    function [](r:Range<Index?>):String {
        def step := r.step

        def current:Int
        if r.start != null {
            current := r.start.value
        }
        else if step > 0 {
            current := start().value
        }
        else {
            current := previous(end()).value
        }

        def end:Int
        if r.end != null {
            end := r.end.value
        }
        else if step > 0 {
            end := self.end().value
        }
        else {
            end := self.start().value
        }

        def result := MutableString()
        if r.step > 0 {
            while current < end {
                def c := data[current]
                result.append(c)
                current += 1
                if c.value->builtin_int64 && 0xFF >= 0b11000000 {
                    result.append(data[current])
                    current += 1
                }
                if c.value->builtin_int64 && 0xFF >= 0b11100000 {
                    result.append(data[current])
                    current += 1
                }
                if c.value->builtin_int64 && 0xFF >= 0b11110000 {
                    result.append(data[current])
                    current += 1
                }
                for i in 1 .. step {
                    if current >= end {
                        return result.convert()
                    }
                    current := next(Index(current)).value
                }
            }
        }
        else {
            assert r.step < 0
            while current > end {
                def c := data[current]
                result.append(c)
                def old := current
                current += 1
                if c.value->builtin_int64 && 0xFF >= 0b11000000 {
                    result.append(data[current])
                    current += 1
                }
                if c.value->builtin_int64 && 0xFF >= 0b11100000 {
                    result.append(data[current])
                    current += 1
                }
                if c.value->builtin_int64 && 0xFF >= 0b11110000 {
                    result.append(data[current])
                }
                current := old - 1
                while data[current].value->builtin_int64 && 0xFF >= 0b10000000 & data[current].value->builtin_int64 && 0xFF < 0b11000000 {
                    current -= 1
                }
                for i in -1 .. step by -1 {
                    if current <= end {
                        return result.convert()
                    }
                    current := previous(Index(current)).value
                }
            }
        }
        if (r.inclusive | r.end = null) & current = end & end < _length {
            def c := data[current]
            result.append(c)
            current += 1
            if c.value->builtin_int64 && 0xFF >= 0b11000000 {
                result.append(data[current])
                current += 1
            }
            if c.value->builtin_int64 && 0xFF >= 0b11100000 {
                result.append(data[current])
                current += 1
            }
            if c.value->builtin_int64 && 0xFF >= 0b11110000 {
                result.append(data[current])
            }
        }
        return result.convert()
    }

    function contains(c:Char8):Bit {
        for i in 0 .. _length {
            if data[i] = c {
                return true
            }
        }
        return false
    }

    function contains(s:String):Bit {
        return indexOf(s) != null
    }

    ================================================================================================
    Returns the index of the first occurrence of the string `s` within this string, or `null` if not
    found.

    @param s the string to search for
    @returns the index of the match, or `null` if not found
    ================================================================================================
    function indexOf(s:String):Index? {
        return indexOf(s, start())
    }

    ================================================================================================
    Returns the index of the first occurrence of the string `s` within this string, starting from
    the specified `index`, or `null` if not found.

    @param s the string to search for
    @param start the index to begin searching from
    @returns the index of the match, or `null` if not found
    ================================================================================================
    function indexOf(s:String, start:Index):Index? {
        if _length < s._length {
            return null
        }
        outer: for i in start.value ... _length - s._length {
            for j in 0 .. s._length {
                if data[i + j] != s.data[j] {
                    continue outer
                }
            }
            return Index(i)
        }
        return null
    }

    ================================================================================================
    Returns the index of the last occurrence of the string `s` within this string, or `null` if not
    found.

    @param s the string to search for
    @returns the index of the match, or `null` if not found
    ================================================================================================
    function lastIndexOf(s:String):Index? {
        return lastIndexOf(s, end())
    }

    ================================================================================================
    Returns the index of the last occurrence of the string `s` within this string, starting the
    search backwards from the specified `index`, or `null` if not found.

    @param s the string to search for
    @param start the index to begin searching from
    @returns the index of the match, or `null` if not found
    ================================================================================================
    function lastIndexOf(s:String, start:Index):Index? {
        if _length < s._length {
            return null
        }
        def startPos := start.value.min(_length - s._length)
        outer: for i in startPos ... 0 by -1 {
            for j in 0 .. s._length {
                if data[i + j] != s.data[j] {
                    continue outer
                }
            }
            return Index(i)
        }
        return null
    }

    ================================================================================================
    Returns a new string with every occurrence of `search` replaced with `replacement`.

    @param search the string to search for
    @param replacement the replacement text
    @returns a string with all matches replaced
    ================================================================================================
    function replace(search:String, replacement:String):String {
        def result := MutableString()
        var index := start()
        loop {
            def nextIndex := indexOf(search, index)
            if nextIndex = null {
                result.append(self[index..])
                break
            }
            result.append(self[index .. nextIndex])
            result.append(replacement)
            index := Index(nextIndex.value + search._length)
        }
        return result.convert()
    }

    ================================================================================================
    Returns the index of the first character in the string.
    ================================================================================================
    function start():Index {
        return Index(0)
    }

    ================================================================================================
    Returns the index just past the end of the string.
    ================================================================================================
    function end():Index {
        return Index(_length)
    }

    ================================================================================================
    Returns the index of the Unicode codepoint after the given index. It is an error to call
    `next()` when already at the end of the string. Note that because a logical character can
    consist of multiple Unicode codepoints (such as LATIN SMALL LETTER A followed by COMBINING ACUTE
    ACCENT), this may return an index in the middle of such a compound character.
    ================================================================================================
    function next(i:Index):Index {
        assert i.value < _length
        def c := data[i.value].value->builtin_int64 && 0xFF
        if c >= 0b11110000 {
            return Index(i.value + 4)
        }
        if c >= 0b11100000 {
            return Index(i.value + 3)
        }
        if c >= 0b11000000 {
            return Index(i.value + 2)
        }
        return Index(i.value + 1)
    }

    ================================================================================================
    Returns the index of the Unicode codepoint before the given index. It is an error to call
    `previous()` when already at the beginning of the string. Note that because a logical character
    can consist of multiple Unicode codepoints (such as LATIN SMALL LETTER A followed by COMBINING
    ACUTE ACCENT), this may return an index in the middle of such a compound character.
    ================================================================================================
    function previous(i:Index):Index {
        assert i.value > 0
        var newValue := i.value - 1
        while data[newValue].value->builtin_int64 && 0xFF >= 0b10000000 &
                data[newValue].value->builtin_int64 && 0xFF < 0b11000000 {
            newValue -= 1
        }
        return Index(newValue)
    }

    ================================================================================================
    Returns the index offset by `offset` Unicode codepoints. It is an error to index before the
    beginning or after the end of the string.  Note that because a logical character can consist of
    multiple Unicode codepoints (such as LATIN SMALL LETTER A followed by COMBINING ACUTE ACCENT),
    this may return an index in the middle of such a compound character.
    ================================================================================================
    function offset(index:Index, offset:Int):Index {
        var result := index
        if offset > 0 {
            for i in 0 .. offset {
                result := next(result)
            }
        }
        else {
            for i in 0 .. offset by -1 {
                result := previous(result)
            }
        }
        return result
    }

    ================================================================================================
    Splits this string into tokens separated by a delimiter. For instance,
    `"This is a long string".split(" ")` yields `"This"`, `"is"`, `"a"`, `"long"`, and `"string"`.

    @param delimiter the token delimiter
    @returns the split tokens
    ================================================================================================
    function split(delimiter:String):Array<String> {
        return split(delimiter, Int.MAX)
    }

    ================================================================================================
    Splits this string into tokens separated by a delimiter. At most `maxResults` results will be
    returned; any additional delimiters beyond that point will be ignored. For instance,
    `"This is a long string".split(" ", 3)` yields `"This"`, `"is"`, and `"a long string"`.

    @param delimiter the token delimiter
    @param maxResults the maximum number of results to return
    @returns the split tokens
    ================================================================================================
    function split(delimiter:String, maxResults:Int):Array<String> {
        def result := Array<String>()
        var index := start()
        loop {
            def nextIndex:Index?
            if delimiter._length = 0 {
                nextIndex := next(index)
            }
            else {
                nextIndex := indexOf(delimiter, index)
            }
            if nextIndex = null | result.count = maxResults - 1 {
                result.add(self[index..])
                break
            }
            result.add(self[index .. nextIndex])
            index := offset(nextIndex, delimiter._length)
        }
        return result
    }

    ================================================================================================
    Converts this string to a number. The string must be a sequence of decimal digits, optionally
    preceded by a minus sign (`-`), whose numeric representation can fit into an `Int64`. Returns
    `null` if the conversion fails.

    @returns this string converted to a number, or `null`
    ================================================================================================
    function convert():Int64? {
        if _length = 0 {
            return null
        }
        var result:Int64 := 0
        var start:Int
        if data[0] = Char8(45) {
            start := 1
        }
        else {
            start := 0
        }
        for i in start .. _length {
            def digit := Int64(data[i].value->builtin_int64) - 48
            if digit < 0 | digit > 9 {
                return null
            }
            result := result * 10 + digit
        }
        if data[0] = Char8(45) {
            result := -result
        }
        return result
    }

    ================================================================================================
    Converts this string to a number. The string must be a sequence of decimal digits whose numeric
    representation can fit into a `UInt64`. Returns `null` if the conversion fails.

    @returns this string converted to a number, or `null`
    ================================================================================================
    function convert():UInt64? {
        if _length = 0 {
            return null
        }
        var result:UInt64 := 0
        for i in 0 .. _length {
            def digit := UInt64(data[i].value->builtin_uint64) - 48
            if digit < 0 | digit > 9 {
                return null
            }
            result := result * 10 + digit
        }
        return result
    }

    @override
    function hash():Int {
        var result := 0
        for i in 0 .. _length {
            result := result * 101 + Int64(data[i].value->builtin_int64)
        }
        return result
    }
}