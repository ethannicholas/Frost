package panda.collections

uses panda.unsafe.Pointer

@final
class ImmutableArray<T> : ListView<T> {
    class ImmutableArrayIterator<T> : Iterator<T> {
        var array:ImmutableArray<T>

        var index := 0

        init(array:ImmutableArray<T>) {
            self.array := array
        }

        @override
        function get_done():Bit {
            return index = array.count
        }

        @override
        function next():T {
            index += 1
            return array[index - 1]
        }
    }

    @private
    def count:Int

    @private
    def dummy:Int -- for binary compatibility with Array

    @private
    def data:Pointer<T>

    init() {
        self.count := 0
        data := Pointer<T>.alloc(0)
    }

    init(data:ListView<T>) {
        self.count := data.get_count()
        self.data := Pointer<T>.alloc(count)
        for i in 0 .. count {
            self.data[i] := data[i]
        }
    }

    @private
    init(data:Pointer<T>, count:Int) {
        self.data := data
        self.count := count
    }

    @override
    method cleanup() {
        for i in 0 .. count {
            data[i] := null->T? -- FIXME this should be automatic
        }
        data.destroy()
    }

    @override
    function [](index:Int):T {
        assert index >= 0 & index < count
        return data[index]
    }

    @override
    function get_count():Int {
        return count
    }

    ================================================================================================
    Returns a slice of the array, containing all of the elements specified by the range.
    ================================================================================================
    function [](r:Range<Int>):ImmutableArray<T> {
        var max := r.max
        if r.inclusive {
            max += 1
        }
        def count := max - r.min
        def result := Pointer<T>.alloc(count)
        for i in 0 .. count {
            result[i] := self[r.min + i]
        }
        return ImmutableArray<T>(result, count)
    }

    ================================================================================================
    Returns a slice of the array, containing all of the elements specified by the range.

    As usual for `Range`, a null `min` starts from the beginning of the array, and a null `max` ends
    at the end of the array.
    ================================================================================================
    function [](r:Range<Int?>):ImmutableArray<T> {
        def start:Int
        if r.min != null {
            start := r.min
        }
        else {
            start := 0
        }

        var end:Int
        if r.max != null {
            end := r.max
        }
        else {
            end := get_count()
            if r.inclusive {
                end -= 1
            }
        }
        return self[Range<Int>(start, end, r.inclusive)]
    }

    ================================================================================================
    Returns a slice of the array, containing all of the elements specified by the range.
    ================================================================================================
    function [](r:SteppedRange<Int?, Int>):ImmutableArray<T> {
        def step := r.step

        def current:Int
        if r.start != null {
            current := r.start
        }
        else if step > 0 {
            current := 0
        }
        else {
            current := get_count() - 1
        }

        def end:Int
        if r.end != null {
            end := r.end
        }
        else if step > 0 {
            end := get_count()
        }
        else {
            end := 0
        }

        def result := Array<T>()
        if r.step > 0 {
            while current < end {
                result.add(self[current])
                current += step
            }
        }
        else {
            assert r.step < 0
            while current > end {
                result.add(self[current])
                current -= step
            }
        }
        if (r.inclusive | r.end = null) & current = end & end < get_count() {
            result.add(self[current])
        }
        return ImmutableArray<T>(result)
    }

    @override
    function iterator():Iterator<T> {
        return ImmutableArrayIterator<T>(self)
    }

    function join():String { -- FIXME move to ListView
        return join(", ")
    }

    function join(separator:String):String { -- FIXME move to ListView
        if count = 0 {
            return ""
        }
        def result := MutableString(self[0].convert())
        for i in 1 .. count {
            result.append(separator)
            result.append(self[i])
        }
        return result.finish()
    }

    @override
    function convert():String {
        def result := MutableString()
        result.append("[")
        var separator := ""
        for v in self {
            result.append(separator)
            separator := ", "
            result.append(v)
        }
        result.append("]")
        return result.finish()
    }
}
