package panda.collections

====================================================================================================
A read-only view of a collection of elements. A `CollectionView`'s elements are accessed via its
[iterator()].

@see CollectionWriter
@see Collection
@see ListView
====================================================================================================
interface CollectionView<T> : Iterable<T> {
    -- property count:Int

    function get_count():Int

    ================================================================================================
    Returns a comma-separated string containing all of the items in this collection, in iteration
    order. Equivalent to `join(", ")`.
    ================================================================================================
    function join():String {
        return join(", ")
    }

    ================================================================================================
    Converts all of the items in this collection to strings and concatenates them in iteration
    order, with the given separator between them. For instance, `[1, 2, 3].join("|")` returns
    `"1|2|3"`.

    @param separator the delimiter string
    ================================================================================================    
    function join(separator:String):String {
        if get_count() = 0 {
            return ""
        }
        var first := true
        def result := MutableString()
        for v in self {
            if first {
                first := false
            }
            else {
                result.append(separator)
            }
            if v != null {
                result.append(v)
            }
            else {
                result.append("<null>")
            }
        }
        return result.finish()
    }

    @pre(get_count() > 0)
    function fold(f:(T, T)=>(T)):T {
        def i := iterator()
        var result := i.next()
        while !i.get_done() {
            result := f(result, i.next())
        }
        return result
    }

    function fold(f:(T, T)=>(T), start:T):T {
        var result := start
        for v in self {
            result := f(result, v)
        }
        return result
    }

    method apply(m:(T)=&>()) {
        for v in self {
            m(v)
        }
    }
}
