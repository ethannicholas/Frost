package panda.collections

uses panda.unsafe.Pointer

interface ListView<T> : CollectionView<T> {
    @pre(index >= 0 & index < get_count())
    function [](index:Int):T

    ================================================================================================
    Returns a slice of the list, containing all of the elements specified by the range. The slice
    is an independent copy of the list and elements may be added to and removed from the original
    without affecting the copy. It is not, however, a deep copy, and thus both lists will refer
    to the same objects.
    ================================================================================================
    function [](r:Range<Int>):ListView<T> {
        var max := r.max
        if r.inclusive {
            max += 1
        }
        def count := max - r.min
        def result := Pointer<T>.alloc(count)
        for i in 0 .. count {
            result[i] := self[r.min + i]
        }
        return Array<T>(result, count)
    }

    ================================================================================================
    Returns a slice of the list, containing all of the elements specified by the range. The slice
    is an independent copy of the list and elements may be added to and removed from the original
    without affecting the copy. It is not, however, a deep copy, and thus both lists will refer
    to the same objects.

    As usual for `Range`, a null `min` starts from the beginning of the list, and a null `max` ends
    at the end of the list.
    ================================================================================================
    function [](r:Range<Int?>):ListView<T> {
        def start:Int
        if r.min != null {
            start := r.min
        }
        else {
            start := 0
        }

        var end:Int
        if r.max != null {
            end := r.max
        }
        else {
            end := get_count()
            if r.inclusive {
                end -= 1
            }
        }
        return self[Range<Int>(start, end, r.inclusive)]
    }

    ================================================================================================
    Returns a slice of the list, containing all of the elements specified by the range. The slice
    is an independent copy of the list and elements may be added to and removed from the original
    without affecting the copy. It is not, however, a deep copy, and thus both lists will refer
    to the same objects.
    ================================================================================================
    function [](r:SteppedRange<Int?, Int>):ListView<T> {
        def step := r.step

        def current:Int
        if r.start != null {
            current := r.start
        }
        else if step > 0 {
            current := 0
        }
        else {
            current := get_count() - 1
        }

        def end:Int
        if r.end != null {
            end := r.end
        }
        else if step > 0 {
            end := get_count()
        }
        else {
            end := 0
        }

        def result := Array<T>()
        if r.step > 0 {
            while current < end {
                result.add(self[current])
                current += step
            }
        }
        else {
            assert r.step < 0
            while current > end {
                result.add(self[current])
                current -= step
            }
        }
        if (r.inclusive | r.end = null) & current = end & end < get_count() {
            result.add(self[current])
        }
        return result
    }

    function join():String {
        return join(", ")
    }

    function join(separator:String):String {
        if get_count() = 0 {
            return ""
        }
        def result := MutableString(self[0].convert())
        for i in 1 .. get_count() {
            result.append(separator)
            if self[i] != null {
                result.append(self[i])
            }
            else {
                result.append("<null>")
            }
        }
        return result.finish()
    }
}
