package panda.collections

uses panda.unsafe.Pointer

====================================================================================================
A random-access `CollectionView` with numbered elements. Each entry has an index, ranging from `0`
to `count - 1`, by which it can be accessed.

@see ListWriter
@see List
====================================================================================================
interface ListView<T> : CollectionView<T> {
    @private
    class ListIterator<T> : Iterator<T> {
        var list:ListView<T>

        var index := 0

        init(list:ListView<T>) {
            self.list := list
        }

        @override
        function get_done():Bit {
            return index = list.count
        }

        @override
        function next():T {
            index += 1
            return list[index - 1]
        }
    }

    ================================================================================================
    Returns an item from this list.

    @param index the (zero-based) index of the item to return
    ================================================================================================    
    @pre(index >= 0 & index < count)
    function [](index:Int):T

    ================================================================================================
    Returns a slice of the list, containing all of the elements specified by the range. The slice
    is an independent copy of the list and elements may be added to and removed from the original
    without affecting the copy. It is not, however, a deep copy, and thus both lists will refer
    to the same objects.
    ================================================================================================
    @default
    function [](r:Range<Int>):ListView<T> {
        var max := r.max
        if r.inclusive {
            max += 1
        }
        def count := max - r.min
        def result := Pointer<T>.alloc(count)
        for i in 0 .. count {
            result[i] := self[r.min + i]
        }
        return Array<T>(result, count)
    }

    ================================================================================================
    Returns a slice of the list, containing all of the elements specified by the range. The slice
    is an independent copy of the list and elements may be added to and removed from the original
    without affecting the copy. It is not, however, a deep copy, and thus both lists will refer
    to the same objects.

    As usual for `Range`, a null `min` starts from the beginning of the list, and a null `max` ends
    at the end of the list.
    ================================================================================================
    @default
    function [](r:Range<Int?>):ListView<T> {
        def start:Int
        if r.min !== null {
            start := r.min
        }
        else {
            start := 0
        }

        var end:Int
        if r.max !== null {
            end := r.max
        }
        else {
            end := count
            if r.inclusive {
                end -= 1
            }
        }
        return self[Range<Int>(start, end, r.inclusive)]
    }

    ================================================================================================
    Returns a slice of the list, containing all of the elements specified by the range. The slice
    is an independent copy of the list and elements may be added to and removed from the original
    without affecting the copy. It is not, however, a deep copy, and thus both lists will refer
    to the same objects.
    ================================================================================================
    @default
    function [](r:SteppedRange<Int?, Int>):ListView<T> {
        def step := r.step

        def current:Int
        if r.start !== null {
            current := r.start
        }
        else if step > 0 {
            current := 0
        }
        else {
            current := count - 1
        }

        def end:Int
        if r.end !== null {
            end := r.end
        }
        else if step > 0 {
            end := count
        }
        else {
            end := 0
        }

        def result := Array<T>()
        if r.step > 0 {
            while current < end {
                result.add(self[current])
                current += step
            }
        }
        else {
            assert r.step < 0
            while current > end {
                result.add(self[current])
                current += step
            }
        }
        if (r.inclusive | r.end == null) & current = end & end < count {
            result.add(self[current])
        }
        return result
    }

    ================================================================================================
    Returns a new list containing every entry in this list for which the `predicate` function
    returns true. For instance, `[1, 7, -10, 5, -2].filter(x => x > 0)` returns `[1, 7, 5]`.
    ================================================================================================
    @default
    function filter(predicate:(T)=>(Bit)):ListView<T> {
        def result := Array<T>()
        for v in self {
            if predicate(v) {
                result.add(v)
            }
        }
        return result
    }

    @default
    @override
    function iterator():Iterator<T> {
        return ListIterator<T>(self)
    }
}
