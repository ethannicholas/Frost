package panda.collections

uses panda.unsafe.Pointer

@final
class Array<T> : List<T> {
    constant DEFAULT_CAPACITY := 16

    @private
    var count := 0

    @private
    var capacity:Int

    @private
    var data:Pointer<T>

    init() {
        init(DEFAULT_CAPACITY)
    }

    init(capacity:Int) {
        self.capacity := capacity
        data := Pointer<T>.alloc(capacity)
    }

    init(c:CollectionView<T>) {
        init(c.get_count().max(DEFAULT_CAPACITY))
        for v in c {
            add(v)
        }
    }

    @private
    init(data:Pointer<T>, count:Int) {
        self.data := data
        self.count := count
        self.capacity := count
    }

    @override
    method cleanup() {
        for i in 0 .. count {
            if data[i] != null {
                Panda.unref(data[i])
            }
        }
        data.destroy()
    }

    @override
    function [](index:Int):T {
        return data[index]
    }

    @override
    method []:=(index:Int, value:T) {
        data[index] := value
    }

    @override
    method insert(index:Int, value:T) {
        ensureCapacity(count + 1)
        for i in count .. index by -1 {
            data[i] := data[i - 1]
        }
        count += 1
        data[index] := value
    }

    @override
    method add(value:T) {
        ensureCapacity(count + 1)
        data[count] := value
        count += 1
    }

    @override
    method addAll(c:CollectionView<T>) {
        ensureCapacity(count + c.get_count())
        for v in c {
            data[count] := v
            count += 1
        }
    }

    method ensureCapacity(newCapacity:Int) {
        assert capacity > 0
        if newCapacity <= capacity {
            return
        }
        def oldCapacity := capacity
        while capacity < newCapacity {
            capacity *= 2
        }
        data := data.realloc(oldCapacity, capacity)
        for i in oldCapacity .. capacity {
            assert data[i] = null
        }
    }

    @override
    function get_count():Int {
        return count
    }

    @override
    method removeIndex(index:Int):T {
        def result := self[index]
        for i in index .. count - 1 {
            self[i] := self[i + 1]
        }
        count -= 1
        data[count] := null->T?
        return result
    }

    @override
    method clear() {
        count := 0
        for i in 0 .. capacity {
            data[i] := null->T?
        }
    }

    @override
    function convert():String {
        def result := MutableString()
        result.append("[")
        var separator := ""
        for v in self {
            result.append(separator)
            separator := ", "
            if v != null {
                result.append(v)
            }
            else {
                result.append("<null>")
            }
        }
        result.append("]")
        return result.finish()
    }

    ================================================================================================
    Invalidates this `Array` and returns its contents as an `ImmutableArray`. This is generally
    preferable to creating a new instance of `ImmutableArray` from this array, as `finish()` does
    not copy the array's contents. Interacting in any way with an `Array` after `finish`ing it will
    cause precondition violations (or, if safety checks are disabled, undefined behavior).
    ================================================================================================
    method finish():ImmutableArray<T> {
        -- FIXME this transformation is only safe at -S0
        data := data.realloc(capacity, count)
        self.$class := ImmutableArray<T>().$class
        self.capacity := -1
        return self->Object->ImmutableArray<T>
    }
}
