package panda.collections

uses panda.unsafe.Pointer

====================================================================================================
Standard implementation of the `List` interface. `Array` is a resizable random-access array,
featuring constant time reads and writes. Appending new elements to the array can be expensive, as
it may require the backing store to be increased in size which in turn may require a memory copy.

Particularly for bigger arrays, tt is best to avoid this expensive size increase by pre-allocating
the array with the expected number of elements it will contain using [init(Int)].
====================================================================================================
@final
class Array<T> : List<T> {
    @private
    constant DEFAULT_CAPACITY := 16

    @private
    var count := 0

    @private
    var capacity:Int

    @private
    var data:Pointer<T>

    ================================================================================================
    Creates a new, empty `Array`.
    ================================================================================================
    init() {
        init(DEFAULT_CAPACITY)
    }

    ================================================================================================
    Creates a new, empty `Array` with the specified maximum capacity. The `Array` will allocate
    enough memory to hold `capacity` elements at the time of its creation.
    ================================================================================================
    init(capacity:Int) {
        self.capacity := capacity
        data := Pointer<T>.alloc(capacity)
    }

    ================================================================================================
    Creates a new `Array` containing all the elements in another collection.
    ================================================================================================
    init(c:CollectionView<T>) {
        init(c.get_count().max(DEFAULT_CAPACITY))
        for v in c {
            add(v)
        }
    }

    @private
    init(data:Pointer<T>, count:Int) {
        self.data := data
        self.count := count
        self.capacity := count
    }

    @override
    method cleanup() {
        for i in 0 .. count {
            if data[i] != null {
                Panda.unref(data[i])
            }
        }
        data.destroy()
    }

    @override
    function [](index:Int):T {
        return data[index]
    }

    @override
    method []:=(index:Int, value:T) {
        data[index] := value
    }

    @pre(range.min <= range.max)
    method []:=(range:Range<Int>, list:ListView<T>) {
        -- FIXME performance, doing this the slow and stupid way for now
        var max := range.max
        if !range.inclusive {
            max -= 1
        }
        for i in max ... range.min by -1 {
            removeIndex(i)
        }
        var index := range.min
        for v in list {
            insert(index, v)
            index += 1
        }
    }

    method []:=(range:Range<Int?>, list:ListView<T>) {
        var min := range.min
        if min = null {
            min := 0
        }

        var max := range.max
        if max = null {
            max := get_count()
        }

        self[Range<Int>(min, max, range.inclusive)] := list
    }

    @override
    method insert(index:Int, value:T) {
        ensureCapacity(count + 1)
        for i in count .. index by -1 {
            data[i] := data[i - 1]
        }
        count += 1
        data[index] := value
    }

    @override
    method add(value:T) {
        ensureCapacity(count + 1)
        data[count] := value
        count += 1
    }

    @override
    method addAll(c:CollectionView<T>) {
        ensureCapacity(count + c.get_count())
        for v in c {
            data[count] := v
            count += 1
        }
    }

    method ensureCapacity(newCapacity:Int) {
        assert capacity >= 0
        if newCapacity <= capacity {
            return
        }
        def oldCapacity := capacity
        capacity := capacity.max(1)
        while capacity < newCapacity {
            capacity *= 2
        }
        data := data.realloc(oldCapacity, capacity)
    }

    @override
    function get_count():Int {
        return count
    }

    @override
    method removeIndex(index:Int):T {
        def result := self[index]
        for i in index .. count - 1 {
            self[i] := self[i + 1]
        }
        count -= 1
        data[count] := null->T?
        return result
    }

    @override
    method clear() {
        count := 0
        for i in 0 .. capacity {
            data[i] := null->T?
        }
    }

    @override
    function convert():String {
        def result := MutableString()
        result.append("[")
        var separator := ""
        for v in self {
            result.append(separator)
            separator := ", "
            if v != null {
                result.append(v)
            }
            else {
                result.append("<null>")
            }
        }
        result.append("]")
        return result.finish()
    }

    ================================================================================================
    Invalidates this `Array` and returns its contents as an `ImmutableArray`. This is generally
    preferable to creating a new instance of `ImmutableArray` from this array, as `finish()` does
    not copy the array's contents. Interacting in any way with an `Array` after `finish`ing it will
    cause precondition violations (or, if safety checks are disabled, undefined behavior).
    ================================================================================================
    method finish():ImmutableArray<T> {
        -- FIXME this transformation is only safe at -S0
        data := data.realloc(capacity, count)
        self.$class := ImmutableArray<T>().$class
        self.capacity := -1
        return self->Object->ImmutableArray<T>
    }
}
