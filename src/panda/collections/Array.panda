package panda.collections

uses panda.unsafe.Pointer

@final
class Array<T> : List<T> {
    constant DEFAULT_CAPACITY := 16

    class ArrayIterator<T> : Iterator<T> {
        var array:Array<T>

        var index := 0

        init(array:Array<T>) {
            self.array := array
        }

        @override
        function get_done():Bit {
            return index = array.count
        }

        @override
        function next():T {
            index += 1
            return array[index - 1]
        }
    }

    @private
    var count := 0

    @private
    var capacity:Int

    @private
    var data:Pointer<T>

    init() {
        init(DEFAULT_CAPACITY)
    }

    init(capacity:Int) {
        self.capacity := capacity
        data := Pointer<T>.alloc(capacity)
    }

    init(list:ListView<T>) {
        init(list.get_count().max(DEFAULT_CAPACITY))
        for v in list {
            add(v)
        }
    }

    @override
    method cleanup() {
        data.destroy()
    }

    @override
    function [](index:Int):T {
        assert index >= 0 & index < count, "index \{index} is out of bounds (count = \{count})"
        return data[index]
    }

    @override
    method []:=(index:Int, value:T) {
        assert index >= 0 & index < count, "index \{index} is out of bounds (count = \{count})"
        data[index] := value
    }

    @override
    method insert(index:Int, value:T) {
        ensureCapacity(count + 1)
        for i in count .. index by -1 {
            self[i] := self[i - 1]
        }
        count += 1
        self[index] := value
    }

    ================================================================================================
    Returns a slice of the array, containing all of the elements specified by the range. The slice
    is an independent copy of the array and elements may be added to and removed from the copy
    without affecting the original. It is not, however, a deep copy, and thus both arrays will refer
    to the same objects.
    ================================================================================================
    function [](r:Range<Int?>):Array<T> {
        def step := 1

        def current:Int
        if r.min != null {
            current := r.min
        }
        else if step > 0 {
            current := 0
        }
        else {
            current := get_count() - 1
        }

        def end:Int
        if r.max != null {
            end := r.max
        }
        else if step > 0 {
            end := get_count()
        }
        else {
            end := 0
        }

        def result := Array<T>()
        if step > 0 {
            while current < end {
                result.add(self[current])
                current += step
            }
        }
        else {
            assert step < 0
            while current > end {
                result.add(self[current])
                current -= step
            }
        }
        if (r.inclusive | r.max = null) & current = end & end < get_count() {
            result.add(self[current])
        }
        return result
    }

    ================================================================================================
    Returns a slice of the array, containing all of the elements specified by the range. The slice
    is an independent copy of the array and elements may be added to and removed from the copy
    without affecting the original. It is not, however, a deep copy, and thus both arrays will refer
    to the same objects.
    ================================================================================================
    function [](r:SteppedRange<Int?, Int>):Array<T> {
        def step := r.step

        def current:Int
        if r.start != null {
            current := r.start
        }
        else if step > 0 {
            current := 0
        }
        else {
            current := get_count() - 1
        }

        def end:Int
        if r.end != null {
            end := r.end
        }
        else if step > 0 {
            end := get_count()
        }
        else {
            end := 0
        }

        def result := Array<T>()
        if r.step > 0 {
            while current < end {
                result.add(self[current])
                current += step
            }
        }
        else {
            assert r.step < 0
            while current > end {
                result.add(self[current])
                current -= step
            }
        }
        if (r.inclusive | r.end = null) & current = end & end < get_count() {
            result.add(self[current])
        }
        return result
    }

    @override
    method add(value:T) {
        ensureCapacity(count + 1)
        data[count] := value
        count += 1
    }

    @override
    method addAll(c:CollectionView<T>) {
        ensureCapacity(count + c.get_count())
        for v in c {
            data[count] := v
            count += 1
        }
    }

    method ensureCapacity(newCapacity:Int) {
        assert capacity > 0
        if newCapacity <= capacity {
            return
        }
        while capacity < newCapacity {
            capacity *= 2
        }
        data := data.realloc(capacity)
    }

    @override
    function get_count():Int {
        return count
    }

    @override
    method removeIndex(index:Int) {
        for i in index .. count - 1 {
            self[i] := self[i + 1]
        }
        count -= 1
    }

    @override
    function iterator():Iterator<T> {
        return ArrayIterator<T>(self)
    }

    @override
    method clear() {
        count := 0
    }

    function join():String { -- FIXME move to ListView
        return join(", ")
    }

    function join(separator:String):String { -- FIXME move to ListView
        if count = 0 {
            return ""
        }
        def result := MutableString(self[0].convert())
        for i in 1 .. count {
            result.append(separator)
            result.append(self[i])
        }
        return result.convert()

    }

    @override
    function convert():String {
        def result := MutableString()
        result.append("[")
        var separator := ""
        for v in self {
            result.append(separator)
            separator := ", "
            if v != null {
                result.append(v)
            }
            else {
                result.append("<null>")
            }
        }
        result.append("]")
        return result.convert()
    }
}
