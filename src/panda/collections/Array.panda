package panda.collections

uses panda.unsafe.Pointer

@final
class Array<T> : List<T> {
    constant DEFAULT_CAPACITY := 16

    class ArrayIterator<T> : Iterator<T> {
        var array:Array<T>

        var index := 0

        init(array:Array<T>) {
            self.array := array
        }

        @override
        function get_done():Bit {
            return index = array.count
        }

        @override
        function next():T {
            index += 1
            return array[index - 1]
        }
    }

    @private
    var count := 0

    @private
    var capacity:Int

    @private
    var data:Pointer<T>

    init() {
        init(DEFAULT_CAPACITY)
    }

    init(capacity:Int) {
        self.capacity := capacity
        data := Pointer<T>.alloc(capacity)
        for i in 0 .. capacity {
            assert data[i] = null
        }
    }

    init(list:ListView<T>) {
        init(list.get_count().max(DEFAULT_CAPACITY))
        for v in list {
            add(v)
        }
    }

    @private
    init(data:Pointer<T>, count:Int) {
        self.data := data
        self.count := count
        self.capacity := count
    }

    @override
    method cleanup() {
        for i in 0 .. count {
            if data[i] != null {
                Panda.unref(data[i])
            }
        }
        data.destroy()
    }

    @override
    function [](index:Int):T {
        assert index >= 0 & index < count, "index \{index} is out of bounds (count = \{count})"
        return data[index]
    }

    @override
    method []:=(index:Int, value:T) {
        assert index >= 0 & index < count, "index \{index} is out of bounds (count = \{count})"
        data[index] := value
    }

    @override
    method insert(index:Int, value:T) {
        ensureCapacity(count + 1)
        for i in count .. index by -1 {
            data[i] := data[i - 1]
        }
        count += 1
        data[index] := value
    }

    ================================================================================================
    Returns a slice of the array, containing all of the elements specified by the range. The slice
    is an independent copy of the array and elements may be added to and removed from the copy
    without affecting the original. It is not, however, a deep copy, and thus both arrays will refer
    to the same objects.
    ================================================================================================
    function [](r:Range<Int>):Array<T> {
        var max := r.max
        if r.inclusive {
            max += 1
        }
        def count := max - r.min
        def result := Pointer<T>.alloc(count)
        for i in 0 .. count {
            result[i] := self[r.min + i]
        }
        return Array<T>(result, count)

    }

    ================================================================================================
    Returns a slice of the array, containing all of the elements specified by the range. The slice
    is an independent copy of the array and elements may be added to and removed from the copy
    without affecting the original. It is not, however, a deep copy, and thus both arrays will refer
    to the same objects.

    As usual for `Range`, a null `min` starts from the beginning of the array, and a null `max` ends
    at the end of the array.
    ================================================================================================
    function [](r:Range<Int?>):Array<T> {
        def start:Int
        if r.min != null {
            start := r.min
        }
        else {
            start := 0
        }

        var end:Int
        if r.max != null {
            end := r.max
        }
        else {
            end := get_count()
            if r.inclusive {
                end -= 1
            }
        }
        return self[Range<Int>(start, end, r.inclusive)]
    }

    ================================================================================================
    Returns a slice of the array, containing all of the elements specified by the range. The slice
    is an independent copy of the array and elements may be added to and removed from the copy
    without affecting the original. It is not, however, a deep copy, and thus both arrays will refer
    to the same objects.
    ================================================================================================
    function [](r:SteppedRange<Int?, Int>):Array<T> {
        def step := r.step

        def current:Int
        if r.start != null {
            current := r.start
        }
        else if step > 0 {
            current := 0
        }
        else {
            current := get_count() - 1
        }

        def end:Int
        if r.end != null {
            end := r.end
        }
        else if step > 0 {
            end := get_count()
        }
        else {
            end := 0
        }

        def result := Array<T>()
        if r.step > 0 {
            while current < end {
                result.add(self[current])
                current += step
            }
        }
        else {
            assert r.step < 0
            while current > end {
                result.add(self[current])
                current -= step
            }
        }
        if (r.inclusive | r.end = null) & current = end & end < get_count() {
            result.add(self[current])
        }
        return result
    }

    @override
    method add(value:T) {
        ensureCapacity(count + 1)
        data[count] := value
        count += 1
    }

    @override
    method addAll(c:CollectionView<T>) {
        ensureCapacity(count + c.get_count())
        for v in c {
            data[count] := v
            count += 1
        }
    }

    method ensureCapacity(newCapacity:Int) {
        assert capacity > 0
        if newCapacity <= capacity {
            return
        }
        def oldCapacity := capacity
        while capacity < newCapacity {
            capacity *= 2
        }
        data := data.realloc(oldCapacity, capacity)
        for i in oldCapacity .. capacity {
            assert data[i] = null
        }
    }

    @override
    function get_count():Int {
        return count
    }

    @override
    method removeIndex(index:Int) {
        for i in index .. count - 1 {
            self[i] := self[i + 1]
        }
        count -= 1
        data[count] := null->T?
    }

    @override
    function iterator():Iterator<T> {
        return ArrayIterator<T>(self)
    }

    @override
    method clear() {
        count := 0
        for i in 0 .. capacity {
            data[i] := null->T?
        }
    }

    function join():String { -- FIXME move to ListView
        return join(", ")
    }

    function join(separator:String):String { -- FIXME move to ListView
        if count = 0 {
            return ""
        }
        def result := MutableString(self[0].convert())
        for i in 1 .. count {
            result.append(separator)
            if self[i] != null {
                result.append(self[i])
            }
            else {
                result.append("<null>")
            }
        }
        return result.finish()
    }

    @override
    function convert():String {
        def result := MutableString()
        result.append("[")
        var separator := ""
        for v in self {
            result.append(separator)
            separator := ", "
            if v != null {
                result.append(v)
            }
            else {
                result.append("<null>")
            }
        }
        result.append("]")
        return result.finish()
    }

    ================================================================================================
    Invalidates this `Array` and returns its contents as an `ImmutableArray`. This is generally
    preferable to creating a new instance of `ImmutableArray` from this array, as `finish()` does
    not copy the array's contents. Interacting in any way with an `Array` after `finish`ing it will
    cause precondition violations (or, if safety checks are disabled, undefined behavior).
    ================================================================================================
    method finish():ImmutableArray<T> {
        -- FIXME this transformation is only safe at -S0
        data := data.realloc(capacity, count)
        self.$class := ImmutableArray<T>().$class
        self.capacity := -1
        return self->Object->ImmutableArray<T>
    }
}
