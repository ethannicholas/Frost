package panda.collections

uses panda.unsafe.Pointer

====================================================================================================
Standard implementation of the `List` interface. `Array` is a resizable random-access array,
featuring constant time reads and writes. Appending new elements to the array can be expensive, as
it may require the backing store to be increased in size which in turn may require a memory copy.

Particularly for bigger arrays, tt is best to avoid this expensive size increase by pre-allocating
the array with the expected number of elements it will contain using [init(Int)].
====================================================================================================
@final
class Array<T> : List<T> {
    @private
    constant DEFAULT_CAPACITY := 16

    @private
    var _count := 0

    @private
    var capacity:Int

    @private
    var data:Pointer<T?>

    ================================================================================================
    Creates a new, empty `Array`.
    ================================================================================================
    init() {
        init(DEFAULT_CAPACITY)
    }

    ================================================================================================
    Creates a new, empty `Array` with the specified maximum capacity. The `Array` will allocate
    enough memory to hold `capacity` elements at the time of its creation.
    ================================================================================================
    init(capacity:Int) {
        self.capacity := capacity
        data := Pointer<T?>.alloc(capacity)
    }

    ================================================================================================
    Creates a new `Array` containing all the elements in another collection.
    ================================================================================================
    init(c:CollectionView<T>) {
        init(c.count.max(DEFAULT_CAPACITY))
        for v in c {
            add(v)
        }
    }

    @private
    init(data:Pointer<T>, count:Int) {
        self.data := data->Pointer<T?>
        self._count := count
        self.capacity := count
    }

    @override
    method cleanup() {
        clear()
        data.destroy()
    }

    @override
    function [](index:Int):T {
        return data[index]
    }

    @override
    method []:=(index:Int, value:T) {
        data[index] := value
    }

    @override
    method insert(index:Int, value:T) {
        ensureCapacity(count + 1)
        for i in count .. index by -1 {
            data[i] := data[i - 1]
        }
        _count += 1
        data[index] := value
    }

    @override
    method add(value:T) {
        ensureCapacity(_count + 1)
        data[_count] := value
        _count += 1
    }

    @override
    method addAll(c:CollectionView<T>) {
        ensureCapacity(_count + c.count)
        for v in c {
            data[_count] := v
            _count += 1
        }
    }

    method ensureCapacity(newCapacity:Int) {
        assert capacity >= 0
        if newCapacity <= capacity {
            return
        }
        def oldCapacity := capacity
        capacity := capacity.max(1)
        while capacity < newCapacity {
            capacity *= 2
        }
        data := data.realloc(oldCapacity, capacity)
    }

    @override
    function get_count():Int {
        return _count
    }

    @override
    method removeIndex(index:Int):T {
        def result := self[index]
        for i in index .. _count - 1 {
            self[i] := self[i + 1]
        }
        _count -= 1
        data[_count] := null
        return result
    }

    @override
    method clear() {
        _count := 0
        for i in 0 .. capacity {
            data[i] := null
        }
    }

    @override
    function convert():String {
        def result := MutableString()
        result.append("[")
        var separator := ""
        for v in self {
            result.append(separator)
            separator := ", "
            if v != null {
                result.append(v)
            }
            else {
                result.append("<null>")
            }
        }
        result.append("]")
        return result.finish()
    }

    ================================================================================================
    Invalidates this `Array` and returns its contents as an `ImmutableArray`. This is generally
    preferable to creating a new instance of `ImmutableArray` from this array, as `finish()` does
    not copy the array's contents. Interacting in any way with an `Array` after `finish`ing it will
    cause precondition violations (or, if safety checks are disabled, undefined behavior).
    ================================================================================================
    method finish():ImmutableArray<T> {
        -- FIXME this transformation is only safe at -S0
        data := data.realloc(capacity, _count)
        self.$class := ImmutableArray<T>().$class
        self.capacity := -1
        return self->Object->ImmutableArray<T>
    }
}
