package panda.collections

uses panda.unsafe.Pointer

class Array<T> (List<T>) {
    constant DEFAULT_CAPACITY := 16

    class ArrayIterator<T> (Iterator<T>) {
        var array:Array<T>

        var index := 0

        init(array:Array<T>) {
            self.array := array
        }

        @override
        function get_done():Bit {
            return index = array.count
        }

        @override
        function next():T {
            index += 1
            return array[index - 1]
        }
    }

    @private
    var count := 0

    @private
    var capacity:Int

    @private
    var data:Pointer<T>

    init() {
        init(DEFAULT_CAPACITY)
    }

    init(capacity:Int) {
        self.capacity := capacity
        data := Pointer<T>.alloc(capacity)
    }

    init(list:ListView<T>) {
        init(list.get_count().max(DEFAULT_CAPACITY))
        for v in list {
            add(v)
        }
    }

    @override
    method cleanup() {
        data.destroy()
    }

    @override
    function [](index:Int):T {
        return data[index]
    }

    @override
    method []:=(index:Int, value:T) {
        data[index] := value
    }

    ================================================================================================
    Returns a slice of the array, containing all of the elements specified by the range. The slice
    is an independent copy of the array and elements may be added to and removed from the copy
    without affecting the original. It is not, however, a deep copy, and thus both arrays will refer
    to the same objects.
    ================================================================================================
    function [](r:Range<Int>):Array<T> {
        Console.printLine("grabbing \{r} from \{get_count()}")
        def step := r.step

        def current:Int
        if r.start != null {
            current := r.start
        }
        else if step > 0 {
            current := 0
        }
        else {
            current := get_count() - 1
        }

        def end:Int
        if r.end != null {
            end := r.end
        }
        else if step > 0 {
            end := get_count()
        }
        else {
            end := 0
        }

        def result := Array<T>()
        if r.step > 0 {
            while current < end {
                result.add(self[current])
                current += step
            }
        }
        else {
            assert r.step < 0
            while current > end {
                result.add(self[current])
                current -= step
            }
        }
        if (r.inclusive | r.end = null) & current = end & end < get_count() {
            result.add(self[current])
        }
        return result
    }

    @override
    method add(value:T) {
        ensureCapacity(count + 1)
        data[count] := value
        count += 1
    }

    @override
    method addAll(c:CollectionView<T>) {
        ensureCapacity(count + c.get_count())
        for v in c {
            data[count] := v
            count += 1
        }
    }

    method ensureCapacity(newCapacity:Int) {
        assert capacity > 0
        if newCapacity <= capacity {
            return
        }
        while capacity < newCapacity {
            capacity *= 2
        }
        data := data.realloc(capacity)
    }

    @override
    function get_count():Int {
        return count
    }

    @override
    method removeIndex(index:Int) {
        for i in index .. count - 1 {
            self[i] := self[i + 1]
        }
        count -= 1
    }

    @override
    function iterator():Iterator<T> {
        return ArrayIterator<T>(self)
    }

    @override
    method clear() {
        count := 0
    }

    @override
    function convert():String {
        def result := MutableString()
        result.append("[")
        var separator := ""
        for v in self {
            result.append(separator)
            separator := ", "
            result.append(v)
        }
        result.append("]")
        return result.convert()
    }
}
