package org.pandalanguage.plex

uses org.pandalanguage.plex.runtime.DFA

====================================================================================================
A simple lexical analyzer generator for Panda, used to build pandac's lexer.
====================================================================================================
class PLex {
    def tokens := HashMap<String, Regex>()

    method process(inputPath:File, tokenPath:File, lexerPath:File) {
        def input := inputPath.openInputStream()
        def token := IndentedOutputStream(tokenPath.openOutputStream())
        def nfa := NFA()
        token.printLine("package org.pandalanguage.pandac.parser")
        token.printLine()
        token.printLine("uses org.pandalanguage.pandac.Position")
        token.printLine()
        token.printLine("@final")
        token.printLine("class Token : Value {")
        token.level += 1
        token.printLine("class Kind { -- FIXME use choice")
        token.level += 1
        var offset := 0
        token.printLine("constant EOF := 0")
        offset += 1
        token.printLine("constant SHIFTRIGHT := 1")
        offset += 1
        for line in input.lines() {
            line := line.trim()
            if line.contains(":=") {
                def id := line[line.start() .. line.indexOf(":=")].trim()
                def pattern := line[line.offset(line.indexOf(":="), 2) .. line.end()].trim()
                def regex:Regex
                if pattern.startsWith('"') {
                    regex := Regex(escape(pattern[pattern.next(pattern.start()) ..
                            pattern.previous(pattern.end())]))
                }
                else {
                    assert pattern.startsWith("/") & pattern.endsWith("/")
                    regex := Regex(pattern[pattern.next(pattern.start()) ..
                            pattern.previous(pattern.end())])
                }
                token.printLine("constant \{id} := \{tokens.get_count() + 2}")
                def states := regex.addToNFA(nfa, nfa.addState(AcceptState(tokens.get_count() +
                        offset)))
                for s in states {
                    nfa.addStartState(s)
                }
                tokens[id] := regex
            }
            else {
                assert line.utf8().get_count() = 0, "error parsing '\{line}'"
            }
        }
        token.printLine()
        token.level -= 1
        token.printLine("}")
        token.printLine()
        token.printLine("def kind:Int")
        token.printLine("def start:String.Index")
        token.printLine("def end:String.Index")
        token.printLine("def position:Position")
        token.printLine()
        token.printLine("init(kind:Int, start:String.Index, end:String.Index, position:Position) {")
        token.level += 1
        token.printLine("self.kind := kind")
        token.printLine("self.start := start")
        token.printLine("self.end := end")
        token.printLine("self.position := position")
        token.level -= 1
        token.printLine("}")
        token.level -= 1
        token.printLine("}")

        def dfa := NFAtoDFA(nfa).createDFA()
        def lexer := IndentedOutputStream(lexerPath.openOutputStream())
        writeLexer(dfa, lexer)
        tokens.clear()
    }

    function escape(s:String):String {
        def result := MutableString()
        for c in s.utf8() {
            if "+*?|.()[]".contains(c) {
                result.append("\\")
            }
            result.append(c)
        }
        return result.finish()
    }

    method writeLexer(dfa:DFA, out:IndentedOutputStream) {
        out.printLine("package org.pandalanguage.pandac.parser")
        out.printLine()
        out.printLine("uses panda.unsafe.Pointer")
        out.printLine("uses org.pandalanguage.plex.runtime.DFA")
        out.printLine("uses org.pandalanguage.pandac.Position")
        out.printLine()
        out.printLine("@final")
        out.printLine("class Lexer {")
        out.level += 1
        out.printLine("def dfa:DFA")
        out.printLine()
        out.printLine("def transitions := getTransitions()")
        out.printLine()
        out.printLine("def accepts := getAccepts()")
        out.printLine()
        out.printLine("method start(source:String) {")
        out.printLine("    dfa := DFA(source, \{dfa.stateCount}, transitions, accepts)")
        out.printLine("}")
        out.printLine()
        writeStateTable(dfa, out)
        out.printLine()
        out.printLine("method next():Token {")
        out.level += 1
        out.printLine("def raw := dfa.next()")
        out.printLine("return Token(raw.kind, raw.start, raw.end, Position(raw.line, " +
                "raw.column))")
        out.level -= 1
        out.printLine("}")
        out.level -= 1
        out.printLine("}")
    }

    method writeStateTable(dfa:DFA, out:IndentedOutputStream) {
        out.printLine("@class")
        out.printLine("function alloc(count:Int, fill:Int):Pointer<Int> {")
        out.printLine("    def result := Pointer<Int>.alloc(count)")
        out.printLine("    for i in 0 .. count {")
        out.printLine("        result[i] := fill")
        out.printLine("    }")
        out.printLine("    return result")
        out.printLine("}")
        out.printLine()
        out.printLine("@class")
        out.printLine("function getTransitions():Pointer<Pointer<Int>> {")
        out.level += 1
        out.printLine("def result := Pointer<Pointer<Int>>.alloc(\{DFA.END_CHAR + 1})")
        for i in 0 ... DFA.END_CHAR.convert()->Int {
            def a := dfa.transitions[i]
            def counts := Array<Int>(dfa.stateCount)
            for j in 0 .. dfa.stateCount {
                counts.add(0)
            }
            var maxIndex := 0
            for j in 0 .. dfa.stateCount {
                counts[a[j]] += 1
                if counts[a[j]] > counts[maxIndex] {
                    maxIndex := a[j]
                }
            }
            def fill := maxIndex
            out.printLine("result[\{i}] := alloc(\{dfa.stateCount}, \{fill})")
            for j in 0 .. dfa.stateCount {
                if a[j] != fill {
                    out.printLine("result[\{i}][\{j}] := \{a[j]}")
                }
            }
        }
        out.printLine("return result")
        out.level -= 1
        out.printLine("}")
        out.printLine()
        out.printLine("@class")
        out.printLine("function getAccepts():Pointer<Int> {")
        out.level += 1
        out.printLine("def result := Pointer<Int>.alloc(\{dfa.stateCount})")
        for i in 0 .. dfa.stateCount {
            out.printLine("result[\{i}] := \{dfa.accepts[i]}")
        }
        out.printLine("return result")
        out.level -= 1
        out.printLine("}")
    }

    @class
    method main() {
        def dst := File("org/pandalanguage/pandac/parser")
        dst.createDirectories()
        PLex().process(File("../src/parser/Panda.plex"),
                dst.resolve("Token.panda"),
                dst.resolve("Lexer.panda"))
    }
}