package org.pandalanguage.plex

uses panda.unsafe.Pointer
uses org.pandalanguage.plex.AcceptState
uses org.pandalanguage.plex.NFA
uses org.pandalanguage.plex.RemappedState
uses org.pandalanguage.plex.runtime.DFA

class NFAtoDFA {
    var nfa:NFA
    def states := HashMap<DFAStateLabel, DFAState>()
    def transitions := Array<List<Int>>()
    def accepts := Array<Int>()

    init(nfa:NFA) {
        self.nfa := nfa
    }

    method getState(label:DFAStateLabel):DFAState {
        var result := states[label]
        if result = null {
            result := DFAState(states.get_count(), label)
            states[label] := result
        }
        return result
    }

    method add(nfaState:Int, states:List<Int>) {
        def state := nfa.states[nfaState]
        if state.kind = State.REMAPPED {
            def next := (state->RemappedState).states -- FIXME remove ()
            for n in next {
                add(n, states)
            }
        }
        else {
            for s in states {
                if s = nfaState {
                    return
                }
            }
            states.add(nfaState)
        }
    }

    method addTransition(c:Char8, start:Int, next:Int) {
        while transitions.get_count() <= c.convert() {
            transitions.add(Array<Int>())
        }
        def a := transitions[c.convert()]
        while a.get_count() <= start {
            a.add(-1)
        }
        assert a[start] = -1
        a[start] := next
    }

    @private
    @class
    method swap(a:List<Int>, i1:Int, i2:Int) {
        def tmp := a[i1]
        a[i1] := a[i2]
        a[i2] := tmp
    }

    @private
    @class
    method sort(a:List<Int>, left:Int, right:Int) {
        if left >= right {
            return
        }
        def pivotIndex := left + (right - left) // 2
        def pivot := a[pivotIndex]
        swap(a, right, pivotIndex)
        var storeIndex := left
        for i in left ... right - 1 {
            if a[i] < pivot {
                swap(a, i, storeIndex)
                storeIndex += 1
            }
        }
        swap(a, storeIndex, right)
        sort(a, left, storeIndex - 1)
        sort(a, storeIndex + 1, right)
    }

    ================================================================================================
    Quick and dirty naive quicksort, until generics are done and ListView can be 
    sorted natively.
    ================================================================================================
    @class
    method sort(a:List<Int>) {
        sort(a, 0, a.get_count() - 1)
    }

    method scanState(state:DFAState) {
        state.scanned := true
        for c:UInt8 in DFA.START_CHAR ... DFA.END_CHAR  { -- FIXME iterate over Char8 directly
            def next := Array<Int>()
            var bestAccept := Int64.MAX
            for idx in state.label.states {
                def nfaState := nfa.states[idx]
                if nfaState.accept(Char8(c)) {
                    outer: for nextState in nfaState.next {
                        if nfa.states[nextState].kind = State.ACCEPT {
                            bestAccept := bestAccept.min(
                                    (nfa.states[nextState]->State->AcceptState).token) -- fixme remove redundant cast and ()
                        }
                        add(nextState, next)
                    }
                }
            }

            sort(next)
            def nextState := getState(DFAStateLabel(next))
            addTransition(Char8(c), state.id, nextState.id)
            if bestAccept < Int32.MAX {
                while accepts.get_count() <= nextState.id {
                    accepts.add(-1)
                }
                accepts[nextState.id] := bestAccept
            }
            if !nextState.scanned {
                scanState(nextState)
            }
        }
    }

    method createDFA():DFA {
        -- create state 0, the "reject" state
        getState(DFAStateLabel(Array<Int>()))
        -- map DFA states to the set of NFA states each represents
        def startStates := Array<Int>()
        for i in 0 .. nfa.startStates.get_count() {
            startStates.add(nfa.startStates[i])
        }
        sort(startStates)
        -- state 1 is the start state
        def start := getState(DFAStateLabel(startStates))
        scanState(start)

        var stateCount := 0
        for i in 0 .. transitions.get_count() {
            stateCount := stateCount.max(transitions[i].get_count())
        }
        def outTransitions := Pointer<Pointer<Int>>.alloc(transitions.get_count())
        for i in 0 ... DFA.END_CHAR.convert()->Int {
            outTransitions[i] := Pointer<Int>.alloc(stateCount)
            for j in 0 .. stateCount {
                if i < transitions.get_count() & j < transitions[i].get_count() {
                    outTransitions[i][j] := transitions[i][j]
                }
                else {
                    outTransitions[i][j] := 0
                }
            }
        }
        def outAccepts := Pointer<Int>.alloc(accepts.get_count())
        for i in 0 .. stateCount {
            if i >= accepts.get_count() {
                outAccepts[i] := -1
            }
            else {
                outAccepts[i] := accepts[i]
            }
        }
        return DFA(stateCount, outTransitions, outAccepts)
    }
}