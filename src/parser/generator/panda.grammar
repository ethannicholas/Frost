{
    #include "ASTNode.h"
    #include "Operator.h"

    #undef NULL
    #define CURRENT_POSITION Position(((String*) parserState->fReference), \
            parserState->fNode->fRow, parserState->fNode->fColumn)

    #define DIE(x) { *die = true; return x; }

    class ParserUtil {
    public:
        static bool IsPandaKeyword(String s) {
            static std::unordered_set<String> keywords {
                "package", "uses", "as", "class", "method", "function", "init", "var", "def",
                "property", "constant", "do", "while", "for", "by", "loop", "if", "else", "match",
                "when", "default", "self", "true", "false", "enum", "return", "break", "continue",
                "null", "assert", "unreachable", "super"
            };
            return keywords.find(s) != keywords.end();
        }

        static int64_t ToInt(String s, int radix) {
            return std::stol(s, 0, radix);
        }

        static double ToDouble(String s) {
            return std::stod(s);
        }

        static String unescape(String s) {
            String result;
            int i = 0;
            while (i < s.size()) {
                char c = s[i];
                ++i;
                if (c == '\\') {
                    c = s[i];
                    switch (c) {
                        case 'n': result += '\n';
                        case 'r': result += '\r';
                        case 't': result += '\t';
                        default:  result += c;
                    }
                    ++i;
                }
                else {
                    result += c;
                }
            }
            return result;
        }
    };
}

@file:ASTNode = WS bodyEntries optionalTrailingLineComment
    { result = bodyEntries; }
@file:ASTNode = WS optionalTrailingLineComment
    { }
bodyEntries:ASTNode = bodyEntries bodyEntry
    {
        result = bodyEntries;
        result.fChildren.push_back(bodyEntry);
    }
bodyEntries:ASTNode = bodyEntry
    { result = ASTNode(CURRENT_POSITION, ASTNode::Kind::BODY_ENTRIES, { bodyEntry }); }
optionalTrailingLineComment = TRAILING_LINE_COMMENT ;
optionalTrailingLineComment = ;

@bodyEntry:ASTNode = usesStatement
    { result = usesStatement; }
@bodyEntry:ASTNode = classDeclaration
    { result = classDeclaration; }
@bodyEntry:ASTNode = interfaceDeclaration
    { result = interfaceDeclaration; }
@bodyEntry:ASTNode = choiceDeclaration
    { result = choiceDeclaration; }
@bodyEntry:ASTNode = methodDeclaration
    { result = methodDeclaration; }
@bodyEntry:ASTNode = functionDeclaration
    { result = functionDeclaration; }
@bodyEntry:ASTNode = packageDeclaration
    { result = packageDeclaration; }
@bodyEntry:ASTNode = instanceDeclaration
    { result = instanceDeclaration; }
@bodyEntry:ASTNode = statement
    { result = statement; }
@bodyEntry:ASTNode = varDeclaration
    { result = varDeclaration; }

packageDeclaration:ASTNode = PACKAGE ^ dottedName
    { result = ASTNode(PACKAGE, ASTNode::Kind::PACKAGE, dottedName); }
dottedName:String = dottedName DOT IDENTIFIER
    {
        result = dottedName + "." + IDENTIFIER.fText;
    }
dottedName:String = IDENTIFIER
    { result = IDENTIFIER.fText; }
usesStatement:ASTNode = USES usesName
    { result = ASTNode(USES, ASTNode::Kind::USES, usesName); }
usesStatement:ASTNode = USES id:dottedName AS ^ alias:dottedName
    { result = ASTNode(USES, ASTNode::Kind::USES, id, { ASTNode(AS, ASTNode::Kind::AS, alias) }); }
usesName:String = dottedName DOT STAR
    { result = dottedName + ".*"; }
usesName:String = dottedName
    { result = dottedName; }
instanceDeclaration:ASTNode = INSTANCE ^ type
    {
        result = ASTNode(CURRENT_POSITION, ASTNode::Kind::INSTANCE, { type });
    }

classDeclaration:ASTNode = optionalDoccomment optionalAnnotations CLASS IDENTIFIER
        optionalGenericsDeclaration @"expected '{'" optionalTypeDeclaration optionalInterfaces
        '{' @"expected '}' to complete class body (started at <pos>)" WS ^ classMembers RBRACE @
    {
        result = ASTNode(CLASS, ASTNode::Kind::CLASS, IDENTIFIER.fText, { optionalDoccomment,
                optionalAnnotations, optionalGenericsDeclaration, optionalTypeDeclaration,
                optionalInterfaces, classMembers });
    }

interfaceDeclaration:ASTNode = optionalDoccomment optionalAnnotations INTERFACE ^ IDENTIFIER
        optionalGenericsDeclaration optionalTypeDeclarations '{'
        @"expected '}' to complete interface body (started at <pos>)" WS classMembers RBRACE @
    {
        result = ASTNode(INTERFACE, ASTNode::Kind::INTERFACE, IDENTIFIER.fText,
                { optionalDoccomment, optionalAnnotations, optionalGenericsDeclaration,
                    optionalTypeDeclarations, classMembers });
    }
choiceDeclaration:ASTNode = optionalDoccomment optionalAnnotations CHOICE ^ IDENTIFIER
        optionalInterfaces '{' @"expected '}' to complete 'choice' (started at <pos>)" WS choices
        RBRACE @
    {
        result = ASTNode(CHOICE, ASTNode::Kind::CHOICE, IDENTIFIER.fText, { optionalDoccomment,
                optionalAnnotations, choices });
    }
choices:ASTNode = choices COMMA choice
    {
        result = choices;
        result.fChildren.push_back(choice);
    }
choices:ASTNode = choice
    { result = ASTNode(choice.fPosition, ASTNode::Kind::CHOICES, { choice }); }
choice:ASTNode = optionalDoccomment IDENTIFIER
    {
        result = ASTNode(IDENTIFIER.fPosition, ASTNode::Kind::CHOICE_VALUE, IDENTIFIER.fText,
                { optionalDoccomment });
    }
optionalDoccomment:ASTNode = DOCCOMMENT
    { result = ASTNode(CURRENT_POSITION, ASTNode::Kind::DOCCOMMENT, DOCCOMMENT); }
optionalDoccomment:ASTNode =
    { result = ASTNode(CURRENT_POSITION, ASTNode::Kind::DOCCOMMENT); }
optionalAnnotations:ASTNode = annotations
    { result = annotations; }
optionalAnnotations:ASTNode =
    { result = ASTNode(CURRENT_POSITION, ASTNode::Kind::ANNOTATIONS); }
optionalTypeDeclarations:ASTNode = COLON typeList
    { result = typeList; }
optionalTypeDeclarations:ASTNode =
    { result = ASTNode(CURRENT_POSITION, ASTNode::Kind::TYPES); }
optionalTypeDeclaration:ASTNode = typeDeclaration
    { result = typeDeclaration; }
optionalTypeDeclaration:ASTNode =
    { result = ASTNode(CURRENT_POSITION, ASTNode::Kind::VOID); }
typeDeclaration:ASTNode = COLON type
    { result = type; }
optionalGenericsDeclaration:ASTNode = LT genericsDeclarations GT
    { result = genericsDeclarations; }
optionalGenericsDeclaration:ASTNode =
    { result = ASTNode(CURRENT_POSITION, ASTNode::Kind::TYPES); }
genericsDeclarations:ASTNode = genericsDeclarations COMMA optionallyTypedIdentifier
    {
        result = genericsDeclarations;
        result.fChildren.push_back(optionallyTypedIdentifier);
    }
genericsDeclarations:ASTNode = optionallyTypedIdentifier
    { result = ASTNode(CURRENT_POSITION, ASTNode::Kind::GENERICS, { optionallyTypedIdentifier }); }
optionalInterfaces:ASTNode = LPAREN typeList RPAREN
    { result = typeList; }
optionalInterfaces:ASTNode =
    { result = ASTNode(CURRENT_POSITION, ASTNode::Kind::TYPES); }
classMembers:ASTNode = classMemberList
    { result = classMemberList; }
classMembers:ASTNode =
    { }
classMemberList:ASTNode = classMemberList classMember
    {
        result = classMemberList;
        result.fChildren.push_back(classMember);
    }
classMemberList:ASTNode =
    { }
classMember:ASTNode = invariant
    { result = invariant; }
classMember:ASTNode = methodDeclaration
    { result = methodDeclaration; }
classMember:ASTNode = functionDeclaration
    { result = functionDeclaration; }
classMember:ASTNode = initDeclaration
    { result = initDeclaration; }
classMember:ASTNode = fieldDeclaration
    { result = fieldDeclaration; }
classMember:ASTNode = classDeclaration
    { result = classDeclaration; }
classMember:ASTNode = interfaceDeclaration
    { result = interfaceDeclaration; }
classMember:ASTNode = choiceDeclaration
    { result = choiceDeclaration; }
classMember:ASTNode = nestedDeclaration
    { result = nestedDeclaration; }
nestedDeclaration:ASTNode = NESTED ^ type
    { result = ASTNode(CURRENT_POSITION, ASTNode::Kind::NESTED, { type }); }

annotations:ASTNode = annotations annotation
    {
        result = annotations;
        result.fChildren.push_back(annotation);
    }
annotations:ASTNode = annotation
    { result = ASTNode(annotation.fPosition, ASTNode::Kind::ANNOTATIONS, { annotation }); }
annotation:ASTNode = '@' identifierText WS
    {
        result = ASTNode(CURRENT_POSITION, ASTNode::Kind::ANNOTATION, identifierText) ;
    }
annotation:ASTNode = MATH LPAREN OVERFLOW RPAREN
    { result = ASTNode(CURRENT_POSITION, ASTNode::Kind::ANNOTATION, "math(overflow)"); }
annotation:ASTNode = PRE LPAREN expression RPAREN
    { result = ASTNode(CURRENT_POSITION, ASTNode::Kind::ANNOTATION, "pre", { expression }); }
annotation:ASTNode = PRE_OR LPAREN expression RPAREN
    { result = ASTNode(CURRENT_POSITION, ASTNode::Kind::ANNOTATION, "preOr", { expression }); }
postcondition:ASTNode = POST LPAREN expression RPAREN
    { result = ASTNode(CURRENT_POSITION, ASTNode::Kind::ANNOTATION, "post", { expression }); }
postcondition:ASTNode = POST_AND LPAREN expression RPAREN
    { result = ASTNode(CURRENT_POSITION, ASTNode::Kind::ANNOTATION, "postAnd", { expression }); }
postconditions:ASTNode = postconditions postcondition
    {
        result = postconditions;
        result.fChildren.push_back(postcondition);
    }
postconditions:ASTNode = postcondition
    { result = ASTNode(CURRENT_POSITION, ASTNode::Kind::ANNOTATIONS, { postcondition }); }
optionalPostconditions:ASTNode = postconditions
    { result = postconditions; }
optionalPostconditions:ASTNode =
    { result = ASTNode(CURRENT_POSITION, ASTNode::Kind::ANNOTATIONS); }

invariant:ASTNode = INVARIANT LPAREN expression RPAREN
    { result = ASTNode(CURRENT_POSITION, ASTNode::Kind::ANNOTATION, "invariant", { expression }); }

methodDeclaration:ASTNode = optionalDoccomment optionalAnnotations METHOD ^ methodName parameters
        optionalTypeDeclaration optionalBlock optionalPostconditions
    {
        ASTNode annotations = optionalAnnotations;
        annotations.fChildren.insert(annotations.fChildren.end(),
                optionalPostconditions.fChildren.begin(), optionalPostconditions.fChildren.end());
        result = ASTNode(CURRENT_POSITION, ASTNode::Kind::METHOD, methodName, { optionalDoccomment,
                annotations, parameters, optionalTypeDeclaration, optionalBlock });
    }
methodName:String = IDENTIFIER
    { result = IDENTIFIER.fText; }
methodName:String = specialMethodName
    { result = specialMethodName; }
specialMethodName:String = SHIFTLEFT
    { result = "<<"; }
specialMethodName:String = SHIFTRIGHT
    { result = ">>"; }
specialMethodName:String = ADD
    { result = "+"; }
specialMethodName:String = SUB
    { result = "-"; }
specialMethodName:String = MUL
    { result = "*"; }
specialMethodName:String = DIV
    { result = "/"; }
specialMethodName:String = INTDIV
    { result = "//"; }
specialMethodName:String = REM
    { result = "%"; }
specialMethodName:String = AND
    { result = "&"; }
specialMethodName:String = OR
    { result = "|"; }
specialMethodName:String = XOR
    { result = "~"; }
specialMethodName:String = BITWISEAND
    { result = "&&"; }
specialMethodName:String = BITWISEOR
    { result = "||"; }
specialMethodName:String = BITWISEXOR
    { result = "~~"; }
specialMethodName:String = POW
    { result = "^"; }
specialMethodName:String = NOT
    { result = "!"; }
specialMethodName:String = BITWISENOT
    { result = "!!"; }
specialMethodName:String = '[]' WS
    { result = "[]"; }
specialMethodName:String = '[..]' WS
    { result = "[..]"; }
specialMethodName:String = '[...]' WS
    { result = "[...]"; }
specialMethodName:String = '[]:=' WS
    { result = "[]:="; }
specialMethodName:String = '[..]:=' WS
    { result = "[..]:="; }
specialMethodName:String = '[...]:=' WS
    { result = "[...]:="; }
specialMethodName:String = EQ
    { result = "="; }
specialMethodName:String = GT
    { result = ">"; }
specialMethodName:String = LT
    { result = "<"; }
specialMethodName:String = GTEQ
    { result = ">="; }
specialMethodName:String = LTEQ
    { result = "<="; }
parameters:ASTNode = @"expected '('" LPAREN @"expected ')'" parameterList RPAREN @
    { result = parameterList; }
parameters:ASTNode = @"expected '('" LPAREN @"expected ')'" RPAREN @
    { result = ASTNode(CURRENT_POSITION, ASTNode::Kind::PARAMETERS); }
parameterList:ASTNode = parameterList COMMA parameter
    {
        result = parameterList;
        result.fChildren.push_back(parameter);
    }
parameterList:ASTNode = parameter
    { result = ASTNode(parameter.fPosition, ASTNode::Kind::PARAMETERS, { parameter }); }
parameter:ASTNode = optionalVar @"expected identifier" IDENTIFIER @ @"expected ':'" COLON @ type
        optionalEllipsis
    {
        result = ASTNode(IDENTIFIER.fPosition, ASTNode::Kind::PARAMETER, IDENTIFIER.fText, { type,
                optionalVar, optionalEllipsis });
    }
optionalVar:ASTNode = VAR
    { result = ASTNode(CURRENT_POSITION, ASTNode::Kind::BIT, true); }
optionalVar:ASTNode =
    { result = ASTNode(CURRENT_POSITION, ASTNode::Kind::BIT, false); }
optionalEllipsis:ASTNode = ELLIPSIS
    { result = ASTNode(CURRENT_POSITION, ASTNode::Kind::BIT, true); }
optionalEllipsis:ASTNode =
    { result = ASTNode(CURRENT_POSITION, ASTNode::Kind::BIT, false); }
optionalBlock:ASTNode = block
    { result = block; }
optionalBlock:ASTNode =
    { result = ASTNode(CURRENT_POSITION, ASTNode::Kind::BLOCK); }

@anyMethod:ASTNode = functionDeclaration
    { result = functionDeclaration; }
@anyMethod:ASTNode = methodDeclaration
    { result = methodDeclaration; }
@anyMethod:ASTNode = initDeclaration
    { result = initDeclaration; }

functionDeclaration:ASTNode = optionalDoccomment optionalAnnotations FUNCTION ^ methodName
        parameters typeDeclaration optionalBlock optionalPostconditions
    {
        ASTNode annotations = optionalAnnotations;
        annotations.fChildren.insert(annotations.fChildren.end(),
                optionalPostconditions.fChildren.begin(), optionalPostconditions.fChildren.end());
        result = ASTNode(CURRENT_POSITION, ASTNode::Kind::FUNCTION, methodName,
                { optionalDoccomment, annotations, parameters, typeDeclaration, optionalBlock });
    }

initDeclaration:ASTNode = optionalDoccomment optionalAnnotations INIT ^ parameters optionalBlock
        optionalPostconditions
    {
        ASTNode annotations = optionalAnnotations;
        annotations.fChildren.insert(annotations.fChildren.end(),
                optionalPostconditions.fChildren.begin(), optionalPostconditions.fChildren.end());
        result = ASTNode(CURRENT_POSITION, ASTNode::Kind::INIT, "init",
                { optionalDoccomment, annotations, parameters, optionalBlock });
    }

fieldDeclaration:ASTNode = optionalDoccomment optionalAnnotations varDeclaration
    {
        result = ASTNode(CURRENT_POSITION, ASTNode::Kind::FIELD,
                { optionalDoccomment, optionalAnnotations, varDeclaration });
    }

declaration:ASTNode = varDeclaration
    { result = varDeclaration; }
declaration:ASTNode = namedMethodValue
    { result = namedMethodValue; }

@statement:ASTNode = @"expected a statement" anyStatement @
    { result = anyStatement; }
anyStatement:ASTNode = ifStatement
    { result = ifStatement; }
anyStatement:ASTNode = forLoop
    { result = forLoop; }
anyStatement:ASTNode = whileLoop
    { result = whileLoop; }
anyStatement:ASTNode = doLoop
    { result = doLoop; }
anyStatement:ASTNode = loopLoop
    { result = loopLoop; }
anyStatement:ASTNode = methodCall
    { result = methodCall; }
anyStatement:ASTNode = assignment
    { result = assignment; }
anyStatement:ASTNode = assertStatement
    { result = assertStatement; }
anyStatement:ASTNode = matchStatement
    { result = matchStatement; }
anyStatement:ASTNode = LBRACE statements RBRACE
    { result = statements; }
anyStatement:ASTNode = LBRACE RBRACE
    { result = ASTNode(CURRENT_POSITION, ASTNode::Kind::STATEMENTS); }

varDeclaration:ASTNode = VAR varDeclarations
    { result = ASTNode(CURRENT_POSITION, ASTNode::Kind::VAR, varDeclarations.fChildren); }
varDeclaration:ASTNode = DEF varDeclarations
    { result = ASTNode(CURRENT_POSITION, ASTNode::Kind::DEF, varDeclarations.fChildren); }
varDeclaration:ASTNode = PROPERTY varDeclarations
    { result = ASTNode(CURRENT_POSITION, ASTNode::Kind::PROPERTY, varDeclarations.fChildren); }
varDeclaration:ASTNode = CONSTANT varDeclarations
    { result = ASTNode(CURRENT_POSITION, ASTNode::Kind::CONSTANT, varDeclarations.fChildren); }

varDeclarations:ASTNode = varDeclarations COMMA singleDeclaration
    {
        result = varDeclarations;
        result.fChildren.push_back(singleDeclaration);
    }
varDeclarations:ASTNode = singleDeclaration
    { result = ASTNode(CURRENT_POSITION, ASTNode::Kind::VARS, { singleDeclaration }); }
singleDeclaration:ASTNode = target
    { result = ASTNode(CURRENT_POSITION, ASTNode::Kind::DECLARATION, { target }); }
singleDeclaration:ASTNode = target ASSIGNMENT expression
    {
        result = ASTNode(CURRENT_POSITION, ASTNode::Kind::DECLARATION,
                std::vector<ASTNode> { target, expression });
    }
target:ASTNode = optionallyTypedIdentifier
    { result = optionallyTypedIdentifier; }
target:ASTNode = LPAREN targetList COMMA target RPAREN
    { 
        result = targetList;
        result.fChildren.push_back(target);
    }
targetList:ASTNode = target
    { result = ASTNode(CURRENT_POSITION, ASTNode::Kind::TUPLE_TARGET, { target }); }
targetList:ASTNode = targetList COMMA target
    {
        result = targetList;
        result.fChildren.push_back(target);        
    }
optionallyTypedIdentifier:ASTNode = IDENTIFIER
    { result = ASTNode(IDENTIFIER.fPosition, ASTNode::Kind::IDENTIFIER, IDENTIFIER.fText); }
optionallyTypedIdentifier:ASTNode = IDENTIFIER COLON type
    {
        result = ASTNode(IDENTIFIER.fPosition, ASTNode::Kind::IDENTIFIER, IDENTIFIER.fText,
                { type });
    }

ifStatement:ASTNode = IF ^ expression block optionalElse
    { result = ASTNode(CURRENT_POSITION, ASTNode::Kind::IF, { expression, block, optionalElse }); }
optionalElse:ASTNode = ELSE ifStatement
    { result = ifStatement; }
optionalElse:ASTNode = ELSE block
    { result = block; }
optionalElse:ASTNode =
    { }

forLoop:ASTNode = optionalLabel FOR @ ^ forTarget @"expected 'in'" IN @ ^ expression block
    {
        result = ASTNode(CURRENT_POSITION, ASTNode::Kind::FOR, optionalLabel, { forTarget,
                expression, block });
    }
optionalLabel:String = IDENTIFIER COLON @"expected 'while', 'loop', 'do', or 'for'"
    { result = IDENTIFIER.fText; }
optionalLabel:String =
    { }
forTarget:ASTNode = optionallyTypedIdentifier
    {
        result = ASTNode(CURRENT_POSITION, ASTNode::Kind::VAR, { optionallyTypedIdentifier });
    }
forTarget:ASTNode = LPAREN varDeclarations RPAREN
    { result = varDeclarations; }

whileLoop:ASTNode = optionalLabel WHILE @ ^ expression block
    {
        result = ASTNode(CURRENT_POSITION, ASTNode::Kind::WHILE, optionalLabel,
                { expression, block });
    }

doLoop:ASTNode = optionalLabel DO @ ^ block @"expected 'while'" WHILE @ expression
    {
        result = ASTNode(CURRENT_POSITION, ASTNode::Kind::DO, optionalLabel, { expression, block });
    }

loopLoop:ASTNode = optionalLabel LOOP @ ^ block
    { result = ASTNode(CURRENT_POSITION, ASTNode::Kind::LOOP, optionalLabel, { block }); }

methodCall:ASTNode = target:callExpression arguments
    {
        std::vector<ASTNode> children { target };
        children.insert(children.end(), arguments.fChildren.begin(), arguments.fChildren.end());
        result = ASTNode(CURRENT_POSITION, ASTNode::Kind::CALL, children);
    }
methodCall:ASTNode = INIT arguments
    {
        result = ASTNode(CURRENT_POSITION, ASTNode::Kind::CALL,
                std::vector<ASTNode> { ASTNode(CURRENT_POSITION, ASTNode::Kind::IDENTIFIER, "init"),
                    arguments } );
    }
assignment:ASTNode = assignmentTarget ASSIGNMENT expression
    {
        result = ASTNode(CURRENT_POSITION, ASTNode::Kind::BINARY, Operator::ASSIGNMENT,
                std::vector<ASTNode> { assignmentTarget, expression });
    }
assignment:ASTNode = e1:expression compoundAssignmentOperator e2:expression
    {
        result = ASTNode(CURRENT_POSITION, ASTNode::Kind::BINARY, compoundAssignmentOperator,
                std::vector<ASTNode> { e1, e2 });
    }
compoundAssignmentOperator:Operator = ASSIGNMENT
    { result = Operator::ASSIGNMENT; }
compoundAssignmentOperator:Operator = ADDEQ
    { result = Operator::ADDEQ; }
compoundAssignmentOperator:Operator = SUBEQ
    { result = Operator::SUBEQ; }
compoundAssignmentOperator:Operator = MULEQ
    { result = Operator::MULEQ; }
compoundAssignmentOperator:Operator = DIVEQ
    { result = Operator::DIVEQ; }
compoundAssignmentOperator:Operator = INTDIVEQ
    { result = Operator::INTDIVEQ; }
compoundAssignmentOperator:Operator = POWEQ
    { result = Operator::POWEQ; }
compoundAssignmentOperator:Operator = REMEQ
    { result = Operator::REMEQ; }
compoundAssignmentOperator:Operator = ANDEQ
    { result = Operator::ANDEQ; }
compoundAssignmentOperator:Operator = BITWISEANDEQ
    { result = Operator::BITWISEANDEQ; }
compoundAssignmentOperator:Operator = OREQ
    { result = Operator::OREQ; }
compoundAssignmentOperator:Operator = BITWISEOREQ
    { result = Operator::BITWISEOREQ; }
compoundAssignmentOperator:Operator = XOREQ
    { result = Operator::XOREQ; }
compoundAssignmentOperator:Operator = BITWISEXOREQ
    { result = Operator::BITWISEXOREQ; }
compoundAssignmentOperator:Operator = SHIFTLEFTEQ
    { result = Operator::SHIFTLEFTEQ; }
compoundAssignmentOperator:Operator = SHIFTRIGHTEQ
    { result = Operator::SHIFTRIGHTEQ; }

assertStatement:ASTNode = ASSERT expression
    { result = ASTNode(CURRENT_POSITION, ASTNode::Kind::ASSERT, { expression }); }
assertStatement:ASTNode = ASSERT test:expression COLON ^ msg:expression
    {
        result = ASTNode(CURRENT_POSITION, ASTNode::Kind::ASSERT,
                std::vector<ASTNode> { test, msg });
    }

matchStatement:ASTNode = MATCH expression LBRACE whens RBRACE ^
    {
        result = ASTNode(CURRENT_POSITION, ASTNode::Kind::MATCH,
                std::vector<ASTNode> { expression, whens });
    }
matchStatement:ASTNode = MATCH expression LBRACE whens matchDefault RBRACE ^
    {
        result = ASTNode(CURRENT_POSITION, ASTNode::Kind::MATCH,
                std::vector<ASTNode> { expression, whens, matchDefault });
    }
whens:ASTNode = whens when
    {
        result = whens;
        result.fChildren.push_back(when);
    }
whens:ASTNode = when
    { result = ASTNode(CURRENT_POSITION, ASTNode::Kind::WHENS, { when }); }
when:ASTNode = WHEN ^ expressionList COLON statements
    {
        ASTNode statement;
        if (statements.fChildren.size() == 1) {
            statement = statements.fChildren[0];
        }
        else {
            statement = ASTNode(statements.fPosition, ASTNode::Kind::BLOCK, statements.fChildren);
        }
        result = ASTNode(CURRENT_POSITION, ASTNode::Kind::WHEN,
                std::vector<ASTNode> { expressionList, statement });
    }
matchDefault:ASTNode = DEFAULT ^ COLON statements
    {
        if (statements.fChildren.size() == 1) {
            result = statements.fChildren[0];
        }
        else {
            result = ASTNode(statements.fPosition, ASTNode::Kind::BLOCK, statements.fChildren);
        }
    }

@block:ASTNode = @"expected '{'" LBRACE @ statements RBRACE
    { result = ASTNode(CURRENT_POSITION, ASTNode::Kind::BLOCK, statements.fChildren); }
@block:ASTNode = LBRACE RBRACE
    { result = ASTNode(CURRENT_POSITION, ASTNode::Kind::BLOCK); }
statements:ASTNode = statementList
    { result = statementList; }
statements:ASTNode = terminalStatement
    { result = ASTNode(CURRENT_POSITION, ASTNode::Kind::STATEMENTS, { terminalStatement }); }
statements:ASTNode = statementList terminalStatement
    {
        result = statementList;
        result.fChildren.push_back(terminalStatement);
    }
statementList:ASTNode = statementList statementOrDeclaration
    {
        result = statementList;
        result.fChildren.push_back(statementOrDeclaration);
    }
statementList:ASTNode = statementOrDeclaration
    { result = ASTNode(CURRENT_POSITION, ASTNode::Kind::STATEMENTS, { statementOrDeclaration }); }
statementOrDeclaration:ASTNode = statement
    { result = statement; }
statementOrDeclaration:ASTNode = declaration
    { result = declaration; }

terminalStatement:ASTNode = returnStatement
    { result = returnStatement; }
terminalStatement:ASTNode = breakStatement
    { result = breakStatement; }
terminalStatement:ASTNode = continueStatement
    { result = continueStatement; }
terminalStatement:ASTNode = unreachableStatement
    { result = unreachableStatement; }

returnStatement:ASTNode = RETURN
    { result = ASTNode(CURRENT_POSITION, ASTNode::Kind::RETURN); }
returnStatement:ASTNode = RETURN WS expression
    { result = ASTNode(CURRENT_POSITION, ASTNode::Kind::RETURN, { expression }); }

breakStatement:ASTNode = BREAK
    { result = ASTNode(CURRENT_POSITION, ASTNode::Kind::BREAK); }
breakStatement:ASTNode = BREAK IDENTIFIER
    { result = ASTNode(CURRENT_POSITION, ASTNode::Kind::BREAK, IDENTIFIER.fText); }

continueStatement:ASTNode = CONTINUE
    { result = ASTNode(CURRENT_POSITION, ASTNode::Kind::CONTINUE); }
continueStatement:ASTNode = CONTINUE IDENTIFIER
    { result = ASTNode(CURRENT_POSITION, ASTNode::Kind::CONTINUE, IDENTIFIER.fText); }

unreachableStatement:ASTNode = UNREACHABLE
    { result = ASTNode(CURRENT_POSITION, ASTNode::Kind::UNREACHABLE); }
unreachableStatement:ASTNode = UNREACHABLE COLON expression
    { result = ASTNode(CURRENT_POSITION, ASTNode::Kind::UNREACHABLE, { expression }); }


@type:ASTNode = @"expected a type" innerType @
    { result = innerType; }
innerType:ASTNode = dottedName optionalQuestion
    {
        result = ASTNode(CURRENT_POSITION, ASTNode::Kind::CLASS_TYPE, dottedName,
                { optionalQuestion });
    }
innerType:ASTNode = dottedName genericParameters optionalQuestion
    {
        result = ASTNode(CURRENT_POSITION, ASTNode::Kind::CLASS_TYPE, dottedName,
                std::vector<ASTNode> { optionalQuestion, genericParameters });
    }
innerType:ASTNode = LPAREN @"expected ')'" twoOrMoreTypes RPAREN @ optionalQuestion
    {
        result = ASTNode(CURRENT_POSITION, ASTNode::Kind::TUPLE_TYPE,
                std::vector<ASTNode> { optionalQuestion, twoOrMoreTypes });
    }
innerType:ASTNode = LPAREN @"expected ')'" optionalTypeList RPAREN @ YIELDS methodReturnType
        optionalQuestion
    {
        result = ASTNode(CURRENT_POSITION, ASTNode::Kind::FUNCTION_TYPE,
                std::vector<ASTNode> { optionalQuestion, optionalTypeList, methodReturnType });
    }
innerType:ASTNode = LPAREN @"expected ')'" optionalTypeList RPAREN @ YIELDS_METHOD methodReturnType
        optionalQuestion
    {
        result = ASTNode(CURRENT_POSITION, ASTNode::Kind::METHOD_TYPE,
                std::vector<ASTNode> { optionalQuestion, optionalTypeList, methodReturnType });
    }
innerType:ASTNode = LPAREN @"expected ')'" optionalTypeList RPAREN @ YIELDS_IMMUTABLE
        methodReturnType optionalQuestion
    {
        result = ASTNode(CURRENT_POSITION, ASTNode::Kind::IMMUTABLE_FUNCTION_TYPE,
                std::vector<ASTNode> { optionalQuestion, optionalTypeList, methodReturnType });
    }
innerType:ASTNode = LPAREN @"expected ')'" optionalTypeList RPAREN @ YIELDS_METHOD_IMMUTABLE
        methodReturnType optionalQuestion
    {
        result = ASTNode(CURRENT_POSITION, ASTNode::Kind::IMMUTABLE_METHOD_TYPE,
                std::vector<ASTNode> { optionalQuestion, optionalTypeList, methodReturnType });
    }
genericParameters:ASTNode = LT typeList GT
    { result = typeList; }
typeList:ASTNode = typeList @"expected ',' or '>'" COMMA @ type
    {
        result = typeList;
        result.fChildren.push_back(type);
    }
twoOrMoreTypes:ASTNode = typeList @"expected ',' or '>'" COMMA @ type
    {
        result = typeList;
        result.fChildren.push_back(type);
    }
typeList:ASTNode = type
    { result = ASTNode(CURRENT_POSITION, ASTNode::Kind::TYPES, { type }); }
optionalTypeList:ASTNode = typeList
    { result = typeList; }
optionalTypeList:ASTNode =
    { }
optionalQuestion:ASTNode = QUESTION
    { result = ASTNode(CURRENT_POSITION, ASTNode::Kind::BIT, true); }
optionalQuestion:ASTNode =
    { result = ASTNode(CURRENT_POSITION, ASTNode::Kind::BIT, false); }
methodReturnType:ASTNode = LPAREN @"expected ')'" RPAREN @
    { }
methodReturnType:ASTNode = LPAREN @"expected ')'" type RPAREN @
    { result = type; }

@expression:ASTNode = @"expected an expression" orExpression @
    { result = orExpression; }
orExpression:ASTNode = andExpression
    { result = andExpression; }
orExpression:ASTNode = orExpression OR andExpression
    {
        result = ASTNode(CURRENT_POSITION, ASTNode::Kind::BINARY, Operator::OR,
                { orExpression, andExpression });
    }
andExpression:ASTNode = comparisonExpression
    { result = comparisonExpression; }
andExpression:ASTNode = andExpression AND comparisonExpression
    {
        result = ASTNode(CURRENT_POSITION, ASTNode::Kind::BINARY, Operator::AND,
                { andExpression, comparisonExpression });
    }
andExpression:ASTNode = andExpression XOR comparisonExpression
    {
        result = ASTNode(CURRENT_POSITION, ASTNode::Kind::BINARY, Operator::XOR,
                { andExpression, comparisonExpression });
    }

comparisonExpression:ASTNode = rangeExpression
    { result = rangeExpression; }
comparisonExpression:ASTNode = comparisonExpression EQ rangeExpression
    {
        result = ASTNode(CURRENT_POSITION, ASTNode::Kind::BINARY, Operator::EQ,
                { comparisonExpression, rangeExpression });
    }
comparisonExpression:ASTNode = comparisonExpression NEQ rangeExpression
    {
        result = ASTNode(CURRENT_POSITION, ASTNode::Kind::BINARY, Operator::NEQ,
                { comparisonExpression, rangeExpression });
    }
comparisonExpression:ASTNode = comparisonExpression IDENTITY
        rangeExpression
    {
        result = ASTNode(CURRENT_POSITION, ASTNode::Kind::BINARY, Operator::IDENTITY,
                { comparisonExpression, rangeExpression });
    }
comparisonExpression:ASTNode = comparisonExpression NIDENTITY
        rangeExpression
    {
        result = ASTNode(CURRENT_POSITION, ASTNode::Kind::BINARY, Operator::NIDENTITY,
                { comparisonExpression, rangeExpression });
    }
comparisonExpression:ASTNode = comparisonExpression GT rangeExpression
    {
        result = ASTNode(CURRENT_POSITION, ASTNode::Kind::BINARY, Operator::GT,
                { comparisonExpression, rangeExpression });
    }
comparisonExpression:ASTNode = comparisonExpression LT rangeExpression
    {
        result = ASTNode(CURRENT_POSITION, ASTNode::Kind::BINARY, Operator::LT,
                { comparisonExpression, rangeExpression });
    }
comparisonExpression:ASTNode = comparisonExpression GTEQ rangeExpression
    {
        result = ASTNode(CURRENT_POSITION, ASTNode::Kind::BINARY, Operator::GTEQ,
                { comparisonExpression, rangeExpression });
    }
comparisonExpression:ASTNode = comparisonExpression LTEQ rangeExpression
    {
        result = ASTNode(CURRENT_POSITION, ASTNode::Kind::BINARY, Operator::LTEQ,
                { comparisonExpression, rangeExpression });
    }

indexRangeExpression:ASTNode = left:optionalBound rangeType right:optionalBound optionalBy
    {
        result = ASTNode(CURRENT_POSITION, rangeType, { left, right, optionalBy });
    }
optionalBound:ASTNode = additiveExpression
    { result = additiveExpression; }
optionalBound:ASTNode =
    { }
rangeType:ASTNode::Kind = DOTDOT
    { result = ASTNode::Kind::RANGE_EXCLUSIVE; }
rangeType:ASTNode::Kind = ELLIPSIS
    { result = ASTNode::Kind::RANGE_INCLUSIVE; }
optionalBy:ASTNode = BY additiveExpression
    { result = additiveExpression; }
optionalBy:ASTNode =
    { }
rangeExpression:ASTNode = left:additiveExpression rangeType right:additiveExpression optionalBy
    {
        result = ASTNode(CURRENT_POSITION, rangeType, { left, right, optionalBy });
    }
rangeExpression:ASTNode = additiveExpression
    { result = additiveExpression; }

additiveExpression:ASTNode = multiplicativeExpression
    { result = multiplicativeExpression; }
additiveExpression:ASTNode = additiveExpression ADD multiplicativeExpression
    {
        result = ASTNode(CURRENT_POSITION, ASTNode::Kind::BINARY, Operator::ADD,
                { additiveExpression, multiplicativeExpression });
    }
additiveExpression:ASTNode = additiveExpression SUB multiplicativeExpression
    {
        result = ASTNode(CURRENT_POSITION, ASTNode::Kind::BINARY, Operator::SUB,
                { additiveExpression, multiplicativeExpression });
    }
additiveExpression:ASTNode = additiveExpression BITWISEOR multiplicativeExpression
    {
        result = ASTNode(CURRENT_POSITION, ASTNode::Kind::BINARY, Operator::BITWISEOR,
                { additiveExpression, multiplicativeExpression });
    }

multiplicativeExpression:ASTNode = preExpression
    { result = preExpression; }
multiplicativeExpression:ASTNode = multiplicativeExpression MUL preExpression
    {
        result = ASTNode(CURRENT_POSITION, ASTNode::Kind::BINARY, Operator::MUL,
                { multiplicativeExpression, preExpression });
    }
multiplicativeExpression:ASTNode = multiplicativeExpression DIV preExpression
    {
        result = ASTNode(CURRENT_POSITION, ASTNode::Kind::BINARY, Operator::DIV,
                { multiplicativeExpression, preExpression });
    }
multiplicativeExpression:ASTNode = multiplicativeExpression INTDIV preExpression
    {
        result = ASTNode(CURRENT_POSITION, ASTNode::Kind::BINARY, Operator::INTDIV,
                { multiplicativeExpression, preExpression });
    }
multiplicativeExpression:ASTNode = multiplicativeExpression REM preExpression
    {
        result = ASTNode(CURRENT_POSITION, ASTNode::Kind::BINARY, Operator::REM,
                { multiplicativeExpression, preExpression });
    }
multiplicativeExpression:ASTNode = multiplicativeExpression SHIFTLEFT preExpression
    {
        result = ASTNode(CURRENT_POSITION, ASTNode::Kind::BINARY, Operator::SHIFTLEFT,
                { multiplicativeExpression, preExpression });
    }
multiplicativeExpression:ASTNode = multiplicativeExpression SHIFTRIGHT preExpression
    {
        result = ASTNode(CURRENT_POSITION, ASTNode::Kind::BINARY, Operator::SHIFTRIGHT,
                { multiplicativeExpression, preExpression });
    }
multiplicativeExpression:ASTNode = multiplicativeExpression BITWISEAND preExpression
    {
        result = ASTNode(CURRENT_POSITION, ASTNode::Kind::BINARY, Operator::BITWISEAND,
                { multiplicativeExpression, preExpression });
    }
multiplicativeExpression:ASTNode = multiplicativeExpression BITWISEXOR
        preExpression
    {
        result = ASTNode(CURRENT_POSITION, ASTNode::Kind::BINARY, Operator::BITWISEXOR,
                { multiplicativeExpression, preExpression });
    }

preExpression:ASTNode = postExpression
    { result = postExpression; }
preExpression:ASTNode = SUB postExpression
    {
        result = ASTNode(CURRENT_POSITION, ASTNode::Kind::PREFIX, Operator::SUB,
                { postExpression });
    }
preExpression:ASTNode = NOT postExpression
    {
        result = ASTNode(CURRENT_POSITION, ASTNode::Kind::PREFIX, Operator::NOT,
                { postExpression });
    }
preExpression:ASTNode = BITWISENOT postExpression
    {
        result = ASTNode(CURRENT_POSITION, ASTNode::Kind::PREFIX, Operator::BITWISENOT,
                { postExpression });
    }

postExpression:ASTNode = exponentExpression
    { result = exponentExpression; }
postExpression:ASTNode = exponentExpression NOT
    {
        result = ASTNode(CURRENT_POSITION, ASTNode::Kind::POSTFIX, Operator::FORCENONNULL,
                { exponentExpression });
    }

exponentExpression:ASTNode = callExpression
    { result = callExpression; }
exponentExpression:ASTNode = callExpression POW exponentExpression
    {
        result = ASTNode(CURRENT_POSITION, ASTNode::Kind::BINARY, Operator::POW,
                { callExpression, exponentExpression });
    }

callExpression:ASTNode = term
    { result = term; }
callExpression:ASTNode = methodCall
    { result = methodCall; }
callExpression:ASTNode = callExpression LBRACKET indexExpression RBRACKET
    {
        result = ASTNode(CURRENT_POSITION, ASTNode::Kind::INDEX,
                std::vector<ASTNode> { callExpression, indexExpression });
    }
callExpression:ASTNode = callExpression LT typeList GT
    {
        if (callExpression.fKind == ASTNode::Kind::IDENTIFIER ||
                callExpression.fKind == ASTNode::Kind::DOT) {
            result = ASTNode(CURRENT_POSITION, ASTNode::Kind::CLASS_LITERAL,
                    std::vector<ASTNode> { callExpression, typeList });
        }
        else {
            DIE(ASTNode());
        }
    }
callExpression:ASTNode = callExpression DOT IDENTIFIER
    {
        result = ASTNode(CURRENT_POSITION, ASTNode::Kind::DOT, IDENTIFIER.fText,
                { callExpression });
    }
callExpression:ASTNode = callExpression DOT specialMethodName
    {
        result = ASTNode(CURRENT_POSITION, ASTNode::Kind::DOT, specialMethodName,
                { callExpression });
    }
callExpression:ASTNode = callExpression DOT CLASS
    { result = ASTNode(CURRENT_POSITION, ASTNode::Kind::DOT, "$class", { callExpression, }); }
callExpression:ASTNode = callExpression DOT INIT
    { result = ASTNode(CURRENT_POSITION, ASTNode::Kind::DOT, "init", { callExpression, }); }
callExpression:ASTNode = callExpression INSTANCEOF typeExpression
    {
        result = ASTNode(CURRENT_POSITION, ASTNode::Kind::BINARY, Operator::INSTANCEOF,
                std::vector<ASTNode> { callExpression, typeExpression });
    }
callExpression:ASTNode = callExpression NINSTANCEOF typeExpression
    {
        result = ASTNode(CURRENT_POSITION, ASTNode::Kind::BINARY, Operator::NINSTANCEOF,
                std::vector<ASTNode> { callExpression, typeExpression });
    }
callExpression:ASTNode = callExpression CAST typeExpression
    {
        result = ASTNode(CURRENT_POSITION, ASTNode::Kind::BINARY, Operator::CAST,
                std::vector<ASTNode> { callExpression, typeExpression });
    }
indexExpression:ASTNode = expression
    { result = expression; }
indexExpression:ASTNode = indexRangeExpression
    { result = indexRangeExpression; }
typeExpression:ASTNode = type
    { result = type; }
typeExpression:ASTNode = LPAREN type RPAREN
    { result = type; }

arguments:ASTNode = LPAREN @"expected ')'" expressionList optionalEllipsis RPAREN @
    {
        result = expressionList;
        if (optionalEllipsis.fValue.fBool) {
            ASTNode last = result.fChildren[result.fChildren.size() - 1];
            result.fChildren[result.fChildren.size() - 1] = ASTNode(last.fPosition,
                    ASTNode::Kind::RANGE_INCLUSIVE, std::vector<ASTNode> { last, ASTNode() });
        }
    }
arguments:ASTNode = LPAREN RPAREN
    { result = ASTNode(CURRENT_POSITION, ASTNode::Kind::EXPRESSIONS); }
optionalEllipsis:ASTNode = ELLIPSIS
    { result = ASTNode(CURRENT_POSITION, ASTNode::Kind::BIT, true); }
optionalEllipsis:ASTNode =
    { result = ASTNode(CURRENT_POSITION, ASTNode::Kind::BIT, false); }
expressionList:ASTNode = expressionList COMMA expression
    {
        result = expressionList;
        result.fChildren.push_back(expression);
    }
expressionList:ASTNode = expression
    { result = ASTNode(CURRENT_POSITION, ASTNode::Kind::EXPRESSIONS, { expression }); }
assignmentTarget:ASTNode = LPAREN assignmentTargetList COMMA assignmentTarget RPAREN
    {
        result = ASTNode(assignmentTargetList.fPosition, ASTNode::Kind::ASSIGNMENT_TUPLE,
                std::move(assignmentTargetList.fChildren));
        result.fChildren.push_back(assignmentTarget);
    }
assignmentTarget:ASTNode = orExpression
    { result = orExpression; }
assignmentTargetList:ASTNode = assignmentTarget
    {
        result = ASTNode(assignmentTarget.fPosition, ASTNode::Kind::EXPRESSIONS,
                { assignmentTarget });
    }
assignmentTargetList:ASTNode = assignmentTargetList COMMA assignmentTarget
    {
        result = assignmentTargetList;
        result.fChildren.push_back(assignmentTarget);
    }

term:ASTNode = IDENTIFIER
    { result = ASTNode(CURRENT_POSITION, ASTNode::Kind::IDENTIFIER, IDENTIFIER.fText); }
term:ASTNode = INTEGER
    { result = INTEGER; }
term:ASTNode = STRING
    { result = STRING; }
term:ASTNode = FLOAT
    { result = FLOAT; }
term:ASTNode = TRUE
    { result = ASTNode(CURRENT_POSITION, ASTNode::Kind::BIT, true); }
term:ASTNode = FALSE
    { result = ASTNode(CURRENT_POSITION, ASTNode::Kind::BIT, false); }
term:ASTNode = NULL
    { result = ASTNode(CURRENT_POSITION, ASTNode::Kind::NULL_LITERAL); }
term:ASTNode = SELF
    { result = ASTNode(CURRENT_POSITION, ASTNode::Kind::SELF); }
term:ASTNode = SUPER
    { result = ASTNode(CURRENT_POSITION, ASTNode::Kind::SUPER); }
term:ASTNode = CLASS
    {
        result = ASTNode(CURRENT_POSITION, ASTNode::Kind::DOT, "$class",
                { ASTNode(CURRENT_POSITION, ASTNode::Kind::SELF) });
    }
term:ASTNode = LPAREN expressionList RPAREN
    {
        if (expressionList.fChildren.size() == 1) {
            result = expressionList.fChildren[0];
        }
        else {
            result = ASTNode(CURRENT_POSITION, ASTNode::Kind::TUPLE, expressionList.fChildren);
        }
    }
term:ASTNode = LBRACKET expressionList RBRACKET
    { result = ASTNode(CURRENT_POSITION, ASTNode::Kind::ARRAY, { expressionList }); }
term:ASTNode = LBRACKET RBRACKET
    { result = ASTNode(CURRENT_POSITION, ASTNode::Kind::ARRAY); }
term:ASTNode = lambda
    { result = lambda; }
term:ASTNode = methodValue
    { result = methodValue; }
REGEX_START = '/' ![/] ;
term:ASTNode = REGEX_START regex '/' WS
    { result = ASTNode(CURRENT_POSITION, ASTNode::Kind::REGEX, regex); }
term:ASTNode = PRE LPAREN expression RPAREN
    { result = ASTNode(CURRENT_POSITION, ASTNode::Kind::PRE, { expression }); }
term:ASTNode = ATRETURN
    { result = ASTNode(CURRENT_POSITION, ASTNode::Kind::AT_RETURN); }

regex:String = regexTerm
    { result = regexTerm; }
regex:String = regexTerm '|' regex
    { result = regexTerm + "|" + regex; }
regexTerm:String = regexFactor
    { result = regexFactor; }
regexTerm:String = regexTerm regexFactor
    { result = regexTerm + regexFactor; }
regexFactor:String = regexAtom
    { result = regexAtom; }
regexFactor:String = regexAtom regexQuantifier
    { result = regexAtom + regexQuantifier; }
regexAtom:String = regexCharacter
    { result = regexCharacter; }
regexAtom:String = c:[.^$]
    { result = c; }
regexAtom:String = '(' regex ')'
    { result = "(" + regex + ")"; }
regexAtom:String = '(?' type:[:=!>] regex ')'
    { result = "(?" + (type + regex) + ")"; }
regexAtom:String = '(?<' type:[!=] regex ')'
    { result = "(?<" + (type + regex) + ")"; }
regexAtom:String = '[' regexCharClass ']'
    { result = "[" + regexCharClass + "]"; }
regexAtom:String = '[^' regexCharClass ']'
    { result = "[^" + regexCharClass + "]"; }
regexCharClass:String = regexRange
    { result = regexRange; }
regexCharClass:String = regexCharClass regexRange
    { result = regexCharClass + regexRange; }
regexRange:String = regexRangeCharacter
    { result = regexRangeCharacter; }
regexRangeCharacter:String = c:[/|()[{^$*+?.]
    { result = c; }
regexRangeCharacter:String = regexCharacter
    { result = regexCharacter; }
regexRangeCharacter:String = begin:regexRangeCharacter '-' end:regexRangeCharacter
    { result = begin + "-" + end; }
regexCharacter:String = c:[-!"#%&',:;<=>@_`~0-9A-Za-z ]
    { result = c; }
regexCharacter:String = '\\' c:[-!"#%&',/:;<=>@_`~0-9A-Za-z \\|()[\]{}^$*+?.]
    { result = String("\\") + c; }
regexQuantifier:String = regexQuantifierBase
    { result = regexQuantifierBase; }
regexQuantifier:String = regexQuantifierBase modifier:[+?]
    { result = regexQuantifierBase + modifier; }
regexQuantifierBase:String = c:[*+?]
    { result = c; }
regexQuantifierBase:String = '{' regexInt '}'
    { result = "{" + regexInt + "}"; }
regexQuantifierBase:String = '{' regexInt ',}'
    { result = "{" + regexInt + ",}"; }
regexQuantifierBase:String = '{' min:regexInt ',' max:regexInt '}'
    { result = "{" + min + "," + max + "}"; }
regexInt:String = DECIMAL_CHAR
    { result = DECIMAL_CHAR; }
regexInt:String = regexInt DECIMAL_CHAR
    { result = regexInt + DECIMAL_CHAR; }

lambda:ASTNode = lambdaParameters YIELDS expression
    {
        result = ASTNode(CURRENT_POSITION, ASTNode::Kind::LAMBDA,
                std::vector<ASTNode> { lambdaParameters, expression });
    }
lambdaParameters:ASTNode = IDENTIFIER
    {
        result = ASTNode(CURRENT_POSITION, ASTNode::Kind::LAMBDA_PARAMETERS,
                std::vector<ASTNode> { ASTNode(IDENTIFIER.fPosition, ASTNode::Kind::IDENTIFIER, 
                    IDENTIFIER.fText) });
    }
lambdaParameters:ASTNode = IDENTIFIER COLON type
    {
        result = ASTNode(CURRENT_POSITION, ASTNode::Kind::LAMBDA_PARAMETERS,
                std::vector<ASTNode> { ASTNode(IDENTIFIER.fPosition, ASTNode::Kind::IDENTIFIER,
                    IDENTIFIER.fText, { type }) });
    }
lambdaParameters:ASTNode = LPAREN RPAREN
    { result = ASTNode(CURRENT_POSITION, ASTNode::Kind::LAMBDA_PARAMETERS); }
lambdaParameters:ASTNode = LPAREN untypedLambdaParameters RPAREN
    { result = untypedLambdaParameters; }
lambdaParameters:ASTNode = LPAREN typedLambdaParameters RPAREN
    { result = typedLambdaParameters; }
untypedLambdaParameters:ASTNode = untypedLambdaParameters COMMA IDENTIFIER
    {
        result = untypedLambdaParameters;
        result.fChildren.push_back(ASTNode(IDENTIFIER.fPosition, ASTNode::Kind::IDENTIFIER,
                IDENTIFIER.fText));
    }
untypedLambdaParameters:ASTNode = IDENTIFIER
    {
        result = ASTNode(CURRENT_POSITION, ASTNode::Kind::LAMBDA_PARAMETERS,
                std::vector<ASTNode> { ASTNode(CURRENT_POSITION, ASTNode::Kind::IDENTIFIER,
                    IDENTIFIER.fText) });
    }
typedLambdaParameters:ASTNode = typedLambdaParameters COMMA IDENTIFIER COLON type
    {
        result = typedLambdaParameters;
        result.fChildren.push_back(ASTNode(IDENTIFIER.fPosition, ASTNode::Kind::IDENTIFIER,
                IDENTIFIER.fText, { type }));
    }
typedLambdaParameters:ASTNode = IDENTIFIER COLON type
    {
        result = ASTNode(CURRENT_POSITION, ASTNode::Kind::LAMBDA_PARAMETERS,
                std::vector<ASTNode> { ASTNode(CURRENT_POSITION, ASTNode::Kind::IDENTIFIER,
                    IDENTIFIER.fText, { type }) });
    }

@methodValue:ASTNode = METHOD parameters ^ optionalTypeDeclaration block
    {
        result = ASTNode(CURRENT_POSITION, ASTNode::Kind::METHOD_VALUE,
                std::vector<ASTNode> { parameters, optionalTypeDeclaration, block });
    }
@methodValue:ASTNode = FUNCTION parameters ^ optionalTypeDeclaration block
    {
        result = ASTNode(CURRENT_POSITION, ASTNode::Kind::FUNCTION_VALUE,
                std::vector<ASTNode> { parameters, optionalTypeDeclaration, block });
    }

namedMethodValue:ASTNode = METHOD IDENTIFIER parameters ^ optionalTypeDeclaration block
    {
        ASTNode id = ASTNode(IDENTIFIER.fPosition, ASTNode::Kind::IDENTIFIER, IDENTIFIER.fText);
        ASTNode m = ASTNode(CURRENT_POSITION, ASTNode::Kind::METHOD_VALUE,
                std::vector<ASTNode> { parameters, optionalTypeDeclaration, block });
        result = ASTNode(CURRENT_POSITION, ASTNode::Kind::DEF, std::vector<ASTNode> { id, m });
    }
namedMethodValue:ASTNode = FUNCTION IDENTIFIER parameters ^ optionalTypeDeclaration block
    {
        ASTNode id = ASTNode(IDENTIFIER.fPosition, ASTNode::Kind::IDENTIFIER, IDENTIFIER.fText);
        ASTNode m = ASTNode(CURRENT_POSITION, ASTNode::Kind::FUNCTION_VALUE,
                std::vector<ASTNode> { parameters, optionalTypeDeclaration, block });
        result = ASTNode(CURRENT_POSITION, ASTNode::Kind::DEF, std::vector<ASTNode> { id, m });
    }

IDENTIFIER:ASTNode = identifierText WS
    {
        if (ParserUtil::IsPandaKeyword(identifierText)) {
            DIE(ASTNode());
        }
        else {
            result = ASTNode(CURRENT_POSITION, ASTNode::Kind::IDENTIFIER, identifierText);
        }
    }
identifierText:String = identifierStart identifierChars ![A-Za-z_$0-9]
    {
        result = identifierStart;
        result += identifierChars;
    }
identifierText:String = identifierStart ![A-Za-z_$0-9]
    { result = identifierStart; }
identifierStart:String = c:[a-zA-Z_$]
    { result = c; }
identifierChars:String = identifierChars identifierChar
    {
        result = identifierChars;
        result += identifierChar;
    }
identifierChars:String = identifierChar
    { result = identifierChar; }
identifierChar:String = c:[a-zA-Z_$0-9]
    { result = c; }

INTEGER:ASTNode = INTEGER_TEXT WS
    { result = INTEGER_TEXT; }
INTEGER_TEXT:ASTNode = DECIMAL_TEXT
    {
        result = ASTNode(CURRENT_POSITION, ASTNode::Kind::INT,
                ParserUtil::ToInt(DECIMAL_TEXT, 10));
    }
INTEGER_TEXT:ASTNode = '0x' HEX_TEXT
    {
        result = ASTNode(CURRENT_POSITION, ASTNode::Kind::INT, ParserUtil::ToInt(HEX_TEXT, 16));
    }
INTEGER_TEXT:ASTNode = '0b' BINARY_TEXT
    {
        result = ASTNode(CURRENT_POSITION, ASTNode::Kind::INT, ParserUtil::ToInt(BINARY_TEXT, 2));
    }
DECIMAL_TEXT:String = DECIMAL_CHARS ![A-Za-z_$0-9]
    { result = DECIMAL_CHARS; }
DECIMAL_CHARS:String = DECIMAL_CHARS DECIMAL_CHAR
    { result = DECIMAL_CHARS + DECIMAL_CHAR; }
DECIMAL_CHARS:String = DECIMAL_CHAR
    { result = DECIMAL_CHAR; }
DECIMAL_CHAR:String = digit:[0-9]
    { result = digit; }
HEX_TEXT:String = HEX_CHARS ![A-Za-z_$0-9]
    { result = HEX_CHARS; }
HEX_CHARS:String = HEX_CHARS HEX_CHAR
    { result = HEX_CHARS + HEX_CHAR; }
HEX_CHARS:String = HEX_CHAR
    { result = HEX_CHAR; }
HEX_CHAR:String = digit:[0-9A-Fa-f]
    { result = digit; }
BINARY_TEXT:String = BINARY_CHARS ![A-Za-z_$0-9]
    { result = BINARY_CHARS; }
BINARY_CHARS:String = BINARY_CHARS BINARY_CHAR
    { result = BINARY_CHARS + BINARY_CHAR; }
BINARY_CHARS:String = BINARY_CHAR
    { result = BINARY_CHAR; }
BINARY_CHAR:String = digit:[01]
    { result = digit; }

FLOAT:ASTNode = '.' DECIMAL_TEXT WS
    {
        result = ASTNode(CURRENT_POSITION, ASTNode::Kind::FLOAT,
                ParserUtil::ToDouble("." + DECIMAL_TEXT));
    }
FLOAT:ASTNode = '.' DECIMAL_CHARS EXPONENT WS
    {
        result = ASTNode(CURRENT_POSITION, ASTNode::Kind::FLOAT,
                ParserUtil::ToDouble("." + DECIMAL_CHARS + EXPONENT));
    }
FLOAT:ASTNode = d1:DECIMAL_CHARS '.' d2:DECIMAL_TEXT WS
    {
        result = ASTNode(CURRENT_POSITION, ASTNode::Kind::FLOAT,
                ParserUtil::ToDouble(d1 + "." + d2));
    }
FLOAT:ASTNode = DECIMAL_CHARS EXPONENT WS
    {
        result = ASTNode(CURRENT_POSITION, ASTNode::Kind::FLOAT,
                ParserUtil::ToDouble(DECIMAL_CHARS + EXPONENT));
    }
FLOAT:ASTNode = d1:DECIMAL_CHARS '.' d2:DECIMAL_CHARS EXPONENT WS
    {
        result = ASTNode(CURRENT_POSITION, ASTNode::Kind::FLOAT,
                ParserUtil::ToDouble(d1 + "." + d2 + EXPONENT));
    }
EXPONENT:String = [eE] DECIMAL_TEXT
    { result = "e" + DECIMAL_TEXT; }
EXPONENT:String = [eE] sign:[+-] DECIMAL_TEXT
    { result = "e" + (sign + DECIMAL_TEXT); }

STRING:ASTNode = STRING_SINGLE ^ WS
    { result = STRING_SINGLE; }
STRING:ASTNode = STRING_DOUBLE ^ WS
    { result = STRING_DOUBLE; }
STRING_SINGLE:ASTNode = ['] STRING_CHARS_SINGLE [']
    { result = ASTNode(CURRENT_POSITION, ASTNode::Kind::STRING, STRING_CHARS_SINGLE); }
STRING_CHARS_SINGLE:String = STRING_CHARS_SINGLE STRING_CHAR_SINGLE
    { result = STRING_CHARS_SINGLE + STRING_CHAR_SINGLE; }
STRING_CHARS_SINGLE:String =
    { result = ""; }
STRING_CHAR_SINGLE:String = c:[^'\\\n\r]
    { result = c; }
STRING_CHAR_SINGLE:String = ESCAPE
    { result = ESCAPE; }
STRING_DOUBLE:ASTNode = ["] STRING_CHARS_DOUBLE ["]
    { result = ASTNode(CURRENT_POSITION, ASTNode::Kind::STRING, STRING_CHARS_DOUBLE); }
STRING_CHARS_DOUBLE:String = STRING_CHARS_DOUBLE STRING_CHAR_DOUBLE
    { result = STRING_CHARS_DOUBLE + STRING_CHAR_DOUBLE; }
STRING_CHARS_DOUBLE:String =
    { result = ""; }
STRING_CHAR_DOUBLE:String = c:[^"\\\n\r]
    { result = c; }
STRING_CHAR_DOUBLE:String = ESCAPE
    { result = ESCAPE; }
ESCAPE:String = '\\' c:[nrt'":\\]
    { result = '\\' + c; }
ESCAPE:String = '\\{' formatExpression '}'
    {
        printf("string expressions broken\n");
        result = "\\{}";
    }
@formatExpression:ASTNode = expression optionalField optionalFormatString
    {
        result = ASTNode(CURRENT_POSITION, ASTNode::Kind::FORMAT_EXPRESSION, optionalFormatString,
                std::vector<ASTNode> { expression, optionalField });
    }
optionalField:ASTNode = COMMA optionalFillChar alignment DECIMAL_CHARS
    {
        result = ASTNode(CURRENT_POSITION, ASTNode::Kind::FORMAT_FIELD,
                std::vector<ASTNode> {
                    ASTNode(CURRENT_POSITION, ASTNode::Kind::INT, (int64_t) optionalFillChar),
                    ASTNode(CURRENT_POSITION, ASTNode::Kind::INT, (int64_t) alignment),
                    ASTNode(CURRENT_POSITION, ASTNode::Kind::INT,
                            ParserUtil::ToInt(DECIMAL_CHARS, 10))
                });
    }
optionalField:ASTNode =
    { }
optionalFillChar:int = c:[^:\n\r\\]
    { result = c; }
optionalFillChar:int = ESCAPE
    { result = ParserUtil::unescape(ESCAPE)[0]; }
optionalFillChar:int =
    { result = ' '; }
alignment:int = '<'
    { result = 0; }
alignment:int = '^'
    { result = 1; }
alignment:int = '>'
    { result = 2; }
formatString:String = formatString c:[^\\}]
    { result = formatString + c; }
formatString:String = c:[^\\}]
    { result = c; }
optionalFormatString:String = ':' formatString
    { result = formatString; }
optionalFormatString:String =
    { }

PACKAGE_TEXT:Position = 'package' ![A-Za-z_$0-9]
    { result = CURRENT_POSITION; }
PACKAGE:Position = PACKAGE_TEXT WS
    { result = PACKAGE_TEXT; }
CLASS_TEXT:Position = 'class' ![A-Za-z_$0-9]
    { result = CURRENT_POSITION; }
CLASS:Position = CLASS_TEXT WS
    { result = CLASS_TEXT; }
INTERFACE_TEXT:Position = 'interface' ![A-Za-z_$0-9]
    { result = CURRENT_POSITION; }
INTERFACE:Position = INTERFACE_TEXT WS
    { result = INTERFACE_TEXT; }
CHOICE_TEXT:Position = 'choice' ![A-Za-z_$0-9]
    { result = CURRENT_POSITION; }
CHOICE:Position = CHOICE_TEXT WS
    { result = CHOICE_TEXT; }
USES_TEXT:Position = 'uses' ![A-Za-z_$0-9]
    { result = CURRENT_POSITION; }
USES:Position = USES_TEXT WS
    { result = USES_TEXT; }
AS_TEXT:Position = 'as' ![A-Za-z_$0-9]
    { result = CURRENT_POSITION; }
AS:Position = AS_TEXT WS
    { result = AS_TEXT; }
METHOD_TEXT:Position = 'method' ![A-Za-z_$0-9]
    { result = CURRENT_POSITION; }
METHOD:Position = METHOD_TEXT WS
    { result = METHOD_TEXT; }
FUNCTION_TEXT:Position = 'function' ![A-Za-z_$0-9]
    { result = CURRENT_POSITION; }
FUNCTION:Position = FUNCTION_TEXT WS
    { result = FUNCTION_TEXT; }
INIT_TEXT :Position= 'init' ![A-Za-z_$0-9]
    { result = CURRENT_POSITION; }
INIT:Position = INIT_TEXT WS
    { result = INIT_TEXT; }
VAR_TEXT:Position = 'var' ![A-Za-z_$0-9]
    { result = CURRENT_POSITION; }
VAR:Position = VAR_TEXT WS
    { result = VAR_TEXT; }
DEF_TEXT:Position = 'def' ![A-Za-z_$0-9]
    { result = CURRENT_POSITION; }
DEF:Position = DEF_TEXT WS
    { result = DEF_TEXT; }
CONSTANT_TEXT:Position = 'constant' ![A-Za-z_$0-9]
    { result = CURRENT_POSITION; }
CONSTANT:Position = CONSTANT_TEXT WS
    { result = CONSTANT_TEXT; }
PROPERTY_TEXT:Position = 'property' ![A-Za-z_$0-9]
    { result = CURRENT_POSITION; }
PROPERTY:Position = PROPERTY_TEXT WS
    { result = PROPERTY_TEXT; }
PROTECTED_TEXT:Position = '@protected' ![A-Za-z_$0-9]
    { result = CURRENT_POSITION; }
PROTECTED:Position = PROTECTED_TEXT WS
    { result = PROTECTED_TEXT; }
MATH_TEXT:Position = '@math' ![A-Za-z_$0-9]
    { result = CURRENT_POSITION; }
MATH:Position = MATH_TEXT WS
    { result = MATH_TEXT; }
OVERFLOW_TEXT = 'overflow' ![A-Za-z_$0-9] ;
OVERFLOW = OVERFLOW_TEXT WS ;
INVARIANT_TEXT:Position = '@invariant' ![A-Za-z_$0-9]
    { result = CURRENT_POSITION; }
INVARIANT:Position = INVARIANT_TEXT WS
    { result = INVARIANT_TEXT; }
INSTANCE = '@$instance' WS ;
NESTED = '@$nested' WS ;
PRE_TEXT:Position = '@pre' ![A-Za-z_$0-9]
    { result = CURRENT_POSITION; }
PRE:Position = PRE_TEXT WS
    { result = PRE_TEXT; }
POST_TEXT:Position= '@post' ![A-Za-z_$0-9]
    { result = CURRENT_POSITION; }
POST:Position = POST_TEXT WS
    { result = POST_TEXT; }
PRE_OR_TEXT:Position= '@preOr' ![A-Za-z_$0-9]
    { result = CURRENT_POSITION; }
PRE_OR:Position = PRE_OR_TEXT WS
    { result = PRE_OR_TEXT; }
POST_AND_TEXT:Position= '@postAnd' ![A-Za-z_$0-9]
    { result = CURRENT_POSITION; }
POST_AND:Position = POST_AND_TEXT WS
    { result = POST_AND_TEXT; }
ATRETURN_TEXT:Position = '@return' ![A-Za-z_$0-9]
    { result = CURRENT_POSITION; }
ATRETURN:Position = ATRETURN_TEXT WS
    { result = ATRETURN_TEXT; }
TRUE_TEXT:Position = 'true' ![A-Za-z_$0-9]
    { result = CURRENT_POSITION; }
TRUE:Position = TRUE_TEXT WS
    { result = TRUE_TEXT; }
FALSE_TEXT:Position = 'false' ![A-Za-z_$0-9]
    { result = CURRENT_POSITION; }
FALSE:Position = FALSE_TEXT WS
    { result = FALSE_TEXT; }
NULL_TEXT:Position = 'null' ![A-Za-z_$0-9]
    { result = CURRENT_POSITION; }
NULL:Position = NULL_TEXT WS
    { result = NULL_TEXT; }
SELF_TEXT:Position = 'self' ![A-Za-z_$0-9]
    { result = CURRENT_POSITION; }
SELF:Position = SELF_TEXT WS
    { result = SELF_TEXT; }
SUPER_TEXT:Position = 'super' ![A-Za-z_$0-9]
    { result = CURRENT_POSITION; }
SUPER:Position = SUPER_TEXT WS
    { result = SUPER_TEXT; }
BY_TEXT:Position = 'by' ![A-Za-z_$0-9]
    { result = CURRENT_POSITION; }
BY:Position = BY_TEXT WS
    { result = BY_TEXT; }
FOR_TEXT:Position = 'for' ![A-Za-z_$0-9]
    { result = CURRENT_POSITION; }
FOR:Position = FOR_TEXT WS
    { result = FOR_TEXT; }
IN_TEXT:Position = 'in' ![A-Za-z_$0-9]
    { result = CURRENT_POSITION; }
IN:Position = IN_TEXT WS
    { result = IN_TEXT; }
WHILE_TEXT:Position = 'while' ![A-Za-z_$0-9]
    { result = CURRENT_POSITION; }
WHILE:Position = WHILE_TEXT WS
    { result = WHILE_TEXT; }
DO_TEXT:Position = 'do' ![A-Za-z_$0-9]
    { result = CURRENT_POSITION; }
DO:Position = DO_TEXT WS
    { result = DO_TEXT; }
LOOP_TEXT:Position = 'loop' ![A-Za-z_$0-9]
    { result = CURRENT_POSITION; }
LOOP:Position = LOOP_TEXT WS
    { result = LOOP_TEXT; }
IF_TEXT:Position = 'if' ![A-Za-z_$0-9]
    { result = CURRENT_POSITION; }
IF:Position = IF_TEXT WS
    { result = IF_TEXT; }
ELSE_TEXT:Position = 'else' ![A-Za-z_$0-9]
    { result = CURRENT_POSITION; }
ELSE:Position = ELSE_TEXT WS
    { result = ELSE_TEXT; }
MATCH_TEXT:Position = 'match' ![A-Za-z_$0-9]
    { result = CURRENT_POSITION; }
MATCH:Position = MATCH_TEXT WS
    { result = MATCH_TEXT; }
WHEN_TEXT:Position = 'when' ![A-Za-z_$0-9]
    { result = CURRENT_POSITION; }
WHEN:Position = WHEN_TEXT WS
    { result = WHEN_TEXT; }
DEFAULT_TEXT:Position = 'default' ![A-Za-z_$0-9]
    { result = CURRENT_POSITION; }
DEFAULT:Position = DEFAULT_TEXT WS
    { result = DEFAULT_TEXT; }
RETURN_TEXT:Position = 'return' ![A-Za-z_$0-9]
    { result = CURRENT_POSITION; }
RETURN:Position = RETURN_TEXT WS
    { result = RETURN_TEXT; }
CONTINUE_TEXT:Position = 'continue' ![A-Za-z_$0-9]
    { result = CURRENT_POSITION; }
CONTINUE:Position = CONTINUE_TEXT WS
    { result = CONTINUE_TEXT; }
BREAK_TEXT:Position = 'break' ![A-Za-z_$0-9]
    { result = CURRENT_POSITION; }
BREAK:Position = BREAK_TEXT WS
    { result = BREAK_TEXT; }
ASSERT_TEXT:Position = 'assert' ![A-Za-z_$0-9]
    { result = CURRENT_POSITION; }
ASSERT:Position = ASSERT_TEXT WS
    { result = ASSERT_TEXT; }
UNREACHABLE_TEXT:Position = 'unreachable' ![A-Za-z_$0-9]
    { result = CURRENT_POSITION; }
UNREACHABLE:Position = UNREACHABLE_TEXT WS
    { result = UNREACHABLE_TEXT; }
COLON = ':' WS ;
LBRACKET = '[' WS ;
RBRACKET = ']' WS ;
LBRACE = '{' WS ;
RBRACE = '}' WS ;
LPAREN_TEXT:Position = '('
    { result = CURRENT_POSITION; }
LPAREN:Position = LPAREN_TEXT WS
    { result = LPAREN_TEXT; }
RPAREN = ')' WS ;
ADD = '+' WS ;
SUB_TEXT = '-' ![-] ;
SUB = SUB_TEXT WS ;
MUL = '*' WS ;
DIV_TEXT = '/' ![/] ;
DIV = DIV_TEXT WS ;
REM = '%' WS ;
INTDIV = '//' WS ;
AND = '&' WS ;
OR = '|' WS ;
XOR = '~' WS ;
SHIFTLEFT = '<<' WS ;
SHIFTRIGHT = '>>' WS ;
BITWISEAND = '&&' WS ;
BITWISEOR = '||' WS ;
BITWISEXOR = '~~' WS ;
POW = '^' WS ;
EQ = '=' WS ;
NEQ = '!=' WS ;
LT = '<' WS ;
GT = '>' WS ;
LTEQ = '<=' WS ;
GTEQ = '>=' WS ;
IDENTITY = '==' WS ;
NIDENTITY = '!==' WS ;
NOT_TEXT = '!' ![=] ;
NOT = NOT_TEXT WS ;
BITWISENOT = '!!' WS ;
ASSIGNMENT = ':=' WS ;
ADDEQ = '+=' WS  ;
SUBEQ = '-=' WS ;
MULEQ = '*=' WS  ;
DIVEQ = '/=' WS  ;
INTDIVEQ = '//=' WS  ;
POWEQ = '^=' WS  ;
REMEQ = '%=' WS  ;
ANDEQ = '&=' WS  ;
BITWISEANDEQ = '&&=' WS  ;
OREQ = '|=' WS  ;
BITWISEOREQ = '||=' WS  ;
XOREQ = '~=' WS  ;
BITWISEXOREQ = '~~=' WS  ;
SHIFTLEFTEQ = '<<=' WS  ;
SHIFTRIGHTEQ = '>>=' WS  ;
CAST = '->' WS ;
INSTANCEOF = '-?>' WS ;
NINSTANCEOF = '-!>' WS ;
COMMA  = ',' WS ;
STAR = '*' WS ;
DOT = '.' WS ;
DOTDOT = '..' WS ;
ELLIPSIS = '...' WS ;
QUESTION = '?' WS ;
YIELDS = '=>' WS ;
YIELDS_METHOD = '=&>' WS ;
YIELDS_IMMUTABLE = '=>*' WS ;
YIELDS_METHOD_IMMUTABLE = '=&>*' WS ;

WS = WS WS_CHAR ;
WS = ;
WS_CHAR = [ \r\n\t] ;
WS_CHAR = COMMENT ;
COMMENT = LINE_COMMENT ;
COMMENT = BLOCK_COMMENT ;
LINE_COMMENT = '--' LINE_COMMENT_CHARS [\n] ;
LINE_COMMENT_CHARS = LINE_COMMENT_CHARS [^\n] ;
LINE_COMMENT_CHARS = ;
TRAILING_LINE_COMMENT = '--' LINE_COMMENT_CHARS ;
BLOCK_COMMENT = '-*' @"expected '*-' to close comment (started at <pos>)" BLOCK_COMMENT_CHARS '*-' @ ;
BLOCK_COMMENT_CHARS = BLOCK_COMMENT_CHARS BLOCK_COMMENT_CHAR ;
BLOCK_COMMENT_CHARS = ;
BLOCK_COMMENT_CHAR = [^*] ;
BLOCK_COMMENT_CHAR = '*' [^-] ;
BLOCK_COMMENT_CHAR = BLOCK_COMMENT ;
SINGLE_LINE_BLOCK_COMMENT = '-*'  @"expected '*-' to close comment (started at <pos>)"
        SINGLE_LINE_BLOCK_COMMENT_CHARS '*-' @ ;
SINGLE_LINE_BLOCK_COMMENT_CHARS = SINGLE_LINE_BLOCK_COMMENT_CHARS
        SINGLE_LINE_BLOCK_COMMENT_CHAR ;
SINGLE_LINE_BLOCK_COMMENT_CHARS = ;
SINGLE_LINE_BLOCK_COMMENT_CHAR = [^*\n\r] ;
SINGLE_LINE_BLOCK_COMMENT_CHAR = '*' [^-] ;
SINGLE_LINE_BLOCK_COMMENT_CHAR = SINGLE_LINE_BLOCK_COMMENT ;
DOCCOMMENT:String = '===' @"expected '===' to close comment (started at <pos>)" TRAILING_EQUALS
        DOCCOMMENT_CHARS '===' @ TRAILING_EQUALS WS
    { result = DOCCOMMENT_CHARS; }
DOCCOMMENT_CHARS:String = DOCCOMMENT_CHARS DOCCOMMENT_CHAR
    { result = DOCCOMMENT_CHARS + DOCCOMMENT_CHAR; }
DOCCOMMENT_CHARS:String = DOCCOMMENT_CHAR
    { result = DOCCOMMENT_CHAR; }
DOCCOMMENT_CHAR:String = c:[^=]
    { result = c; }
DOCCOMMENT_CHAR:String = '=' c:[^=]
    { result = String("=") + c; }
DOCCOMMENT_CHAR:String = '==' c:[^=]
    { result = String("==") + c; }
TRAILING_EQUALS = TRAILING_EQUALS_CHARS ;
TRAILING_EQUALS = ;
TRAILING_EQUALS_CHARS = TRAILING_EQUALS_CHARS '=' ;
TRAILING_EQUALS_CHARS = '=' ;
