package org.pandalanguage.pandac

uses org.pandalanguage.pandac.parser.Token

class LLVMCodeGenerator (CodeGenerator) {
    class ClassConstant : Immutable {
        def name:String
        def type:String

        init(name:String, type:String) {
            self.name := name
            self.type := type
        }
    }

    class LoopDescriptor : Immutable {
        def loopLabel:String?
        def breakLabel:String
        def continueLabel:String

        init(loopLabel:String?, breakLabel:String, continueLabel:String) {
            self.loopLabel := loopLabel
            self.breakLabel := breakLabel
            self.continueLabel := continueLabel
        }
    }

    constant POINTER_SIZE := 8

    constant OBJECT_FIELD_COUNT := 2

    constant INT_TYPE := "i64"

    def out:OutputStream

    def compiler:Compiler

    def declarations := MemoryOutputStream()

    def types := MemoryOutputStream()

    def methodsBuffer := MemoryOutputStream()

    def methods := IndentedOutputStream(methodsBuffer)

    def methodHeaderBuffer := MemoryOutputStream()

    def methodHeader := IndentedOutputStream(methodHeaderBuffer)

    def strings := MemoryOutputStream()

    def declared := Set<String>()

    def writtenTypes := Set<String>()

    def writtenWrappers := Set<String>()

    def classConstants := HashMap<String, ClassConstant>()

    def variableNames := IdentityMap<Variable, String>()

    var currentBlock:String

    def loopDescriptors := Stack<LoopDescriptor>()

    var varCount := 0

    var labelCount := 0

    init(compiler:Compiler) {
        self.compiler := compiler
    }

    @override
    method start(out:OutputStream) {
        self.out := IndentedOutputStream(out)

        out.printLine("target datalayout = \"e-p:64:64:64-i1:8:8-i8:8:8-i16:16:16-i32:32:32-i64:" +
                "64:64-f32:32:32-f64:64:64-v64:64:64-v128:128:128-a0:0:64-s0:64:64-f80:128:128-" +
                "n8:16:32:64-S128\"")
        out.printLine("target triple = \"x86_64-apple-macosx10.8.0\"")
        out.printLine("declare i8* @malloc(i64)")
    }

    @override
    method finish() {
        out.print(types.convert())
        out.print(strings.convert())
        out.print(declarations.convert())
        out.print(methodsBuffer.convert())
    }

    method nextVar():String {
        varCount += 1
        return "%\{varCount}"
    }

    method nextLabel():String {
        labelCount += 1
        return "$l\{labelCount}"
    }

    method createBlock(label:String, out:OutputStream) {
        out.printLine("\n\{label}:")
        currentBlock := label
    }

    function endsWithBranch(stmt:IRNode):Bit {
        match stmt.kind {
            when IRNode.Kind.BLOCK:
                if stmt.children.get_count() = 0 {
                    return false
                }
                return endsWithBranch(stmt.children[stmt.children.get_count() - 1])
            when IRNode.Kind.BREAK, IRNode.Kind.CONTINUE, IRNode.Kind.RETURN:
                return true
            otherwise: return false
        }
    }

    function fieldSize(t:Type):Int {
        assert t.resolved
        if t.isBuiltinNumber() {
            if t.name.endsWith("8") {
                return 1
            }
            if t.name.endsWith("16") {
                return 2
            }
            if t.name.endsWith("32") {
                return 4
            }
            assert t.name.endsWith("64")
            return 8
        }
        if t = Type.BuiltinBit() {
            return 1
        }
        def cl := compiler.getClass(t)
        assert cl != null
        if !compiler.isValue(cl) {
            return POINTER_SIZE
        }
        var result := 0
        for f in compiler.instanceFields(cl) {
            if f.annotations.isClass() {
                continue
            }
            compiler.resolve(f)
            def size := fieldSize(f.type)
            def align := result % size
            if align != 0 {
                result += size - align
            }
            assert result % size = 0
            result += size
        }
        if t.typeKind = Type.Kind.NULLABLE {
            result += 1
        }
        return result
    }

    function alignment(t:Type):Int {
        return fieldSize(t).min(8)
    }

    function sizeOf(t:Type):Int {
        if !t.isClass() {
            return fieldSize(t)
        }
        def cl := compiler.getClass(t)
        assert cl != null
        var result := 0
        for f in compiler.instanceFields(cl) {
            compiler.resolve(f)
            def size := fieldSize(f.type)
            def align := result % size
            if align != 0 {
                result += size - align
            }
            assert result % size = 0
            result += size
        }
        if compiler.isValue(cl) & t.typeKind = Type.Kind.NULLABLE {
            result += 1
        }
        return result
    }

    function sizeOfWrapper(t:Type):Int {
        def cl := compiler.getClass(t)
        assert cl != null & compiler.isValue(cl)
        var result := sizeOf(Type.Object())
        for f in compiler.instanceFields(cl) {
            compiler.resolve(f)
            def size := fieldSize(f.type)
            def align := result % size
            if align != 0 {
                result += size - align
            }
            assert result % size = 0
            result += size
        }
        if t.typeKind = Type.Kind.NULLABLE {
            result += 1
        }
        return result
    }

    method writeType(t:Type) {
        if writtenTypes.contains(t.name) {
            return
        }
        writtenTypes.add(t.name)
        def code := MutableString("%\{escapeName(t.name)} = type { ")
        def cl := compiler.getClass(t)
        assert cl != null
        var separator := ""
        for f in compiler.instanceFields(cl) {
            compiler.resolve(f)
            code.append("\{separator}\{type(f.type)}")
            separator := ", "
        }
        code.append(" }")
        types.printLine(code)
    }

    method writeWrapperType(t:Type) {
        if writtenWrappers.contains(t.name) {
            return
        }
        writtenWrappers.add(t.name)
        def code := MutableString("\{type(t)}$wrapper = type { ")
        def object := compiler.getClass(Type.Object())
        assert object != null
        var separator := ""
        for f in compiler.instanceFields(object) {
            compiler.resolve(f)
            code.append("\{separator}\{type(f.type)}")
            separator := ", "
        }
        code.append(", \{type(t)}")
        code.append(" }")
        types.printLine(code)
        types.printLine("\{type(t)}$nullable = type { \{type(t)}, i1 }")
    }

    function typeName(t:Type):String {
        return "%" + escapeName(t.name)
    }

    method type(t:Type):String {
        match t.typeKind {
            when Type.Kind.VOID:
                return "void"
            when Type.Kind.BUILTIN_INT, Type.Kind.BUILTIN_UINT:
                return "i\{sizeOf(t) * 8}"
            when Type.Kind.BUILTIN_BIT:
                return "i1"
            when Type.Kind.CLASS:
                writeType(t)
                def name := "%\{escapeName(t.name)}"
                if t.isClass() {
                    def cl := compiler.getClass(t)
                    assert cl != null
                    if !compiler.isValue(cl) {
                        return name + "*"
                    }
                }
                return name
            when Type.Kind.NULLABLE:
                def cl := compiler.getClass(t)
                assert cl != null
                if compiler.isValue(cl) {
                    return nullableType(t)
                }
                return type(t.subtypes[0])
            when Type.Kind.GENERIC:
                if t.subtypes[0].name = "panda.unsafe.Pointer" {
                    return type(t.subtypes[1]) + "*"
                }
                return type(t.subtypes[0])
            when Type.Kind.GENERIC_PARAMETER:
                return type(t.subtypes[0])
            otherwise:
                assert false, "unsupported type '\{t}'"
        }
    }

    method wrapperTypeName(t:Type):String {
        if t.typeKind = Type.Kind.NULLABLE {
            return wrapperTypeName(t.subtypes[0])
        }
        writeWrapperType(t)
        return "%\{escapeName(t.name)}$wrapper"
    }

    method wrapperType(t:Type):String {
        return wrapperTypeName(t) + "*"
    }

    method nullableType(t:Type):String {
        assert t.typeKind = Type.Kind.NULLABLE, "\{t} is not nullable"
        return "\{type(t.subtypes[0])}$nullable"
    }

    method getITable(cl:ClassDecl):String {
        return "null"
    }

    -- FIXME use tuple
    class Pair<A, B> {
        def first:A
        def second:B

        init(first:A, second:B) {
            self.first := first
            self.second := second
        }
    }

    function needsStructIndirection(m:MethodDecl):Bit {
        return false
    }

    method getMethodTableEntry(m:MethodDecl):Pair<String, String> -* name, type *- {
        compiler.resolve(m)
        if m.owner.external {
            writeDeclaration(m)
        }
        def resultName := getName(m)
        def effective := compiler.inheritedTypeWithSelf(m)
        if needsStructIndirection(m) {
            def resultType := MutableString("void (")
            resultType.append(type(effective.subtypes[effective.subtypes.get_count() - 1]))
            resultType.append("*")
            for i in 0 .. effective.subtypes.get_count() - 1 {
                resultType.append(", ")
                resultType.append(type(effective.subtypes[i]))
            }
            resultType.append(")*")
            return Pair<String, String>(resultName, resultType.convert())
        }
        return Pair<String, String>(resultName, type(effective))
    }

    method getClassConstant(cl:ClassDecl):ClassConstant {
        var result := classConstants[cl.name]
        if result = null {
            compiler.resolve(cl)
            def type:String
            if cl.external {
                result := ClassConstant("@\{escapeName(cl.type().name)}$class",
                        "%panda$core$Class*")
                classConstants[cl.name] := result
                types.printLine("\{result.name} = external global \{result.type}")
                return classConstants[cl.name]
            }
            def vtable := compiler.getVTable(cl)
            result := ClassConstant("@\{escapeName(cl.type().name)}$class",
                    "{ i8*, \{INT_TYPE}, %$itable*, [\{vtable.get_count()} x i8*] }")
            classConstants[cl.name] := result
            def superPtr:String
            if cl.rawSuper != Type.Void() {
                def superCC := getClassConstant(compiler.getClass(cl.rawSuper))
                superPtr := "bitcast(\{superCC.type}* \{superCC.name} to i8*)"
            }
            else {
                superPtr := "null"
            }
            def itable := getITable(cl)
            def code := MutableString("\{result.name} = constant \{result.type} { " +
                    "i8* \{super}, \{INT_TYPE} 1, \{getITable(cl)}, " +
                    "[\{vtable.get_count()} x i8*] [")
            var separator := ""
            for m in vtable {
                code.append(separator)
                if m.annotations.isAbstract() {
                    code.append("i8* null")
                }
                else {
                    def entry := getMethodTableEntry(m)
                    code.append("i8* bitcast(\{entry.second} \{entry.first} to i8*)")
                }
                separator := ", "
            }
            code.append("] }\n")
            types.printLine(code)
        }
        return result
    }

    method getWrapperClassConstant(cl:ClassDecl):ClassConstant {
        def name := "@\{escapeName(cl.name)}$wrapperclass"
        var result := classConstants[name]
        if result = null {
            if cl.external {
                type(Type.Class())
                def type := "%panda$core$Class"
                types.printLine("\{name} = external global \{type}")
                result := ClassConstant(name, type)
                classConstants[name] := result
            }
            else {
                assert false
            }
        }
        return result
    }

    function escapeName(s:String):String {
        return s.replace(".", "$").replace("?", "$Q")
    }

    function getName(v:Variable):String {
        if v.storage = Variable.Storage.PARAMETER {
            return "%\{v.name}"
        }
        var result := variableNames[v]
        if result = null {
            labelCount += 1
            result := "%\{v.name}\{labelCount}"
            variableNames[v] := result
        }
        return result
    }

    function getName(m:MethodDecl):String {
        if m.name = "main" {
            return "@pandaMain"
        }
        def result := MutableString("@")
        result.append(escapeName(m.owner.name))
        result.append("$")
        match m.name {
            when "+":    result.append("$ADD")
            when "-":    result.append("$SUB")
            when "*":    result.append("$MUL")
            when "/":    result.append("$DIV")
            when "//":   result.append("$INTDIV")
            when "%":    result.append("$REM")
            when "^":    result.append("$POW")
            when "[]":   result.append("$IDX")
            when "[]:=": result.append("$IDXEQ")
            when "=":    result.append("$EQ")
            when "!=":   result.append("$NEQ")
            when ">":    result.append("$GT")
            when "<":    result.append("$LT")
            when ">=":   result.append("$GE")
            when "<=":   result.append("$LE")
            when "|":    result.append("$OR")
            when "||":   result.append("$BOR")
            when "&":    result.append("$AND")
            when "&&":   result.append("$BAND")
            when "~":    result.append("$XOR")
            when "~~":   result.append("$BXOR")
            when "!":    result.append("$NOT")
            when "!!":   result.append("$BNOT")
            when "<<":   result.append("$SHL")
            when ">>":   result.append("$SHR")
            otherwise:   result.append(escapeName(m.name))
        }
        for p in m.parameters {
            result.append("$\{escapeName(p.type.name)}")
        }
        if m.returnType != Type.Void() {
            result.append("$R$")
            result.append(escapeName(m.returnType.name))
        }
        return result.convert()
    }

    class OpClass {
        constant SIGNED   := 10121
        constant UNSIGNED := 10122
        constant FLOAT    := 10123
    }

    function opClass(t:Type):Int {
        match t.typeKind {
            when Type.Kind.BUILTIN_INT:   return OpClass.SIGNED
            when Type.Kind.BUILTIN_UINT:  return OpClass.UNSIGNED
            when Type.Kind.BUILTIN_FLOAT: return OpClass.FLOAT
            otherwise:
                assert false
        }
    }

    method getBinaryReference(cl:Int, leftRef:String, op:Int, rightRef:String,
            out:OutputStream):String {
        def llvmOp:String
        match cl {
            when OpClass.SIGNED:
                match op {
                    when Token.Kind.ADD:        llvmOp := "add"
                    when Token.Kind.SUB:        llvmOp := "sub"
                    when Token.Kind.MUL:        llvmOp := "mul"
                    when Token.Kind.INTDIV:     llvmOp := "sdiv"
                    when Token.Kind.REM:        llvmOp := "srem"
                    when Token.Kind.SHIFTLEFT:  llvmOp := "shl"
                    when Token.Kind.SHIFTRIGHT: llvmOp := "ashr"
                    when Token.Kind.BITWISEAND: llvmOp := "and"
                    when Token.Kind.BITWISEOR:  llvmOp := "or"
                    when Token.Kind.XOR, Token.Kind.BITWISEXOR: 
                                                llvmOp := "xor"
                    when Token.Kind.EQ:         llvmOp := "icmp eq"
                    when Token.Kind.NEQ:        llvmOp := "icmp ne"
                    when Token.Kind.GT:         llvmOp := "icmp sgt"
                    when Token.Kind.LT:         llvmOp := "icmp slt"
                    when Token.Kind.GTEQ:       llvmOp := "icmp sge"
                    when Token.Kind.LTEQ:       llvmOp := "icmp sle"
                    otherwise:
                        assert false
                }
            when OpClass.UNSIGNED:
                match op {
                    when Token.Kind.ADD:        llvmOp := "add"
                    when Token.Kind.SUB:        llvmOp := "sub"
                    when Token.Kind.MUL:        llvmOp := "mul"
                    when Token.Kind.INTDIV:     llvmOp := "udiv"
                    when Token.Kind.REM:        llvmOp := "urem"
                    when Token.Kind.SHIFTLEFT:  llvmOp := "shl"
                    when Token.Kind.SHIFTRIGHT: llvmOp := "lshr"
                    when Token.Kind.BITWISEAND: llvmOp := "and"
                    when Token.Kind.BITWISEOR:  llvmOp := "or"
                    when Token.Kind.XOR, Token.Kind.BITWISEXOR: 
                                                llvmOp := "xor"
                    when Token.Kind.EQ:         llvmOp := "icmp eq"
                    when Token.Kind.NEQ:        llvmOp := "icmp ne"
                    when Token.Kind.GT:         llvmOp := "icmp ugt"
                    when Token.Kind.LT:         llvmOp := "icmp ult"
                    when Token.Kind.GTEQ:       llvmOp := "icmp uge"
                    when Token.Kind.LTEQ:       llvmOp := "icmp ule"
                    otherwise:
                        assert false
                }
            when OpClass.FLOAT:
                match op {
                    when Token.Kind.ADD:        llvmOp := "fadd"
                    when Token.Kind.SUB:        llvmOp := "fsub"
                    when Token.Kind.MUL:        llvmOp := "fmul"
                    when Token.Kind.INTDIV:     llvmOp := "fdiv"
                    when Token.Kind.EQ:         llvmOp := "fcmp oeq"
                    when Token.Kind.NEQ:        llvmOp := "fcmp one"
                    when Token.Kind.GT:         llvmOp := "fcmp ogt"
                    when Token.Kind.LT:         llvmOp := "fcmp olt"
                    when Token.Kind.GTEQ:       llvmOp := "fcmp oge"
                    when Token.Kind.LTEQ:       llvmOp := "fcmp ole"
                    otherwise:
                        assert false
                }
        }
        def result := nextVar()
        out.printLine("\{result} = \{llvmOp} \{leftRef}, \{rightRef}")
        return result
    }

    method getBinaryReference(left:IRNode, op:Int, right:IRNode, out:OutputStream):String {
        assert left.type = right.type
        match op {
            when Token.Kind.AND:       assert false -- return getAndReference(left, right, out)
            when Token.Kind.OR:        assert false -- return getOrReference(left, right, out)
            when Token.Kind.IDENTITY:  assert false -- return getIdentityReference(left, right, out)
            when Token.Kind.NIDENTITY: assert false -- return getNIdentityReference(left, right, out)
            otherwise:
                def leftRef := getTypedReference(left, out)
                def rightRef := getReference(right, out)
                return getBinaryReference(opClass(left.type), leftRef, op, rightRef, out)
        }
    }

    method getBinaryReference(b:IRNode, out:OutputStream):String {
        assert b.kind = IRNode.Kind.BINARY
        assert b.children.get_count() = 2
        return getBinaryReference(b.children[0], b.payload->Int, b.children[1], out)
    }

    function callingConvention(m:MethodDecl):String {
        return "fastcc "
    }

    method getCallReference(call:IRNode, out:OutputStream):String {
        assert call.kind = IRNode.Kind.CALL
        def m := (call.payload->MethodRef).value
        if m.owner.external {
            writeDeclaration(m)
        }
        def args := Array<String>(call.children.get_count())
        for a in call.children {
            args.add(getTypedReference(a, out))
        }
        def result := nextVar()
        out.printLine("\{result} = call \{callingConvention(m)}\{type(call.type)} " +
                "\{getName(m)}(\{args.join()})")
        return result
    }

    method wrapValue(value:String, srcType:Type, dstType:Type, out:OutputStream):String {
        out.printLine("; wrapping \{value}")
        def src := compiler.getClass(srcType)
        assert src != null
        if srcType.typeKind = Type.Kind.NULLABLE {
            -- casting nullable value to nullable wrapper, need to special-case null
            def testStart := currentBlock
            def isNonNull := nextVar()
            out.printLine("\{isNonNull} = extractvalue \{nullableType(srcType)} \{value}, 1")
            def nonNullLabel := nextLabel()
            def endLabel := nextLabel()
            out.printLine("br i1 \{isNonNull}, label %\{nonNullLabel}, label %\{endLabel}")
            createBlock(nonNullLabel, out)
            def unwrapped := toNonNullableValue(value, srcType, srcType.subtypes[0], out)
            def nonNullValue := wrapValue(unwrapped, srcType.subtypes[0], dstType, out)
            out.printLine("br label %\{endLabel}")
            createBlock(endLabel, out)
            def result := nextVar()
            out.printLine("\{result} = phi \{type(dstType)} [null, %\{testStart}], " +
                    "[\{nonNullValue}, %\{nonNullLabel}]")
            return result
        }
        def mallocRef := nextVar()
        out.printLine("\{mallocRef} = call i8* @malloc(i64 \{sizeOfWrapper(src.type())})")
        def wrapperTypeName := wrapperTypeName(src.type())
        def wrapperType := wrapperType(src.type())
        def wrapperCast := nextVar()
        out.printLine("\{wrapperCast} = bitcast i8* \{mallocRef} to \{wrapperType}")
        def classPtr := nextVar()
        out.printLine("\{classPtr} = getelementptr \{wrapperTypeName}, " +
                "\{wrapperType} \{wrapperCast}, i64 0, i32 0")
        def cc := getWrapperClassConstant(src)
        out.printLine("store %panda$core$Class* bitcast(\{cc.type}* \{cc.name} to " +
                "%panda$core$Class*), %panda$core$Class** \{classPtr}")
        def refCount := nextVar()
        out.printLine("\{refCount} = getelementptr \{wrapperTypeName}, " +
                "\{wrapperType} \{wrapperCast}, i64 0, i32 1, i32 0")
        out.printLine("store i32 0, i32* \{refCount}")
        def target := nextVar()
        out.printLine("\{target} = getelementptr \{wrapperTypeName}, " +
                "\{wrapperType} \{wrapperCast}, i64 0, i32 2")
        out.printLine("store \{type(srcType)} \{value}, \{type(srcType)}* \{target}")
        if wrapperType != type(dstType) {
            def result := nextVar()
            out.printLine("\{result} = bitcast \{wrapperType} \{wrapperCast} to \{type(dstType)}")
            return result
        }
        return wrapperCast
    }

    method getFieldReference(fieldRef:IRNode, out:OutputStream):String {
        assert fieldRef.kind = IRNode.Kind.FIELD_REFERENCE
        assert fieldRef.children.get_count() = 1
        def field := fieldRef.payload->FieldDecl
        def t := type(field.type)
        if field.annotations.isClass() {
-*            if (field->fValue && !is_constant_number(*field->fValue) &&
                        fInitializedClasses.find(&field->fOwner) == fInitializedClasses.end()) {
                fInitializedClasses.insert(&field->fOwner);
                if (fDeclaredClassInitializers.find(field->fOwner.fName) == fDeclaredClassInitializers.end()) {
                    fMethodDeclarations << "declare fastcc void @" << escape_type_name(field->fOwner.fName) <<
                            "$$classInit()\n";
                    fDeclaredClassInitializers.insert(field->fOwner.fName);
                }
                fMethodHeader << "    call fastcc void @" << escape_type_name(field->fOwner.fName) <<
                        "$$classInit()\n";
            }
            def load := nextVar()
            out << "    " << load << " = load " << type << ", " << type << "* " <<
                    this->fieldName(*field) << "\n";
            return load;*-
            assert false
        }
        def cl := compiler.getClass(fieldRef.children[0].type)
        assert cl != null
        if compiler.isValue(cl) {
            def base := getReference(fieldRef.children[0], out)
            def fields := compiler.instanceFields(cl)
            def index:Int? := null
            for i in 0 .. fields.get_count() {
                if fields[i]->FieldDecl == field { -- FIXME unnecessary cast
                    index := i
                    break
                }
            }
            assert index != null
            def result := nextVar()
            out.printLine("\{result} = extractvalue \{type(fieldRef.children[0].type)} \{base}" +
                    ", \{index}")
            return result
        }
        -*
        String ptr = type + "* " + this->getLValue(fieldRef, out);
        def result := nextVar()
        out << "    " << result << " = load " << type << ", " << ptr << "\n";
        return result;*-
        assert false
    }

    method unwrapValue(value:String, srcType:Type, dstType:Type, out:OutputStream):String {
-*        Class* target = fCompiler->getClass(dstType);
        std.vector<Field*> fields = fCompiler->getInstanceFields(*target);
        if (dstType.fCategory == Type.Category.NULLABLE) {
            // casting nullable wrapper to nullable value, need to special-case null
            String testStart = fCurrentBlock;
            String isNonNull = nextVar();
            out << "    " << isNonNull << " = icmp ne " << llvmType(srcType) <<
                    " " << value << ", null\n";
            String nonNullLabel = nextLabel();
            String endLabel = nextLabel();
            out << "    br i1 " << isNonNull << ", label %" << nonNullLabel << ", label %" <<
                    endLabel << "\n";
            createBlock(nonNullLabel, out);
            String wrapped = unwrapValue(value, srcType, dstType.fSubtypes[0], out);
            String nonNullValue = toNullableValue(wrapped, dstType.fSubtypes[0], dstType, out);
            out << "    br label %" << endLabel << "\n";
            createBlock(endLabel, out);
            String result = nextVar();
            out << "    " << result << " = phi " << llvmType(dstType) << " [{";
            const char* separator = " ";
            for (const Field* f : fields) {
                out << separator << llvmType(f->fType) << " undef";
                separator = ", ";
            }
            out << separator << "i1 0 }, %" << testStart << "], [" << nonNullValue << ", %" <<
                    nonNullLabel << "]\n";
            return result;
        }
        ASSERT(target);
        String targetType = llvmType(dstType);
        String wrapperTypeName = llvmWrapperTypeName(dstType);
        String wrapperType = llvmWrapperType(dstType);
        String srcCast = nextVar();
        out << "    " << srcCast << " = bitcast " << llvmType(srcType) <<
                " " << value << " to " << wrapperType << "\n";
        String result = "{";
        const char* separator = " ";
        for (const Field* f : fields) {
            result += separator;
            result += llvmType(f->fType);
            result += " undef";
            separator = ", ";
        }
        result += " }";
        for (int i = 0; i < fields.size(); ++i) {
            String ptr = nextVar();
            out << "    " << ptr << " = getelementptr " << wrapperTypeName << ", " <<
                    wrapperType << " " << srcCast << ", i64 0, i32 " <<
                    OBJECT_FIELD_COUNT + i << "\n";
            String read = nextVar();
            out << "    " << read << " = load " << llvmType(fields[i]->fType) << ", " <<
                    llvmType(fields[i]->fType) << "* " << ptr << "\n";
            String next = nextVar();
            out << "    " << next << " = insertvalue " << targetType << " " << result <<
                    ", " << llvmType(fields[i]->fType) << " " << read << ", " << i <<
                    "\n";
            result = next;
        }
        return result;*-
        assert false
    }

    method toNullableValue(value:String, srcType:Type, dstType:Type, out:OutputStream):String {
        def nullableType := nullableType(dstType)
        def result := nextVar()
        out.printLine("\{result} = insertvalue \{nullableType} " +
                "{ \{type(srcType)} undef, i1 true }, \{type(srcType)} \{value}, 0")
        return result
    }

    method toNonNullableValue(value:String, srcType:Type, dstType:Type, out:OutputStream):String {
        def result := nextVar()
        out.printLine("\{result} = extractvalue \{type(srcType)} \{value}, 0")
        return result
    }

    method getCastReference(value:String, src:Type, target:Type, out:OutputStream):String {
        out.printLine("; cast \{value} from \{src} to \{target}")
        def op:String
        if target.isBuiltinNumber() {
            assert src.isBuiltinNumber()
            def size1 := sizeOf(src)
            def size2 := sizeOf(target)
            if size1 > size2 {
                op := "trunc"
            }
            else if size1 < size2 {
                if target.typeKind = Type.Kind.BUILTIN_INT {
                    op := "sext"
                }
                else {
                    op := "zext"
                }
            }
            else {
                return value
            }
        }
        else {
            def srcClass := compiler.getClass(src)
            assert srcClass != null
            def targetClass := compiler.getClass(target)
            assert targetClass != null
            if compiler.isValue(srcClass) & !compiler.isValue(targetClass) {
                return wrapValue(value, src, target, out)
            }
            else if !compiler.isValue(srcClass) & compiler.isValue(targetClass) {
                return unwrapValue(value, src, target, out)
            }
            else if compiler.isValue(srcClass) & target.typeKind = Type.Kind.NULLABLE &
                    target.subtypes[0] = src {
                return toNullableValue(value, src, target, out)
            }
            else if compiler.isValue(targetClass) & src.typeKind = Type.Kind.NULLABLE &
                    src.subtypes[0] = target {
                return toNonNullableValue(value, src, target, out)
            }
            op := "bitcast"
        }
        def srcType := type(src)
        def dstType := type(target)
        if srcType = dstType {
            return value
        }
        def result := nextVar()
        out.printLine("\{result} = \{op} \{srcType} \{value} to \{dstType}")
        return result
    }

    method getCastReference(cast:IRNode, out:OutputStream):String {
        assert cast.kind = IRNode.Kind.CAST
        assert cast.children.get_count() = 1
        def base := getReference(cast.children[0], out)
        return getCastReference(base, cast.children[0].type, cast.type, out)
    }

    method getConstructReference(construct:IRNode, out:OutputStream):String {
        assert construct.kind = IRNode.Kind.CONSTRUCT
        assert construct.children.get_count() >= 1
        def cl := compiler.getClass(construct.type)
        assert cl != null
        def t := type(construct.type)
        if construct.type.isNumber() {
            assert construct.children.get_count() = 1
            assert construct.children[0].children.get_count() = 1
            def value := getTypedReference(construct.children[0].children[0], out)
            if construct.children[0].children[0].kind = IRNode.Kind.INT {
                return "{ " + value + " }"
            }
            def result := nextVar()
            def lastField := cl.fields[cl.fields.get_count() - 1]
            assert !lastField.annotations.isClass()
            out.printLine("\{result} = insertvalue \{t} { \{type(lastField.type)} undef }, " +
                    "\{value}, 0\n")
            return result
        }
        if construct.type = Type.Bit() {
            assert construct.children.get_count() = 1
            assert construct.children[0].children.get_count() = 1
            def value := getTypedReference(construct.children[0].children[0], out)
            if construct.children[0].children[0].kind = IRNode.Kind.BIT {
                return "{ " + value + " }"
            }
            def result := nextVar()
            def lastField := cl.fields[cl.fields.get_count() - 1]
            assert !lastField.annotations.isClass()
            out.printLine("\{result} = insertvalue \{t} { \{type(lastField.type)} undef }, " +
                    "\{value}, 0\n")
            return result
        }
        if compiler.isValue(cl) {
            labelCount += 1
            def alloca := "%$tmp\{labelCount}"
            methodHeader.printLine("\{alloca} = alloca \{t}")
            writeCall(construct.children[0], "\{t}* \{alloca}", out)
            def result := nextVar()
            out.printLine("\{result} = load \{t}, \{t}* \{alloca}")
            return result
        }
        def callRef := nextVar()
        out.printLine("\{callRef} = call i8* @malloc(i64 \{sizeOf(construct.type)})")
        def result := nextVar()
        out.printLine("\{result} = bitcast i8* \{callRef} to \{type(construct.type)}")
        def classPtr := nextVar()
        def className:String
        if construct.type.typeKind = Type.Kind.GENERIC {
            className := typeName(construct.type.subtypes[0])
        }
        else {
            className := typeName(construct.type)
        }
        out.printLine("\{classPtr} = getelementptr inbounds \{className}, \{t} \{result}, i64 0, " +
                "i32 0")
-*        def cc := getClassConstant(cl)
        out.printLine("store %panda$core$Class* bitcast(\{cc.type}* \{cc.name} to " +
                "%panda$core$Class*), %panda$core$Class** \{classPtr}")
        writeCall(construct.children[0], "\{type} \{result}", out)
        return result*-
        assert false
    }

    method getIntReference(int:IRNode, out:OutputStream):String {
        return (int.payload->Int).convert() -- FIXME parens
    }

    method getNegatedIntReference(int:IRNode, out:OutputStream):String {
        return "-" + (int.payload->Int).convert() -- FIXME parens
    }

    method getBitReference(bit:IRNode, out:OutputStream):String {
        if bit.payload->Bit {
            return "true"
        }
        return "false"
    }

    method getVariableReference(v:Variable, out:OutputStream):String {
        if v.storage = Variable.Storage.PARAMETER {
            return getName(v)
        }
        def result := nextVar()
        def t := type(v.type)
        out.printLine("\{result} = load \{t}, \{t}* \{getName(v)}")
        return result
    }

    method getStringReference(s:String, out:OutputStream):String {
        labelCount += 1
        def chars := "@$chars\{labelCount}"
        def charsType := "[\{s.utf8().get_count()} x i8]"
        strings.print("\{chars} = private unnamed_addr constant \{charsType} [ ")
        var separator := ""
        for c in s.utf8() {
            strings.print("\{separator}i8 \{c.convert()->Int8}")
            separator := ", "
        }
        strings.printLine(" ]")
        labelCount += 1
        def result := "@$str\{labelCount}"
        def string := compiler.getClass(Type.StringType())
        assert string != null
        def cc := getClassConstant(string)
        strings.printLine("\{result} = private unnamed_addr constant %panda$core$String { " +
                "%panda$core$Class* bitcast(\{cc.type}* \{cc.name} to " +
                "%panda$core$Class*), %panda$core$Int32 insertvalue(%panda$core$Int32 " +
                "{ i32 undef }, i32 1, 0), %panda$core$Char8* bitcast(\{charsType}* \{chars}" +
                " to %panda$core$Char8*), %panda$core$Int64 insertvalue(%panda$core$Int64 " +
                "{ i64 undef }, i64 \{s.utf8().get_count()}, 0) }")
        return result
    }

    method getReference(expr:IRNode, out:OutputStream):String {
        match expr.kind {
            when IRNode.Kind.BINARY:
                return getBinaryReference(expr, out)
            when IRNode.Kind.CALL:
                return getCallReference(expr, out)
            when IRNode.Kind.CAST:
                return getCastReference(expr, out)
            when IRNode.Kind.INT:
                return getIntReference(expr, out)
            when IRNode.Kind.NEGATED_INT:
                return getNegatedIntReference(expr, out)
            when IRNode.Kind.BIT:
                return getBitReference(expr, out)
            when IRNode.Kind.CONSTRUCT:
                return getConstructReference(expr, out)
            when IRNode.Kind.VARIABLE_REFERENCE:
                return getVariableReference(expr.payload->Variable, out)
            when IRNode.Kind.FIELD_REFERENCE:
                return getFieldReference(expr, out)
            when IRNode.Kind.STRING:
                return getStringReference(expr.payload->String, out)
            otherwise:
                assert false, "unsupported expression \{expr}"
        }
    }

    method getTypedReference(expr:IRNode, out:OutputStream):String {
        return "\{type(expr.type)} \{getReference(expr, out)}"
    }

    method writeBlock(block:IRNode, out:OutputStream) {
        assert block.kind = IRNode.Kind.BLOCK
        for s in block.children {
            writeStatement(s, out)
        }
    }

    method writeCall(call:IRNode, target:String?, out:OutputStream) {
        assert call.kind = IRNode.Kind.CALL
        def m := (call.payload->MethodRef).value
        if m.owner.external {
            writeDeclaration(m)
        }
        def args := Array<String>()
        if target != null {
            args.add(target)
        }
        for a in call.children {
            args.add(getTypedReference(a, out))
        }
        out.printLine("call \{callingConvention(m)}\{type(call.type)} " +
                "\{getName(m)}(\{args.join()})")
    }

    method writeIf(s:IRNode, out:OutputStream) {
        assert s.kind = IRNode.Kind.IF
        assert s.children.get_count() = 2 | s.children.get_count() = 3
        assert s.children[0].type = Type.Bit()
        def test := getTypedReference(s.children[0], out)
        def testBit := nextVar()
        out.printLine("\{testBit} = extractvalue \{test}, 0")
        def ifTrue := nextLabel()
        def ifFalse := nextLabel()
        out.printLine("br i1 \{testBit}, label %\{ifTrue}, label %\{ifFalse}")
        createBlock(ifTrue, out)
        writeStatement(s.children[1], out)
        def end:String
        if s.children.get_count() = 3 {
            end := nextLabel()
        }
        else {
            end := ifFalse
        }
        if !endsWithBranch(s.children[1]) {
            out.printLine("br label %\{end}")
        }
        if s.children.get_count() = 3 {
            createBlock(ifFalse, out)
            writeStatement(s.children[2], out)
            if !endsWithBranch(s.children[2]) {
                out.printLine("br label %\{end}")
            }
        }
        createBlock(end, out)
    }

    method writeRangeFor(f:IRNode, out:OutputStream) {
        -- I am acutely aware of how horrific this looks.
        --
        -- There's no easy way to produce clean output here, since we have to handle different step
        -- values, different loop directions, and both inclusive and exclusive ranges, all of which
        -- could potentially be determined at runtime. It gets even uglier when you consider the
        -- difficulty of handling the extremes of the numeric types. You can't just add 1 and then
        -- check to see if it's in range when the limit is MAX_INT, because you'll overflow and end
        -- up with an infinite loop. You also can't just check for being equal to the limit before
        -- adding the step, because with a step bigger than 1 (or smaller than -1) you might need to
        -- stop before actually hitting the end. So you instead check the difference between the
        -- current index and the limit, but even there you need to be careful because it could
        -- overflow in a signed test, and we need to handle null values, and... ugh, it's
        -- surprisingly messy and results in a ton of code.
        --
        -- Fortunately, we can just write incredibly awful-but-straightforward code and let LLVM
        -- optimize it to something sensible if it turns out the values are known at compile time.
        -- This works remarkably well, because LLVM is awesome.
        assert f.kind = IRNode.Kind.RANGE_FOR
        assert f.children.get_count() = 3
        def target := f.children[0]
        assert f.children[1].type.typeKind = Type.Kind.GENERIC
        assert f.children[1].type.subtypes.get_count() = 2
        assert f.children[1].type.subtypes[0].name = "panda.core.Range"
        def range := getTypedReference(f.children[1], out)
        def block := f.children[2]
        def t := f.children[1].type.subtypes[1]
        def llt := type(t)
        def indexType:String
        if t.typeKind == Type.Kind.NULLABLE {
            assert t.subtypes.get_count() = 1
            indexType := type(t.subtypes[0])
        }
        else {
            indexType := llt
        }
        def cl := compiler.getClass(t)
        assert cl != null
        assert compiler.instanceFields(cl).get_count() = 1
        def numberType := type(compiler.instanceFields(cl)[0].type)
        assert target.kind = IRNode.Kind.VARIABLE_REFERENCE
        def index := getName(target.payload->Variable)
        methodHeader.printLine("\{index} = alloca \{indexType}")

        -- extract start value from range
        def startPtr := nextVar()
        out.printLine("\{startPtr} = extractvalue \{range}, 0")
        def startPtrCast := nextVar()
        out.printLine("\{startPtrCast} = bitcast \{type(Type.Object())} \{startPtr} to " +
                "\{wrapperType(t)}")
        def startFieldPtr := nextVar()
        out.printLine("\{startFieldPtr} = getelementptr \{wrapperTypeName(t)}, " +
                "\{wrapperType(t)} \{startPtrCast}, i64 0, i32 \{OBJECT_FIELD_COUNT}, i32 0")
        def start := nextVar()
        out.printLine("\{start} = load \{numberType}, \{numberType}* \{startFieldPtr}")

        -- store start value
        def indexValuePtr := nextVar()
        out.printLine("\{indexValuePtr} = getelementptr \{indexType}, \{indexType}* \{index}, " +
                "i64 0, i32 0")
        out.printLine("store \{numberType} \{start}, \{numberType}* \{indexValuePtr}")

        -- extract end value from range
        def endPtr := nextVar()
        out.printLine("\{endPtr} = extractvalue \{range}, 1")
        def endPtrCast := nextVar()
        out.printLine("\{endPtrCast} = bitcast \{type(Type.Object())} \{endPtr} to " +
                "\{wrapperType(t)}")
        def endFieldPtr := nextVar()
        out.printLine("\{endFieldPtr} = getelementptr \{wrapperTypeName(t)}, \{wrapperType(t)} " +
                "\{endPtrCast}, i64 0, i32 \{OBJECT_FIELD_COUNT}, i32 0")
        def end := nextVar()
        out.printLine("\{end} = load \{numberType}, \{numberType}* \{endFieldPtr}")

        -- extract step value from range
        def rawStep := nextVar()
        out.printLine("\{rawStep} = extractvalue \{range}, 2, 0")
        def step:String
        if numberType != "i64" {
            step := nextVar()
            out.printLine("\{step} = trunc i64 \{rawStep} to \{numberType}")
        }
        else {
            step := rawStep
        }

        -- extract inclusive / exclusive from range
        def inclusive := nextVar()
        out.printLine("\{inclusive} = extractvalue \{range}, 3, 0")

        -- start block
        def loopStart := nextLabel()
        def loopBody := nextLabel()
        def loopEnd := nextLabel()
        def loopTest := nextLabel()
        loopDescriptors.push(LoopDescriptor(f.payload->String?, loopEnd, loopTest)) -- FIXME Auto
        def forwardEntry := nextLabel()
        def backwardEntry := nextLabel()
        def signPrefix := "s"
        def direction:String
        if signPrefix = "s" {
            direction := nextVar()
            out.printLine("\{direction} = icmp sge \{numberType} \{step}, 0")
        }
        else {
            direction := "1"
        }
        out.printLine("br i1 \{direction}, label %\{forwardEntry}, label %\{backwardEntry}")
        createBlock(forwardEntry, out)
        def forwardEntryInclusive := nextLabel()
        def forwardEntryExclusive := nextLabel()
        out.printLine("br i1 \{inclusive}, label %\{forwardEntryInclusive}, " +
                "label %\{forwardEntryExclusive}")
        createBlock(forwardEntryInclusive, out)
        def forwardEntryInclusiveTest := nextVar()
        out.printLine("\{forwardEntryInclusiveTest} = icmp \{signPrefix}le \{numberType} \{start}, \{end}")
        out.printLine("br i1 \{forwardEntryInclusiveTest}, label %\{loopStart}, label %\{loopEnd}")
        createBlock(forwardEntryExclusive, out)
        def forwardEntryExclusiveTest := nextVar()
        out.printLine("\{forwardEntryExclusiveTest} = icmp \{signPrefix}lt \{numberType} \{start}, \{end}")
        out.printLine("br i1 \{forwardEntryExclusiveTest}, label %\{loopStart}, label %\{loopEnd}")
        createBlock(backwardEntry, out)
        def backwardEntryInclusive := nextLabel()
        def backwardEntryExclusive := nextLabel()
        out.printLine("br i1 \{inclusive}, label %\{backwardEntryInclusive}, " +
                "label %\{backwardEntryExclusive}")
        createBlock(backwardEntryInclusive, out)
        def backwardEntryInclusiveTest := nextVar()
        out.printLine("\{backwardEntryInclusiveTest} = icmp \{signPrefix}ge \{numberType} \{start}, \{end}")
        out.printLine("br i1 \{backwardEntryInclusiveTest}, label %\{loopStart}, label %\{loopEnd}")
        createBlock(backwardEntryExclusive, out)
        def backwardEntryExclusiveTest := nextVar()
        out.printLine("\{backwardEntryExclusiveTest} = icmp \{signPrefix}gt \{numberType} \{start}, \{end}")
        out.printLine("br i1 \{backwardEntryExclusiveTest}, label %\{loopStart}, label %\{loopEnd}")
        createBlock(loopStart, out)
        def indexValue := nextVar()
        out.printLine("\{indexValue} = load \{numberType}, \{numberType}* \{indexValuePtr}")
        writeStatement(block, out)
        if !endsWithBranch(block) {
            out.printLine("br label %\{loopTest}")
        }
        createBlock(loopTest, out)
        def loopInc := nextLabel()
        -- beginning of loop test, determine direction
        def forwardLabel := nextLabel()
        def backwardLabel := nextLabel()
        out.printLine("br i1 \{direction}, label %\{forwardLabel}, label %\{backwardLabel}")

        -- forward loop; perform the test by subtracting index from end and then comparing to step, to
        -- avoid overflows near the maximum value
        createBlock(forwardLabel, out)
        def forwardDelta := nextVar()
        out.printLine("\{forwardDelta} = sub \{numberType} \{end}, \{indexValue}")

        -- forward loop; determine inclusive / exclusive
        def forwardInclusiveLabel := nextLabel()
        def forwardExclusiveLabel := nextLabel()
        out.printLine("br i1 \{inclusive}, label %\{forwardInclusiveLabel}, label %" +
                forwardExclusiveLabel)

        -- forward inclusive test
        createBlock(forwardInclusiveLabel, out)
        def forwardInclusiveTest := nextVar()
        -- always use unsigned comparison to avoid overflow; we know both the delta and the step are
        -- the same sign
        out.printLine("\{forwardInclusiveTest} = icmp uge \{numberType} \{forwardDelta}, \{step}")
        out.printLine("br i1 \{forwardInclusiveTest}, label %\{loopInc}, label %\{loopEnd}")
        createBlock(forwardExclusiveLabel, out)

        -- forward exclusive test
        def forwardExclusiveTest := nextVar()
        out.printLine("\{forwardExclusiveTest} = icmp ugt \{numberType} \{forwardDelta}, \{step}")
        out.printLine("br i1 \{forwardExclusiveTest}, label %\{loopInc}, label %\{loopEnd}")

        -- backward loop; perform the test by subtracting end from index and then comparing to -step, to
        -- avoid overflows near the minimum value
        createBlock(backwardLabel, out)
        def backwardDelta := nextVar()
        out.printLine("\{backwardDelta} = sub \{numberType} \{indexValue}, \{end}")
        def negStep := nextVar()
        out.printLine("\{negStep} = sub \{numberType} 0, \{step}")

        -- backward loop; determine inclusive / exclusive
        def backwardInclusiveLabel := nextLabel()
        def backwardExclusiveLabel := nextLabel()
        out.printLine("br i1 \{inclusive}, label %\{backwardInclusiveLabel}, label %" +
                backwardExclusiveLabel)

        -- backward inclusive test
        createBlock(backwardInclusiveLabel, out)
        def backwardInclusiveTest := nextVar()
        out.printLine("\{backwardInclusiveTest} = icmp uge \{numberType} \{backwardDelta}, " +
                negStep)
        out.printLine("br i1 \{backwardInclusiveTest}, label %\{loopInc}, label %\{loopEnd}")
        createBlock(backwardExclusiveLabel, out)

        -- backward exclusive test
        def backwardExclusiveTest := nextVar()
        out.printLine("\{backwardExclusiveTest} = icmp ugt \{numberType} \{backwardDelta}, " +
                negStep)
        out.printLine("br i1 \{backwardExclusiveTest}, label %\{loopInc}, label %\{loopEnd}")

        createBlock(loopInc, out)
        def inc := nextVar()
        out.printLine("\{inc} = add \{numberType} \{indexValue}, \{step}")
        def incStruct := nextVar()
        out.printLine("\{incStruct} = insertvalue \{indexType} { \{numberType} undef")
        out.printLine(" }, \{numberType} \{inc}, 0")
        out.printLine("store \{indexType} \{incStruct}, \{indexType}* \{index}")
        out.printLine("br label %\{loopStart}")

        createBlock(loopEnd, out)
    }

    method writeWhile(w:IRNode, out:OutputStream) {
        assert w.kind = IRNode.Kind.WHILE
        assert w.children.get_count() = 2
        assert w.children[0].type = Type.Bit()
        def loopStart := nextLabel()
        def loopBody := nextLabel()
        def loopEnd := nextLabel()
        loopDescriptors.push(LoopDescriptor(w.payload->String?, loopEnd, loopStart)) -- FIXME Auto
        out.printLine("br label %\{loopStart}")
        createBlock(loopStart, out)
        def test := getTypedReference(w.children[0], out)
        def testBit := nextVar()
        out.printLine("\{testBit} = extractvalue \{test}, 0")
        out.printLine("br i1 \{testBit}, label %\{loopBody}, label %\{loopEnd}")
        createBlock(loopBody, out)
        writeStatement(w.children[1], out)
        if !endsWithBranch(w.children[1]) {
            out.printLine("br label %\{loopStart}")
        }
        createBlock(loopEnd, out)
        loopDescriptors.pop()
    }

    method writeDo(d:IRNode, out:OutputStream) {
        assert d.kind = IRNode.Kind.DO
        assert d.children.get_count() = 2
        assert d.children[1].type = Type.Bit()
        def loopStart := nextLabel()
        def loopBody := nextLabel()
        def loopEnd := nextLabel()
        loopDescriptors.push(LoopDescriptor(d.payload->String?, loopEnd, loopStart)) -- FIXME Auto
        out.printLine("br label %\{loopBody}")
        createBlock(loopStart, out)
        def test := getTypedReference(d.children[1], out)
        def testBit := nextVar()
        out.printLine("\{testBit} = extractvalue \{test}, 0")
        out.printLine("br i1 \{testBit}, label %\{loopBody}, label %\{loopEnd}")
        createBlock(loopBody, out)
        writeStatement(d.children[0], out)
        if !endsWithBranch(d.children[0]) {
            out.printLine("br label %\{loopStart}")
        }
        createBlock(loopEnd, out)
        loopDescriptors.pop()
    }

    method writeLoop(l:IRNode, out:OutputStream) {
        assert l.kind = IRNode.Kind.LOOP
        assert l.children.get_count() = 1
        def loopStart := nextLabel()
        def loopEnd := nextLabel()
        loopDescriptors.push(LoopDescriptor(l.payload->String?, loopEnd, loopStart))
        out.printLine("br label %\{loopStart}")
        createBlock(loopStart, out)
        writeStatement(l.children[0], out)
        if !endsWithBranch(l.children[0]) {
            out.printLine("br label %\{loopStart}")
        }
        createBlock(loopEnd, out)
        loopDescriptors.pop()
    }

    method writeVarTarget(target:IRNode, value:IRNode?, out:OutputStream) {
        match target.kind {
            when IRNode.Kind.VARIABLE_REFERENCE:
                def v := target.payload->Variable
                methodHeader.printLine("\{getName(v)} = alloca \{type(v.type)}")
                if value != null {
                    def ref := getTypedReference(value, out)
                    out.printLine("store \{ref}, \{type(v.type)}* \{getName(v)}")
                }
            when IRNode.Kind.TUPLE_TARGET:
                assert false
            otherwise:
                assert false
        }
    }

    method writeVar(v:IRNode, out:OutputStream) {
        assert v.kind = IRNode.Kind.VAR |
                v.kind = IRNode.Kind.DEF |
                v.kind = IRNode.Kind.PROPERTY |
                v.kind = IRNode.Kind.CONSTANT
        for decl in v.children {
            assert decl.kind = IRNode.Kind.DECLARATION
            if decl.children.get_count() > 1 {
                writeVarTarget(decl.children[0], decl.children[1], out)
            }
            else {
                writeVarTarget(decl.children[0], null, out)
            }
        }
    }

    method getLValue(lvalue:IRNode, out:OutputStream):String {
        match lvalue.kind {
            when IRNode.Kind.VARIABLE_REFERENCE:
                return getName(lvalue.payload->Variable)
            otherwise:
                assert false
        }
    }

    method writeAssignment(a:IRNode, out:OutputStream) {
        assert a.kind = IRNode.Kind.BINARY
        assert a.children.get_count() = 2
        def lvalue := "\{type(a.children[0].type)}* \{getLValue(a.children[0], out)}"
        def value:String
        def t := type(a.children[0].type)
        def op := a.payload->Int
        if op = Token.Kind.ASSIGNMENT {
            def right := getReference(a.children[1], out)
            value := "\{t} \{right}"
        }
        else {
-*            Operator binOp;
            switch (op) {
                case Operator.ADDEQ:        binOp = Operator.ADD;                         break;
                case Operator.SUBEQ:        binOp = Operator.SUB;                         break;
                case Operator.MULEQ:        binOp = Operator.MUL;                         break;
                case Operator.DIVEQ:        binOp = Operator.DIV;                         break;
                case Operator.INTDIVEQ:     binOp = Operator.INTDIV;                      break;
                case Operator.REMEQ:        binOp = Operator.REM;                         break;
                case Operator.POWEQ:        binOp = Operator.POW;                         break;
                case Operator.XOREQ:        binOp = Operator.XOR;                         break;
                case Operator.BITWISEOREQ:  binOp = Operator.BITWISEOR;                   break;
                case Operator.BITWISEANDEQ: binOp = Operator.BITWISEAND;                  break;
                case Operator.BITWISEXOREQ: binOp = Operator.BITWISEXOR;                  break;
                case Operator.SHIFTLEFTEQ:  binOp = Operator.SHIFTLEFT;                   break;
                case Operator.SHIFTRIGHTEQ: binOp = Operator.SHIFTRIGHT;                  break;
                case Operator.ANDEQ:        this->writeAndEq(lvalue, a.fChildren[1], out); return;
                case Operator.OREQ:         this->writeOrEq(lvalue, a.fChildren[1], out);  return;
                default: abort();
            }
            def left := nextVar()
            out << "    " << left << " = load " << this->llvmType(a.fChildren[0].fType) << ", " <<
                    lvalue << "\n";
            String right = this->getReference(a.fChildren[1], out);
            value = type + " " +
                    this->getBinaryReference(op_class(a.fChildren[0].fType), type + " " + left, binOp,
                            right, out);
            *-
            assert false
        }
        out.printLine("store \{value}, \{lvalue}")
    }

    method writeReturn(r:IRNode, out:OutputStream) {
        if r.children.get_count() = 1 {
            out.printLine("ret \{getTypedReference(r.children[0], out)}")
        }
        else {
            assert r.children.get_count() = 0
            out.printLine("ret void")
        }
    }

    method writeStatement(stmt:IRNode, out:OutputStream) {
        match stmt.kind {
            when IRNode.Kind.BINARY:
                writeAssignment(stmt, out)
            when IRNode.Kind.BLOCK:
                writeBlock(stmt, out)
            when IRNode.Kind.CALL:
                writeCall(stmt, null, out)
            when IRNode.Kind.IF:
                writeIf(stmt, out)
            when IRNode.Kind.RANGE_FOR:
                writeRangeFor(stmt, out)
            when IRNode.Kind.WHILE:
                writeWhile(stmt, out)
            when IRNode.Kind.DO:
                writeDo(stmt, out)
            when IRNode.Kind.LOOP:
                writeLoop(stmt, out)
            when IRNode.Kind.VAR, IRNode.Kind.DEF, IRNode.Kind.CONSTANT, IRNode.Kind.PROPERTY:
                writeVar(stmt, out)
            when IRNode.Kind.RETURN:
                writeReturn(stmt, out)
            otherwise:
                assert false, "unsupported statement \{stmt}"
        }
    }

    method selfType(m:MethodDecl):String {
        def result := type(m.owner.type())
        if m.methodKind = MethodDecl.Kind.INIT & !result.endsWith("*") {
            return result + "*"
        }
        return result
    }

    method writeDeclaration(m:MethodDecl) {
        def name := getName(m)
        if declared.contains(name) {
            return
        }
        declared.add(name)
        declarations.print("declare \{callingConvention(m)}\{type(m.returnType)} \{getName(m)}(")
        var separator := ""
        if !m.annotations.isClass() {
            declarations.print("\{selfType(m)} %self")
            separator := ", "
        }
        for p in m.parameters {
            declarations.print("\{separator}\{type(p.type)} %\{escapeName(p.name)}")
            separator := ", "
        }
        declarations.printLine(")")
    }

    @override
    method write(m:MethodDecl, body:IRNode) {
        currentBlock := "0"
        varCount := 0
        methodHeaderBuffer.clear()
        methods.print("define \{type(m.returnType)} \{getName(m)}(")
        var separator := ""
        for p in m.parameters {
            methods.print("\{separator}\{type(p.type)} %\{escapeName(p.name)}")
            separator := ", "
        }
        methods.printLine(") {")
        methods.level += 1
        assert body.kind = IRNode.Kind.BLOCK
        def bodyBuffer := MemoryOutputStream()
        for s in body.children {
            writeStatement(s, bodyBuffer)
        }
        methods.print(methodHeaderBuffer.convert())
        methods.print(bodyBuffer.convert())
        if !endsWithBranch(body) {
            if m.returnType = Type.Void() {
                methods.printLine("ret void")
            }
            else {
                methods.printLine("unreachable")
            }
        }
        methods.level -= 1
        methods.printLine("}")
    }
}