package org.pandalanguage.pandac

uses org.pandalanguage.pandac.parser.Token

@final
class LLVMCodeGenerator : CodeGenerator {
    constant NO_REFCNT := -999

    class ClassConstant : Immutable {
        def name:String
        def type:String

        init(name:String, type:String) {
            self.name := name
            self.type := type
        }
    }

    class MethodShim {
        def name:String
        def type:String

        init(name:String, type:String) {
            self.name := name
            self.type := type
        }
    }

    choice EnclosingContext {
        LOOP(String? -* label *-, String -* break target *-, String -* continue target *-)
        FINALLY(String -* label *-, Map<String, String> -* map from source label to return label *-)
        ================================================================================================
        Overrides features such as method arguments and return handling for use in compiling inline
        methods.
        ================================================================================================
        INLINE(InlineContext)

        @override
        function convert():String {
            match self {
                when LOOP(label, breakTarget, continueTarget):
                    if label != null {
                        return "LOOP(\{label}, \{breakTarget}, \{continueTarget})"
                    }
                    return "LOOP(<null>, \{breakTarget}, \{continueTarget})"
                when FINALLY(label, map):
                    return "FINALLY(\{label}, \{map})"
                when INLINE(context):
                    return context.convert()
            }
        }
    }

    class InlineContext {
        ============================================================================================
        Local variable name suffix.
        ============================================================================================
        def varSuffix:String

        ============================================================================================
        Reference to use instead of the normal "%self".
        ============================================================================================
        def selfRef:String

        ============================================================================================
        Reference to use instead of the normal method parameter names.
        ============================================================================================
        def argRefs:ImmutableArray<String>

        ============================================================================================
        Contains pairs of (source block, return value), which can be turned into the actual return
        value using a phi node. Initially empty, filled in as the inline call is written.
        ============================================================================================
        def returns := Array<Pair<String, String>>()

        ============================================================================================
        Label to jump to after returning.
        ============================================================================================
        def exitLabel:String

        init(varSuffix:String, selfRef:String, argRefs:ListView<String>, exitLabel:String) {
            self.varSuffix := varSuffix
            self.selfRef := selfRef
            self.argRefs := ImmutableArray<String>(argRefs)
            self.exitLabel := exitLabel
        }
    }

    class AutoContext {
        def cg:LLVMCodeGenerator

        def context:EnclosingContext

        init(cg:LLVMCodeGenerator, context:EnclosingContext) {
            self.cg := cg
            self.context := context
            cg.enclosingContexts.push(context)
        }

        @override
        method cleanup() {
            cg.enclosingContexts.pop(context)
        }
    }

    constant POINTER_SIZE        := 8
    constant OBJECT_FIELD_COUNT  := 2
    constant CLASS_POINTER_INDEX := 0
    constant ITABLE_INDEX        := 4
    constant VTABLE_INDEX        := 5

    constant INT_TYPE  := "i64"
    constant SIZE_TYPE := "i64"

    def out:OutputStream

    @weak
    def compiler:Compiler?

    def declarations := MemoryOutputStream()

    def types := MemoryOutputStream()

    def methods := MemoryOutputStream()

    def methodHeader := MemoryOutputStream()

    def wrapperShims := MemoryOutputStream()

    def shims := MemoryOutputStream()

    def strings := MemoryOutputStream()

    def declared := Set<String>()

    def writtenTypes := Set<String>()

    def writtenWrappers := Set<String>()

    def classConstants := HashMap<String, ClassConstant>()

    def variableNames := IdentityMap<Variable, String>()

    var currentBlock:String

    var currentMethod:MethodDecl?

    var returnValueVar:String?

    def enclosingContexts := Stack<EnclosingContext>()

    choice ExtraEffect {
        STATEMENT(IRNode)
        STRING(String)
    }
    def extraEffects := Stack<Array<ExtraEffect>>()

    var varCount := 0

    var labelCount := 0

    def reusedValues := HashMap<Int64, String>()

    def methodShims := IdentityMap<MethodDecl, MethodShim>()

    def currentlyInlining := IdentityMap<MethodDecl, MethodDecl>() -- FIXME need IdentitySet

    def sizes := IdentityMap<ClassDecl, Int>()

    def choiceDataSizes := IdentityMap<ClassDecl, Int>()

    init(triple:String, out:OutputStream) {
        self.out := out

        out.printLine("target datalayout = \"e-m:o-i64:64-f80:128-n8:16:32:64-S128\"")
        out.printLine("target triple = \"\{triple}\"")
        out.printLine("declare i8* @pandaZAlloc(\{SIZE_TYPE})")
        out.printLine("declare i8* @pandaObjectAlloc(\{SIZE_TYPE}, %panda$core$Class*)")
        out.printLine("declare i8* @pandaRealloc(i8*, \{SIZE_TYPE}, \{SIZE_TYPE})")
        out.printLine("declare void @pandaFree(i8*)")
        out.printLine("declare i8* @memset(i8*, i8, \{SIZE_TYPE})")
        out.printLine("%$itable = type { %panda$core$Class*, %$itable*, [0 x i8*] }")
    }

    @override
    method setCompiler(compiler:Compiler) {
        self.compiler := compiler
    }

    @override
    method finish() {
        type(Type.Class())
        out.print(types.finish())
        out.print(strings.finish())
        out.print(declarations.finish())
        out.print(wrapperShims.finish())
        out.print(shims.finish())
        out.print(methods.finish())
    }

    method nextVar():String {
        varCount += 1
        return "%\{varCount}"
    }

    method nextLabel():String {
        labelCount += 1
        return "$l\{labelCount}"
    }

    method createBlock(label:String, out:OutputStream) {
        out.printLine("\n\{label}:")
        currentBlock := label
    }

    function fieldSize(t:Type):Int {
        assert t.resolved
        if t.isBuiltinNumber() {
            if t.name.endsWith("8") {
                return 1
            }
            if t.name.endsWith("16") {
                return 2
            }
            if t.name.endsWith("32") {
                return 4
            }
            assert t.name.endsWith("64")
            return 8
        }
        if t = Type.BuiltinBit() {
            return 1
        }
        def cl := compiler.getClass(t)
        assert cl != null
        if !compiler.isValue(cl) | cl.name = "panda.unsafe.Pointer" {
            return POINTER_SIZE
        }
        var result := 0
        for f in compiler.instanceFields(cl) {
            if f.annotations.isClass() {
                continue
            }
            compiler.resolve(f)
            if f.type = Type.ChoiceData() {
                -- FIXME need to respect alignment!
                result += getChoiceDataSize(cl)
            }
            else {
                def size := fieldSize(f.type)
                def align := result % size
                if align != 0 {
                    result += size - align
                }
                assert result % size = 0
                result += size
            }
        }
        if t.typeKind = Type.Kind.NULLABLE {
            result += 1
        }
        return result
    }

    function alignment(t:Type):Int {
        return fieldSize(t).min(8)
    }

    function sizeOf(t:Type):Int {
        if !t.isClass() {
            return fieldSize(t)
        }
        def cl := compiler.getClass(t)
        assert cl != null
        if cl.name = "panda.unsafe.Pointer" {
            return POINTER_SIZE
        }
        var cached := sizes[cl]
        if cached != null {
            return cached
        }
        var result := 0
        for f in compiler.instanceFields(cl) {
            compiler.resolve(f)
            if f.type = Type.ChoiceData() {
                -- FIXME need to respect alignment!
                result += getChoiceDataSize(cl)
            }
            else {
                def size := fieldSize(f.type)
                def align := result % size
                if align != 0 {
                    result += size - align
                }
                assert result % size = 0
                result += size
            }
        }
        if compiler.isValue(cl) & t.typeKind = Type.Kind.NULLABLE {
            result += 1
        }
        sizes[cl] := result
        return result
    }

    function stride(t:Type):Int {
        def s := fieldSize(t)
        def a := alignment(t)
        if s % a = 0 {
            return s
        }
        return s + a - s % a
    }

    function sizeOfWrapper(t:Type):Int {
        def cl := compiler.getClass(t)
        assert cl != null & compiler.isValue(cl)
        var result := sizeOf(Type.Object())
        for f in compiler.instanceFields(cl) {
            compiler.resolve(f)
            if f.type = Type.ChoiceData() {
                 -- FIXME need to respect alignment!
                result += getChoiceDataSize(cl)
            }
            else {
                def size := fieldSize(f.type)
                def align := result % size
                if align != 0 {
                    result += size - align
                }
                assert result % size = 0
                result += size
            }
        }
        if t.typeKind = Type.Kind.NULLABLE {
            result += 1
        }
        return result
    }

    method getChoiceDataSize(cl:ClassDecl):Int {
        var result := choiceDataSizes[cl]
        if result = null {
            result := 0
            for entry in cl.choiceEntries {
                compiler.resolve(entry)
                var current := 0
                for f in entry.fields {
                    -- FIXME need to respect alignment!
                    current += fieldSize(f)
                }
                result := result.max(current)
            }
            choiceDataSizes[cl] := result
        }
        return result
    }

    method writeType(t:Type) {
        if writtenTypes.contains(t.name) {
            return
        }
        writtenTypes.add(t.name)
        def cl := compiler.getClass(t)
        assert !cl.annotations.isSpecialize()
        def code := MutableString("%\{escapeName(t.name)} = type { ")
        compiler.currentClass.push(cl)
        assert cl != null
        var separator := ""
        for f in compiler.instanceFields(cl) {
            compiler.resolve(f)
            if !f.type.resolved {
                return
            }
            if f.type.isClass() {
                def fCl := compiler.getClass(f.type)
                if !compiler.isValue(fCl) {
                    -- If we write the correct type definition here, we end up loading and parsing a
                    -- ton of otherwise-unused classes, for no other reason than to figure out their
                    -- type definitions (which we likely never use for anything else). Handling all
                    -- pointers as opaque i8* pointers massively reduces the number of files we need
                    -- to parse.
                    code.append("\{separator}i8*")
                    separator := ", "
                    continue
                }
            }
            if f.type = Type.ChoiceData() {
                code.append("\{separator}[\{getChoiceDataSize(cl)} x i8]")
                separator := ", "
                continue
            }
            code.append("\{separator}\{type(f.type)}")
            separator := ", "
        }
        if t = Type.Class() {
            code.append(", %$itable*, [0 x i8*]")
        }
        code.append(" }")
        types.printLine(code.finish())
        if compiler.isValue(cl) {
            getWrapperClassConstant(cl)
        }
        compiler.currentClass.pop()
    }

    method writeWrapperType(t:Type) {
        if writtenWrappers.contains(t.name) {
            return
        }
        writtenWrappers.add(t.name)
        def code := MutableString("\{type(t)}$wrapper = type { ")
        def object := compiler.getClass(Type.Object())
        assert object != null
        var separator := ""
        for f in compiler.instanceFields(object) {
            compiler.resolve(f)
            code.append("\{separator}\{type(f.type)}")
            separator := ", "
        }
        code.append(", \{type(t)}")
        code.append(" }")
        types.printLine(code.finish())
        types.printLine("\{type(t)}$nullable = type { \{type(t)}, i1 }")
    }

    function typeName(t:Type):String {
        return "%" + escapeName(t.name)
    }

    method type(t:Type):String {
        match t.typeKind {
            when Type.Kind.VOID:
                return "void"
            when Type.Kind.BUILTIN_INT, Type.Kind.BUILTIN_UINT:
                return "i\{sizeOf(t) * 8}"
            when Type.Kind.BUILTIN_BIT:
                return "i1"
            when Type.Kind.BUILTIN_FLOAT:
                match sizeOf(t) {
                    when 4: return "float"
                    when 8: return "double"
                    otherwise: assert false
                }
            when Type.Kind.CLASS:
                writeType(t)
                def name := "%\{escapeName(t.name)}"
                def cl := compiler.getClass(t)
                assert cl != null
                if !compiler.isValue(cl) {
                    return name + "*"
                }
                return name
            when Type.Kind.NULLABLE:
                def cl := compiler.getClass(t)
                assert cl != null
                if compiler.isValue(cl) {
                    return nullableType(t)
                }
                return type(t.subtypes[0])
            when Type.Kind.GENERIC:
                if t.subtypes[0].name = "panda.unsafe.Pointer" {
                    return type(t.subtypes[1]) + "*"
                }
                def cl := compiler.getClass(t)
                if cl.isSpecialization() {
                    def name := "%\{escapeName(t.name)}"
                    def cl := compiler.getClass(t)
                    assert cl != null
                    if !compiler.isValue(cl) {
                        return name + "*"
                    }
                    return name
                }
                return type(t.subtypes[0])
            when Type.Kind.GENERIC_PARAMETER:
                return type(t.parameter.bound)
            when Type.Kind.FUNCTION, Type.Kind.METHOD:
                return type(Type.Method())
            otherwise:
                assert false, "unsupported type '\{t}'"
        }
    }

    ================================================================================================
    Returns the signature of a method type. Methods in Panda have two different types: normally they
    are manipulated as instances of [Method] or [MutableMethod], but sometimes we need the actual
    type signature of the underlying method. The [type()] function always returns
    `%panda.core.Method*` or `%panda.core.MutableMethod*`, whereas `methodType` returns the call
    signature of the method.
    ================================================================================================
    @pre(t.typeKind = Type.Kind.FUNCTION | t.typeKind = Type.Kind.METHOD)
    method methodType(t:Type, selfType:Type?):String {
        def result := MutableString(type(t.subtypes[t.subtypes.get_count() - 1]))
        result.append(" (")
        var separator := ""
        if selfType != null {
            result.append(type(selfType))
            separator := ", "
        }
        for i in 0 .. t.subtypes.get_count() - 1 {
            result.append(separator)
            result.append(type(t.subtypes[i]))
            separator := ", "
        }
        result.append(")*")
        return result.finish()
    }

    method wrapperTypeName(t:Type):String {
        if t.typeKind = Type.Kind.NULLABLE {
            return wrapperTypeName(t.subtypes[0])
        }
        writeWrapperType(t)
        return "%\{escapeName(t.name)}$wrapper"
    }

    method wrapperType(t:Type):String {
        return wrapperTypeName(t) + "*"
    }

    method wrapperType(m:MethodDecl):String {
        def inheritedType := compiler.inheritedType(m)
        def result := MutableString()
        result.append(type(inheritedType.subtypes[inheritedType.subtypes.get_count() - 1]))
        result.append("(")
        assert m.isInstance()
        result.append("%\{escapeName(m.owner.name)}")
        if compiler.isValue(m.owner) {
            result.append("$wrapper")
        }
        result.append("*")
        for i in 0 .. inheritedType.subtypes.get_count() - 1 { 
            result.append(", ")
            result.append(type(inheritedType.subtypes[i]))
        }
        result.append(")*")
        return result.finish()
    }

    method nullableType(t:Type):String {
        assert t.typeKind = Type.Kind.NULLABLE, "\{t} is not nullable"
        writeWrapperType(t.subtypes[0])
        return "\{type(t.subtypes[0])}$nullable"
    }

    method getITable(cl:ClassDecl):String {
        def interfaces := compiler.allInterfaces(cl.type())
        var previous := "%$itable* null"
        for intfType in interfaces {
            def intf := compiler.getClass(intfType)
            def intfCC := getClassConstant(intf)
            def methods := compiler.interfaceMethods(cl, intfType)
            def name := "@\{escapeName(cl.name)}$.\{escapeName(intf.name)}"
            def t := "{\{type(Type.Class())}, %$itable*, [\{methods.get_count()} x i8*] }"
            def intfCCCast:String
            if intfCC.type != type(Type.Class()) {
                intfCCCast := "bitcast(\{intfCC.type}* \{intfCC.name} to \{type(Type.Class())})"
            }
            else {
                intfCCCast := intfCC.name
            }
            def result := MutableString("\{name} = ")
            if cl.isSpecialization() {
                result.append("linkonce_odr ")
            }
            result.append("constant \{t} { \{type(Type.Class())} \{intfCCCast}, \{previous}, " +
                    "[\{methods.get_count()} x i8*][")
            var separator := ""
            for m in methods {
                result.append(separator)
                separator := ", "
                if m.annotations.isAbstract() {
                    result.append("i8* null")
                }
                else {
                    def entry := getMethodTableEntry(m)
                    result.append("i8* bitcast(\{entry.second} \{entry.first} to i8*)")
                }
            }
            result.append("] }\n")
            types.printLine(result.finish())
            previous := "%$itable* bitcast(\{t}* \{name} to %$itable*)"
        }
        return previous
    }

    method createMethodShim(raw:MethodDecl, effective:Type, rawOut:OutputStream):MethodShim {
        def out := MemoryOutputStream()
        def found := methodShims[raw]
        if found != null {
            return found
        }
        assert effective.isMethod()
        assert effective.subtypes.get_count() = raw.parameters.get_count() + 1
        assert raw.isInstance()
        def oldVarCount := varCount
        varCount := 0
        def effectiveReturnType := effective.subtypes[effective.subtypes.get_count() - 1]
        def resultName := getName(raw) + "$shim"
        def resultType := MutableString(type(effectiveReturnType))
        out.print("define ")
        if raw.owner.isSpecialization() {
            out.print("linkonce_odr ")
        }
        out.print("\{resultType} \{resultName}(")
        def self_t := selfType(raw)
        out.print("\{self_t} %self")
        resultType.append("(")
        resultType.append(self_t)
        for i in 0 .. raw.parameters.get_count() {
            def pType := type(effective.subtypes[i])
            resultType.append(", ")
            resultType.append(pType)
            out.print(", \{pType} %p\{i}")
        }
        out.printLine(") {")
        resultType.append(")*")
        def casts := Array<String>()
        for i in 0 .. raw.parameters.get_count() {
            def p := "%p\{i}"
            if raw.parameters[i].type != effective.subtypes[i] {
                casts.add(getCastReference(p, effective.subtypes[i],
                        raw.parameters[i].type, out))
            }
            else {
                casts.add(p)
            }
        }
        def returnValue:String
        if raw.returnType != Type.Void() {
            returnValue := nextVar()
            out.print("\{returnValue} = ")
        }
        else {
            returnValue := "void"
        }
        out.print("call \{callingConvention(raw)}\{type(raw.returnType)} \{getName(raw)}(" +
                "\{self_t} %self")
        for i in 0 .. raw.parameters.get_count() {
            out.print(", \{type(raw.parameters[i].type)} \{casts[i]}")
        }
        out.printLine(")")
        if raw.returnType != Type.Void() {
            returnValue := type(effectiveReturnType) + " " +
                    getCastReference(returnValue, raw.returnType, effectiveReturnType, out)
        }
        out.printLine("ret \{returnValue}")
        out.printLine("}")
        varCount := oldVarCount
        def result := MethodShim(resultName, resultType.finish())
        methodShims[raw] := result
        rawOut.print(out.finish())
        return result
    }

    method createWrapperShim(m:MethodDecl, out:OutputStream):String {
        def oldMethod := currentMethod
        currentMethod := m
        assert m.isInstance()
        def oldVarCount := varCount
        varCount := 0
        def result := "\{getName(m)}$wrappershim"
        def selfType := "%\{escapeName(m.owner.name)}$wrapper*"
        out.print("define ")
        if m.owner.isSpecialization() {
            out.print("linkonce_odr ")
        }
        out.print("\{type(m.returnType)} \{result}(\{selfType} %actualSelf")
        def actualMethodType := compiler.declaredType(m)
        def inheritedMethodType := compiler.inheritedType(m)
        for i in 0 .. m.parameters.get_count() {
            out.print(", \{type(inheritedMethodType.subtypes[i])} %\{m.parameters[i].name}")
        }
        out.printLine(") {")
        out.printLine("%self = bitcast \{selfType} %actualSelf to %panda$core$Object*")
        def parameters := Array<String>()
        for i in 0 .. m.parameters.get_count() {
            parameters.add(getCastReference("%" + m.parameters[i].name,
                    inheritedMethodType.subtypes[i], actualMethodType.subtypes[i], out))
        }
        def unwrapped := type(m.owner.type()) + " " +
                getCastReference(IRNode.SELF(Position(), Type.Object()), m.owner.type(), out)
        def returnValue:String
        if m.returnType != Type.Void() {
            returnValue := nextVar()
            out.print("\{returnValue} = ")
            returnValue := "\{type(m.returnType)} \{returnValue}"
        }
        else {
            returnValue := "void"
        }
        out.print("call \{callingConvention(m)}\{type(m.returnType)} \{getName(m)}(\{unwrapped}")
        for i in 0 .. m.parameters.get_count() {
            out.print(", \{type(actualMethodType.subtypes[i])} \{parameters[i]}")
        }
        out.printLine(")")
        out.printLine("ret \{returnValue}")
        out.printLine("}")
        varCount := oldVarCount
        currentMethod := oldMethod
        return result
    }

    method getWrapperITable(cl:ClassDecl):String {
        def interfaces := compiler.allInterfaces(cl.type())
        var previous := "%$itable* null"
        for intfType in interfaces {
            def intf := compiler.getClass(intfType)
            def intfCC := getClassConstant(intf)
            def methods := compiler.interfaceMethods(cl, intfType)
            def name := "@\{escapeName(cl.name)}$wrapper.\{escapeName(intf.name)}"
            def t := "{\{type(Type.Class())}, %$itable*, [\{methods.get_count()} x i8*] }"
            def intfCCCast:String
            if intfCC.type != type(Type.Class()) {
                intfCCCast := "bitcast(\{intfCC.type}* \{intfCC.name} to \{type(Type.Class())})"
            }
            else {
                intfCCCast := intfCC.name
            }
            def result := MutableString("\{name} = ")
            if cl.isSpecialization() {
                result.append("linkonce_odr ")
            }
            result.append("constant \{t} { \{type(Type.Class())} \{intfCCCast}, \{previous}, " +
                    "[\{methods.get_count()} x i8*][")
            var separator := ""
            for m in methods {
                result.append(separator)
                separator := ", "
                if m.annotations.isAbstract() {
                    result.append("i8* null")
                }
                else {
                    def shim := createWrapperShim(m, wrapperShims)
                    result.append("i8* bitcast(\{wrapperType(m)} \{shim} to i8*)")
                }
            }
            result.append("] }\n")
            types.printLine(result.finish())
            previous := "%$itable* bitcast(\{t}* \{name} to %$itable*)"
        }
        return previous
    }

    ================================================================================================
    Returns true if this is an external method returning a struct.

    Returning structs from C functions into LLVM code is tricky. I tried it the naive and obvious
    way, and found it didn't work. Some cursory research indicated that C functions that return
    structs are at least sometimes compiled to accept a special pointer ("sret") as an extra
    parameter, and the caller is expected to know to alloca space for the return value and pass in a
    pointer to it.

    Since online sources were complaining about how poorly documented this is, there were
    indications that there may be multiple struct return strategies depending on the nature of
    the struct, people were suggesting looking at the assembly code generated by Clang to figure
    out how one was supposed to call a given function, and this all varies from platform to
    platform, we avoid the whole mess by making it explicit. External functions which wish to
    return structs explicitly receive a pointer to the result structure as their first parameter.
    ================================================================================================
    function needsStructIndirection(m:MethodDecl):Bit {
        if !m.returnType.isClass() {
            return false
        }
        def result := m.annotations.isExternal() & m.returnType.isClass() &
                compiler.isValue(compiler.getClass(m.returnType))
        -- if an external method requires struct indirection, it will have a different signature
        -- than a non-external method; this means this feature doesn't play nice with overriding. We
        -- can fix this down the road with shims, but for right now just assert that a method
        -- requiring struct indirection is not an override and cannot be overridden
        assert !result | (!m.annotations.isOverride() & (m.annotations.isFinal() |
                m.annotations.isClass())), "invalid struct indirection on \{m.signature()}"
        return result
    }

    method getMethodTableEntry(m:MethodDecl):Pair<String, String> -* name, type *- {
        compiler.resolve(m)
        if m.owner.external {
            writeDeclaration(m)
        }
        def resultName:String
        def declared := compiler.declaredTypeWithSelf(m, m.owner.type())
        def inherited := compiler.inheritedTypeWithSelf(m)
        if declared != inherited {
            def shim := createMethodShim(m, compiler.inheritedType(m), shims)
            resultName := shim.name
        }
        else {
            resultName := getName(m)
        }
        if needsStructIndirection(m) {
            def resultType := MutableString("void (")
            resultType.append(type(inherited.subtypes[inherited.subtypes.get_count() - 1]))
            resultType.append("*")
            for i in 0 .. inherited.subtypes.get_count() - 1 {
                resultType.append(", ")
                resultType.append(type(inherited.subtypes[i]))
            }
            resultType.append(")*")
            return Pair<String, String>(resultName, resultType.finish())
        }
        return Pair<String, String>(resultName, methodType(inherited, null))
    }

    method getClassConstant(cl:ClassDecl):ClassConstant {
        assert !cl.annotations.isSpecialize()
        var result := classConstants[cl.name]
        if result = null {
            compiler.resolve(cl)
            def type:String
            if cl.external {
                result := ClassConstant("@\{escapeName(cl.type().name)}$class",
                        "%panda$core$Class")
                classConstants[cl.name] := result
                types.printLine("\{result.name} = external global \{result.type}")
                return classConstants[cl.name]
            }
            def vtable := compiler.getVTable(cl)
            result := ClassConstant("@\{escapeName(cl.type().name)}$class",
                    "{ %panda$core$Class*, \{INT_TYPE}, %panda$core$String*, %panda$core$Class*, " +
                    "%$itable*, [\{vtable.get_count()} x i8*] }")
            classConstants[cl.name] := result
            def superPtr:String
            if cl.rawSuper != null {
                def superCC := getClassConstant(compiler.getClass(cl.rawSuper))
                superPtr := "bitcast(\{superCC.type}* \{superCC.name} to %panda$core$Class*)"
            }
            else {
                superPtr := "null"
            }
            def clConstant := getClassConstant(compiler.getClass(Type.Class()))
            def code := MutableString("\{result.name} = ")
            if cl.isSpecialization() {
                code.append("linkonce_odr ")
            }
            code.append("constant \{result.type} { " +
                    "%panda$core$Class* bitcast(\{clConstant.type}* \{clConstant.name} to " +
                    "%panda$core$Class*), \{INT_TYPE} \{NO_REFCNT}, %panda$core$String* " +
                    getStringReference(cl.name) + ", %panda$core$Class* \{superPtr}, " +
                    "\{getITable(cl)}, [\{vtable.get_count()} x i8*] [")
            var separator := ""
            for m in vtable {
                code.append(separator)
                if m.annotations.isAbstract() {
                    code.append("i8* null")
                }
                else {
                    def entry := getMethodTableEntry(m)
                    code.append("i8* bitcast(\{entry.second} \{entry.first} to i8*)")
                }
                separator := ", "
            }
            code.append("] }\n")
            types.printLine(code.finish())
        }
        return result
    }

    method getWrapperClassConstant(cl:ClassDecl):ClassConstant {
        compiler.resolve(cl)
        def name := "@\{escapeName(cl.name)}$wrapperclass"
        var result := classConstants[name]
        if result = null {
            if cl.external {
                type(Type.Class())
                def type := "%panda$core$Class"
                types.printLine("\{name} = external global \{type}")
                result := ClassConstant(name, type)
                classConstants[name] := result
            }
            else {
                def value := compiler.getClass(Type.Value())
                def valueVTable := compiler.getVTable(value)
                result := ClassConstant("@\{escapeName(cl.name)}$wrapperclass",
                        "{ %panda$core$Class*, \{INT_TYPE}, %panda$core$String*, " +
                        "%panda$core$Class*, %$itable*, [\{valueVTable.get_count()} x i8*] }")
                classConstants[name] := result
                def vtable := compiler.getVTable(cl)
                def superCC := getClassConstant(compiler.getClass(cl.rawSuper))
                def superCast:String
                if superCC.type != type(Type.Class()) {
                    superCast := "bitcast(\{superCC.type}* \{superCC.name} to %panda$core$Class*)"
                }
                else {
                    superCast := superCC.name
                }
                def itable := getWrapperITable(cl)
                def clConstant := getClassConstant(compiler.getClass(Type.Class()))
                def code := MutableString("\{result.name} = ")
                if cl.isSpecialization() {
                    code.append("linkonce_odr ")
                }
                code.append("constant \{result.type} { " +
                        "%panda$core$Class* bitcast(\{clConstant.type}* \{clConstant.name} to " +
                        "%panda$core$Class*), \{INT_TYPE} \{NO_REFCNT}, %panda$core$String* " +
                        "\{getStringReference(cl.name)}, \{type(Type.Class())} \{superCast}, " +
                        "\{itable}, [\{valueVTable.get_count()} x i8*] [")
                var separator := ""
                for i in 0 .. valueVTable.get_count() {
                    def m := vtable[i]
                    def methodName:String
                    if m.owner == cl {
                        methodName := createWrapperShim(m, wrapperShims)
                    }
                    else {
                        methodName := getName(m)
                        if m.owner.external {
                            writeDeclaration(m)
                        }
                    }
                    code.append("\{separator}i8* bitcast(\{wrapperType(m)} \{methodName} to i8*)")
                    separator := ", "
                }
                code.append("] }\n")
                types.print(code.finish())
            }
        }
        return result
    }

    function escapeName(s:String):String {
        def result := MutableString(s.byteLength() * 2)
        var current := s.start()
        def end := s.end()
        while current != end {
            def c := s[current]
            match c {
                when ".": result.append("$")
                when "?": result.append("$Q")
                when "<": result.append("$LT")
                when ">": result.append("$GT")
                when " ": -- do nothing
                when ",": result.append("$C")
                when "(": result.append("$LP")
                when ")": result.append("$RP")
                when "=": result.append("$EQ")
                when "&": result.append("$AM")
                when "*": result.append("$ST")
                otherwise: result.append(c)
            }
            current := s.next(current)
        }
        return result.finish()
    }

    function getInlineContext():InlineContext? {
        for c in enclosingContexts {
            match c {
                when EnclosingContext.INLINE(inline):
                    return inline
            }
        }
        return null
    }

    function getName(v:Variable):String {
        def inline := getInlineContext()
        if v.storage = Variable.Storage.PARAMETER {
            if inline != null {
                for i in 0 .. currentMethod.parameters.get_count() {
                    if v.name == currentMethod.parameters[i].name {
                        return inline.argRefs[i]
                    }
                }
                assert false
            }
            return "%\{v.name}"
        }
        var result := variableNames[v]
        if result = null {
            labelCount += 1
            result := "%\{v.name}\{labelCount}"
            variableNames[v] := result
        }
        if inline != null {
            result += inline.varSuffix
        }
        return result
    }

    function getName(m:MethodDecl):String {
        if m.name = "main" {
            return "@pandaMain"
        }
        def result := MutableString("@")
        result.append(escapeName(m.owner.name))
        result.append("$")
        match m.name {
            when "+":    result.append("$ADD")
            when "-":    result.append("$SUB")
            when "*":    result.append("$MUL")
            when "/":    result.append("$DIV")
            when "//":   result.append("$INTDIV")
            when "%":    result.append("$REM")
            when "^":    result.append("$POW")
            when "[]":   result.append("$IDX")
            when "[]:=": result.append("$IDXEQ")
            when "=":    result.append("$EQ")
            when "!=":   result.append("$NEQ")
            when ">":    result.append("$GT")
            when "<":    result.append("$LT")
            when ">=":   result.append("$GE")
            when "<=":   result.append("$LE")
            when "|":    result.append("$OR")
            when "||":   result.append("$BOR")
            when "&":    result.append("$AND")
            when "&&":   result.append("$BAND")
            when "~":    result.append("$XOR")
            when "~~":   result.append("$BXOR")
            when "!":    result.append("$NOT")
            when "!!":   result.append("$BNOT")
            when "<<":   result.append("$SHL")
            when ">>":   result.append("$SHR")
            otherwise:   result.append(escapeName(m.name))
        }
        for p in m.parameters {
            result.append("$\{escapeName(p.type.name)}")
        }
        if m.returnType != Type.Void() {
            result.append("$R$")
            result.append(escapeName(m.returnType.name))
        }
        return result.finish()
    }

    function getName(f:FieldDecl):String {
        assert f.annotations.isClass()
        return "@\{escapeName(f.owner.name)}$\{f.name}"
    }

    class OpClass {
        constant SIGNED   := 10121
        constant UNSIGNED := 10122
        constant FLOAT    := 10123
    }

    function opClass(t:Type):Int {
        match t.typeKind {
            when Type.Kind.BUILTIN_INT:
                return OpClass.SIGNED
            when Type.Kind.BUILTIN_UINT, Type.Kind.BUILTIN_BIT:
                return OpClass.UNSIGNED
            when Type.Kind.BUILTIN_FLOAT:
                return OpClass.FLOAT
            otherwise:
                assert false
        }
    }

    method getAndReference(left:IRNode, right:IRNode, out:OutputStream):String {
        extraEffects.push(Array<ExtraEffect>())
        var leftRef := getReference(left, out)
        if left.type() = Type.Bit() {
            def leftField := nextVar()
            out.printLine("\{leftField} = extractvalue %panda$core$Bit \{leftRef}, 0")
            leftRef := leftField
        }
        writeExtraEffects(out)
        def start := currentBlock
        def ifTrue := nextLabel()
        def ifFalse := nextLabel()
        out.printLine("br i1 \{leftRef}, label %\{ifTrue}, label %\{ifFalse}")
        createBlock(ifTrue, out)
        extraEffects.push(Array<ExtraEffect>())
        def rightRef := getReference(right, out)
        if right.type() = Type.Bit() {
            def rightField := nextVar()
            out.printLine("\{rightField} = extractvalue %panda$core$Bit \{rightRef}, 0")
            rightRef := rightField
        }
        writeExtraEffects(out)
        def truePred := currentBlock
        out.printLine("br label %\{ifFalse}")
        createBlock(ifFalse, out)
        def result := nextVar()
        out.printLine("\{result} = phi i1 [0, %\{start}], [\{rightRef}, %\{truePred}]")
        return result
    }

    method getOrReference(left:IRNode, right:IRNode, out:OutputStream):String {
        extraEffects.push(Array<ExtraEffect>())
        var leftRef := getReference(left, out)
        if left.type() = Type.Bit() {
            def leftField := nextVar()
            out.printLine("\{leftField} = extractvalue %panda$core$Bit \{leftRef}, 0")
            leftRef := leftField
        }
        writeExtraEffects(out)
        def start := currentBlock
        def ifTrue := nextLabel()
        def ifFalse := nextLabel()
        out.printLine("br i1 \{leftRef}, label %\{ifTrue}, label %\{ifFalse}")
        createBlock(ifFalse, out)
        extraEffects.push(Array<ExtraEffect>())
        def rightRef := getReference(right, out)
        if right.type() = Type.Bit() {
            def rightField := nextVar()
            out.printLine("\{rightField} = extractvalue %panda$core$Bit \{rightRef}, 0")
            rightRef := rightField
        }
        writeExtraEffects(out)
        def falsePred := currentBlock
        out.printLine("br label %\{ifTrue}")
        createBlock(ifTrue, out)
        def result := nextVar()
        out.printLine("\{result} = phi i1 [1, %\{start}], [\{rightRef}, %\{falsePred}]")
        return result
    }

    method getBinaryReference(t:Type, leftRef:String, op:Token.Kind, rightRef:String,
            out:OutputStream):String {
        def llvmOp:String
        match opClass(t) {
            when OpClass.SIGNED:
                match op {
                    when Token.Kind.ADD:        llvmOp := "add"
                    when Token.Kind.SUB:        llvmOp := "sub"
                    when Token.Kind.MUL:        llvmOp := "mul"
                    when Token.Kind.INTDIV:     llvmOp := "sdiv"
                    when Token.Kind.REM:        llvmOp := "srem"
                    when Token.Kind.SHIFTLEFT:  llvmOp := "shl"
                    when Token.Kind.SHIFTRIGHT: llvmOp := "ashr"
                    when Token.Kind.BITWISEAND: llvmOp := "and"
                    when Token.Kind.BITWISEOR:  llvmOp := "or"
                    when Token.Kind.XOR, Token.Kind.BITWISEXOR: 
                                                llvmOp := "xor"
                    when Token.Kind.EQ:         llvmOp := "icmp eq"
                    when Token.Kind.NEQ:        llvmOp := "icmp ne"
                    when Token.Kind.GT:         llvmOp := "icmp sgt"
                    when Token.Kind.LT:         llvmOp := "icmp slt"
                    when Token.Kind.GTEQ:       llvmOp := "icmp sge"
                    when Token.Kind.LTEQ:       llvmOp := "icmp sle"
                    otherwise:
                        assert false
                }
            when OpClass.UNSIGNED:
                match op {
                    when Token.Kind.ADD:        llvmOp := "add"
                    when Token.Kind.SUB:        llvmOp := "sub"
                    when Token.Kind.MUL:        llvmOp := "mul"
                    when Token.Kind.INTDIV:     llvmOp := "udiv"
                    when Token.Kind.REM:        llvmOp := "urem"
                    when Token.Kind.SHIFTLEFT:  llvmOp := "shl"
                    when Token.Kind.SHIFTRIGHT: llvmOp := "lshr"
                    when Token.Kind.BITWISEAND: llvmOp := "and"
                    when Token.Kind.BITWISEOR:  llvmOp := "or"
                    when Token.Kind.XOR, Token.Kind.BITWISEXOR: 
                                                llvmOp := "xor"
                    when Token.Kind.EQ:         llvmOp := "icmp eq"
                    when Token.Kind.NEQ:        llvmOp := "icmp ne"
                    when Token.Kind.GT:         llvmOp := "icmp ugt"
                    when Token.Kind.LT:         llvmOp := "icmp ult"
                    when Token.Kind.GTEQ:       llvmOp := "icmp uge"
                    when Token.Kind.LTEQ:       llvmOp := "icmp ule"
                    otherwise:
                        assert false
                }
            when OpClass.FLOAT:
                match op {
                    when Token.Kind.ADD:        llvmOp := "fadd"
                    when Token.Kind.SUB:        llvmOp := "fsub"
                    when Token.Kind.MUL:        llvmOp := "fmul"
                    when Token.Kind.DIV:        llvmOp := "fdiv"
                    when Token.Kind.EQ:         llvmOp := "fcmp oeq"
                    when Token.Kind.NEQ:        llvmOp := "fcmp one"
                    when Token.Kind.GT:         llvmOp := "fcmp ogt"
                    when Token.Kind.LT:         llvmOp := "fcmp olt"
                    when Token.Kind.GTEQ:       llvmOp := "fcmp oge"
                    when Token.Kind.LTEQ:       llvmOp := "fcmp ole"
                    otherwise:
                        assert false
                }
        }
        def result := nextVar()
        def typeString := type(t)
        out.printLine("\{result} = \{llvmOp} \{typeString} \{leftRef}, \{rightRef}")
        return result
    }

    method getIdentityReference(left:IRNode, right:IRNode, out:OutputStream):String {
        def leftRef := getTypedReference(left, out)
        def rightRef := getReference(right, out)
        def raw := nextVar()
        out.printLine("\{raw} = icmp eq \{leftRef}, \{rightRef}")
        def result := nextVar()
        out.printLine("\{result} = insertvalue %panda$core$Bit { i1 undef }, i1 \{raw}, 0")
        return result
    }

    method getNIdentityReference(left:IRNode, right:IRNode, out:OutputStream):String {
        def leftRef := getTypedReference(left, out)
        def rightRef := getReference(right, out)
        def raw := nextVar()
        out.printLine("\{raw} = icmp ne \{leftRef}, \{rightRef}")
        def result := nextVar()
        out.printLine("\{result} = insertvalue %panda$core$Bit { i1 undef }, i1 \{raw}, 0")
        return result
    }

    method getBinaryReference(left:IRNode, op:Token.Kind, right:IRNode, out:OutputStream):String {
        assert left.type() = right.type()
        match op {
            when Token.Kind.AND:       return getAndReference(left, right, out)
            when Token.Kind.OR:        return getOrReference(left, right, out)
            when Token.Kind.IDENTITY:  return getIdentityReference(left, right, out)
            when Token.Kind.NIDENTITY: return getNIdentityReference(left, right, out)
            otherwise:
                def leftRef := getReference(left, out)
                def rightRef := getReference(right, out)
                return getBinaryReference(left.type(), leftRef, op, rightRef, out)
        }
    }

    method getTernaryReference(test:IRNode, ifTrue:IRNode, ifFalse:IRNode,
            out:OutputStream):String {
        extraEffects.push(Array<ExtraEffect>())
        def testRef := getTypedReference(test, out)
        writeExtraEffects(out)
        def testBit := nextVar()
        out.printLine("\{testBit} = extractvalue \{testRef}, 0")
        var trueLabel := nextLabel()
        var falseLabel := nextLabel()
        def merge := nextLabel()
        out.printLine("br i1 \{testBit}, label %\{trueLabel}, label %\{falseLabel}")
        createBlock(trueLabel, out)
        extraEffects.push(Array<ExtraEffect>())
        def ifTrueRef := getReference(ifTrue, out)
        writeExtraEffects(out)
        trueLabel := currentBlock
        out.printLine("br label %\{merge}")
        createBlock(falseLabel, out)
        extraEffects.push(Array<ExtraEffect>())
        def ifFalseRef := getReference(ifFalse, out)
        writeExtraEffects(out)
        falseLabel := currentBlock
        out.printLine("br label %\{merge}")
        createBlock(merge, out)
        def result := nextVar()
        out.printLine("\{result} = phi \{type(test.type())} " +
                "[\{ifTrueRef}, %\{trueLabel}], " +
                "[\{ifFalseRef}, %\{falseLabel}]")
        return result
    }

    function callingConvention(m:MethodDecl):String {
-*        if m.annotations.isFinal() & !m.annotations.isOverride() & !m.annotations.isExternal() {
            return "fastcc "
        }*-
        return ""
    }

    method getVirtualMethodReference(target:String, m:MethodDecl, out:OutputStream):String {
        def cc := getClassConstant(m.owner)
        var index := -1
        def vtable := compiler.getVTable(m.owner)
        for i in 0 .. vtable.get_count() {
            if vtable[i]->MethodDecl == m { -- FIXME unnecessary cast
                index := i
                break
            }
        }
        assert index != -1
        def classPtrPtr := nextVar()
        out.printLine("\{classPtrPtr} = getelementptr inbounds \{typeName(m.owner.type())}, " +
                "\{target}, i64 0, i32 0")
        def classPtr := nextVar()
        out.printLine("\{classPtr} = load i8*, i8** \{classPtrPtr}")
        def cast := nextVar()
        out.printLine("\{cast} = bitcast i8* \{classPtr} to \{cc.type}*")
        def ptr := nextVar()
        out.printLine("\{ptr} = getelementptr inbounds \{cc.type}, \{cc.type}* \{cast}, i64 0, " +
                "i32 \{VTABLE_INDEX}, i64 \{index}")
        def load := nextVar()
        out.printLine("\{load} = load i8*, i8** \{ptr}")
        def result := nextVar()
        out.printLine("\{result} = bitcast i8* \{load} to " +
                methodType(compiler.inheritedTypeWithSelf(m), null))
        return result
    }

    method getInterfaceMethodReference(target:String, m:MethodDecl,
            out:OutputStream):String {
        def methodTypeString := methodType(compiler.inheritedTypeWithSelf(m), null)
        -- load class constant entry
        def entry := nextLabel()
        out.printLine("br label %\{entry}")
        createBlock(entry, out)
        def rawClassPointer := nextVar()
        out.printLine("\{rawClassPointer} = getelementptr inbounds \{typeName(m.owner.type())}, " +
                "\{target}, \{SIZE_TYPE} 0, i32 \{CLASS_POINTER_INDEX}")
        def classPointer := nextVar()
        def classType := typeName(Type.Class())
        out.printLine("\{classPointer} = bitcast i8** \{rawClassPointer} to \{classType}**")
        def loadedClass := nextVar()
        out.printLine("\{loadedClass} = load \{classType}*, \{classType}** \{classPointer}")
        def itableFirst := nextVar()
        out.printLine("\{itableFirst} = getelementptr inbounds \{classType}, \{classType}* " +
                "\{loadedClass}, \{SIZE_TYPE} 0, i32 \{ITABLE_INDEX}")
        def next := nextLabel()
        out.printLine("br label %\{next}")
        def leavingEntryLabel := currentBlock
        createBlock(next, out)
        labelCount += 1
        def itableNext := "%$itable\{labelCount}"
        def itablePtrPtr := nextVar()
        def fail := nextLabel()
        out.printLine("\{itablePtrPtr} = phi %$itable** [ \{itableFirst}, %\{leavingEntryLabel}]," +
                " [ \{itableNext}, %\{fail} ]")
        def itablePtr := nextVar()
        out.printLine("\{itablePtr} = load %$itable*, %$itable** \{itablePtrPtr}")
        def itableClassPtr := nextVar()
        out.printLine("\{itableClassPtr} = getelementptr inbounds %$itable, %$itable* " +
                "\{itablePtr}, \{SIZE_TYPE} 0, i32 0")
        def itableClass := nextVar()
        out.printLine("\{itableClass} = load \{classType}*, \{classType}** \{itableClassPtr}")
        def test := nextVar()
        def intfCC := getClassConstant(m.owner)
        out.printLine("\{test} = icmp eq \{classType}* bitcast(\{intfCC.type}* \{intfCC.name} to " +
                "\{classType}*), \{itableClass}")
        def success := nextLabel()
        out.printLine("br i1 \{test}, label %\{success}, label %\{fail}")

        createBlock(fail, out)
        out.printLine("\{itableNext} = getelementptr inbounds %$itable, %$itable* \{itablePtr}, " +
                "\{SIZE_TYPE} 0, i32 1")
        out.printLine("br label %\{next}")

        createBlock(success, out)
        var index := -1
        def vtable := compiler.getVTable(m.owner)
        for i in 0 .. vtable.get_count() {
            if vtable[i]->MethodDecl == m { -- FIXME unnecessary cast
                index := i
                break
            }
        }
        index -= compiler.getVTable(compiler.getClass(Type.Object())).get_count()
        assert index != -1
        def methodPtrPtr := nextVar()
        out.printLine("\{methodPtrPtr} = getelementptr inbounds %$itable, %$itable* " +
                "\{itablePtr}, \{SIZE_TYPE} 0, i32 2, i32 \{index}")
        def cast := nextVar()
        out.printLine("\{cast} = bitcast i8** \{methodPtrPtr} to \{methodTypeString}*")
        def methodPtr := nextVar()
        out.printLine("\{methodPtr} = load \{methodTypeString}, \{methodTypeString}* \{cast}")
        return methodPtr
    }

    method getMethodReference(target:String?, m:MethodDecl, isSuper:Bit,
            out:OutputStream):String {
        if !isSuper & m.isVirtual() {
            assert target != null, "calling instance \{m.signature()} without a target"
            if m.owner.classKind = ClassDecl.Kind.INTERFACE {
                return getInterfaceMethodReference(target, m, out)
            }
            else {
                return getVirtualMethodReference(target, m, out)
            }
        }
        else {
            if m.owner.external {
                writeDeclaration(m)
            }
            return getName(m)
        }
    }

    method getPointerCallReference(t:Type, m:MethodRef, args:ImmutableArray<IRNode>,
            out:OutputStream):String {
        match m.value.name {
            when "alloc":
                assert args.get_count() = 1
                def countStruct := getTypedReference(args[0], out)
                def count := nextVar()
                out.printLine("\{count} = extractvalue \{countStruct}, 0")
                def size := nextVar()
                def elementSize := stride(m.returnType().subtypes[1])
                assert elementSize > 0, "invalid size for type \{m.returnType().subtypes[1]}"
                out.printLine("\{size} = mul \{SIZE_TYPE} \{count}, \{elementSize}")
                def malloc := nextVar()
                out.printLine("\{malloc} = call i8* @pandaZAlloc(\{SIZE_TYPE} \{size})")
                def result := nextVar()
                out.printLine("\{result} = bitcast i8* \{malloc} to \{type(m.returnType())}")
                return result
            when "get":
                assert args.get_count() = 1
                def ptr := getTypedReference(args[0], out)
                def baseType := type(m.returnType())
                def ptrType := baseType + "*"
                def cast := nextVar()
                out.printLine("\{cast} = bitcast \{ptr} to \{ptrType}")
                def load := nextVar()
                out.printLine("\{load} = load \{baseType}, \{ptrType} \{cast}")
                return load
            when "[]":
                assert args.get_count() = 2
                def ptr := getTypedReference(args[0], out)
                def baseType := type(m.returnType())
                def ptrType := baseType + "*"
                def cast := nextVar()
                out.printLine("\{cast} = bitcast \{ptr} to \{ptrType}")
                def indexStruct := getTypedReference(args[1], out)
                def index := nextVar()
                out.printLine("\{index} = extractvalue \{indexStruct}, 0")
                def offsetPtr := nextVar()
                out.printLine("\{offsetPtr} = getelementptr \{baseType}, \{ptrType} \{cast}, " +
                        "i64 \{index}")
                def load := nextVar()
                out.printLine("\{load} = load \{baseType}, \{ptrType} \{offsetPtr}")
                return load
            when "realloc":
                assert args.get_count() = 3
                def ptr := getTypedReference(args[0], out)
                def ptrCast := nextVar()
                out.printLine("\{ptrCast} = bitcast \{ptr} to i8*")
                def oldCountStruct := getTypedReference(args[1], out)
                def oldCount := nextVar()
                out.printLine("\{oldCount} = extractvalue \{oldCountStruct}, 0")
                def oldSize := nextVar()
                out.printLine("\{oldSize} = mul \{SIZE_TYPE} \{oldCount}, " +
                        stride(m.returnType().subtypes[1]))
                def newCountStruct := getTypedReference(args[2], out)
                def newCount := nextVar()
                out.printLine("\{newCount} = extractvalue \{newCountStruct}, 0")
                def newSize := nextVar()
                out.printLine("\{newSize} = mul \{SIZE_TYPE} \{newCount}, " +
                        stride(m.returnType().subtypes[1]))
                def realloc := nextVar()
                out.printLine("\{realloc} = call i8* @pandaRealloc(i8* \{ptrCast}, \{SIZE_TYPE} " +
                        "\{oldSize}, \{SIZE_TYPE} \{newSize})")
                def result := nextVar()
                out.printLine("\{result} = bitcast i8* \{realloc} to \{type(m.returnType())}")
                return result
            when "offset":
                assert args.get_count() = 2
                def ptr := getTypedReference(args[0], out)
                def baseType := type(args[0].type().subtypes[1])
                def offsetStruct := getTypedReference(args[1], out)
                def offset := nextVar()
                out.printLine("\{offset} = extractvalue \{offsetStruct}, 0")
                def result := nextVar()
                out.printLine("\{result} = getelementptr \{baseType}, \{ptr}, i64 \{offset}")
                return result
            otherwise:
                assert false
        }
    }

--    @post(currentMethod = @pre(currentMethod) & returnValueVar = @pre(returnValueVar))
    method getInlineCallReference(t:Type, mref:MethodRef, args:ImmutableArray<IRNode>,
            body:ImmutableArray<IRNode>, out:OutputStream):String {
        def m := mref.value
        compiler.currentClass.push(m.owner)
        currentlyInlining[m] := m
        var selfRef := "<inline call self error>"
        def argStart:Int
        if m.isInstance() {
            argStart := 1
            selfRef := getReference(args[0], out)
        }
        else {
            argStart := 0
        }
        def argRefs := Array<String>()
        for i in argStart .. args.get_count() {
            argRefs.add(getReference(args[i], out))
        }
        def end := nextLabel()
        assert argRefs.get_count() = m.parameters.get_count()
        def inline := InlineContext("$inline\{varCount}", selfRef, argRefs, end)
        {
            def context := AutoContext(self, EnclosingContext.INLINE(inline))
            def old := currentMethod
            currentMethod := m
            def oldReturnValueVar := returnValueVar
            returnValueVar := null
            writeBlock(body, out)
            returnValueVar := oldReturnValueVar
            currentMethod := old
        }
        if !compiler.endsWithBranch(body) {
            out.printLine("unreachable")
        }
        createBlock(end, out)
        currentlyInlining.remove(m)
        compiler.currentClass.pop()
        if inline.returns.get_count() = 1 {
            def load := nextVar()
            out.printLine("\{load} = load \{type(m.returnType)}, \{type(m.returnType)}* " +
                    "\{inline.returns[0].second}")
            return load
        }
        if inline.returns.get_count() = 0 {
            assert false, "no return from inline method \{m.declaration()}"
            out.printLine("unreachable")
            return "undef"
        }
        def phi := nextVar()
        out.print("\{phi} = phi \{type(m.returnType)}* ")
        var separator := ""
        for ret in inline.returns {
            out.print("\{separator}[\{ret.second}, %\{ret.first}]")
            separator := ", "
        }
        out.printLine()
        def load := nextVar()
        out.printLine("load \{type(m.returnType)}, \{type(m.returnType)}* \{phi}")
        return load
    }

    method getCallReference(t:Type, mref:MethodRef, args:ImmutableArray<IRNode>,
            out:OutputStream):String {
        def m := mref.value
        if m.owner.name = "panda.unsafe.Pointer" {
            return getPointerCallReference(t, mref, args, out)
        }
        if m.owner.external {
            writeDeclaration(m)
        }
        if m.owner.name = "panda.core.Bit" {
            if m.name = "&" {
                assert args.get_count() = 2
                def bit := getAndReference(args[0], args[1], out)
                def result := nextVar()
                out.printLine("\{result} = insertvalue %panda$core$Bit { i1 undef }, i1 " +
                        "\{bit}, 0")
                return result
            }
            if m.name = "|" {
                assert args.get_count() = 2
                def bit := getOrReference(args[0], args[1], out)
                def result := nextVar()
                out.printLine("\{result} = insertvalue %panda$core$Bit { i1 undef }, i1 " +
                        "\{bit}, 0")
                return result
            }
        }
        if m.annotations.isInline() & currentlyInlining[m] = null {
            def block := compiler.compileBody(m)
            if block != null {
                return getInlineCallReference(t, mref, args, block, out)
            }
            return "<error>"
        }
        def argRefs := Array<String>(args.get_count())
        def actualMethodType:Type
        def actualResultType:String
        def isSuper := args.get_count() >= 1 & args[0] = IRNode.SUPER
        if !isSuper & m.isVirtual() {
            actualMethodType := compiler.inheritedType(m)
            actualResultType := type(actualMethodType.subtypes[actualMethodType.subtypes.get_count() - 1])
        }
        else {
            actualMethodType := compiler.declaredType(m)
            actualResultType := type(t)
        }
        def offset := args.get_count() - actualMethodType.subtypes.get_count() + 1
        for i in 0 .. args.get_count() {
            def arg := getReference(args[i], out)
            if i >= offset & actualMethodType.subtypes[i - offset] != args[i].type() {
                arg := type(actualMethodType.subtypes[i - offset]) + " " +
                        getCastReference(arg, args[i].type(),
                            actualMethodType.subtypes[i - offset], out)
            }
            else {
                arg := type(args[i].type()) + " " + arg
            }
            argRefs.add(arg)
        }
        def target:String?
        if args.get_count() > 0 {
            -- this isn't actually correct - args[0] could be the target of an instance method, or
            -- just the first parameter to a class method. But getMethodReference ignores target for
            -- class methods, so this works and is easier than doing it the right way.
            target := argRefs[0]
        }
        else {
            target := null
        }
        def methodRef := getMethodReference(target, m, isSuper, out)
        def result:String
        def indirect := needsStructIndirection(m)
        if indirect {
            out.print("call \{callingConvention(m)}void")
        }
        else {
            result := nextVar()
            out.print("\{result} = call \{callingConvention(m)}\{actualResultType}")
        }
        out.print(" \{methodRef}(")
        var separator := ""
        def indirectVar:String
        if indirect {
            labelCount += 1
            indirectVar := "%$tmp" + labelCount
            methodHeader.printLine("\{indirectVar} = alloca \{actualResultType}")
            out.print("\{actualResultType}* \{indirectVar}")
            separator := ", "
        }
        for arg in argRefs {
            out.print("\{separator}\{arg}")
            separator := ", "
        }
        out.printLine(")")
        if indirect {
            result := nextVar()
            out.printLine("\{result} = load \{actualResultType}, \{actualResultType}* " +
                        indirectVar)
        }
        if type(t) != actualResultType {
            return getCastReference(result, 
                        actualMethodType.subtypes[actualMethodType.subtypes.get_count() - 1],
                        t,
                        out)
        }
        return result
    }

    method getDynamicCallReference(m:IRNode, args:ListView<IRNode>, out:OutputStream):String {
        def argRefs := Array<String>(args.get_count())
        for a in args {
            argRefs.add(getTypedReference(a, out))
        }
        def targetType := "i8*"
        def methodObjectPtrRef := getTypedReference(m, out)
        def methodObjectRef := nextVar()
        def methodObjectType := "%panda$core$Method"
        out.printLine("\{methodObjectRef} = load \{methodObjectType}, \{methodObjectPtrRef}")
        def rawMethodRef := nextVar()
        out.printLine("\{rawMethodRef} = extractvalue \{methodObjectType} \{methodObjectRef}, " +
                "\{OBJECT_FIELD_COUNT + 0}")
        def target := nextVar()
        out.printLine("\{target} = extractvalue \{methodObjectType} \{methodObjectRef}, " +
                "\{OBJECT_FIELD_COUNT + 1}")
        def targetNonNull := nextVar()
        out.printLine("\{targetNonNull} = icmp ne \{targetType} \{target}, null")
        def haveTarget := nextLabel()
        def noTarget := nextLabel()
        def merge := nextLabel()
        out.printLine("br i1 \{targetNonNull}, label %\{haveTarget}, label %\{noTarget}")
        def resultType := m.type().subtypes[m.type().subtypes.get_count() - 1]

        createBlock(haveTarget, out)
        def haveTargetMethodRef := nextVar()
        out.printLine("\{haveTargetMethodRef} = bitcast %panda$core$Int8* \{rawMethodRef} to " +
                methodType(m.type(), Type.pointerTo(Type.BuiltinInt8())))
        def haveTargetResult := nextVar()
        out.print("\{haveTargetResult} = call \{type(resultType)} \{haveTargetMethodRef}(" +
                "\{targetType} \{target}")
        if argRefs.get_count() > 0 {
            out.print(", \{argRefs.join()}")
        }
        out.printLine(")")

        out.print("br label %\{merge}")

        createBlock(noTarget, out)
        def noTargetMethodRef := nextVar()
        out.printLine("\{noTargetMethodRef} = bitcast %panda$core$Int8* \{rawMethodRef} to " +
                methodType(m.type(), null))
        def noTargetResult := nextVar()
        out.printLine("\{noTargetResult} = call \{type(resultType)} \{noTargetMethodRef}(" +
                "\{argRefs.join()})")
        out.print("br label %\{merge}")

        createBlock(merge, out)
        def result := nextVar()
        out.printLine("\{result} = phi \{type(resultType)} " +
                "[\{haveTargetResult}, %\{haveTarget}], " +
                "[\{noTargetResult}, %\{noTarget}]")
        return result
    }

    method wrapValue(value:String, srcType:Type, dstType:Type, out:OutputStream):String {
        def src := compiler.getClass(srcType)
        assert src != null
        if srcType.typeKind = Type.Kind.NULLABLE {
            -- casting nullable value to nullable wrapper, need to special-case null
            def testStart := currentBlock
            def isNonNull := nextVar()
            out.printLine("\{isNonNull} = extractvalue \{nullableType(srcType)} \{value}, 1")
            def nonNullLabel := nextLabel()
            def endLabel := nextLabel()
            out.printLine("br i1 \{isNonNull}, label %\{nonNullLabel}, label %\{endLabel}")
            createBlock(nonNullLabel, out)
            def unwrapped := toNonNullableValue(value, srcType, srcType.subtypes[0], out)
            def nonNullValue := wrapValue(unwrapped, srcType.subtypes[0], dstType, out)
            out.printLine("br label %\{endLabel}")
            createBlock(endLabel, out)
            def result := nextVar()
            out.printLine("\{result} = phi \{type(dstType)} [null, %\{testStart}], " +
                    "[\{nonNullValue}, %\{nonNullLabel}]")
            return result
        }
        def cc := getWrapperClassConstant(src)
        def ccCast:String
        if cc.type != "%panda$core$Class" {
            ccCast := "bitcast(\{cc.type}* \{cc.name} to %panda$core$Class*)"
        }
        else {
            ccCast := cc.name
        }
        def mallocRef := nextVar()
        out.printLine("\{mallocRef} = call i8* @pandaObjectAlloc(" +
                "i64 \{sizeOfWrapper(src.type())}, %panda$core$Class* \{ccCast})")
        def wrapperTypeName := wrapperTypeName(src.type())
        def wrapperType := wrapperType(src.type())
        def wrapperCast := nextVar()
        out.printLine("\{wrapperCast} = bitcast i8* \{mallocRef} to \{wrapperType}")
        def target := nextVar()
        out.printLine("\{target} = getelementptr \{wrapperTypeName}, " +
                "\{wrapperType} \{wrapperCast}, i64 0, i32 2")
        out.printLine("store \{type(srcType)} \{value}, \{type(srcType)}* \{target}")
        if wrapperType != type(dstType) {
            def result := nextVar()
            out.printLine("\{result} = bitcast \{wrapperType} \{wrapperCast} to \{type(dstType)}")
            return result
        }
        return wrapperCast
    }

    method getFieldReference(base:IRNode, field:FieldDecl, out:OutputStream):String {
        def t := type(field.type)
        if field.annotations.isClass() {
            assert field.value != null
            return getReference(field.value, out)
        }
        def cl := compiler.getClass(base.type())
        assert cl != null
        if compiler.isValue(cl) & (base != IRNode.SELF |
                currentMethod.methodKind != MethodDecl.Kind.INIT) {
            def baseRef := getReference(base, out)
            def fields := compiler.instanceFields(cl)
            def index:Int? := null
            for i in 0 .. fields.get_count() {
                if fields[i]->FieldDecl == field { -- FIXME unnecessary cast
                    index := i
                    break
                }
            }
            assert index != null
            var result := nextVar()
            out.printLine("\{result} = extractvalue \{type(base.type())} \{baseRef}, " +
                    index)
            if field.type.isClass() & !compiler.isValue(compiler.getClass(field.type)) {
                def cast := nextVar()
                out.printLine("\{cast} = bitcast i8* \{result} to \{t}")
                result := cast
            }
            return result
        }
        def ptr := "\{t}* \{getFieldLValue(base, field, out)}"
        def result := nextVar()
        out.printLine("\{result} = load \{t}, \{ptr}")
        return result
    }

    method unwrapValue(value:String, srcType:Type, dstType:Type, out:OutputStream):String {
        def target := compiler.getClass(dstType)
        assert target != null
        if dstType.typeKind = Type.Kind.NULLABLE {
            -- casting nullable wrapper to nullable value, need to special-case null
            def testStart := currentBlock
            def isNonNull := nextVar()
            out.printLine("\{isNonNull} = icmp ne \{type(srcType)} \{value}, null")
            def nonNullLabel := nextLabel()
            def endLabel := nextLabel()
            out.printLine("br i1 \{isNonNull}, label %\{nonNullLabel}, label %\{endLabel}")
            createBlock(nonNullLabel, out)
            def wrapped := unwrapValue(value, srcType, dstType.subtypes[0], out)
            def nonNullValue := toNullableValue(wrapped, dstType.subtypes[0], dstType, out)
            out.printLine("br label %\{endLabel}")
            createBlock(endLabel, out)
            def result := nextVar()
            out.printLine("\{result} = phi \{type(dstType)} " +
                    "[{ \{type(dstType.subtypes[0])} undef, i1 0 }, " +
                    "%\{testStart}], [\{nonNullValue}, %\{nonNullLabel}]")
            return result
        }
        def targetType := type(dstType)
        def wrapperTypeName := wrapperTypeName(dstType)
        def wrapperType := wrapperType(dstType)
        def srcCast := nextVar()
        out.printLine("\{srcCast} = bitcast \{type(srcType)} \{value} to \{wrapperType}")
        def load := nextVar()
        out.printLine("\{load} = load \{wrapperTypeName}, \{wrapperType} \{srcCast}")
        def result := nextVar()
        out.printLine("\{result} = extractvalue \{wrapperTypeName} \{load}, \{OBJECT_FIELD_COUNT}")
        return result
    }

    method toNullableValue(value:String, srcType:Type, dstType:Type,
            out:OutputStream):String {
        def nullableType := nullableType(dstType)
        def result := nextVar()
        out.printLine("\{result} = insertvalue \{nullableType} " +
                "{ \{type(srcType)} undef, i1 true }, \{type(srcType)} \{value}, 0")
        return result
    }

    method toNonNullableValue(value:String, srcType:Type, dstType:Type,
            out:OutputStream):String {
        def result := nextVar()
        out.printLine("\{result} = extractvalue \{type(srcType)} \{value}, 0")
        return result
    }

    method getCastReference(value:String, src:Type, target:Type, out:OutputStream):String {
        def op:String
        if target.isBuiltinNumber() {
            assert src.isBuiltinNumber()
            def size1 := sizeOf(src)
            def size2 := sizeOf(target)
            if src.typeKind = Type.Kind.BUILTIN_FLOAT {
                if target.typeKind = Type.Kind.BUILTIN_FLOAT {
                    if size1 > size2 {
                        op := "fptrunc"
                    }
                    else if size1 < size2 {
                        op := "fpext"
                    }
                    else {
                        return value
                    }
                }
                else if target.typeKind = Type.Kind.BUILTIN_INT {
                    op := "fptosi"
                }
                else {
                    assert target.typeKind = Type.Kind.BUILTIN_UINT
                    op := "fptoui"
                }
            }
            else if target.typeKind = Type.Kind.BUILTIN_FLOAT {
                if src.typeKind = Type.Kind.BUILTIN_INT {
                    op := "sitofp"
                }
                else {
                    assert src.typeKind = Type.Kind.BUILTIN_UINT
                    op := "uitofp"
                }
            }
            else {
                if size1 > size2 {
                    op := "trunc"
                }
                else if size1 < size2 {
                    if src.typeKind = Type.Kind.BUILTIN_INT {
                        op := "sext"
                    }
                    else {
                        op := "zext"
                    }
                }
                else {
                    return value
                }
            }
        }
        else {
            def srcClass := compiler.getClass(src)
            assert srcClass != null
            def targetClass := compiler.getClass(target)
            assert targetClass != null
            if compiler.isValue(srcClass) & !compiler.isValue(targetClass) {
                return wrapValue(value, src, target, out)
            }
            else if !compiler.isValue(srcClass) & compiler.isValue(targetClass) {
                return unwrapValue(value, src, target, out)
            }
            else if compiler.isValue(srcClass) & target.typeKind = Type.Kind.NULLABLE &
                    target.subtypes[0] = src {
                return toNullableValue(value, src, target, out)
            }
            else if compiler.isValue(targetClass) & src.typeKind = Type.Kind.NULLABLE &
                    src.subtypes[0] = target {
                return toNonNullableValue(value, src, target, out)
            }
            op := "bitcast"
        }
        def srcType := type(src)
        def dstType := type(target)
        if srcType = dstType {
            return value
        }
        def result := nextVar()
        out.printLine("\{result} = \{op} \{srcType} \{value} to \{dstType}")
        return result
    }

    method getCastReference(base:IRNode, t:Type, out:OutputStream):String {
        def baseRef := getReference(base, out)
        return getCastReference(baseRef, base.type(), t, out)
    }

    method getConstructReference(target:Type, initCall:IRNode, out:OutputStream):String {
        match initCall {
            when IRNode.CALL(_, initType, initMref, args):
                def cl := compiler.getClass(target)
                assert cl != null
                def t := type(target)
                if target.isNumber() & args[0].type().isBuiltinNumber() {
                    assert args.get_count() = 1
                    def value := getTypedReference(args[0], out)
                    if args[0] = IRNode.INT {
                        return "{ " + value + " }"
                    }
                    def result := nextVar()
                    def lastField := cl.fields[cl.fields.get_count() - 1]
                    assert !lastField.annotations.isClass()
                    out.printLine("\{result} = insertvalue \{t} { \{type(lastField.type)} undef }" +
                            ", \{value}, 0\n")
                    return result
                }
                if target = Type.Bit() &
                        args[0].type().typeKind = Type.Kind.BUILTIN_BIT {
                    assert args.get_count() = 1
                    def value := getTypedReference(args[0], out)
                    if args[0] = IRNode.BIT {
                        return "{ " + value + " }"
                    }
                    def result := nextVar()
                    def lastField := cl.fields[cl.fields.get_count() - 1]
                    assert !lastField.annotations.isClass()
                    out.printLine("\{result} = insertvalue \{t} { \{type(lastField.type)} undef }" +
                            ", \{value}, 0\n")
                    return result
                }
                if compiler.isValue(cl) {
                    labelCount += 1
                    def alloca := "%$tmp\{labelCount}"
                    methodHeader.printLine("\{alloca} = alloca \{t}")
                    writeCall(initType, initMref, args, "\{t}* \{alloca}", out)
                    def result := nextVar()
                    out.printLine("\{result} = load \{t}, \{t}* \{alloca}")
                    return result
                }
                def cc := getClassConstant(cl)
                def ccCast:String
                if cc.type != "%panda$core$Class" {
                    ccCast := "bitcast(\{cc.type}* \{cc.name} to %panda$core$Class*)"
                }
                else {
                    ccCast := cc.name
                }
                def callRef := nextVar()
                out.printLine("\{callRef} = call i8* @pandaObjectAlloc(i64 \{sizeOf(target)}, " +
                        "%panda$core$Class* \{ccCast})")
                def result := nextVar()
                out.printLine("\{result} = bitcast i8* \{callRef} to \{type(target)}")
                def className:String
                if target.typeKind = Type.Kind.GENERIC & !cl.isSpecialization() {
                    className := typeName(target.subtypes[0])
                }
                else {
                    className := typeName(target)
                }
                writeCall(initType, initMref, args, "\{t} \{result}", out)
                return result
            otherwise:
                assert false
        }
    }

    method getIntReference(int:UInt64, out:OutputStream):String {
        return int.convert()
    }

    method getNegatedIntReference(int:UInt64, out:OutputStream):String {
        return "-" + int.convert()
    }

    method getRealReference(t:Type, r64:Real64, out:OutputStream):String {
        if t.size() = 32 {
            -- LLVM has a bizarre representation of float. You still use a double, but must ensure
            -- that said double is exactly representable as a float. We convert through Real32 to
            -- ensure this.
            def r32 := r64.convert()->panda.core.Real32.convert()->Real64
            return "0x\{Panda.floatToIntBits(r32):x}"
        }
        return "0x\{Panda.floatToIntBits(r64):x}"
    }

    method getBitReference(bit:Bit, out:OutputStream):String {
        if bit {
            return "true"
        }
        return "false"
    }

    method getVariableReference(v:Variable, out:OutputStream):String {
        if v.storage = Variable.Storage.PARAMETER {
            return getName(v)
        }
        def result := nextVar()
        def t := type(v.type)
        out.printLine("\{result} = load \{t}, \{t}* \{getName(v)}")
        return result
    }

    method getStringReference(s:String):String {
        labelCount += 1
        def chars := "@$chars\{labelCount}"
        def charsType := "[\{s.utf8().get_count()} x i8]"
        strings.print("\{chars} = private unnamed_addr constant \{charsType} [ ")
        var separator := ""
        for c in s.utf8() {
            strings.print("\{separator}i8 \{c.convert()->Int8}")
            separator := ", "
        }
        strings.printLine(" ]")
        labelCount += 1
        def result := "@$str\{labelCount}"
        def string := compiler.getClass(Type.StringType())
        assert string != null
        def cc := getClassConstant(string)
        strings.printLine("\{result} = private unnamed_addr constant %panda$core$String { " +
                "i8* bitcast(\{cc.type}* \{cc.name} to " +
                "i8*), %panda$core$Int32 insertvalue(%panda$core$Int32 " +
                "{ i32 undef }, i32 \{NO_REFCNT}, 0), " +
                "%panda$core$Char8* bitcast(\{charsType}* \{chars} " +
                "to %panda$core$Char8*), %panda$core$Int64 { i64 \{s.utf8().get_count()} }, " +
                "%panda$core$Int64 { i64 \{s.hash()} }, i8* null }")
        return result
    }

    ================================================================================================
    In init methods, %self must be a pointer rather than a value, so that we can modify our fields.
    This returns true if our current %self is a pointer to a value.
    ================================================================================================
    function haveSelfValuePointer():Bit {
        return currentMethod.methodKind = MethodDecl.Kind.INIT &
                compiler.isValue(currentMethod.owner)
    }

    ================================================================================================
    Returns the current %self, as a pointer. For values, this pointer is only available from within
    init methods.
    ================================================================================================
    method getSelfPointer():String {
        assert currentMethod.methodKind = MethodDecl.Kind.INIT |
                !compiler.isValue(currentMethod.owner),
                "self pointer for values is only accessible from init methods " +
                "(in \{currentMethod.declaration()})"
        def inline := getInlineContext()
        if inline != null {
            return inline.selfRef
        }
        return "%self"
    }

    ================================================================================================
    Returns the current %self, as a value if the current object is a value. For non-value objects
    %self is always a pointer.
    ================================================================================================
    method getSelfValue(out:OutputStream):String {
        assert currentMethod != null
        if haveSelfValuePointer() {
            def load := nextVar()
            out.printLine("\{load} = load \{type(currentMethod.owner.type())}, " +
                    "\{type(currentMethod.owner.type())}* \{getSelfPointer()}")
            return load
        }
        def inline := getInlineContext()
        if inline != null {
            return inline.selfRef
        }
        return "%self"
    }

    method getSelfReference(out:OutputStream):String {
        return getSelfValue(out)
    }

    method getSuperReference(t:Type, out:OutputStream):String {
        def ref := getSelfReference(out)
        def result := nextVar()
        out.printLine("\{result} = bitcast \{selfType(currentMethod)} \{ref} to \{type(t)}")
        return result
    }

    method getIsNullReference(value:IRNode, out:OutputStream):String {
        def valueRef := getTypedReference(value, out)
        def cl := compiler.getClass(value.type())
        def resultValue:String
        if compiler.isValue(cl) {
            if value.type().typeKind != Type.Kind.NULLABLE {
                return "{ i1 0 }"
            }
            def field := nextVar()
            out.printLine("\{field} = extractvalue \{valueRef}, 1")
            resultValue := nextVar()
            out.printLine("\{resultValue} = xor i1 \{field}, -1")
        }
        else {
            resultValue := nextVar()
            out.printLine("\{resultValue} = icmp eq \{valueRef}, null")
        }
        def result := nextVar()
        out.printLine("\{result} = insertvalue %panda$core$Bit { i1 undef }, i1 \{resultValue}, 0")
        return result
    }

    method getIsNonNullReference(value:IRNode, out:OutputStream):String {
        def valueRef := getTypedReference(value, out)
        def cl := compiler.getClass(value.type())
        def resultValue:String
        if compiler.isValue(cl) {
            if value.type().typeKind != Type.Kind.NULLABLE {
                return "{ i1 1 }"
            }
            resultValue := nextVar()
            out.printLine("\{resultValue} = extractvalue \{valueRef}, 1")
        }
        else {
            resultValue := nextVar()
            out.printLine("\{resultValue} = icmp ne \{valueRef}, null")
        }
        def result := nextVar()
        out.printLine("\{result} = insertvalue %panda$core$Bit { i1 undef }, i1 \{resultValue}, 0")
        return result
    }

    method getNullReference(t:Type, out:OutputStream):String {
        assert t.typeKind = Type.Kind.NULLABLE
        def cl := compiler.getClass(t.subtypes[0])
        assert cl != null
        if compiler.isValue(cl) {
            return "{ \{type(t.subtypes[0])} undef, i1 0 }"
        }
        else {
            return "null"
        }
    }

    method getPrefixReference(op:Token.Kind, base:IRNode, out:OutputStream):String {
        def baseRef := getReference(base, out)
        def result := nextVar()
        def t := type(base.type())
        match op {
            when Token.Kind.SUB:
                def zero:String
                if base.type().typeKind = Type.Kind.BUILTIN_FLOAT {
                    out.printLine("\{result} = fsub \{t} 0.0, \{baseRef}")
                }
                else {
                    out.printLine("\{result} = sub \{t} 0, \{baseRef}")
                }
                return result
            when Token.Kind.NOT, Token.Kind.BITWISENOT:
                out.printLine("\{result} = xor \{t} -1, \{baseRef}")
                return result
            otherwise:
                assert false
        }
    }

    method getChoiceFieldReference(base:IRNode, ce:ChoiceEntry, field:Int,
            out:OutputStream):String {
        def lvalue := getChoiceFieldLValue(base, ce, field, out)
        def load := nextVar()
        def t := type(ce.fields[field])
        out.printLine("\{load} = load \{t}, \{t}* \{lvalue}")
        return load
    }

    method getExpressionWithExtraEffectsReference(expr:IRNode, stmt:IRNode,
            out:OutputStream):String {
        def result := getReference(expr, out)
        extraEffects[0].add(ExtraEffect.STATEMENT(stmt))
        return result
    }

    method getAtReturnReference(t:Type, out:OutputStream):String {
        def load := nextVar()
        def llvmType := type(t)
        out.printLine("\{load} = load \{llvmType}, \{llvmType}* \{returnValueVar}")
        return load
    }

    method getMethodRefReference(target:IRNode?, m:MethodDecl, out:OutputStream):String {
        def methodObjectType := Type.Method()
        def methodClass := compiler.getClass(methodObjectType)
        def cc := getClassConstant(methodClass)
        def ccCast:String
        if cc.type != "%panda$core$Class" {
            ccCast := "bitcast(\{cc.type}* \{cc.name} to %panda$core$Class*)"
        }
        else {
            ccCast := cc.name
        }
        def alloc := nextVar()
        out.printLine("\{alloc} = call i8* @pandaObjectAlloc(i64 \{sizeOf(methodObjectType)}, " +
                "%panda$core$Class* \{ccCast})")
        def result := nextVar()
        out.printLine("\{result} = bitcast i8* \{alloc} to \{type(methodObjectType)}")
        def initMethod := methodClass.methods[0]
        compiler.resolve(initMethod)
        writeDeclaration(initMethod)
        def methodCast := nextVar()
        def targetType:Type?
        if target != null {
            targetType := target.type()
        }
        else {
            targetType := null
        }
        out.printLine("\{methodCast} = bitcast \{methodType(m.type(), targetType)} " +
                "\{getName(m)} to %panda$core$Int8*")
        def targetCast:String
        if target != null {
            def targetRef := getTypedReference(target, out)
            targetCast := nextVar()
            out.printLine("\{targetCast} = bitcast \{targetRef} to \{type(Type.Object())}")
        }
        else {
            targetCast := "null"
        }
        out.printLine("call void \{getName(initMethod)}(\{type(methodObjectType)} \{result}, " +
                "%panda$core$Int8* \{methodCast}, \{type(Type.Any())} \{targetCast})")

        def resultCast := nextVar()
        out.printLine("\{resultCast} = bitcast %panda$core$Method* \{result} to %panda$core$Object*")
        extraEffects[0].add(ExtraEffect.STRING("call void " +
                "@panda$core$Panda$unref$panda$core$Object(%panda$core$Object* \{resultCast})"))
        return result
    }

    @post(extraEffects.get_count() = @pre(extraEffects.get_count()))
    method getReference(expr:IRNode, out:OutputStream):String {
        match expr {
            when IRNode.AT_RETURN(_, type):
                return getAtReturnReference(type, out)
            when IRNode.BINARY(_, _, left, op, right):
                return getBinaryReference(left, op, right, out)
            when IRNode.BIT(_, _, value):
                return getBitReference(value, out)
            when IRNode.CALL(_, type, target, args):
                return getCallReference(type, target, args, out)
            when IRNode.CAST(_, base, type, explicit):
                return getCastReference(base, type, out)
            when IRNode.CHOICE_FIELD_REFERENCE(_, base, ce, field):
                return getChoiceFieldReference(base, ce, field, out)
            when IRNode.CONSTRUCT(_, type, initCall):
                return getConstructReference(type, initCall, out)
            when IRNode.DYNAMIC_CALL(m, args):
                return getDynamicCallReference(m, args, out)
            when IRNode.EXPRESSION_WITH_EXTRA_EFFECTS(expr, stmt):
                return getExpressionWithExtraEffectsReference(expr, stmt, out)
            when IRNode.FIELD_REFERENCE(_, _, base, field):
                return getFieldReference(base, field, out)
            when IRNode.INT(_, _, value):
                return getIntReference(value, out)
            when IRNode.IS_NONNULL(_, value):
                return getIsNonNullReference(value, out)
            when IRNode.IS_NULL(_, value):
                return getIsNullReference(value, out)
            when IRNode.METHOD_REFERENCE(_, target, ref):
                return getMethodRefReference(target, ref.value, out)
            when IRNode.NEGATED_INT(_, _, value):
                return getNegatedIntReference(value, out)
            when IRNode.NULL(_, type):
                return getNullReference(type, out)
            when IRNode.PREFIX(_, op, base):
                return getPrefixReference(op, base, out)
            when IRNode.REAL(_, type, value):
                return getRealReference(type, value, out)
            when IRNode.REUSED_VALUE(_, _, id):
                def result := reusedValues[id]
                assert result != null
                return result
            when IRNode.REUSED_VALUE_DEFINITION(base, id):
                def value := getReference(base, out)
                reusedValues[id] := value
                return value
            when IRNode.SELF:
                return getSelfReference(out)
            when IRNode.STRING(_, str):
                return getStringReference(str)
            when IRNode.SUPER(_, t):
                return getSuperReference(t, out)
            when IRNode.TERNARY(_, test, ifTrue, ifFalse):
                return getTernaryReference(test, ifTrue, ifFalse, out)
            when IRNode.VARIABLE_REFERENCE(_, variable):
                return getVariableReference(variable, out)
            otherwise:
                assert false, "unsupported expression \{expr}(\{expr.$rawValue}):\{expr.position()}"
        }
    }

    method getTypedReference(expr:IRNode, out:OutputStream):String {
        return "\{type(expr.type())} \{getReference(expr, out)}"
    }

    method writeBlock(statements:ImmutableArray<IRNode>, out:OutputStream) {
        for s in statements {
            writeStatement(s, out)
        }
    }

    method writeBlockWithFinally(statements:ImmutableArray<IRNode>,
                                 finally:ImmutableArray<IRNode>,
                                 out:OutputStream) {
        -- The basic idea is to create a block for each finally which knows where to return to based
        -- on where it came from. We use a phi statement at the beginning of the finally to
        -- discriminate based on source block, then a switch statement at the end of the finally to
        -- jump back to the right location based on the returnMap. The returnMap initially only
        -- contains the default fallthrough block that we go to if we fall off the end of the block,
        -- but other statements such as returns will add their own entries to the map.
        def finallyLabel := nextLabel()
        def returnLabelMap := HashMap<String, String>()
        labelCount += 1
        def context := AutoContext(self, EnclosingContext.FINALLY(finallyLabel, returnLabelMap))
        writeBlock(statements, out)
        def fallthrough := nextLabel()
        if !compiler.endsWithBranch(statements) {
            out.printLine("br label %\{finallyLabel}")
            returnLabelMap[currentBlock] := fallthrough
        }
        createBlock(finallyLabel, out)
        
        def source := nextVar()
        out.print("\{source} = phi i16 ")
        var i := 0
        var separator := ""
        for label in returnLabelMap.keys() {
            out.print("\{separator}[\{i}, %\{label}]")
            separator := ", "
            i += 1
        }
        out.printLine()

        for s in finally {
            writeStatement(s, out)
        }
        out.print("switch i16 \{source}, label %\{fallthrough} [")
        i := 0
        for label in returnLabelMap.keys() {
            out.print(" i16 \{i}, label %\{returnLabelMap[label]}")
            i += 1
        }
        out.printLine(" ]")
        createBlock(fallthrough, out)
    }

    method writePointerCall(m:MethodRef, args:ImmutableArray<IRNode>, out:OutputStream) {
        match m.value.name {
            when "set":
                assert args.get_count() = 2
                def ptr := getTypedReference(args[0], out)
                def arg := getTypedReference(compiler.unwrapCast(args[1]), out)
                out.printLine("store \{arg}, \{ptr}")
            when "[]:=":
                assert args.get_count() = 3
                assert compiler.unwrapCast(args[0]).type().subtypes.get_count() = 2
                def baseType := compiler.unwrapCast(args[0]).type().subtypes[1]
                def base := getTypedReference(args[0], out)
                def indexStruct := getTypedReference(args[1], out)
                def index := nextVar()
                out.printLine("\{index} = extractvalue \{indexStruct}, 0")
                def value := getTypedReference(compiler.unwrapCast(args[2]), out)
                def ptr := nextVar()
                out.printLine("\{ptr} = getelementptr inbounds \{type(baseType)}, \{base}, " +
                        "\{SIZE_TYPE} \{index}")
                out.printLine("store \{value}, \{type(baseType)}* \{ptr}")
            when "destroy":
                assert args.get_count() = 1
                def ptr := getTypedReference(args[0], out)
                def cast := nextVar()
                out.printLine("\{cast} = bitcast \{ptr} to i8*")
                out.printLine("call void @pandaFree(i8* \{cast})")
            otherwise:
                assert false
        }
    }

    -- if 'target' is non-null, it is inserted as a hidden first parameter to the call. This is used
    -- for init() calls, which require a self parameter but do not have a target in the IR.
    method writeCall(t:Type, mref:MethodRef, args:ImmutableArray<IRNode>, target:String?,
            out:OutputStream) {
        def m := mref.value
        if m.owner.name = "panda.unsafe.Pointer" {
            writePointerCall(mref, args, out)
            return
        }
        if m.owner.external {
            writeDeclaration(m)
        }
        def actualMethodType:Type
        def actualResultType:String
        def isSuper := args.get_count() >= 1 & args[0] = IRNode.SUPER
        if !isSuper & m.isVirtual() {
            actualMethodType := compiler.inheritedType(m)
            actualResultType := type(actualMethodType.subtypes[actualMethodType.subtypes.get_count() - 1])
        }
        else {
            actualMethodType := compiler.declaredType(m)
            actualResultType := type(t)
        }
        def argRefs := Array<String>()
        if target != null {
            argRefs.add(target)
        }
        def offset := args.get_count() - actualMethodType.subtypes.get_count() + 1
        for i in 0 .. args.get_count() {
            if target = null & i = 0 & args[i] = IRNode.SELF &
                    m.methodKind = MethodDecl.Kind.INIT {
                argRefs.add("\{selfType(m)} \{getSelfPointer()}")
                continue
            }
            def argType := type(args[i].type())
            if target = null & i = 0 & args[i] = IRNode.SUPER &
                    m.methodKind = MethodDecl.Kind.INIT {
                def cast := nextVar()
                out.printLine("\{cast} = bitcast \{selfType(currentMethod)} \{getSelfPointer()} " +
                        " to \{argType}")
                argRefs.add("\{argType} \{cast}")
                continue
            }
            def arg := getReference(args[i], out)
            if i >= offset & actualMethodType.subtypes[i - offset] != args[i].type() {
                arg := type(actualMethodType.subtypes[i - offset]) + " " +
                        getCastReference(arg, args[i].type(),
                            actualMethodType.subtypes[i - offset], out)
            }
            else {
                arg := "\{argType} \{arg}"
            }
            argRefs.add(arg)
        }
        def targetRef:String?
        if argRefs.get_count() > 0 {
            -- this isn't actually correct - args[0] could be the target of an instance method, or
            -- just the first parameter to a class method. But getMethodReference ignores target for
            -- non-virtual methods, so this works and is easier than doing it the right way.
            targetRef := argRefs[0]
        }
        else {
            targetRef := null
        }
        def methodRef := getMethodReference(targetRef, m, isSuper, out)
        var separator := ""
        if needsStructIndirection(m) {
            labelCount += 1
            def indirectVar := "%$tmp" + labelCount
            def resultType := type(t)
            methodHeader.printLine("\{indirectVar} = alloca \{resultType}")
            out.print("call \{callingConvention(m)}void " +
                    "\{methodRef}(\{resultType}* \{indirectVar}")
            separator := ", "
        }
        else {
            if t != Type.Void() {
                nextVar()
            }
            out.print("call \{callingConvention(m)}\{type(t)} \{methodRef}(")
        }
        for a in argRefs {
            out.print(separator)
            out.print(a)
            separator := ", "
        }
        out.printLine(")")
    }

    method writeIf(test:IRNode, ifTrue:ImmutableArray<IRNode>, ifFalse:IRNode?, out:OutputStream) {
        extraEffects.push(Array<ExtraEffect>())
        def testRef := getTypedReference(test, out)
        def testBit := nextVar()
        out.printLine("\{testBit} = extractvalue \{testRef}, 0")
        writeExtraEffects(out)
        def ifTrueLabel := nextLabel()
        def ifFalseLabel := nextLabel()
        out.printLine("br i1 \{testBit}, label %\{ifTrueLabel}, label %\{ifFalseLabel}")
        createBlock(ifTrueLabel, out)
        writeBlock(ifTrue, out)
        def end:String
        if ifFalse != null {
            end := nextLabel()
        }
        else {
            end := ifFalseLabel
        }
        if !compiler.endsWithBranch(ifTrue) {
            out.printLine("br label %\{end}")
        }
        if ifFalse != null {
            createBlock(ifFalseLabel, out)
            writeStatement(ifFalse, out)
            if !compiler.endsWithBranch(ifFalse) {
                out.printLine("br label %\{end}")
            }
        }
        createBlock(end, out)
    }

    method writeSimpleRealRangeFor(label:String?, target:IRNode, list:IRNode,
            statements:ImmutableArray<IRNode>, out:OutputStream) {
        -- this could probably be simplified quite a bit; it's just a cut-down version of
        -- writeSteppedRealRangeFor
        assert list.type().typeKind = Type.Kind.GENERIC
        assert list.type().subtypes.get_count() = 2
        assert list.type().subtypes[0].name = Compiler.RANGE_NAME
        def range := getTypedReference(list, out)
        def t := list.type().subtypes[1]
        def llt := type(t)
        def indexType:String
        if t.typeKind = Type.Kind.NULLABLE {
            assert t.subtypes.get_count() = 1
            indexType := type(t.subtypes[0])
        }
        else {
            indexType := llt
        }
        def cl := compiler.getClass(t)
        assert cl != null
        assert compiler.instanceFields(cl).get_count() = 1
        def numberType := type(compiler.instanceFields(cl)[0].type)
        def index:String
        match target {
            when IRNode.VARIABLE_REFERENCE(_, v):
                index := getName(v)
            otherwise:
                assert false
        }
        methodHeader.printLine("\{index} = alloca \{indexType}")

        -- extract start value from range
        def start := nextVar()
        out.printLine("\{start} = extractvalue \{range}, 0, 0")

        -- store start value
        def indexValuePtr := nextVar()
        out.printLine("\{indexValuePtr} = getelementptr \{indexType}, \{indexType}* \{index}, " +
                "i64 0, i32 0")
        out.printLine("store \{numberType} \{start}, \{numberType}* \{indexValuePtr}")

        -- extract end value from range
        def end := nextVar()
        out.printLine("\{end} = extractvalue \{range}, 1, 0")

        -- extract inclusive / exclusive from range
        def inclusive := nextVar()
        out.printLine("\{inclusive} = extractvalue \{range}, 2, 0")

        -- start block
        def loopStart := nextLabel()
        def loopBody := nextLabel()
        def loopEnd := nextLabel()
        def loopInc := nextLabel()
        def context := AutoContext(self, EnclosingContext.LOOP(label, loopEnd, loopInc))
        def forward := nextLabel()
        def backward := nextLabel()
        out.printLine("br label %\{loopStart}")
        createBlock(loopStart, out)
        def indexValue := nextVar()
        out.printLine("\{indexValue} = load \{numberType}, \{numberType}* \{indexValuePtr}")
        def forwardInclusive := nextLabel()
        def forwardExclusive := nextLabel()
        out.printLine("br i1 \{inclusive}, label %\{forwardInclusive}, " +
                "label %\{forwardExclusive}")
        createBlock(forwardInclusive, out)
        def forwardInclusiveTest := nextVar()
        out.printLine("\{forwardInclusiveTest} = fcmp ole \{numberType} \{indexValue}, \{end}")
        out.printLine("br i1 \{forwardInclusiveTest}, label %\{loopBody}, label %\{loopEnd}")
        createBlock(forwardExclusive, out)
        def forwardExclusiveTest := nextVar()
        out.printLine("\{forwardExclusiveTest} = fcmp olt \{numberType} \{indexValue}, \{end}")
        out.printLine("br i1 \{forwardExclusiveTest}, label %\{loopBody}, label %\{loopEnd}")
        createBlock(loopBody, out)
        writeBlock(statements, out)
        if !compiler.endsWithBranch(statements) {
            out.printLine("br label %\{loopInc}")
        }
        createBlock(loopInc, out)
        def inc := nextVar()
        out.printLine("\{inc} = fadd \{numberType} \{indexValue}, 1.0")
        def incStruct := nextVar()
        out.printLine("\{incStruct} = insertvalue \{indexType} { \{numberType} undef")
        out.printLine(" }, \{numberType} \{inc}, 0")
        out.printLine("store \{indexType} \{incStruct}, \{indexType}* \{index}")
        out.printLine("br label %\{loopStart}")

        createBlock(loopEnd, out)
    }

    method writeSteppedRealRangeFor(label:String?, target:IRNode, list:IRNode,
            statements:ImmutableArray<IRNode>, out:OutputStream) {
        assert list.type().typeKind = Type.Kind.GENERIC
        assert list.type().subtypes.get_count() = 3
        assert list.type().subtypes[0].name = Compiler.STEPPED_RANGE_NAME
        def range := getTypedReference(list, out)
        def t := list.type().subtypes[1]
        def llt := type(t)
        def indexType:String
        if t.typeKind = Type.Kind.NULLABLE {
            assert t.subtypes.get_count() = 1
            indexType := type(t.subtypes[0])
        }
        else {
            indexType := llt
        }
        def cl := compiler.getClass(t)
        assert cl != null
        assert compiler.instanceFields(cl).get_count() = 1
        def numberType := type(compiler.instanceFields(cl)[0].type)
        def index:String
        match target {
            when IRNode.VARIABLE_REFERENCE(_, v):
                index := getName(v)
            otherwise:
                assert false
        } 
        methodHeader.printLine("\{index} = alloca \{indexType}")

        -- extract start value from range
        def start := nextVar()
        out.printLine("\{start} = extractvalue \{range}, 0, 0")

        -- store start value
        def indexValuePtr := nextVar()
        out.printLine("\{indexValuePtr} = getelementptr \{indexType}, \{indexType}* \{index}, " +
                "i64 0, i32 0")
        out.printLine("store \{numberType} \{start}, \{numberType}* \{indexValuePtr}")

        -- extract end value from range
        def end := nextVar()
        out.printLine("\{end} = extractvalue \{range}, 1, 0")

        -- extract step value from range
        def step := nextVar()
        out.printLine("\{step} = extractvalue \{range}, 2, 0")

        -- extract inclusive / exclusive from range
        def inclusive := nextVar()
        out.printLine("\{inclusive} = extractvalue \{range}, 3, 0")

        -- start block
        def loopStart := nextLabel()
        def loopBody := nextLabel()
        def loopEnd := nextLabel()
        def loopInc := nextLabel()
        def context := AutoContext(self, EnclosingContext.LOOP(label, loopEnd, loopInc))
        def forward := nextLabel()
        def backward := nextLabel()
        def direction:String
        direction := nextVar()
        out.printLine("\{direction} = fcmp ogt \{numberType} \{step}, 0.0")
        out.printLine("br label %\{loopStart}")
        createBlock(loopStart, out)
        def indexValue := nextVar()
        out.printLine("\{indexValue} = load \{numberType}, \{numberType}* \{indexValuePtr}")
        out.printLine("br i1 \{direction}, label %\{forward}, label %\{backward}")
        createBlock(forward, out)
        def forwardInclusive := nextLabel()
        def forwardExclusive := nextLabel()
        out.printLine("br i1 \{inclusive}, label %\{forwardInclusive}, " +
                "label %\{forwardExclusive}")
        createBlock(forwardInclusive, out)
        def forwardInclusiveTest := nextVar()
        out.printLine("\{forwardInclusiveTest} = fcmp ole \{numberType} \{indexValue}, \{end}")
        out.printLine("br i1 \{forwardInclusiveTest}, label %\{loopBody}, label %\{loopEnd}")
        createBlock(forwardExclusive, out)
        def forwardExclusiveTest := nextVar()
        out.printLine("\{forwardExclusiveTest} = fcmp olt \{numberType} \{indexValue}, \{end}")
        out.printLine("br i1 \{forwardExclusiveTest}, label %\{loopBody}, label %\{loopEnd}")
        createBlock(backward, out)
        def backwardInclusive := nextLabel()
        def backwardExclusive := nextLabel()
        out.printLine("br i1 \{inclusive}, label %\{backwardInclusive}, " +
                "label %\{backwardExclusive}")
        createBlock(backwardInclusive, out)
        def backwardInclusiveTest := nextVar()
        out.printLine("\{backwardInclusiveTest} = fcmp oge \{numberType} \{indexValue}, \{end}")
        out.printLine("br i1 \{backwardInclusiveTest}, label %\{loopBody}, label %\{loopEnd}")
        createBlock(backwardExclusive, out)
        def backwardExclusiveTest := nextVar()
        out.printLine("\{backwardExclusiveTest} = fcmp ogt \{numberType} \{indexValue}, \{end}")
        out.printLine("br i1 \{backwardExclusiveTest}, label %\{loopBody}, label %\{loopEnd}")
        createBlock(loopBody, out)
        writeBlock(statements, out)
        if !compiler.endsWithBranch(statements) {
            out.printLine("br label %\{loopInc}")
        }
        createBlock(loopInc, out)
        def inc := nextVar()
        out.printLine("\{inc} = fadd \{numberType} \{indexValue}, \{step}")
        def incStruct := nextVar()
        out.printLine("\{incStruct} = insertvalue \{indexType} { \{numberType} undef")
        out.printLine(" }, \{numberType} \{inc}, 0")
        out.printLine("store \{indexType} \{incStruct}, \{indexType}* \{index}")
        out.printLine("br label %\{loopStart}")

        createBlock(loopEnd, out)
    }

    method writeSimpleRangeFor(label:String?, target:IRNode, list:IRNode,
            statements:ImmutableArray<IRNode>, out:OutputStream) {
        -- this could probably be simplified quite a bit; it's just a cut-down version of
        -- writeSteppedRangeFor
        assert list.type().typeKind = Type.Kind.GENERIC
        assert list.type().subtypes.get_count() = 2
        assert list.type().subtypes[0].name = Compiler.RANGE_NAME
        def range := getTypedReference(list, out)
        def t := list.type().subtypes[1]
        def llt := type(t)
        def indexType:String
        if t.typeKind = Type.Kind.NULLABLE {
            assert t.subtypes.get_count() = 1
            indexType := type(t.subtypes[0])
        }
        else {
            indexType := llt
        }
        def cl := compiler.getClass(t)
        assert cl != null
        assert compiler.instanceFields(cl).get_count() = 1
        def numberType := type(compiler.instanceFields(cl)[0].type)
        def index:String
        match target {
            when IRNode.VARIABLE_REFERENCE(_, v):
                index := getName(v)
            otherwise:
                assert false
        } 
        methodHeader.printLine("\{index} = alloca \{indexType}")

        -- extract start value from range
        def start := nextVar()
        out.printLine("\{start} = extractvalue \{range}, 0, 0")

        -- store start value
        def indexValuePtr := nextVar()
        out.printLine("\{indexValuePtr} = getelementptr \{indexType}, \{indexType}* \{index}, " +
                "i64 0, i32 0")
        out.printLine("store \{numberType} \{start}, \{numberType}* \{indexValuePtr}")

        -- extract end value from range
        def end := nextVar()
        out.printLine("\{end} = extractvalue \{range}, 1, 0")

        -- extract inclusive / exclusive from range
        def inclusive := nextVar()
        out.printLine("\{inclusive} = extractvalue \{range}, 2, 0")

        -- start block
        def loopStart := nextLabel()
        def loopBody := nextLabel()
        def loopEnd := nextLabel()
        def loopTest := nextLabel()
        def context := AutoContext(self, EnclosingContext.LOOP(label, loopEnd, loopTest))
        def forwardEntry := nextLabel()
        def backwardEntry := nextLabel()
        def signPrefix:String
        if t.name.startsWith("panda.core.Int") {
            signPrefix := "s"
        }
        else {
            assert t.name.startsWith("panda.core.UInt") | t.name.startsWith("panda.core.Char")
            signPrefix := "u"
        }
        def forwardEntryInclusive := nextLabel()
        def forwardEntryExclusive := nextLabel()
        out.printLine("br i1 \{inclusive}, label %\{forwardEntryInclusive}, " +
                "label %\{forwardEntryExclusive}")
        createBlock(forwardEntryInclusive, out)
        def forwardEntryInclusiveTest := nextVar()
        out.printLine("\{forwardEntryInclusiveTest} = icmp \{signPrefix}le \{numberType} " +
                "\{start}, \{end}")
        out.printLine("br i1 \{forwardEntryInclusiveTest}, label %\{loopStart}, label %\{loopEnd}")
        createBlock(forwardEntryExclusive, out)
        def forwardEntryExclusiveTest := nextVar()
        out.printLine("\{forwardEntryExclusiveTest} = icmp \{signPrefix}lt \{numberType} " +
                "\{start}, \{end}")
        out.printLine("br i1 \{forwardEntryExclusiveTest}, label %\{loopStart}, label %\{loopEnd}")
        createBlock(loopStart, out)
        def indexValue := nextVar()
        out.printLine("\{indexValue} = load \{numberType}, \{numberType}* \{indexValuePtr}")
        writeBlock(statements, out)
        if !compiler.endsWithBranch(statements) {
            out.printLine("br label %\{loopTest}")
        }
        createBlock(loopTest, out)
        def loopInc := nextLabel()
        def forwardDelta := nextVar()
        out.printLine("\{forwardDelta} = sub \{numberType} \{end}, \{indexValue}")

        -- forward loop; determine inclusive / exclusive
        def forwardInclusiveLabel := nextLabel()
        def forwardExclusiveLabel := nextLabel()
        out.printLine("br i1 \{inclusive}, label %\{forwardInclusiveLabel}, label %" +
                forwardExclusiveLabel)

        -- forward inclusive test
        createBlock(forwardInclusiveLabel, out)
        def forwardInclusiveTest := nextVar()
        -- always use unsigned comparison to avoid overflow; we know both the delta and the step are
        -- the same sign
        out.printLine("\{forwardInclusiveTest} = icmp uge \{numberType} \{forwardDelta}, 1")
        out.printLine("br i1 \{forwardInclusiveTest}, label %\{loopInc}, label %\{loopEnd}")
        createBlock(forwardExclusiveLabel, out)

        -- forward exclusive test
        def forwardExclusiveTest := nextVar()
        out.printLine("\{forwardExclusiveTest} = icmp ugt \{numberType} \{forwardDelta}, 1")
        out.printLine("br i1 \{forwardExclusiveTest}, label %\{loopInc}, label %\{loopEnd}")

        createBlock(loopInc, out)
        def inc := nextVar()
        out.printLine("\{inc} = add \{numberType} \{indexValue}, 1")
        def incStruct := nextVar()
        out.printLine("\{incStruct} = insertvalue \{indexType} { \{numberType} undef")
        out.printLine(" }, \{numberType} \{inc}, 0")
        out.printLine("store \{indexType} \{incStruct}, \{indexType}* \{index}")
        out.printLine("br label %\{loopStart}")

        createBlock(loopEnd, out)
    }

    method writeSteppedRangeFor(label:String?, target:IRNode, list:IRNode,
            statements:ImmutableArray<IRNode>, out:OutputStream) {
        -- I am acutely aware of how horrific this looks.
        --
        -- There's no easy way to produce clean output here, since we have to handle different step
        -- values, different loop directions, and both inclusive and exclusive ranges, all of which
        -- could potentially be determined at runtime. It gets even uglier when you consider the
        -- difficulty of handling the extremes of the numeric types. You can't just add 1 and then
        -- check to see if it's in range when the limit is MAX_INT, because you'll overflow and end
        -- up with an infinite loop. You also can't just check for being equal to the limit before
        -- adding the step, because with a step bigger than 1 (or smaller than -1) you might need to
        -- stop before actually hitting the end. So you instead check the difference between the
        -- current index and the limit, but even there you need to be careful because it could
        -- overflow in a signed test, and we need to handle null values, and... ugh, it's
        -- surprisingly messy and results in a ton of code.
        --
        -- Fortunately, we can just write incredibly awful-but-straightforward code and let LLVM
        -- optimize it to something sensible if it turns out the values are known at compile time.
        -- This works remarkably well, because LLVM is awesome.
        assert list.type().typeKind = Type.Kind.GENERIC
        assert list.type().subtypes.get_count() = 3
        assert list.type().subtypes[0].name = Compiler.STEPPED_RANGE_NAME
        def range := getTypedReference(list, out)
        def t := list.type().subtypes[1]
        def stepType := list.type().subtypes[2]
        def llt := type(t)
        def indexType:String
        if t.typeKind = Type.Kind.NULLABLE {
            assert t.subtypes.get_count() = 1
            indexType := type(t.subtypes[0])
        }
        else {
            indexType := llt
        }
        def cl := compiler.getClass(t)
        assert cl != null
        assert compiler.instanceFields(cl).get_count() = 1
        def numberType := type(compiler.instanceFields(cl)[0].type)
        def index:String
        match target {
            when IRNode.VARIABLE_REFERENCE(_, v):
                index := getName(v)
            otherwise:
                assert false
        } 
        methodHeader.printLine("\{index} = alloca \{indexType}")

        -- extract start value from range
        def start := nextVar()
        out.printLine("\{start} = extractvalue \{range}, 0, 0")

        -- store start value
        def indexValuePtr := nextVar()
        out.printLine("\{indexValuePtr} = getelementptr \{indexType}, \{indexType}* \{index}, " +
                "i64 0, i32 0")
        out.printLine("store \{numberType} \{start}, \{numberType}* \{indexValuePtr}")

        -- extract end value from range
        def end := nextVar()
        out.printLine("\{end} = extractvalue \{range}, 1, 0")

        -- extract step value from range
        def step := nextVar()
        out.printLine("\{step} = extractvalue \{range}, 2, 0")

        -- extract inclusive / exclusive from range
        def inclusive := nextVar()
        out.printLine("\{inclusive} = extractvalue \{range}, 3, 0")

        -- start block
        def loopStart := nextLabel()
        def loopBody := nextLabel()
        def loopEnd := nextLabel()
        def loopTest := nextLabel()
        def context := AutoContext(self, EnclosingContext.LOOP(label, loopEnd, loopTest))
        def forwardEntry := nextLabel()
        def backwardEntry := nextLabel()
        def signPrefix:String
        if stepType.name.startsWith("panda.core.Int") {
            signPrefix := "s"
        }
        else {
            assert stepType.name.startsWith("panda.core.UInt") |
                    stepType.name.startsWith("panda.core.Char")
            signPrefix := "u"
        }
        def direction:String
        if signPrefix = "s" {
            direction := nextVar()
            out.printLine("\{direction} = icmp sge \{numberType} \{step}, 0")
        }
        else {
            direction := "1"
        }
        out.printLine("br i1 \{direction}, label %\{forwardEntry}, label %\{backwardEntry}")
        createBlock(forwardEntry, out)
        def forwardEntryInclusive := nextLabel()
        def forwardEntryExclusive := nextLabel()
        out.printLine("br i1 \{inclusive}, label %\{forwardEntryInclusive}, " +
                "label %\{forwardEntryExclusive}")
        createBlock(forwardEntryInclusive, out)
        def forwardEntryInclusiveTest := nextVar()
        out.printLine("\{forwardEntryInclusiveTest} = icmp \{signPrefix}le \{numberType} " +
                "\{start}, \{end}")
        out.printLine("br i1 \{forwardEntryInclusiveTest}, label %\{loopStart}, label %\{loopEnd}")
        createBlock(forwardEntryExclusive, out)
        def forwardEntryExclusiveTest := nextVar()
        out.printLine("\{forwardEntryExclusiveTest} = icmp \{signPrefix}lt \{numberType} " +
                "\{start}, \{end}")
        out.printLine("br i1 \{forwardEntryExclusiveTest}, label %\{loopStart}, label %\{loopEnd}")
        createBlock(backwardEntry, out)
        def backwardEntryInclusive := nextLabel()
        def backwardEntryExclusive := nextLabel()
        out.printLine("br i1 \{inclusive}, label %\{backwardEntryInclusive}, " +
                "label %\{backwardEntryExclusive}")
        createBlock(backwardEntryInclusive, out)
        def backwardEntryInclusiveTest := nextVar()
        out.printLine("\{backwardEntryInclusiveTest} = icmp \{signPrefix}ge \{numberType} " +
                "\{start}, \{end}")
        out.printLine("br i1 \{backwardEntryInclusiveTest}, label %\{loopStart}, label %\{loopEnd}")
        createBlock(backwardEntryExclusive, out)
        def backwardEntryExclusiveTest := nextVar()
        out.printLine("\{backwardEntryExclusiveTest} = icmp \{signPrefix}gt \{numberType} " +
                "\{start}, \{end}")
        out.printLine("br i1 \{backwardEntryExclusiveTest}, label %\{loopStart}, label %\{loopEnd}")
        createBlock(loopStart, out)
        def indexValue := nextVar()
        out.printLine("\{indexValue} = load \{numberType}, \{numberType}* \{indexValuePtr}")
        writeBlock(statements, out)
        if !compiler.endsWithBranch(statements) {
            out.printLine("br label %\{loopTest}")
        }
        createBlock(loopTest, out)
        def loopInc := nextLabel()
        -- beginning of loop test, determine direction
        def forwardLabel := nextLabel()
        def backwardLabel := nextLabel()
        out.printLine("br i1 \{direction}, label %\{forwardLabel}, label %\{backwardLabel}")

        -- forward loop; perform the test by subtracting index from end and then comparing to step,
        -- to avoid overflows near the maximum value
        createBlock(forwardLabel, out)
        def forwardDelta := nextVar()
        out.printLine("\{forwardDelta} = sub \{numberType} \{end}, \{indexValue}")

        -- forward loop; determine inclusive / exclusive
        def forwardInclusiveLabel := nextLabel()
        def forwardExclusiveLabel := nextLabel()
        out.printLine("br i1 \{inclusive}, label %\{forwardInclusiveLabel}, label %" +
                forwardExclusiveLabel)

        -- forward inclusive test
        createBlock(forwardInclusiveLabel, out)
        def forwardInclusiveTest := nextVar()
        -- always use unsigned comparison to avoid overflow; we know both the delta and the step are
        -- the same sign
        out.printLine("\{forwardInclusiveTest} = icmp uge \{numberType} \{forwardDelta}, \{step}")
        out.printLine("br i1 \{forwardInclusiveTest}, label %\{loopInc}, label %\{loopEnd}")
        createBlock(forwardExclusiveLabel, out)

        -- forward exclusive test
        def forwardExclusiveTest := nextVar()
        out.printLine("\{forwardExclusiveTest} = icmp ugt \{numberType} \{forwardDelta}, \{step}")
        out.printLine("br i1 \{forwardExclusiveTest}, label %\{loopInc}, label %\{loopEnd}")

        -- backward loop; perform the test by subtracting end from index and then comparing to
        -- -step, to avoid overflows near the minimum value
        createBlock(backwardLabel, out)
        def backwardDelta := nextVar()
        out.printLine("\{backwardDelta} = sub \{numberType} \{indexValue}, \{end}")
        def negStep := nextVar()
        out.printLine("\{negStep} = sub \{numberType} 0, \{step}")

        -- backward loop; determine inclusive / exclusive
        def backwardInclusiveLabel := nextLabel()
        def backwardExclusiveLabel := nextLabel()
        out.printLine("br i1 \{inclusive}, label %\{backwardInclusiveLabel}, label %" +
                backwardExclusiveLabel)

        -- backward inclusive test
        createBlock(backwardInclusiveLabel, out)
        def backwardInclusiveTest := nextVar()
        out.printLine("\{backwardInclusiveTest} = icmp uge \{numberType} \{backwardDelta}, " +
                negStep)
        out.printLine("br i1 \{backwardInclusiveTest}, label %\{loopInc}, label %\{loopEnd}")
        createBlock(backwardExclusiveLabel, out)

        -- backward exclusive test
        def backwardExclusiveTest := nextVar()
        out.printLine("\{backwardExclusiveTest} = icmp ugt \{numberType} \{backwardDelta}, " +
                negStep)
        out.printLine("br i1 \{backwardExclusiveTest}, label %\{loopInc}, label %\{loopEnd}")

        createBlock(loopInc, out)
        def inc := nextVar()
        out.printLine("\{inc} = add \{numberType} \{indexValue}, \{step}")
        def incStruct := nextVar()
        out.printLine("\{incStruct} = insertvalue \{indexType} { \{numberType} undef")
        out.printLine(" }, \{numberType} \{inc}, 0")
        out.printLine("store \{indexType} \{incStruct}, \{indexType}* \{index}")
        out.printLine("br label %\{loopStart}")

        createBlock(loopEnd, out)
    }

    method writeRangeFor(label:String?, target:IRNode, list:IRNode,
            statements:ImmutableArray<IRNode>, out:OutputStream) {
        if list.type().subtypes[1].isReal() {
            if list.type().isRange() {
                writeSimpleRealRangeFor(label, target, list, statements, out)
            }
            else {
                writeSteppedRealRangeFor(label, target, list, statements, out)
            }
        }
        else if list.type().isRange() {
            writeSimpleRangeFor(label, target, list, statements, out)
        }
        else {
            writeSteppedRangeFor(label, target, list, statements, out)
        }
    }

    method writeWhile(label:String?, test:IRNode, statements:ImmutableArray<IRNode>,
            out:OutputStream) {
        def loopStart := nextLabel()
        def loopBody := nextLabel()
        def loopEnd := nextLabel()
        def context := AutoContext(self, EnclosingContext.LOOP(label, loopEnd, loopStart))
        out.printLine("br label %\{loopStart}")
        createBlock(loopStart, out)
        extraEffects.push(Array<ExtraEffect>())
        def testRef := getTypedReference(test, out)
        def testBit := nextVar()
        out.printLine("\{testBit} = extractvalue \{testRef}, 0")
        writeExtraEffects(out)
        out.printLine("br i1 \{testBit}, label %\{loopBody}, label %\{loopEnd}")
        createBlock(loopBody, out)
        writeBlock(statements, out)
        if !compiler.endsWithBranch(statements) {
            out.printLine("br label %\{loopStart}")
        }
        createBlock(loopEnd, out)
    }

    method writeDo(label:String?, statements:ImmutableArray<IRNode>, test:IRNode,
            out:OutputStream) {
        def loopStart := nextLabel()
        def loopBody := nextLabel()
        def loopEnd := nextLabel()
        def context := AutoContext(self, EnclosingContext.LOOP(label, loopEnd, loopStart))
        out.printLine("br label %\{loopBody}")
        createBlock(loopStart, out)
        extraEffects.push(Array<ExtraEffect>())
        def testRef := getTypedReference(test, out)
        def testBit := nextVar()
        out.printLine("\{testBit} = extractvalue \{testRef}, 0")
        writeExtraEffects(out)
        out.printLine("br i1 \{testBit}, label %\{loopBody}, label %\{loopEnd}")
        createBlock(loopBody, out)
        writeBlock(statements, out)
        if !compiler.endsWithBranch(statements) {
            out.printLine("br label %\{loopStart}")
        }
        createBlock(loopEnd, out)
    }

    method writeLoop(label:String?, statements:ImmutableArray<IRNode>, out:OutputStream) {
        def loopStart := nextLabel()
        def loopEnd := nextLabel()
        def context := AutoContext(self, EnclosingContext.LOOP(label, loopEnd, loopStart))
        out.printLine("br label %\{loopStart}")
        createBlock(loopStart, out)
        writeBlock(statements, out)
        if !compiler.endsWithBranch(statements) {
            out.printLine("br label %\{loopStart}")
        }
        createBlock(loopEnd, out)
    }

    method writeVarTarget(target:IRNode, value:IRNode?, out:OutputStream) {
        match target {
            when IRNode.VARIABLE_REFERENCE(_, v):
                def name := getName(v)
                def t := type(v.type)
                methodHeader.printLine("\{name} = alloca \{t}")
                if compiler.isRefCounted(v.type) {
                    methodHeader.printLine("store \{t} null, \{t}* \{name}")
                }
                if value != null {
                    def ref := getTypedReference(value, out)
                    out.printLine("store \{ref}, \{t}* \{name}")
                }
                else if compiler.isRefCounted(v.type) {
                    out.printLine("store \{t} null, \{t}* \{name}")
                }
                else if v.varKind = Variable.Kind.VAR &
                        compiler.isValue(compiler.getClass(v.type)) {
                    def cast := nextVar()
                    out.printLine("\{cast} = bitcast \{t}* \{name} to i8*")
                    def size := sizeOf(v.type)
                    out.printLine("call i8* @memset(i8* \{cast}, i8 0, \{SIZE_TYPE} \{size})")
                    nextVar()
                }
            otherwise:
                assert false
        }
    }

    method writeVar(kind:Variable.Kind, decls:ImmutableArray<IRNode>, out:OutputStream) {
        for decl in decls {
            match decl {
                when IRNode.DECLARATION(target, value):
                    writeVarTarget(target, value, out)
                otherwise:
                    assert false
            }
        }
    }

    method getChoiceFieldOffset(e:ChoiceEntry, index:Int):Int {
        var result := 0
        for i in 0 .. index {
            -- FIXME need to respect alignment!
            result += fieldSize(e.fields[i])
        }
        return result
    }

    method getFieldLValue(base:IRNode, field:FieldDecl, out:OutputStream):String {
        def baseRef:String
        if base = IRNode.SELF {
            baseRef := getSelfPointer()
        }
        else {
            baseRef := getReference(base, out)
        }
        def raw := nextVar()
        def cl := compiler.getClass(base.type())
        assert cl != null
        def fields := compiler.instanceFields(cl)
        var index := -1
        for i in 0 .. fields.get_count() {
            if fields[i].name = field.name {
                index := i
                break
            }
        }
        assert index != -1
        out.printLine("\{raw} = getelementptr inbounds \{typeName(cl.type())}, " +
                "\{typeName(cl.type())}* \{baseRef}, i64 0, i32 \{index}")
        if !field.type.isClass() | compiler.isValue(compiler.getClass(field.type)) {
            return raw
        }
        def result := nextVar()
        out.printLine("\{result} = bitcast i8** \{raw} to \{type(field.type)}*")
        return result
    }

    method getChoiceFieldLValue(base:IRNode, ce:ChoiceEntry, field:Int, out:OutputStream):String {
        def data := ce.owner.fields[1]
        assert data.name = ClassDecl.CHOICE_DATA_NAME
        def dataLValue := getFieldLValue(base, data, out)
        def offset := nextVar()
        def size := getChoiceDataSize(ce.owner)
        out.printLine("\{offset} = getelementptr [\{size} x i8], [\{size} x i8]* \{dataLValue}," +
                " i64 0, i64 \{getChoiceFieldOffset(ce, field)}")
        def cast := nextVar()
        out.printLine("\{cast} = bitcast i8* \{offset} to \{type(ce.fields[field])}*")
        return cast
    }

    method getLValue(lvalue:IRNode, out:OutputStream):String {
        match lvalue {
            when IRNode.CAST:
                return getLValue(compiler.unwrapCast(lvalue), out)
            when IRNode.VARIABLE_REFERENCE(_, v):
                return getName(v)
            when IRNode.FIELD_REFERENCE(_, _, base, field):
                return getFieldLValue(base, field, out)
            when IRNode.REUSED_VALUE_DEFINITION(base, id):
                def result := getLValue(base, out)
                def reused := nextVar()
                def t := type(base.type())
                out.printLine("\{reused} = load \{t}, \{t}* \{result}")
                reusedValues[id] := reused
                return result
            when IRNode.CHOICE_FIELD_REFERENCE(_, base, ce, field):
                return getChoiceFieldLValue(base, ce, field, out)
            otherwise:
                assert false, "unsupported lvalue: \{lvalue}"
        }
    }

    method writeAssignment(left:IRNode, right:IRNode, out:OutputStream) {
        def t := type(left.type())
        def lvalue := "\{t}* \{getLValue(left, out)}"
        out.printLine("store \{t} \{getReference(right, out)}, \{lvalue}")
    }

    -- invokes all currently-pending finally blocks and resumes the same code flow
    method writeFinallies(boundary:EnclosingContext?, out:OutputStream) {
        for c in enclosingContexts {
            match c {
                when EnclosingContext.FINALLY(label, returnMap):
                    def returnLabel := nextLabel()
                    out.printLine("br label %\{label}")
                    returnMap[currentBlock] := returnLabel
                    createBlock(returnLabel, out)
                when EnclosingContext.INLINE:
                    return
            }
            if boundary != null & boundary == c {
                break
            }
        }
    }

    method writeReturn(value:IRNode?, out:OutputStream) {
        def inline := getInlineContext()
        if value != null {
            labelCount += 1
            def valueType := type(value.type())
            if returnValueVar = null {
                labelCount += 1
                returnValueVar := "%$returnValue\{labelCount}"
                methodHeader.printLine("\{returnValueVar} = alloca \{valueType}")
            }
            extraEffects.push(Array<ExtraEffect>())
            def result := getReference(value, out)
            out.printLine("store \{valueType} \{result}, \{valueType}* \{returnValueVar}")
            if inline != null {
                writeExtraEffects(out)
                writeFinallies(null, out)
                inline.returns.add(Pair<String, String>(currentBlock, returnValueVar))
                out.printLine("br label %\{inline.exitLabel}")
            }
            else {
                writeExtraEffects(out)
                writeFinallies(null, out)
                def load := nextVar()
                out.printLine("\{load} = load \{valueType}, \{valueType}* \{returnValueVar}")
                out.printLine("ret \{valueType} \{load}")
            }
        }
        else {
            writeFinallies(null, out)
            if inline != null {
                out.printLine("br label %\{inline.exitLabel}")
            }
            else {
                out.printLine("ret void")
            }
        }
    }

    function findLoop(name:String?):EnclosingContext {
        for i in 0 .. enclosingContexts.get_count() {
            def context := enclosingContexts[i]
            match context {
                when EnclosingContext.LOOP(loopLabel, _, _):
                    if name = null | (loopLabel != null & loopLabel = name) {
                        return context
                    }
            }
        }
        assert false
    }

    method writeBreak(label:String?, out:OutputStream) {
        def desc := findLoop(label)
        writeFinallies(desc, out)
        match desc {
            when EnclosingContext.LOOP(_, breakLabel, _):
                out.printLine("br label %\{breakLabel}")
            otherwise:
                assert false
        }
    }

    method writeContinue(label:String?, out:OutputStream) {
        def desc := findLoop(label)
        writeFinallies(desc, out)
        match desc {
            when EnclosingContext.LOOP(_, _, continueLabel):
                out.printLine("br label %\{continueLabel}")
            otherwise:
                assert false
        }
    }

    method writeAssert(position:Position, test:IRNode, msg:IRNode?, out:OutputStream) {
        if compiler.settings.safetyLevel < 2 {
            return
        }
        extraEffects.push(Array<ExtraEffect>())
        def testRef := getReference(test, out)
        writeExtraEffects(out)
        def ifTrue := nextLabel()
        def ifFalse := nextLabel()
        out.printLine("br i1 \{testRef}, label %\{ifTrue}, label %\{ifFalse}")
        createBlock(ifFalse, out)
        extraEffects.push(Array<ExtraEffect>())
        def name:String
        def path := compiler.currentClass[0].source.path
        def index := path.lastIndexOf("/")
        if index = null {
            name := path
        }
        else {
            name := path[path.next(index)...]
        }
        def nameRef := getStringReference(name)
        def line := "%panda$core$Int64 { i64 \{position.line} }"
        def msgRef:String?
        if msg != null {
            msgRef := getReference(msg, out)
        }
        else {
            msgRef := null
        }
        out.print("call void ")
        for m in compiler.getClass(Type.Panda()).methods {
            if m.name = "assertionFailure" {
                compiler.resolve(m)
                if m.owner.external {
                    writeDeclaration(m)
                }
            }
        }
        if msgRef != null {
            out.print("@panda$core$Panda$assertionFailure$" +
                    "panda$core$String$panda$core$Int64$panda$core$String")
        }
        else {
            out.print("@panda$core$Panda$assertionFailure$panda$core$String$panda$core$Int64")
        }
        out.print("(%panda$core$String* \{nameRef}, \{line}")
        if msgRef != null {
            out.print(", %panda$core$String* \{msgRef}")
        }
        out.printLine(")")
        extraEffects.pop()
        out.printLine("unreachable")
        createBlock(ifTrue, out)
    }

    method writeMatch(value:IRNode, whens:ImmutableArray<IRNode>, other:ImmutableArray<IRNode>?,
            out:OutputStream) {
        def valueStruct := getTypedReference(value, out)
        def numberClass := compiler.getClass(value.type())
        def valueRef := nextVar()
        out.printLine("\{valueRef} = extractvalue \{valueStruct}, 0")
        def f := numberClass.symbolTable["value"]->FieldDecl
        compiler.resolve(f)
        def switchType := type(f.type)
        out.print("switch \{switchType} \{valueRef}, ")
        def endLabel := nextLabel()
        def whenLabels := Array<String>()
        def otherwiseLabel:String
        if other != null {
            otherwiseLabel := nextLabel()
        }
        else {
            otherwiseLabel := endLabel
        }
        out.printLine("label %\{otherwiseLabel} [")
        for w in whens {
            def label := nextLabel()
            whenLabels.add(label)
            match w {
                when IRNode.WHEN(_, tests, _):
                    for test in tests {
                        def number := compiler.getConstantInt(test)
                        out.printLine("        \{switchType} \{number}, label %\{label}")
                    }
                otherwise:
                    assert false
            }
        }
        out.printLine("    ]")
        for i in 0 .. whens.get_count() {
            def w := whens[i]
            match w {
                when IRNode.WHEN(_, _, statements):
                    createBlock(whenLabels[i], out)
                    writeBlock(statements, out)
                    if !compiler.endsWithBranch(statements) {
                        out.printLine("br label %\{endLabel}")
                    }
                otherwise:
                    assert false
            }
        }
        if other != null {
            createBlock(otherwiseLabel, out)
            writeBlock(other, out)
            if !compiler.endsWithBranch(other) {
                out.printLine("br label %\{endLabel}")
            }
        }
        createBlock(endLabel, out)
    }

    method writeDynamicCall(m:IRNode, args:ListView<IRNode>, out:OutputStream) {
        def argRefs := Array<String>(args.get_count())
        for a in args {
            argRefs.add(getTypedReference(a, out))
        }
        def targetType := "i8*"
        def methodObjectPtrRef := getTypedReference(m, out)
        def methodObjectRef := nextVar()
        def methodObjectType := "%panda$core$Method"
        out.printLine("\{methodObjectRef} = load \{methodObjectType}, \{methodObjectPtrRef}")
        def rawMethodRef := nextVar()
        out.printLine("\{rawMethodRef} = extractvalue \{methodObjectType} \{methodObjectRef}, " +
                "\{OBJECT_FIELD_COUNT + 0}")
        def target := nextVar()
        out.printLine("\{target} = extractvalue \{methodObjectType} \{methodObjectRef}, " +
                "\{OBJECT_FIELD_COUNT + 1}")
        def targetNonNull := nextVar()
        out.printLine("\{targetNonNull} = icmp ne \{targetType} \{target}, null")
        def haveTarget := nextLabel()
        def noTarget := nextLabel()
        def merge := nextLabel()
        out.printLine("br i1 \{targetNonNull}, label %\{haveTarget}, label %\{noTarget}")
        def resultType := m.type().subtypes[m.type().subtypes.get_count() - 1]

        createBlock(haveTarget, out)
        def haveTargetMethodRef := nextVar()
        out.printLine("\{haveTargetMethodRef} = bitcast %panda$core$Int8* \{rawMethodRef} to " +
                methodType(m.type(), Type.pointerTo(Type.BuiltinInt8())))
        out.print("call \{type(resultType)} \{haveTargetMethodRef}(\{targetType} \{target}")
        if argRefs.get_count() > 0 {
            out.print(", \{argRefs.join()}")
        }
        out.printLine(")")
        out.print("br label %\{merge}")

        createBlock(noTarget, out)
        def noTargetMethodRef := nextVar()
        out.printLine("\{noTargetMethodRef} = bitcast %panda$core$Int8* \{rawMethodRef} to " +
                methodType(m.type(), null))
        out.printLine("call \{type(resultType)} \{noTargetMethodRef}(\{argRefs.join()})")
        out.print("br label %\{merge}")

        createBlock(merge, out)
    }

    method writeExtraEffects(out:OutputStream) {
        def finalEffects := extraEffects.pop()
        for i in finalEffects.get_count() - 1 ... 0 by -1 {
            match finalEffects[i] {
                when ExtraEffect.STATEMENT(stmt):
                    writeStatement(stmt, out)
                when ExtraEffect.STRING(s):
                    out.printLine(s)
            }
        }
    }

    @post(extraEffects.get_count() = @pre(extraEffects.get_count()))
    method writeStatement(stmt:IRNode, out:OutputStream) {
        extraEffects.push(Array<ExtraEffect>())
        match stmt {
            when IRNode.BINARY(_, _, left, op, right):
                writeAssignment(left, right, out)
            when IRNode.BLOCK(_, statements):
                writeBlock(statements, out)
            when IRNode.BLOCK_WITH_FINALLY(_, statements, finally):
                writeBlockWithFinally(statements, finally, out)
            when IRNode.CALL(_, target, mref, args):
                writeCall(target, mref, args, null, out)
            when IRNode.DYNAMIC_CALL(m, args):
                writeDynamicCall(m, args, out)
            when IRNode.EXPRESSION_WITH_EXTRA_EFFECTS(base, stmt):
                getExpressionWithExtraEffectsReference(base, stmt, out)
            when IRNode.IF(_, test, ifTrue, ifFalse):
                writeIf(test, ifTrue, ifFalse, out)
            when IRNode.RANGE_FOR(_, label, target, list, statements):
                writeRangeFor(label, target, list, statements, out)
            when IRNode.WHILE(_, label, test, statements):
                writeWhile(label, test, statements, out)
            when IRNode.DO(_, label, statements, test):
                writeDo(label, statements, test, out)
            when IRNode.LOOP(_, label, statements):
                writeLoop(label, statements, out)
            when IRNode.VAR(_, kind, decls):
                writeVar(kind, decls, out)
            when IRNode.RETURN(_, value):
                writeReturn(value, out)
            when IRNode.BREAK(_, label):
                writeBreak(label, out)
            when IRNode.CONTINUE(_, label):
                writeContinue(label, out)
            when IRNode.ASSERT(position, test, msg):
                writeAssert(position, test, msg, out)
            when IRNode.MATCH(_, value, whens, other):
                writeMatch(value, whens, other, out)
            when IRNode.REUSED_VALUE_DEFINITION(base, id):
                reusedValues[id] := getReference(base, out)
            otherwise:
                assert false, "unsupported statement '\{stmt}' (\{stmt.$rawValue})"
        }
        writeExtraEffects(out)
    }

    method selfType(m:MethodDecl):String {
        def result := type(m.owner.type())
        if m.methodKind = MethodDecl.Kind.INIT & !result.endsWith("*") {
            return result + "*"
        }
        return result
    }

    @override
    method writeDeclaration(m:MethodDecl) {
        def name := getName(m)
        if declared.contains(name) {
            return
        }
        declared.add(name)
        declarations.print("declare \{callingConvention(m)}")
        def needsIndirection := needsStructIndirection(m)
        if needsIndirection {
            declarations.print("void")
        }
        else {
            declarations.print(type(m.returnType))
        }
        declarations.print(" \{getName(m)}(")
        var separator := ""
        if needsIndirection {
            declarations.print("\{type(m.returnType)}*")
            separator := ", "
        }
        if !m.annotations.isClass() {
            declarations.print("\{separator}\{selfType(m)} %self")
            separator := ", "
        }
        for p in m.parameters {
            declarations.print("\{separator}\{type(p.type)} %\{escapeName(p.name)}")
            separator := ", "
        }
        declarations.printLine(")")
    }

    @override
    method write(m:MethodDecl, body:ImmutableArray<IRNode>) {
        assert compiler.currentClass[0] == m.owner,
                "compiling \{m.owner.name}.\{m.signature()} from within " +
                compiler.currentClass[0].name
        currentMethod := m
        returnValueVar := null
        currentBlock := "0"
        varCount := 0
        methodHeader := MemoryOutputStream()
        methods.print("define ")
        if m.owner.isSpecialization() {
            methods.print("linkonce_odr ")
        }
        methods.print("\{callingConvention(m)}\{type(m.returnType)} \{getName(m)}(")
        var separator := ""
        if !m.annotations.isClass() {
            methods.print("\{selfType(m)} %self")
            separator := ", "
        }
        for p in m.parameters {
            methods.print("\{separator}\{type(p.type)} %\{escapeName(p.name)}")
            separator := ", "
        }
        methods.printLine(") {")
        def bodyBuffer := MemoryOutputStream()
        if m.methodKind = MethodDecl.Kind.INIT {
            for f in compiler.instanceFields(m.owner) {
                compiler.resolve(f)
                if f.name != "$class" & compiler.isRefCounted(f.type) {
                    writeAssignment(IRNode.FIELD_REFERENCE(m.position, f.type,
                            IRNode.SELF(m.position, m.owner.type()), f),
                            IRNode.NULL(m.position, f.type.nullable()), bodyBuffer)
                }
            }
        }
        for s in body {
            writeStatement(s, bodyBuffer)
        }
        methods.print(methodHeader.finish())
        methods.print(bodyBuffer.finish())
        if !compiler.endsWithBranch(body) {
            if m.returnType = Type.Void() {
                methods.printLine("ret void")
            }
            else {
                methods.printLine("unreachable")
            }
        }
        methods.printLine("}")
        currentMethod := null
    }

    @override
    method start(cl:ClassDecl) {
        if cl.annotations.isSpecialize() {
            return
        }
        writeType(cl.type())
        getClassConstant(cl)
    }

    @override
    method end(cl:ClassDecl) {
    }
}