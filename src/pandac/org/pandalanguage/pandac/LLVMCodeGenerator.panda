package org.pandalanguage.pandac

uses org.pandalanguage.pandac.parser.Token

@final
class LLVMCodeGenerator : CodeGenerator {
    class ClassConstant : Immutable {
        def name:String
        def type:String

        init(name:String, type:String) {
            self.name := name
            self.type := type
        }
    }

    class MethodShim {
        def name:String
        def type:String

        init(name:String, type:String) {
            self.name := name
            self.type := type
        }
    }

    class LoopDescriptor : Immutable {
        def loopLabel:String?
        def breakLabel:String
        def continueLabel:String

        init(loopLabel:String?, breakLabel:String, continueLabel:String) {
            self.loopLabel := loopLabel
            self.breakLabel := breakLabel
            self.continueLabel := continueLabel
        }

        @override
        function convert():String {
            if loopLabel != null {
                return "LoopDescriptor<\{loopLabel}>"
            }
            else {
                return "LoopDescriptor<>"
            }
        }
    }

    ================================================================================================
    Overrides features such as method arguments and return handling for use in compiling inline
    methods.
    ================================================================================================
    class InlineContext {
        ============================================================================================
        Local variable name suffix.
        ============================================================================================
        def varSuffix:String

        ============================================================================================
        Reference to use instead of the normal "%self".
        ============================================================================================
        def selfRef:String

        ============================================================================================
        Reference to use instead of the normal method parameter names.
        ============================================================================================
        def argRefs:ImmutableArray<String>

        ============================================================================================
        Contains pairs of (source block, return value), which can be turned into the actual return
        value using a phi node. Initially empty, filled in as the inline call is written.
        ============================================================================================
        def returns := Array<Pair<String, String>>()

        ============================================================================================
        Label to jump to after returning.
        ============================================================================================
        def exitLabel:String

        init(varSuffix:String, selfRef:String, argRefs:ListView<String>, exitLabel:String) {
            self.varSuffix := varSuffix
            self.selfRef := selfRef
            self.argRefs := ImmutableArray<String>(argRefs)
            self.exitLabel := exitLabel
        }
    }

    constant POINTER_SIZE        := 8
    constant OBJECT_FIELD_COUNT  := 2
    constant CLASS_POINTER_INDEX := 0
    constant ITABLE_INDEX        := 3
    constant VTABLE_INDEX        := 4

    constant INT_TYPE  := "i64"
    constant SIZE_TYPE := "i64"

    def out:OutputStream

    def compiler:Compiler

    def declarations := MemoryOutputStream()

    def types := MemoryOutputStream()

    def methods := MemoryOutputStream()

    def methodHeader := MemoryOutputStream()

    def wrapperShims := MemoryOutputStream()

    def shims := MemoryOutputStream()

    def strings := MemoryOutputStream()

    def declared := Set<String>()

    def writtenTypes := Set<String>()

    def writtenWrappers := Set<String>()

    def classConstants := HashMap<String, ClassConstant>()

    def variableNames := IdentityMap<Variable, String>()

    var currentBlock:String

    var currentMethod:MethodDecl?

    def loopDescriptors := Stack<LoopDescriptor>()

    var varCount := 0

    var labelCount := 0

    def reusedValues := HashMap<UInt64, String>()

    def methodShims := IdentityMap<MethodDecl, MethodShim>()

    def inlineContext := Stack<InlineContext>()

    def currentlyInlining := IdentityMap<MethodDecl, MethodDecl>() -- FIXME need IdentitySet

    init(out:OutputStream) {
        self.out := out

        out.printLine("target datalayout = \"e-p:64:64:64-i1:8:8-i8:8:8-i16:16:16-i32:32:32-i64:" +
                "64:64-f32:32:32-f64:64:64-v64:64:64-v128:128:128-a0:0:64-s0:64:64-f80:128:128-" +
                "n8:16:32:64-S128\"")
        out.printLine("target triple = \"x86_64-apple-macosx10.8.0\"")
--        out.printLine("target triple = \"x86_64-pc-linux-gnu\"")
        out.printLine("declare i8* @malloc(i64)")
        out.printLine("declare i8* @realloc(i8*, i64)")
        out.printLine("declare void @free(i8*)")
        out.printLine("%$itable = type { %panda$core$Class*, %$itable*, [0 x i8*] }")
    }

    @override
    method setCompiler(compiler:Compiler) {
        self.compiler := compiler
    }

    @override
    method finish() {
        type(Type.Class())
        out.print(types.finish())
        out.print(strings.finish())
        out.print(declarations.finish())
        out.print(wrapperShims.finish())
        out.print(shims.finish())
        out.print(methods.finish())
        out.cleanup() -- FIXME this should be automatic when memory management is in
    }

    method nextVar():String {
        varCount += 1
        return "%\{varCount}"
    }

    method nextLabel():String {
        labelCount += 1
        return "$l\{labelCount}"
    }

    method createBlock(label:String, out:OutputStream) {
        out.printLine("\n\{label}:")
        currentBlock := label
    }

    function endsWithBranch(stmt:IRNode):Bit {
        match stmt.kind {
            when IRNode.Kind.BLOCK:
                if stmt.children.get_count() = 0 {
                    return false
                }
                return endsWithBranch(stmt.children[stmt.children.get_count() - 1])
            when IRNode.Kind.BREAK, IRNode.Kind.CONTINUE, IRNode.Kind.RETURN:
                return true
            otherwise: return false
        }
    }

    function fieldSize(t:Type):Int {
        assert t.resolved
        if t.isBuiltinNumber() {
            if t.name.endsWith("8") {
                return 1
            }
            if t.name.endsWith("16") {
                return 2
            }
            if t.name.endsWith("32") {
                return 4
            }
            assert t.name.endsWith("64")
            return 8
        }
        if t = Type.BuiltinBit() {
            return 1
        }
        def cl := compiler.getClass(t)
        assert cl != null
        if !compiler.isValue(cl) | cl.name = "panda.unsafe.Pointer" {
            return POINTER_SIZE
        }
        var result := 0
        for f in compiler.instanceFields(cl) {
            if f.annotations.isClass() {
                continue
            }
            compiler.resolve(f)
            def size := fieldSize(f.type)
            def align := result % size
            if align != 0 {
                result += size - align
            }
            assert result % size = 0
            result += size
        }
        if t.typeKind = Type.Kind.NULLABLE {
            result += 1
        }
        return result
    }

    function alignment(t:Type):Int {
        return fieldSize(t).min(8)
    }

    function sizeOf(t:Type):Int {
        if !t.isClass() {
            return fieldSize(t)
        }
        def cl := compiler.getClass(t)
        assert cl != null
        if cl.name = "panda.unsafe.Pointer" {
            return POINTER_SIZE
        }
        var result := 0
        for f in compiler.instanceFields(cl) {
            compiler.resolve(f)
            def size := fieldSize(f.type)
            def align := result % size
            if align != 0 {
                result += size - align
            }
            assert result % size = 0
            result += size
        }
        if compiler.isValue(cl) & t.typeKind = Type.Kind.NULLABLE {
            result += 1
        }
        return result
    }

    function sizeOfWrapper(t:Type):Int {
        def cl := compiler.getClass(t)
        assert cl != null & compiler.isValue(cl)
        var result := sizeOf(Type.Object())
        for f in compiler.instanceFields(cl) {
            compiler.resolve(f)
            def size := fieldSize(f.type)
            def align := result % size
            if align != 0 {
                result += size - align
            }
            assert result % size = 0
            result += size
        }
        if t.typeKind = Type.Kind.NULLABLE {
            result += 1
        }
        return result
    }

    method writeType(t:Type) {
        if writtenTypes.contains(t.name) {
            return
        }
        writtenTypes.add(t.name)
        def cl := compiler.getClass(t)
        assert !cl.annotations.isSpecialize()
        def code := MutableString("%\{escapeName(t.name)} = type { ")
        compiler.currentClass.push(cl)
        assert cl != null
        var separator := ""
        for f in compiler.instanceFields(cl) {
            compiler.resolve(f)
            if !f.type.resolved {
                return
            }
            if f.type.isClass() {
                def fCl := compiler.getClass(f.type)
                if !compiler.isValue(fCl) {
                    -- If we write the correct type definition here, we end up loading and parsing a
                    -- ton of otherwise-unused classes, for no other reason than to figure out their
                    -- type definitions (which we likely never use for anything else). Handling all
                    -- pointers as opaque i8* pointers massively reduces the number of files we need
                    -- to parse.
                    code.append("\{separator}i8*")
                    separator := ", "
                    continue
                }
            }
            code.append("\{separator}\{type(f.type)}")
            separator := ", "
        }
        if t = Type.Class() {
            code.append(", %panda$core$Class*, %$itable*, [0 x i8*]")
        }
        code.append(" }")
        types.printLine(code.finish())
        if compiler.isValue(cl) {
            getWrapperClassConstant(cl)
        }
        compiler.currentClass.pop()
    }

    method writeWrapperType(t:Type) {
        if writtenWrappers.contains(t.name) {
            return
        }
        writtenWrappers.add(t.name)
        def code := MutableString("\{type(t)}$wrapper = type { ")
        def object := compiler.getClass(Type.Object())
        assert object != null
        var separator := ""
        for f in compiler.instanceFields(object) {
            compiler.resolve(f)
            code.append("\{separator}\{type(f.type)}")
            separator := ", "
        }
        code.append(", \{type(t)}")
        code.append(" }")
        types.printLine(code.finish())
        types.printLine("\{type(t)}$nullable = type { \{type(t)}, i1 }")
    }

    function typeName(t:Type):String {
        return "%" + escapeName(t.name)
    }

    method type(t:Type):String {
        match t.typeKind {
            when Type.Kind.VOID:
                return "void"
            when Type.Kind.BUILTIN_INT, Type.Kind.BUILTIN_UINT:
                return "i\{sizeOf(t) * 8}"
            when Type.Kind.BUILTIN_BIT:
                return "i1"
            when Type.Kind.BUILTIN_FLOAT:
                match sizeOf(t) {
                    when 4: return "float"
                    when 8: return "double"
                    otherwise: assert false
                }
            when Type.Kind.CLASS:
                writeType(t)
                def name := "%\{escapeName(t.name)}"
                def cl := compiler.getClass(t)
                assert cl != null
                if !compiler.isValue(cl) {
                    return name + "*"
                }
                return name
            when Type.Kind.NULLABLE:
                def cl := compiler.getClass(t)
                assert cl != null
                if compiler.isValue(cl) {
                    return nullableType(t)
                }
                return type(t.subtypes[0])
            when Type.Kind.GENERIC:
                if t.subtypes[0].name = "panda.unsafe.Pointer" {
                    return type(t.subtypes[1]) + "*"
                }
                def cl := compiler.getClass(t)
                if cl.isSpecialization() {
                    def name := "%\{escapeName(t.name)}"
                    def cl := compiler.getClass(t)
                    assert cl != null
                    if !compiler.isValue(cl) {
                        return name + "*"
                    }
                    return name
                }
                return type(t.subtypes[0])
            when Type.Kind.GENERIC_PARAMETER:
                return type(t.parameter.bound)
            when Type.Kind.FUNCTION, Type.Kind.METHOD:
                def result := MutableString(type(t.subtypes[t.subtypes.get_count() - 1]))
                result.append(" (")
                for i in 0 .. t.subtypes.get_count() - 1 {
                    if i > 0 {
                        result.append(", ")
                    }
                    result.append(type(t.subtypes[i]))
                }
                result.append(")*")
                return result.finish()
            otherwise:
                assert false, "unsupported type '\{t}'"
        }
    }

    method wrapperTypeName(t:Type):String {
        if t.typeKind = Type.Kind.NULLABLE {
            return wrapperTypeName(t.subtypes[0])
        }
        writeWrapperType(t)
        return "%\{escapeName(t.name)}$wrapper"
    }

    method wrapperType(t:Type):String {
        return wrapperTypeName(t) + "*"
    }

    method wrapperType(m:MethodDecl):String {
        def inheritedType := compiler.inheritedType(m)
        def result := MutableString()
        result.append(type(inheritedType.subtypes[inheritedType.subtypes.get_count() - 1]))
        result.append("(")
        assert m.isInstance()
        result.append("%\{escapeName(m.owner.name)}")
        if compiler.isValue(m.owner) {
            result.append("$wrapper")
        }
        result.append("*")
        for i in 0 .. inheritedType.subtypes.get_count() - 1 { 
            result.append(", ")
            result.append(type(inheritedType.subtypes[i]))
        }
        result.append(")*")
        return result.finish()
    }

    method nullableType(t:Type):String {
        assert t.typeKind = Type.Kind.NULLABLE, "\{t} is not nullable"
        writeWrapperType(t.subtypes[0])
        return "\{type(t.subtypes[0])}$nullable"
    }

    method getITable(cl:ClassDecl):String {
        def interfaces := compiler.allInterfaces(cl.type())
        var previous := "%$itable* null"
        for intfType in interfaces {
            def intf := compiler.getClass(intfType)
            def intfCC := getClassConstant(intf)
            def methods := compiler.interfaceMethods(cl, intfType)
            def name := "@\{escapeName(cl.name)}$.\{escapeName(intf.name)}"
            def t := "{\{type(Type.Class())}, %$itable*, [\{methods.get_count()} x i8*] }"
            def intfCCCast:String
            if intfCC.type != type(Type.Class()) {
                intfCCCast := "bitcast(\{intfCC.type}* \{intfCC.name} to \{type(Type.Class())})"
            }
            else {
                intfCCCast := intfCC.name
            }
            def result := MutableString("\{name} = ")
            if cl.isSpecialization() {
                result.append("linkonce_odr ")
            }
            result.append("constant \{t} { \{type(Type.Class())} \{intfCCCast}, \{previous}, " +
                    "[\{methods.get_count()} x i8*][")
            var separator := ""
            for m in methods {
                result.append(separator)
                separator := ", "
                if m.annotations.isAbstract() {
                    result.append("i8* null")
                }
                else {
                    def entry := getMethodTableEntry(m)
                    result.append("i8* bitcast(\{entry.second} \{entry.first} to i8*)")
                }
            }
            result.append("] }\n")
            types.printLine(result.finish())
            previous := "%$itable* bitcast(\{t}* \{name} to %$itable*)"
        }
        return previous
    }

    method createMethodShim(raw:MethodDecl, effective:Type, rawOut:OutputStream):MethodShim {
        def out := MemoryOutputStream()
        def found := methodShims[raw]
        if found != null {
            return found
        }
        assert effective.isMethod()
        assert effective.subtypes.get_count() = raw.parameters.get_count() + 1
        assert raw.isInstance()
        def oldVarCount := varCount
        varCount := 0
        def effectiveReturnType := effective.subtypes[effective.subtypes.get_count() - 1]
        def resultName := getName(raw) + "$shim"
        def resultType := MutableString(type(effectiveReturnType))
        out.print("define ")
        if raw.owner.isSpecialization() {
            out.print("linkonce_odr ")
        }
        out.print("\{resultType} \{resultName}(")
        def self_t := selfType(raw)
        out.print("\{self_t} %self")
        resultType.append("(")
        resultType.append(self_t)
        for i in 0 .. raw.parameters.get_count() {
            def pType := type(effective.subtypes[i])
            resultType.append(", ")
            resultType.append(pType)
            out.print(", \{pType} %p\{i}")
        }
        out.printLine(") {")
        resultType.append(")*")
        def casts := Array<String>()
        for i in 0 .. raw.parameters.get_count() {
            def p := "%p\{i}"
            if raw.parameters[i].type != effective.subtypes[i] {
                casts.add(getCastReference(p, effective.subtypes[i],
                        raw.parameters[i].type, out))
            }
            else {
                casts.add(p)
            }
        }
        def returnValue:String
        if raw.returnType != Type.Void() {
            returnValue := nextVar()
            out.print("\{returnValue} = ")
        }
        else {
            returnValue := "void"
        }
        out.print("call \{callingConvention(raw)}\{type(raw.returnType)} \{getName(raw)}(" +
                "\{self_t} %self")
        for i in 0 .. raw.parameters.get_count() {
            out.print(", \{type(raw.parameters[i].type)} \{casts[i]}")
        }
        out.printLine(")")
        if raw.returnType != Type.Void() {
            returnValue := type(effectiveReturnType) + " " +
                    getCastReference(returnValue, raw.returnType, effectiveReturnType, out)
        }
        out.printLine("ret \{returnValue}")
        out.printLine("}")
        varCount := oldVarCount
        def result := MethodShim(resultName, resultType.finish())
        methodShims[raw] := result
        rawOut.print(out.finish())
        return result
    }

    method createWrapperShim(m:MethodDecl, out:OutputStream):String {
        def oldMethod := currentMethod
        currentMethod := m
        assert m.isInstance()
        def oldVarCount := varCount
        varCount := 0
        def result := "\{getName(m)}$wrappershim"
        def selfType := "%\{escapeName(m.owner.name)}$wrapper*"
        out.print("define ")
        if m.owner.isSpecialization() {
            out.print("linkonce_odr ")
        }
        out.print("\{type(m.returnType)} \{result}(\{selfType} %actualSelf")
        def actualMethodType := compiler.declaredType(m)
        def inheritedMethodType := compiler.inheritedType(m)
        for i in 0 .. m.parameters.get_count() {
            out.print(", \{type(inheritedMethodType.subtypes[i])} %\{m.parameters[i].name}")
        }
        out.printLine(") {")
        out.printLine("%self = bitcast \{selfType} %actualSelf to %panda$core$Object*")
        def parameters := Array<String>()
        for i in 0 .. m.parameters.get_count() {
            parameters.add(getCastReference("%" + m.parameters[i].name,
                    inheritedMethodType.subtypes[i], actualMethodType.subtypes[i], out))
        }
        def children := Array<IRNode>()
        children.add(IRNode(IRNode.Kind.SELF, Position(), Type.Object()))
        def unwrapped := getTypedReference(IRNode(IRNode.Kind.CAST, Position(), m.owner.type(),
                children), out)
        def returnValue:String
        if m.returnType != Type.Void() {
            returnValue := nextVar()
            out.print("\{returnValue} = ")
            returnValue := "\{type(m.returnType)} \{returnValue}"
        }
        else {
            returnValue := "void"
        }
        out.print("call \{callingConvention(m)}\{type(m.returnType)} \{getName(m)}(\{unwrapped}")
        for i in 0 .. m.parameters.get_count() {
            out.print(", \{type(actualMethodType.subtypes[i])} \{parameters[i]}")
        }
        out.printLine(")")
        out.printLine("ret \{returnValue}")
        out.printLine("}")
        varCount := oldVarCount
        currentMethod := oldMethod
        return result
    }

    method getWrapperITable(cl:ClassDecl):String {
        def interfaces := compiler.allInterfaces(cl.type())
        var previous := "%$itable* null"
        for intfType in interfaces {
            def intf := compiler.getClass(intfType)
            def intfCC := getClassConstant(intf)
            def methods := compiler.interfaceMethods(cl, intfType)
            def name := "@\{escapeName(cl.name)}$wrapper.\{escapeName(intf.name)}"
            def t := "{\{type(Type.Class())}, %$itable*, [\{methods.get_count()} x i8*] }"
            def intfCCCast:String
            if intfCC.type != type(Type.Class()) {
                intfCCCast := "bitcast(\{intfCC.type}* \{intfCC.name} to \{type(Type.Class())})"
            }
            else {
                intfCCCast := intfCC.name
            }
            def result := MutableString("\{name} = ")
            if cl.isSpecialization() {
                result.append("linkonce_odr ")
            }
            result.append("constant \{t} { \{type(Type.Class())} \{intfCCCast}, \{previous}, " +
                    "[\{methods.get_count()} x i8*][")
            var separator := ""
            for m in methods {
                result.append(separator)
                separator := ", "
                if m.annotations.isAbstract() {
                    result.append("i8* null")
                }
                else {
                    def shim := createWrapperShim(m, wrapperShims)
                    result.append("i8* bitcast(\{wrapperType(m)} \{shim} to i8*)")
                }
            }
            result.append("] }\n")
            types.printLine(result.finish())
            previous := "%$itable* bitcast(\{t}* \{name} to %$itable*)"
        }
        return previous
    }

    -- FIXME use tuple
    class Pair<A, B> {
        def first:A
        def second:B

        init(first:A, second:B) {
            self.first := first
            self.second := second
        }
    }

    ================================================================================================
    Returns true if this is an external method returning a struct.

    Returning structs from C functions into LLVM code is tricky. I tried it the naive and obvious
    way, and found it didn't work. Some cursory research indicated that C functions that return
    structs are at least sometimes compiled to accept a special pointer ("sret") as an extra
    parameter, and the caller is expected to know to alloca space for the return value and pass in a
    pointer to it.

    Since online sources were complaining about how poorly documented this is, there were
    indications that there may be multiple struct return strategies depending on the nature of
    the struct, people were suggesting looking at the assembly code generated by Clang to figure
    out how one was supposed to call a given function, and this all varies from platform to
    platform, we avoid the whole mess by making it explicit. External functions which wish to
    return structs explicitly receive a pointer to the result structure as their first parameter.
    ================================================================================================
    function needsStructIndirection(m:MethodDecl):Bit {
        if !m.returnType.isClass() {
            return false
        }
        def result := m.annotations.isExternal() & m.returnType.isClass() &
                compiler.isValue(compiler.getClass(m.returnType))
        -- if an external method requires struct indirection, it will have a different signature
        -- than a non-external method; this means this feature doesn't play nice with overriding. We
        -- can fix this down the road with shims, but for right now just assert that a method
        -- requiring struct indirection is not an override and cannot be overridden
        assert !result | (!m.annotations.isOverride() & (m.annotations.isFinal() |
                m.annotations.isClass())), "invalid struct indirection on \{m.signature()}"
        return result
    }

    method getMethodTableEntry(m:MethodDecl):Pair<String, String> -* name, type *- {
        compiler.resolve(m)
        if m.owner.external {
            writeDeclaration(m)
        }
        def resultName:String
        def declared := compiler.declaredTypeWithSelf(m, m.owner.type())
        def inherited := compiler.inheritedTypeWithSelf(m)
        if declared != inherited {
            def shim := createMethodShim(m, compiler.inheritedType(m), shims)
            resultName := shim.name
        }
        else {
            resultName := getName(m)
        }
        if needsStructIndirection(m) {
            def resultType := MutableString("void (")
            resultType.append(type(inherited.subtypes[inherited.subtypes.get_count() - 1]))
            resultType.append("*")
            for i in 0 .. inherited.subtypes.get_count() - 1 {
                resultType.append(", ")
                resultType.append(type(inherited.subtypes[i]))
            }
            resultType.append(")*")
            return Pair<String, String>(resultName, resultType.finish())
        }
        return Pair<String, String>(resultName, type(inherited))
    }

    method getClassConstant(cl:ClassDecl):ClassConstant {
        assert !cl.annotations.isSpecialize()
        var result := classConstants[cl.name]
        if result = null {
            compiler.resolve(cl)
            def type:String
            if cl.external {
                result := ClassConstant("@\{escapeName(cl.type().name)}$class",
                        "%panda$core$Class")
                classConstants[cl.name] := result
                types.printLine("\{result.name} = external global \{result.type}")
                return classConstants[cl.name]
            }
            def vtable := compiler.getVTable(cl)
            result := ClassConstant("@\{escapeName(cl.type().name)}$class",
                    "{ %panda$core$Class*, \{INT_TYPE}, %panda$core$Class*, %$itable*, " +
                    "[\{vtable.get_count()} x i8*] }")
            classConstants[cl.name] := result
            def superPtr:String
            if cl.rawSuper != null {
                def superCC := getClassConstant(compiler.getClass(cl.rawSuper))
                superPtr := "bitcast(\{superCC.type}* \{superCC.name} to %panda$core$Class*)"
            }
            else {
                superPtr := "null"
            }
            def clConstant := getClassConstant(compiler.getClass(Type.Class()))
            def code := MutableString("\{result.name} = ")
            if cl.isSpecialization() {
                code.append("linkonce_odr ")
            }
            code.append("constant \{result.type} { " +
                    "%panda$core$Class* bitcast(\{clConstant.type}* \{clConstant.name} to " +
                    "%panda$core$Class*), \{INT_TYPE} 1, %panda$core$Class* \{superPtr}, " +
                    "\{getITable(cl)}, [\{vtable.get_count()} x i8*] [")
            var separator := ""
            for m in vtable {
                code.append(separator)
                if m.annotations.isAbstract() {
                    code.append("i8* null")
                }
                else {
                    def entry := getMethodTableEntry(m)
                    code.append("i8* bitcast(\{entry.second} \{entry.first} to i8*)")
                }
                separator := ", "
            }
            code.append("] }\n")
            types.printLine(code.finish())
        }
        return result
    }

    method getWrapperClassConstant(cl:ClassDecl):ClassConstant {
        compiler.resolve(cl)
        def name := "@\{escapeName(cl.name)}$wrapperclass"
        var result := classConstants[name]
        if result = null {
            if cl.external {
                type(Type.Class())
                def type := "%panda$core$Class"
                types.printLine("\{name} = external global \{type}")
                result := ClassConstant(name, type)
            }
            else {
                def value := compiler.getClass(Type.Value())
                def valueVTable := compiler.getVTable(value)
                result := ClassConstant("@\{escapeName(cl.name)}$wrapperclass",
                        "{ %panda$core$Class*, \{INT_TYPE}, %panda$core$Class*, %$itable*, " +
                        "[\{valueVTable.get_count()} x i8*] }")
                def vtable := compiler.getVTable(cl)
                def superCC := getClassConstant(compiler.getClass(cl.rawSuper))
                def superCast:String
                if superCC.type != type(Type.Class()) {
                    superCast := "bitcast(\{superCC.type}* \{superCC.name} to %panda$core$Class*)"
                }
                else {
                    superCast := superCC.name
                }
                def itable := getWrapperITable(cl)
                def clConstant := getClassConstant(compiler.getClass(Type.Class()))
                def code := MutableString("\{result.name} = ")
                if cl.isSpecialization() {
                    code.append("linkonce_odr ")
                }
                code.append("constant \{result.type} { " +
                        "%panda$core$Class* bitcast(\{clConstant.type}* \{clConstant.name} to " +
                        "%panda$core$Class*), \{INT_TYPE} 1, \{type(Type.Class())} \{superCast}, " +
                        "\{itable}, [\{valueVTable.get_count()} x i8*] [")
                var separator := ""
                for i in 0 .. valueVTable.get_count() {
                    def m := vtable[i]
                    def methodName:String
                    if m.owner == cl {
                        methodName := createWrapperShim(m, wrapperShims)
                    }
                    else {
                        methodName := getName(m)
                        if m.owner.external {
                            writeDeclaration(m)
                        }
                    }
                    code.append("\{separator}i8* bitcast(\{wrapperType(m)} \{methodName} to i8*)")
                    separator := ", "
                }
                code.append("] }")
                types.print(code.finish())
            }
            classConstants[name] := result
        }
        return result
    }

    function escapeName(s:String):String {
        def result := MutableString(s.byteLength() * 2)
        var current := s.start()
        def end := s.end()
        while current != end {
            def c := s[current]
            match c {
                when ".": result.append("$")
                when "?": result.append("$Q")
                when "<": result.append("$LT")
                when ">": result.append("$GT")
                when " ": { }
                when ",": result.append("$C")
                otherwise: result.append(c)
            }
            current := s.next(current)
        }
        return result.finish()
    }

    function getName(v:Variable):String {
        if v.storage = Variable.Storage.PARAMETER {
            if inlineContext.get_count() > 0 {
                for i in 0 .. currentMethod.parameters.get_count() {
                    if v.name == currentMethod.parameters[i].name {
                        return inlineContext.peek().argRefs[i]
                    }
                }
                assert false
            }
            return "%\{v.name}"
        }
        var result := variableNames[v]
        if result = null {
            labelCount += 1
            result := "%\{v.name}\{labelCount}"
            variableNames[v] := result
        }
        if inlineContext.get_count() > 0 {
            result += inlineContext.peek().varSuffix
        }
        return result
    }

    function getName(m:MethodDecl):String {
        if m.name = "main" {
            return "@pandaMain"
        }
        def result := MutableString("@")
        result.append(escapeName(m.owner.name))
        result.append("$")
        match m.name {
            when "+":    result.append("$ADD")
            when "-":    result.append("$SUB")
            when "*":    result.append("$MUL")
            when "/":    result.append("$DIV")
            when "//":   result.append("$INTDIV")
            when "%":    result.append("$REM")
            when "^":    result.append("$POW")
            when "[]":   result.append("$IDX")
            when "[]:=": result.append("$IDXEQ")
            when "=":    result.append("$EQ")
            when "!=":   result.append("$NEQ")
            when ">":    result.append("$GT")
            when "<":    result.append("$LT")
            when ">=":   result.append("$GE")
            when "<=":   result.append("$LE")
            when "|":    result.append("$OR")
            when "||":   result.append("$BOR")
            when "&":    result.append("$AND")
            when "&&":   result.append("$BAND")
            when "~":    result.append("$XOR")
            when "~~":   result.append("$BXOR")
            when "!":    result.append("$NOT")
            when "!!":   result.append("$BNOT")
            when "<<":   result.append("$SHL")
            when ">>":   result.append("$SHR")
            otherwise:   result.append(escapeName(m.name))
        }
        for p in m.parameters {
            result.append("$\{escapeName(p.type.name)}")
        }
        if m.returnType != Type.Void() {
            result.append("$R$")
            result.append(escapeName(m.returnType.name))
        }
        return result.finish()
    }

    function getName(f:FieldDecl):String {
        assert f.annotations.isClass()
        return "@\{escapeName(f.owner.name)}$\{f.name}"
    }

    class OpClass {
        constant SIGNED   := 10121
        constant UNSIGNED := 10122
        constant FLOAT    := 10123
    }

    function opClass(t:Type):Int {
        match t.typeKind {
            when Type.Kind.BUILTIN_INT:
                return OpClass.SIGNED
            when Type.Kind.BUILTIN_UINT, Type.Kind.BUILTIN_BIT:
                return OpClass.UNSIGNED
            when Type.Kind.BUILTIN_FLOAT:
                return OpClass.FLOAT
            otherwise:
                assert false
        }
    }

    method getAndReference(left:IRNode, right:IRNode, out:OutputStream):String {
        var leftRef := getReference(left, out)
        if left.type = Type.Bit() {
            def leftField := nextVar()
            out.printLine("\{leftField} = extractvalue %panda$core$Bit \{leftRef}, 0")
            leftRef := leftField
        }
        def start := currentBlock
        def ifTrue := nextLabel()
        def ifFalse := nextLabel()
        out.printLine("br i1 \{leftRef}, label %\{ifTrue}, label %\{ifFalse}")
        createBlock(ifTrue, out)
        def rightRef := getReference(right, out)
        if right.type = Type.Bit() {
            def rightField := nextVar()
            out.printLine("\{rightField} = extractvalue %panda$core$Bit \{rightRef}, 0")
            rightRef := rightField
        }
        def truePred := currentBlock
        out.printLine("br label %\{ifFalse}")
        createBlock(ifFalse, out)
        def result := nextVar()
        out.printLine("\{result} = phi i1 [0, %\{start}], [\{rightRef}, %\{truePred}]")
        return result
    }

    method getOrReference(left:IRNode, right:IRNode, out:OutputStream):String {
        var leftRef := getReference(left, out)
        if left.type = Type.Bit() {
            def leftField := nextVar()
            out.printLine("\{leftField} = extractvalue %panda$core$Bit \{leftRef}, 0")
            leftRef := leftField
        }
        def start := currentBlock
        def ifTrue := nextLabel()
        def ifFalse := nextLabel()
        out.printLine("br i1 \{leftRef}, label %\{ifTrue}, label %\{ifFalse}")
        createBlock(ifFalse, out)
        def rightRef := getReference(right, out)
        if right.type = Type.Bit() {
            def rightField := nextVar()
            out.printLine("\{rightField} = extractvalue %panda$core$Bit \{rightRef}, 0")
            rightRef := rightField
        }
        def falsePred := currentBlock
        out.printLine("br label %\{ifTrue}")
        createBlock(ifTrue, out)
        def result := nextVar()
        out.printLine("\{result} = phi i1 [1, %\{start}], [\{rightRef}, %\{falsePred}]")
        return result
    }

    method getBinaryReference(t:Type, leftRef:String, op:Int, rightRef:String,
            out:OutputStream):String {
        def llvmOp:String
        match opClass(t) {
            when OpClass.SIGNED:
                match op {
                    when Token.Kind.ADD:        llvmOp := "add"
                    when Token.Kind.SUB:        llvmOp := "sub"
                    when Token.Kind.MUL:        llvmOp := "mul"
                    when Token.Kind.INTDIV:     llvmOp := "sdiv"
                    when Token.Kind.REM:        llvmOp := "srem"
                    when Token.Kind.SHIFTLEFT:  llvmOp := "shl"
                    when Token.Kind.SHIFTRIGHT: llvmOp := "ashr"
                    when Token.Kind.BITWISEAND: llvmOp := "and"
                    when Token.Kind.BITWISEOR:  llvmOp := "or"
                    when Token.Kind.XOR, Token.Kind.BITWISEXOR: 
                                                llvmOp := "xor"
                    when Token.Kind.EQ:         llvmOp := "icmp eq"
                    when Token.Kind.NEQ:        llvmOp := "icmp ne"
                    when Token.Kind.GT:         llvmOp := "icmp sgt"
                    when Token.Kind.LT:         llvmOp := "icmp slt"
                    when Token.Kind.GTEQ:       llvmOp := "icmp sge"
                    when Token.Kind.LTEQ:       llvmOp := "icmp sle"
                    otherwise:
                        assert false
                }
            when OpClass.UNSIGNED:
                match op {
                    when Token.Kind.ADD:        llvmOp := "add"
                    when Token.Kind.SUB:        llvmOp := "sub"
                    when Token.Kind.MUL:        llvmOp := "mul"
                    when Token.Kind.INTDIV:     llvmOp := "udiv"
                    when Token.Kind.REM:        llvmOp := "urem"
                    when Token.Kind.SHIFTLEFT:  llvmOp := "shl"
                    when Token.Kind.SHIFTRIGHT: llvmOp := "lshr"
                    when Token.Kind.BITWISEAND: llvmOp := "and"
                    when Token.Kind.BITWISEOR:  llvmOp := "or"
                    when Token.Kind.XOR, Token.Kind.BITWISEXOR: 
                                                llvmOp := "xor"
                    when Token.Kind.EQ:         llvmOp := "icmp eq"
                    when Token.Kind.NEQ:        llvmOp := "icmp ne"
                    when Token.Kind.GT:         llvmOp := "icmp ugt"
                    when Token.Kind.LT:         llvmOp := "icmp ult"
                    when Token.Kind.GTEQ:       llvmOp := "icmp uge"
                    when Token.Kind.LTEQ:       llvmOp := "icmp ule"
                    otherwise:
                        assert false
                }
            when OpClass.FLOAT:
                match op {
                    when Token.Kind.ADD:        llvmOp := "fadd"
                    when Token.Kind.SUB:        llvmOp := "fsub"
                    when Token.Kind.MUL:        llvmOp := "fmul"
                    when Token.Kind.DIV:        llvmOp := "fdiv"
                    when Token.Kind.EQ:         llvmOp := "fcmp oeq"
                    when Token.Kind.NEQ:        llvmOp := "fcmp one"
                    when Token.Kind.GT:         llvmOp := "fcmp ogt"
                    when Token.Kind.LT:         llvmOp := "fcmp olt"
                    when Token.Kind.GTEQ:       llvmOp := "fcmp oge"
                    when Token.Kind.LTEQ:       llvmOp := "fcmp ole"
                    otherwise:
                        assert false
                }
        }
        def result := nextVar()
        def typeString := type(t)
        out.printLine("\{result} = \{llvmOp} \{typeString} \{leftRef}, \{rightRef}")
        return result
    }

    method getIdentityReference(left:IRNode, right:IRNode, out:OutputStream):String {
        def leftRef := getTypedReference(left, out)
        def rightRef := getReference(right, out)
        def raw := nextVar()
        out.printLine("\{raw} = icmp eq \{leftRef}, \{rightRef}")
        def result := nextVar()
        out.printLine("\{result} = insertvalue %panda$core$Bit { i1 undef }, i1 \{raw}, 0")
        return result
    }

    method getNIdentityReference(left:IRNode, right:IRNode, out:OutputStream):String {
        def leftRef := getTypedReference(left, out)
        def rightRef := getReference(right, out)
        def raw := nextVar()
        out.printLine("\{raw} = icmp ne \{leftRef}, \{rightRef}")
        def result := nextVar()
        out.printLine("\{result} = insertvalue %panda$core$Bit { i1 undef }, i1 \{raw}, 0")
        return result
    }

    method getBinaryReference(left:IRNode, op:Int, right:IRNode, out:OutputStream):String {
        assert left.type = right.type
        match op {
            when Token.Kind.AND:       return getAndReference(left, right, out)
            when Token.Kind.OR:        return getOrReference(left, right, out)
            when Token.Kind.IDENTITY:  return getIdentityReference(left, right, out)
            when Token.Kind.NIDENTITY: return getNIdentityReference(left, right, out)
            otherwise:
                def leftRef := getReference(left, out)
                def rightRef := getReference(right, out)
                return getBinaryReference(left.type, leftRef, op, rightRef, out)
        }
    }

    method getBinaryReference(b:IRNode, out:OutputStream):String {
        assert b.kind = IRNode.Kind.BINARY
        assert b.children.get_count() = 2
        return getBinaryReference(b.children[0], b.payload->Int, b.children[1], out)
    }

    method getTernaryReference(t:IRNode, out:OutputStream):String {
        assert t.kind = IRNode.Kind.TERNARY
        assert t.children.get_count() = 3
        assert t.children[0].type = Type.Bit()
        assert t.children[1].type = t.children[2].type
        def test := getTypedReference(t.children[0], out)
        def testBit := nextVar()
        out.printLine("\{testBit} = extractvalue \{test}, 0")
        var trueLabel := nextLabel()
        var falseLabel := nextLabel()
        def merge := nextLabel()
        out.printLine("br i1 \{testBit}, label %\{trueLabel}, label %\{falseLabel}")
        createBlock(trueLabel, out)
        def ifTrue := getReference(t.children[1], out)
        trueLabel := currentBlock
        out.printLine("br label %\{merge}")
        createBlock(falseLabel, out)
        def ifFalse := getReference(t.children[2], out)
        falseLabel := currentBlock
        out.printLine("br label %\{merge}")
        createBlock(merge, out)
        def result := nextVar()
        out.printLine("\{result} = phi \{type(t.children[1].type)} [\{ifTrue}, %\{trueLabel}], " +
                "[\{ifFalse}, %\{falseLabel}]")
        return result
    }

    function callingConvention(m:MethodDecl):String {
        if m.annotations.isFinal() & !m.annotations.isOverride() & !m.annotations.isExternal() {
            return "fastcc "
        }
        return ""
    }

    method getVirtualMethodReference(target:String, m:MethodDecl, out:OutputStream):String {
        def cc := getClassConstant(m.owner)
        var index := -1
        def vtable := compiler.getVTable(m.owner)
        for i in 0 .. vtable.get_count() {
            if vtable[i]->MethodDecl == m { -- FIXME unnecessary cast
                index := i
                break
            }
        }
        assert index != -1
        def classPtrPtr := nextVar()
        out.printLine("\{classPtrPtr} = getelementptr inbounds \{typeName(m.owner.type())}, " +
                "\{target}, i64 0, i32 0")
        def classPtr := nextVar()
        out.printLine("\{classPtr} = load i8*, i8** \{classPtrPtr}")
        def cast := nextVar()
        out.printLine("\{cast} = bitcast i8* \{classPtr} to \{cc.type}*")
        def ptr := nextVar()
        out.printLine("\{ptr} = getelementptr inbounds \{cc.type}, \{cc.type}* \{cast}, i64 0, " +
                "i32 \{VTABLE_INDEX}, i64 \{index}")
        def load := nextVar()
        out.printLine("\{load} = load i8*, i8** \{ptr}")
        def result := nextVar()
        out.printLine("\{result} = bitcast i8* \{load} to " +
                type(compiler.inheritedTypeWithSelf(m)))
        return result
    }

    method getInterfaceMethodReference(target:String, m:MethodDecl,
            out:OutputStream):String {
        def methodType := type(compiler.inheritedTypeWithSelf(m))
        -- load class constant entry
        def entry := nextLabel()
        out.printLine("br label %\{entry}")
        createBlock(entry, out)
        def rawClassPointer := nextVar()
        out.printLine("\{rawClassPointer} = getelementptr inbounds \{typeName(m.owner.type())}, " +
                "\{target}, \{SIZE_TYPE} 0, i32 \{CLASS_POINTER_INDEX}")
        def classPointer := nextVar()
        def classType := typeName(Type.Class())
        out.printLine("\{classPointer} = bitcast i8** \{rawClassPointer} to \{classType}**")
        def loadedClass := nextVar()
        out.printLine("\{loadedClass} = load \{classType}*, \{classType}** \{classPointer}")
        def itableFirst := nextVar()
        out.printLine("\{itableFirst} = getelementptr inbounds \{classType}, \{classType}* " +
                "\{loadedClass}, \{SIZE_TYPE} 0, i32 \{ITABLE_INDEX}")
        def next := nextLabel()
        out.printLine("br label %\{next}")
        def leavingEntryLabel := currentBlock
        createBlock(next, out)
        labelCount += 1
        def itableNext := "%$itable\{labelCount}"
        def itablePtrPtr := nextVar()
        def fail := nextLabel()
        out.printLine("\{itablePtrPtr} = phi %$itable** [ \{itableFirst}, %\{leavingEntryLabel}]," +
                " [ \{itableNext}, %\{fail} ]")
        def itablePtr := nextVar()
        out.printLine("\{itablePtr} = load %$itable*, %$itable** \{itablePtrPtr}")
        def itableClassPtr := nextVar()
        out.printLine("\{itableClassPtr} = getelementptr inbounds %$itable, %$itable* " +
                "\{itablePtr}, \{SIZE_TYPE} 0, i32 0")
        def itableClass := nextVar()
        out.printLine("\{itableClass} = load \{classType}*, \{classType}** \{itableClassPtr}")
        def test := nextVar()
        def intfCC := getClassConstant(m.owner)
        out.printLine("\{test} = icmp eq \{classType}* bitcast(\{intfCC.type}* \{intfCC.name} to " +
                "\{classType}*), \{itableClass}")
        def success := nextLabel()
        out.printLine("br i1 \{test}, label %\{success}, label %\{fail}")

        createBlock(fail, out)
        out.printLine("\{itableNext} = getelementptr inbounds %$itable, %$itable* \{itablePtr}, " +
                "\{SIZE_TYPE} 0, i32 1")
        out.printLine("br label %\{next}")

        createBlock(success, out)
        var index := -1
        def vtable := compiler.getVTable(m.owner)
        for i in 0 .. vtable.get_count() {
            if vtable[i]->MethodDecl == m { -- FIXME unnecessary cast
                index := i
                break
            }
        }
        index -= compiler.getVTable(compiler.getClass(Type.Object())).get_count()
        assert index != -1
        def methodPtrPtr := nextVar()
        out.printLine("\{methodPtrPtr} = getelementptr inbounds %$itable, %$itable* " +
                "\{itablePtr}, \{SIZE_TYPE} 0, i32 2, i32 \{index}")
        def cast := nextVar()
        out.printLine("\{cast} = bitcast i8** \{methodPtrPtr} to \{methodType}*")
        def methodPtr := nextVar()
        out.printLine("\{methodPtr} = load \{methodType}, \{methodType}* \{cast}")
        return methodPtr
    }

    method getMethodReference(target:String?, m:MethodDecl, isSuper:Bit,
            out:OutputStream):String {
        if !isSuper & m.isVirtual() {
            assert target != null, "calling instance \{m.signature()} without a target"
            if m.owner.classKind = ClassDecl.Kind.INTERFACE {
                return getInterfaceMethodReference(target, m, out)
            }
            else {
                return getVirtualMethodReference(target, m, out)
            }
        }
        else {
            if m.owner.external {
                writeDeclaration(m)
            }
            return getName(m)
        }
    }

    method getPointerCallReference(call:IRNode, out:OutputStream):String {
        def m := call.payload->MethodRef
        match m.value.name {
            when "alloc":
                assert call.children.get_count() = 1
                def countStruct := getTypedReference(call.children[0], out)
                def count := nextVar()
                out.printLine("\{count} = extractvalue \{countStruct}, 0")
                def size := nextVar()
                def elementSize := sizeOf(m.returnType().subtypes[1])
                assert elementSize > 0, "invalid size for type \{m.returnType().subtypes[1]}"
                out.printLine("\{size} = mul \{SIZE_TYPE} \{count}, \{elementSize}")
                def malloc := nextVar()
                out.printLine("\{malloc} = call i8* @malloc(\{SIZE_TYPE} \{size})")
                def result := nextVar()
                out.printLine("\{result} = bitcast i8* \{malloc} to \{type(m.returnType())}")
                return result
            when "get":
                assert call.children.get_count() = 1
                def ptr := getTypedReference(call.children[0], out)
                def baseType := type(m.returnType())
                def ptrType := baseType + "*"
                def cast := nextVar()
                out.printLine("\{cast} = bitcast \{ptr} to \{ptrType}")
                def load := nextVar()
                out.printLine("\{load} = load \{baseType}, \{ptrType} \{cast}")
                return load
            when "[]":
                assert call.children.get_count() = 2
                def ptr := getTypedReference(call.children[0], out)
                def baseType := type(m.returnType())
                def ptrType := baseType + "*"
                def cast := nextVar()
                out.printLine("\{cast} = bitcast \{ptr} to \{ptrType}")
                def indexStruct := getTypedReference(call.children[1], out)
                def index := nextVar()
                out.printLine("\{index} = extractvalue \{indexStruct}, 0")
                def offsetPtr := nextVar()
                out.printLine("\{offsetPtr} = getelementptr \{baseType}, \{ptrType} \{cast}, " +
                        "i64 \{index}")
                def load := nextVar()
                out.printLine("\{load} = load \{baseType}, \{ptrType} \{offsetPtr}")
                return load
            when "realloc":
                assert call.children.get_count() = 2
                def ptr := getTypedReference(call.children[0], out)
                def ptrCast := nextVar()
                out.printLine("\{ptrCast} = bitcast \{ptr} to i8*")
                def countStruct := getTypedReference(call.children[1], out)
                def count := nextVar()
                out.printLine("\{count} = extractvalue \{countStruct}, 0")
                def size := nextVar()
                out.printLine("\{size} = mul \{SIZE_TYPE} \{count}, " +
                        sizeOf(m.returnType().subtypes[1]))
                def realloc := nextVar()
                out.printLine("\{realloc} = call i8* @realloc(i8* \{ptrCast}, \{SIZE_TYPE} " +
                        "\{size})")
                def result := nextVar()
                out.printLine("\{result} = bitcast i8* \{realloc} to \{type(m.returnType())}")
                return result
            when "offset":
                assert call.children.get_count() = 2
                def ptr := getTypedReference(call.children[0], out)
                def baseType := type(call.children[0].type.subtypes[1])
                def offsetStruct := getTypedReference(call.children[1], out)
                def offset := nextVar()
                out.printLine("\{offset} = extractvalue \{offsetStruct}, 0")
                def result := nextVar()
                out.printLine("\{result} = getelementptr \{baseType}, \{ptr}, i64 \{offset}")
                return result
            otherwise:
                assert false
        }
    }

    method getInlineCallReference(call:IRNode, body:IRNode, out:OutputStream):String {
        def m := (call.payload->MethodRef).value
        compiler.currentClass.push(m.owner)
        currentlyInlining[m] := m
        var selfRef := "<inline call self error>"
        def argStart:Int
        if m.isInstance() {
            argStart := 1
            selfRef := getReference(call.children[0], out)
        }
        else {
            argStart := 0
        }
        def args := Array<String>()
        for i in argStart .. call.children.get_count() {
            args.add(getReference(call.children[i], out))
        }
        def end := nextLabel()
        if args.get_count() != m.parameters.get_count() {
            Console.printLine("parameter count mismatch in \{call}") -- FIXME use assert
            System.crash()
        }
        def inline := InlineContext("$inline\{varCount}", selfRef, args, end)
        inlineContext.push(inline)
        def old := currentMethod
        currentMethod := m
        writeBlock(body, out)
        currentMethod := old
        inlineContext.pop()
        if !endsWithBranch(body) {
            out.printLine("unreachable")
        }
        createBlock(end, out)
        currentlyInlining.remove(m)
        compiler.currentClass.pop()
        if inline.returns.get_count() = 1 {
            return inline.returns[0].second
        }
        if inline.returns.get_count() = 0 {
            assert false, "no return from inline method \{m.declaration()}"
            out.printLine("unreachable")
            return "undef"
        }
        def phi := nextVar()
        out.print("\{phi} = phi \{type(m.returnType)} ")
        var separator := ""
        for ret in inline.returns {
            out.print("\{separator}[\{ret.second}, %\{ret.first}]")
            separator := ", "
        }
        out.printLine()
        return phi
    }

    method getCallReference(call:IRNode, out:OutputStream):String {
        assert call.kind = IRNode.Kind.CALL
        def m := (call.payload->MethodRef).value
        if m.owner.name = "panda.unsafe.Pointer" {
            return getPointerCallReference(call, out)
        }
        if m.owner.external {
            writeDeclaration(m)
        }
        if m.owner.name = "panda.core.Bit" {
            if m.name = "&" {
                assert call.children.get_count() = 2
                def bit := getAndReference(call.children[0], call.children[1], out)
                def result := nextVar()
                out.printLine("\{result} = insertvalue %panda$core$Bit { i1 undef }, i1 " +
                        "\{bit}, 0")
                return result
            }
            if m.name = "|" {
                assert call.children.get_count() = 2
                def bit := getOrReference(call.children[0], call.children[1], out)
                def result := nextVar()
                out.printLine("\{result} = insertvalue %panda$core$Bit { i1 undef }, i1 " +
                        "\{bit}, 0")
                return result
            }
        }
        if m.annotations.isInline() & currentlyInlining[m] = null {
            def block := compiler.compileBody(m)
            if block != null {
                return getInlineCallReference(call, block, out)
            }
            return "<error>"
        }
        def args := Array<String>(call.children.get_count())
        def actualMethodType:Type
        def actualResultType:String
        def isSuper := call.children.get_count() >= 1 & call.children[0].kind = IRNode.Kind.SUPER
        if !isSuper & m.isVirtual() {
            actualMethodType := compiler.inheritedType(m)
            actualResultType := type(actualMethodType.subtypes[actualMethodType.subtypes.get_count() - 1])
        }
        else {
            actualMethodType := compiler.declaredType(m)
            actualResultType := type(call.type)
        }
        def offset := call.children.get_count() - actualMethodType.subtypes.get_count() + 1
        for i in 0 .. call.children.get_count() {
            def arg := getReference(call.children[i], out)
            if i >= offset & actualMethodType.subtypes[i - offset] != call.children[i].type {
                arg := type(actualMethodType.subtypes[i - offset]) + " " +
                        getCastReference(arg, call.children[i].type,
                            actualMethodType.subtypes[i - offset], out)
            }
            else {
                arg := type(call.children[i].type) + " " + arg
            }
            args.add(arg)
        }
        def target:String?
        if args.get_count() > 0 {
            -- this isn't actually correct - args[0] could be the target of an instance method, or
            -- just the first parameter to a class method. But getMethodReference ignores target for
            -- class methods, so this works and is easier than doing it the right way.
            target := args[0]
        }
        else {
            target := null
        }
        def methodRef := getMethodReference(target, m, isSuper, out)
        def result:String
        def indirect := needsStructIndirection(m)
        if indirect {
            out.print("call \{callingConvention(m)}void")
        }
        else {
            result := nextVar()
            out.print("\{result} = call \{callingConvention(m)}\{actualResultType}")
        }
        out.print(" \{methodRef}(")
        var separator := ""
        def indirectVar:String
        if indirect {
            labelCount += 1
            indirectVar := "%$tmp" + labelCount
            methodHeader.printLine("\{indirectVar} = alloca \{actualResultType}")
            out.print("\{actualResultType}* \{indirectVar}")
            separator := ", "
        }
        for arg in args {
            out.print("\{separator}\{arg}")
            separator := ", "
        }
        out.printLine(")")
        if indirect {
            result := nextVar()
            out.printLine("\{result} = load \{actualResultType}, \{actualResultType}* " +
                        indirectVar)
        }
        if type(call.type) != actualResultType {
            return getCastReference(result, 
                        actualMethodType.subtypes[actualMethodType.subtypes.get_count() - 1],
                        call.type,
                        out)
        }
        return result
    }

    method wrapValue(value:String, srcType:Type, dstType:Type, out:OutputStream):String {
        def src := compiler.getClass(srcType)
        assert src != null
        if srcType.typeKind = Type.Kind.NULLABLE {
            -- casting nullable value to nullable wrapper, need to special-case null
            def testStart := currentBlock
            def isNonNull := nextVar()
            out.printLine("\{isNonNull} = extractvalue \{nullableType(srcType)} \{value}, 1")
            def nonNullLabel := nextLabel()
            def endLabel := nextLabel()
            out.printLine("br i1 \{isNonNull}, label %\{nonNullLabel}, label %\{endLabel}")
            createBlock(nonNullLabel, out)
            def unwrapped := toNonNullableValue(value, srcType, srcType.subtypes[0], out)
            def nonNullValue := wrapValue(unwrapped, srcType.subtypes[0], dstType, out)
            out.printLine("br label %\{endLabel}")
            createBlock(endLabel, out)
            def result := nextVar()
            out.printLine("\{result} = phi \{type(dstType)} [null, %\{testStart}], " +
                    "[\{nonNullValue}, %\{nonNullLabel}]")
            return result
        }
        def mallocRef := nextVar()
        out.printLine("\{mallocRef} = call i8* @malloc(i64 \{sizeOfWrapper(src.type())})")
        def wrapperTypeName := wrapperTypeName(src.type())
        def wrapperType := wrapperType(src.type())
        def wrapperCast := nextVar()
        out.printLine("\{wrapperCast} = bitcast i8* \{mallocRef} to \{wrapperType}")
        def classPtr := nextVar()
        out.printLine("\{classPtr} = getelementptr \{wrapperTypeName}, " +
                "\{wrapperType} \{wrapperCast}, i64 0, i32 0")
        def cc := getWrapperClassConstant(src)
        def ccCast:String
        if cc.type != "%panda$core$Class" {
            ccCast := "bitcast(\{cc.type}* \{cc.name} to %panda$core$Class*)"
        }
        else {
            ccCast := cc.name
        }
        out.printLine("store %panda$core$Class* \{ccCast}, %panda$core$Class** \{classPtr}")
        def refCount := nextVar()
        out.printLine("\{refCount} = getelementptr \{wrapperTypeName}, " +
                "\{wrapperType} \{wrapperCast}, i64 0, i32 1, i32 0")
        out.printLine("store i32 0, i32* \{refCount}")
        def target := nextVar()
        out.printLine("\{target} = getelementptr \{wrapperTypeName}, " +
                "\{wrapperType} \{wrapperCast}, i64 0, i32 2")
        out.printLine("store \{type(srcType)} \{value}, \{type(srcType)}* \{target}")
        if wrapperType != type(dstType) {
            def result := nextVar()
            out.printLine("\{result} = bitcast \{wrapperType} \{wrapperCast} to \{type(dstType)}")
            return result
        }
        return wrapperCast
    }

    method getFieldReference(fieldRef:IRNode, out:OutputStream):String {
        assert fieldRef.kind = IRNode.Kind.FIELD_REFERENCE
        assert fieldRef.children.get_count() = 1
        def field := fieldRef.payload->FieldDecl
        def t := type(field.type)
        if field.annotations.isClass() {
            assert field.value != null
            return getReference(field.value, out)
        }
        def cl := compiler.getClass(fieldRef.children[0].type)
        assert cl != null
        if compiler.isValue(cl) & (fieldRef.children[0].kind != IRNode.Kind.SELF |
                currentMethod.methodKind != MethodDecl.Kind.INIT) {
            def base := getReference(fieldRef.children[0], out)
            def fields := compiler.instanceFields(cl)
            def index:Int? := null
            for i in 0 .. fields.get_count() {
                if fields[i]->FieldDecl == field { -- FIXME unnecessary cast
                    index := i
                    break
                }
            }
            assert index != null
            var result := nextVar()
            out.printLine("\{result} = extractvalue \{type(fieldRef.children[0].type)} \{base}, " +
                    index)
            if field.type.isClass() & !compiler.isValue(compiler.getClass(field.type)) {
                def cast := nextVar()
                out.printLine("\{cast} = bitcast i8* \{result} to \{type(fieldRef.type)}")
                result := cast
            }
            return result
        }
        def ptr := "\{t}* \{getLValue(fieldRef, out)}"
        def result := nextVar()
        out.printLine("\{result} = load \{t}, \{ptr}")
        return result
    }

    method unwrapValue(value:String, srcType:Type, dstType:Type, out:OutputStream):String {
        def target := compiler.getClass(dstType)
        assert target != null
        if dstType.typeKind = Type.Kind.NULLABLE {
            -- casting nullable wrapper to nullable value, need to special-case null
            def testStart := currentBlock
            def isNonNull := nextVar()
            out.printLine("\{isNonNull} = icmp ne \{type(srcType)} \{value}, null")
            def nonNullLabel := nextLabel()
            def endLabel := nextLabel()
            out.printLine("br i1 \{isNonNull}, label %\{nonNullLabel}, label %\{endLabel}")
            createBlock(nonNullLabel, out)
            def wrapped := unwrapValue(value, srcType, dstType.subtypes[0], out)
            def nonNullValue := toNullableValue(wrapped, dstType.subtypes[0], dstType, out)
            out.printLine("br label %\{endLabel}")
            createBlock(endLabel, out)
            def result := nextVar()
            out.printLine("\{result} = phi \{type(dstType)} " +
                    "[{ \{type(dstType.subtypes[0])} undef, i1 0 }, " +
                    "%\{testStart}], [\{nonNullValue}, %\{nonNullLabel}]")
            return result
        }
        def targetType := type(dstType)
        def wrapperTypeName := wrapperTypeName(dstType)
        def wrapperType := wrapperType(dstType)
        def srcCast := nextVar()
        out.printLine("\{srcCast} = bitcast \{type(srcType)} \{value} to \{wrapperType}")
        def load := nextVar()
        out.printLine("\{load} = load \{wrapperTypeName}, \{wrapperType} \{srcCast}")
        def result := nextVar()
        out.printLine("\{result} = extractvalue \{wrapperTypeName} \{load}, \{OBJECT_FIELD_COUNT}")
        return result
    }

    method toNullableValue(value:String, srcType:Type, dstType:Type,
            out:OutputStream):String {
        def nullableType := nullableType(dstType)
        def result := nextVar()
        out.printLine("\{result} = insertvalue \{nullableType} " +
                "{ \{type(srcType)} undef, i1 true }, \{type(srcType)} \{value}, 0")
        return result
    }

    method toNonNullableValue(value:String, srcType:Type, dstType:Type,
            out:OutputStream):String {
        def result := nextVar()
        out.printLine("\{result} = extractvalue \{type(srcType)} \{value}, 0")
        return result
    }

    method getCastReference(value:String, src:Type, target:Type, out:OutputStream):String {
        def op:String
        if target.isBuiltinNumber() {
            assert src.isBuiltinNumber()
            def size1 := sizeOf(src)
            def size2 := sizeOf(target)
            if src.typeKind = Type.Kind.BUILTIN_FLOAT {
                if target.typeKind = Type.Kind.BUILTIN_FLOAT {
                    if size1 > size2 {
                        op := "fptrunc"
                    }
                    else if size1 < size2 {
                        op := "fpext"
                    }
                    else {
                        return value
                    }
                }
                else if target.typeKind = Type.Kind.BUILTIN_INT {
                    op := "fptosi"
                }
                else {
                    assert target.typeKind = Type.Kind.BUILTIN_UINT
                    op := "fptoui"
                }
            }
            else if target.typeKind = Type.Kind.BUILTIN_FLOAT {
                if src.typeKind = Type.Kind.BUILTIN_INT {
                    op := "sitofp"
                }
                else {
                    assert src.typeKind = Type.Kind.BUILTIN_UINT
                    op := "uitofp"
                }
            }
            else {
                if size1 > size2 {
                    op := "trunc"
                }
                else if size1 < size2 {
                    if src.typeKind = Type.Kind.BUILTIN_INT {
                        op := "sext"
                    }
                    else {
                        op := "zext"
                    }                    
                }
                else {
                    return value
                }
            }
        }
        else {
            def srcClass := compiler.getClass(src)
            assert srcClass != null
            def targetClass := compiler.getClass(target)
            assert targetClass != null
            if compiler.isValue(srcClass) & !compiler.isValue(targetClass) {
                return wrapValue(value, src, target, out)
            }
            else if !compiler.isValue(srcClass) & compiler.isValue(targetClass) {
                return unwrapValue(value, src, target, out)
            }
            else if compiler.isValue(srcClass) & target.typeKind = Type.Kind.NULLABLE &
                    target.subtypes[0] = src {
                return toNullableValue(value, src, target, out)
            }
            else if compiler.isValue(targetClass) & src.typeKind = Type.Kind.NULLABLE &
                    src.subtypes[0] = target {
                return toNonNullableValue(value, src, target, out)
            }
            op := "bitcast"
        }
        def srcType := type(src)
        def dstType := type(target)
        if srcType = dstType {
            return value
        }
        def result := nextVar()
        out.printLine("\{result} = \{op} \{srcType} \{value} to \{dstType}")
        return result
    }

    method getCastReference(cast:IRNode, out:OutputStream):String {
        assert cast.kind = IRNode.Kind.CAST
        assert cast.children.get_count() = 1
        def base := getReference(cast.children[0], out)
        return getCastReference(base, cast.children[0].type, cast.type, out)
    }

    method getConstructReference(construct:IRNode, out:OutputStream):String {
        assert construct.kind = IRNode.Kind.CONSTRUCT
        assert construct.children.get_count() >= 1
        def cl := compiler.getClass(construct.type)
        assert cl != null
        def t := type(construct.type)
        if construct.type.isNumber() & construct.children[0].children[0].type.isBuiltinNumber() {
            assert construct.children.get_count() = 1
            assert construct.children[0].children.get_count() = 1
            def value := getTypedReference(construct.children[0].children[0], out)
            if construct.children[0].children[0].kind = IRNode.Kind.INT {
                return "{ " + value + " }"
            }
            def result := nextVar()
            def lastField := cl.fields[cl.fields.get_count() - 1]
            assert !lastField.annotations.isClass()
            out.printLine("\{result} = insertvalue \{t} { \{type(lastField.type)} undef }, " +
                    "\{value}, 0\n")
            return result
        }
        if construct.type = Type.Bit() &
                construct.children[0].children[0].type.typeKind = Type.Kind.BUILTIN_BIT {
            assert construct.children.get_count() = 1
            assert construct.children[0].children.get_count() = 1
            def value := getTypedReference(construct.children[0].children[0], out)
            if construct.children[0].children[0].kind = IRNode.Kind.BIT {
                return "{ " + value + " }"
            }
            def result := nextVar()
            def lastField := cl.fields[cl.fields.get_count() - 1]
            assert !lastField.annotations.isClass()
            out.printLine("\{result} = insertvalue \{t} { \{type(lastField.type)} undef }, " +
                    "\{value}, 0\n")
            return result
        }
        if compiler.isValue(cl) {
            labelCount += 1
            def alloca := "%$tmp\{labelCount}"
            methodHeader.printLine("\{alloca} = alloca \{t}")
            writeCall(construct.children[0], "\{t}* \{alloca}", out)
            def result := nextVar()
            out.printLine("\{result} = load \{t}, \{t}* \{alloca}")
            return result
        }
        def callRef := nextVar()
        out.printLine("\{callRef} = call i8* @malloc(i64 \{sizeOf(construct.type)})")
        def result := nextVar()
        out.printLine("\{result} = bitcast i8* \{callRef} to \{type(construct.type)}")
        def classPtr := nextVar()
        def className:String
        if construct.type.typeKind = Type.Kind.GENERIC & !cl.isSpecialization() {
            className := typeName(construct.type.subtypes[0])
        }
        else {
            className := typeName(construct.type)
        }
        out.printLine("\{classPtr} = getelementptr inbounds \{className}, \{t} \{result}, i64 0, " +
                "i32 0")
        def cc := getClassConstant(cl)
        out.printLine("store i8* bitcast(\{cc.type}* \{cc.name} to " +
                "i8*), i8** \{classPtr}")
        writeCall(construct.children[0], "\{t} \{result}", out)
        return result
    }

    method getIntReference(int:IRNode, out:OutputStream):String {
        return int.payload->UInt64.convert()
    }

    method getNegatedIntReference(int:IRNode, out:OutputStream):String {
        return "-" + int.payload->UInt64.convert()
    }

    method getRealReference(real:IRNode, out:OutputStream):String {
        var r64 := real.payload->Real64
        if real.type.size() = 32 {
            -- LLVM has a bizarre representation of float. You still use a double, but must ensure
            -- that said double is exactly representable as a float. We convert through Real32 to
            -- ensure this.
            r64 := r64.convert()->panda.core.Real32.convert()->Real64
        }
        var bits := Panda.floatToIntBits(r64)
        def result := MutableString()
        for i in 0 .. 16 {
            if bits >= 0 {
                result.append("0123456789ABCDEF"[bits % 16])
            }
            else {
                result.append("0123456789ABCDEF"[15 + bits % 16])
            }
            bits //= 16
        }
        return "0x" + result.finish()[.. by -1]
    }

    method getBitReference(bit:IRNode, out:OutputStream):String {
        if bit.payload->Bit {
            return "true"
        }
        return "false"
    }

    method getVariableReference(v:Variable, out:OutputStream):String {
        if v.storage = Variable.Storage.PARAMETER {
            return getName(v)
        }
        def result := nextVar()
        def t := type(v.type)
        out.printLine("\{result} = load \{t}, \{t}* \{getName(v)}")
        return result
    }

    method getStringReference(s:String, out:OutputStream):String {
        labelCount += 1
        def chars := "@$chars\{labelCount}"
        def charsType := "[\{s.utf8().get_count()} x i8]"
        strings.print("\{chars} = private unnamed_addr constant \{charsType} [ ")
        var separator := ""
        for c in s.utf8() {
            strings.print("\{separator}i8 \{c.convert()->Int8}")
            separator := ", "
        }
        strings.printLine(" ]")
        labelCount += 1
        def result := "@$str\{labelCount}"
        def string := compiler.getClass(Type.StringType())
        assert string != null
        def cc := getClassConstant(string)
        strings.printLine("\{result} = private unnamed_addr constant %panda$core$String { " +
                "i8* bitcast(\{cc.type}* \{cc.name} to " +
                "i8*), %panda$core$Int32 insertvalue(%panda$core$Int32 " +
                "{ i32 undef }, i32 1, 0), %panda$core$Char8* bitcast(\{charsType}* \{chars}" +
                " to %panda$core$Char8*), %panda$core$Int64 { i64 \{s.utf8().get_count()} }, " +
                "%panda$core$Int64 { i64 \{s.hash()} }, i8* null }")
        return result
    }

    ================================================================================================
    In init methods, %self must be a pointer rather than a value, so that we can modify our fields.
    This returns true if our current %self is a pointer to a value.
    ================================================================================================
    function haveSelfValuePointer():Bit {
        return currentMethod.methodKind = MethodDecl.Kind.INIT &
                compiler.isValue(currentMethod.owner)
    }

    ================================================================================================
    Returns the current %self, as a pointer. For values, this pointer is only available from within
    init methods.
    ================================================================================================
    method getSelfPointer():String {
        assert currentMethod.methodKind = MethodDecl.Kind.INIT |
                !compiler.isValue(currentMethod.owner),
                "self pointer for values is only accessible from init methods " +
                "(in \{currentMethod.declaration()})"
        if inlineContext.get_count() > 0 {
            return inlineContext.peek().selfRef
        }
        return "%self"
    }

    ================================================================================================
    Returns the current %self, as a value if the current object is a value. For non-value objects
    %self is always a pointer.
    ================================================================================================
    method getSelfValue(out:OutputStream):String {
        assert currentMethod != null
        if haveSelfValuePointer() {
            def load := nextVar()
            out.printLine("\{load} = load \{type(currentMethod.owner.type())}, " +
                    "\{type(currentMethod.owner.type())}* \{getSelfPointer()}")
            return load
        }
        if inlineContext.get_count() > 0 {
            return inlineContext.peek().selfRef
        }
        return "%self"
    }

    method getSelfReference(s:IRNode, out:OutputStream):String {
        return getSelfValue(out)
    }

    method getSuperReference(s:IRNode, out:OutputStream):String {
        def ref := getSelfReference(s, out)
        def result := nextVar()
        out.printLine("\{result} = bitcast \{selfType(currentMethod)} \{ref} to \{type(s.type)}")
        return result
    }

    method getIsNullReference(test:IRNode, out:OutputStream):String {
        assert test.kind = IRNode.Kind.IS_NULL
        assert test.children.get_count() = 1
        def value := getTypedReference(test.children[0], out)
        def cl := compiler.getClass(test.children[0].type)
        def resultValue:String
        if compiler.isValue(cl) {
            if test.children[0].type.typeKind != Type.Kind.NULLABLE {
                return "{ i1 0 }"
            }
            def field := nextVar()
            out.printLine("\{field} = extractvalue \{value}, 1")
            resultValue := nextVar()
            out.printLine("\{resultValue} = xor i1 \{field}, -1")
        }
        else {
            resultValue := nextVar()
            out.printLine("\{resultValue} = icmp eq \{value}, null")
        }
        def result := nextVar()
        out.printLine("\{result} = insertvalue %panda$core$Bit { i1 undef }, i1 \{resultValue}, 0")
        return result
    }

    method getIsNonNullReference(test:IRNode, out:OutputStream):String {
        assert test.kind = IRNode.Kind.IS_NONNULL
        assert test.children.get_count() = 1
        def value := getTypedReference(test.children[0], out)
        def cl := compiler.getClass(test.children[0].type)
        def resultValue:String
        if compiler.isValue(cl) {
            if test.children[0].type.typeKind != Type.Kind.NULLABLE {
                return "{ i1 1 }"
            }
            resultValue := nextVar()
            out.printLine("\{resultValue} = extractvalue \{value}, 1")
        }
        else {
            resultValue := nextVar()
            out.printLine("\{resultValue} = icmp ne \{value}, null")
        }
        def result := nextVar()
        out.printLine("\{result} = insertvalue %panda$core$Bit { i1 undef }, i1 \{resultValue}, 0")
        return result
    }

    method getNullReference(expr:IRNode, out:OutputStream):String {
        assert expr.type.typeKind = Type.Kind.NULLABLE
        def cl := compiler.getClass(expr.type.subtypes[0])
        assert cl != null
        if compiler.isValue(cl) {
            return "{ \{type(expr.type.subtypes[0])} undef, i1 0 }"
        }
        else {
            return "null"
        }
    }

    method getPrefixReference(expr:IRNode, out:OutputStream):String {
        assert expr.kind = IRNode.Kind.PREFIX
        assert expr.children.get_count() = 1
        def base := getReference(expr.children[0], out)
        def result := nextVar()
        match (expr.payload->UInt64).convert()->Int64 {
            when Token.Kind.SUB:
                def zero:String
                if expr.type.typeKind = Type.Kind.BUILTIN_FLOAT {
                    out.printLine("\{result} = fsub \{type(expr.type)} 0.0, \{base}")                    
                }
                else {
                    out.printLine("\{result} = sub \{type(expr.type)} 0, \{base}")                    
                }
                return result
            when Token.Kind.NOT, Token.Kind.BITWISENOT:
                out.printLine("\{result} = xor \{type(expr.type)} -1, \{base}")
                return result
            otherwise:
                assert false, expr.convert()
        }
    }

    method getReference(expr:IRNode, out:OutputStream):String {
        match expr.kind {
            when IRNode.Kind.BINARY:
                return getBinaryReference(expr, out)
            when IRNode.Kind.TERNARY:
                return getTernaryReference(expr, out)
            when IRNode.Kind.CALL:
                return getCallReference(expr, out)
            when IRNode.Kind.CAST:
                return getCastReference(expr, out)
            when IRNode.Kind.INT:
                return getIntReference(expr, out)
            when IRNode.Kind.NEGATED_INT:
                return getNegatedIntReference(expr, out)
            when IRNode.Kind.REAL:
                return getRealReference(expr, out)
            when IRNode.Kind.BIT:
                return getBitReference(expr, out)
            when IRNode.Kind.CONSTRUCT:
                return getConstructReference(expr, out)
            when IRNode.Kind.VARIABLE_REFERENCE:
                return getVariableReference(expr.payload->Variable, out)
            when IRNode.Kind.FIELD_REFERENCE:
                return getFieldReference(expr, out)
            when IRNode.Kind.STRING:
                return getStringReference(expr.payload->String, out)
            when IRNode.Kind.SELF:
                return getSelfReference(expr, out)
            when IRNode.Kind.SUPER:
                return getSuperReference(expr, out)
            when IRNode.Kind.REUSED_VALUE_DEFINITION:
                def value := getReference(expr.children[0], out)
                reusedValues[expr.payload->UInt64] := value
                return value
            when IRNode.Kind.REUSED_VALUE:
                def result := reusedValues[expr.payload->UInt64]
                assert result != null
                return result
            when IRNode.Kind.NULL:
                return getNullReference(expr, out)
            when IRNode.Kind.IS_NULL:
                return getIsNullReference(expr, out)
            when IRNode.Kind.IS_NONNULL:
                return getIsNonNullReference(expr, out)
            when IRNode.Kind.PREFIX:
                return getPrefixReference(expr, out)
            otherwise:
                assert false, "unsupported expression \{expr}:\{expr.position}"
        }
    }

    method getTypedReference(expr:IRNode, out:OutputStream):String {
        return "\{type(expr.type)} \{getReference(expr, out)}"
    }

    method writeBlock(block:IRNode, out:OutputStream) {
        assert block.kind = IRNode.Kind.BLOCK
        for s in block.children {
            writeStatement(s, out)
        }
    }

    method writePointerCall(stmt:IRNode, out:OutputStream) {
        def m := stmt.payload->MethodRef
        match m.value.name {
            when "set":
                assert stmt.children.get_count() = 2
                def ptr := getTypedReference(stmt.children[0], out)
                def arg := getTypedReference(compiler.unwrapCast(stmt.children[1]), out)
                out.printLine("store \{arg}, \{ptr}")
            when "[]:=":
                assert stmt.children.get_count() = 3
                assert compiler.unwrapCast(stmt.children[0]).type.subtypes.get_count() = 2
                def baseType := compiler.unwrapCast(stmt.children[0]).type.subtypes[1]
                def base := getTypedReference(stmt.children[0], out)
                def indexStruct := getTypedReference(stmt.children[1], out)
                def index := nextVar()
                out.printLine("\{index} = extractvalue \{indexStruct}, 0")
                def value := getTypedReference(compiler.unwrapCast(stmt.children[2]), out)
                def ptr := nextVar()
                out.printLine("\{ptr} = getelementptr inbounds \{type(baseType)}, \{base}, " +
                        "\{SIZE_TYPE} \{index}")
                out.printLine("store \{value}, \{type(baseType)}* \{ptr}")
            when "destroy":
                assert stmt.children.get_count() = 1
                def ptr := getTypedReference(stmt.children[0], out)
                def cast := nextVar()
                out.printLine("\{cast} = bitcast \{ptr} to i8*")
                out.printLine("call void @free(i8* \{cast})")
            otherwise:
                assert false
        }
    }

    -- if 'target' is non-null, it is inserted as a hidden first parameter to the call. This is used
    -- for init() calls, which require a self parameter but do not have a target in the IR.
    method writeCall(call:IRNode, target:String?, out:OutputStream) {
        assert call.kind = IRNode.Kind.CALL
        def m := (call.payload->MethodRef).value
        if m.owner.name = "panda.unsafe.Pointer" {
            writePointerCall(call, out)
            return
        }
        if m.owner.external {
            writeDeclaration(m)
        }
        def actualMethodType:Type
        def actualResultType:String
        def isSuper := call.children.get_count() >= 1 & call.children[0].kind = IRNode.Kind.SUPER
        if !isSuper & m.isVirtual() {
            actualMethodType := compiler.inheritedType(m)
            actualResultType := type(actualMethodType.subtypes[actualMethodType.subtypes.get_count() - 1])
        }
        else {
            actualMethodType := compiler.declaredType(m)
            actualResultType := type(call.type)
        }
        def args := Array<String>()
        if target != null {
            args.add(target)
        }
        def offset := call.children.get_count() - actualMethodType.subtypes.get_count() + 1
        for i in 0 .. call.children.get_count() {
            if target = null & i = 0 & call.children[i].kind = IRNode.Kind.SELF &
                    m.methodKind = MethodDecl.Kind.INIT {
                args.add("\{selfType(m)} \{getSelfPointer()}")
                continue
            }
            if target = null & i = 0 & call.children[i].kind = IRNode.Kind.SUPER &
                    m.methodKind = MethodDecl.Kind.INIT {
                def cast := nextVar()
                out.printLine("\{cast} = bitcast \{selfType(currentMethod)} \{getSelfPointer()} " +
                        " to \{type(call.children[i].type)}")
                args.add("\{type(call.children[i].type)} \{cast}")
                continue
            }
            def arg := getReference(call.children[i], out)
            if i >= offset & actualMethodType.subtypes[i - offset] != call.children[i].type {
                arg := type(actualMethodType.subtypes[i - offset]) + " " +
                        getCastReference(arg, call.children[i].type,
                            actualMethodType.subtypes[i - offset], out)
            }
            else {
                arg := type(call.children[i].type) + " " + arg
            }
            args.add(arg)
        }
        def refTarget:String?
        if args.get_count() > 0 {
            -- this isn't actually correct - args[0] could be the target of an instance method, or
            -- just the first parameter to a class method. But getMethodReference ignores target for
            -- non-virtual methods, so this works and is easier than doing it the right way.
            refTarget := args[0]
        }
        else {
            refTarget := null
        }
        def methodRef := getMethodReference(refTarget, m, isSuper, out)
        var separator := ""
        if needsStructIndirection(m) {
            labelCount += 1
            def indirectVar := "%$tmp" + labelCount
            def resultType := type(call.type)
            methodHeader.printLine("\{indirectVar} = alloca \{resultType}")
            out.print("call \{callingConvention(m)}void " +
                    "\{methodRef}(\{resultType}* \{indirectVar}")
            separator := ", "
        }
        else {
            if call.type != Type.Void() {
                nextVar()
            }
            out.print("call \{callingConvention(m)}\{type(call.type)} " +
                    "\{methodRef}(")
        }
        for a in args {
            out.print(separator)
            out.print(a)
            separator := ", "
        }
        out.printLine(")")
    }

    method writeIf(s:IRNode, out:OutputStream) {
        assert s.kind = IRNode.Kind.IF
        assert s.children.get_count() = 2 | s.children.get_count() = 3
        assert s.children[0].type = Type.Bit()
        def test := getTypedReference(s.children[0], out)
        def testBit := nextVar()
        out.printLine("\{testBit} = extractvalue \{test}, 0")
        def ifTrue := nextLabel()
        def ifFalse := nextLabel()
        out.printLine("br i1 \{testBit}, label %\{ifTrue}, label %\{ifFalse}")
        createBlock(ifTrue, out)
        writeStatement(s.children[1], out)
        def end:String
        if s.children.get_count() = 3 {
            end := nextLabel()
        }
        else {
            end := ifFalse
        }
        if !endsWithBranch(s.children[1]) {
            out.printLine("br label %\{end}")
        }
        if s.children.get_count() = 3 {
            createBlock(ifFalse, out)
            writeStatement(s.children[2], out)
            if !endsWithBranch(s.children[2]) {
                out.printLine("br label %\{end}")
            }
        }
        createBlock(end, out)
    }

    method writeSimpleRealRangeFor(f:IRNode, out:OutputStream) {
        -- this could probably be simplified quite a bit; it's just a cut-down version of
        -- writeSteppedRealRangeFor
        assert f.kind = IRNode.Kind.RANGE_FOR
        assert f.children.get_count() = 3
        def target := f.children[0]
        assert f.children[1].type.typeKind = Type.Kind.GENERIC
        assert f.children[1].type.subtypes.get_count() = 2
        assert f.children[1].type.subtypes[0].name = Compiler.RANGE_NAME
        def range := getTypedReference(f.children[1], out)
        def block := f.children[2]
        def t := f.children[1].type.subtypes[1]
        def llt := type(t)
        def indexType:String
        if t.typeKind = Type.Kind.NULLABLE {
            assert t.subtypes.get_count() = 1
            indexType := type(t.subtypes[0])
        }
        else {
            indexType := llt
        }
        def cl := compiler.getClass(t)
        assert cl != null
        assert compiler.instanceFields(cl).get_count() = 1
        def numberType := type(compiler.instanceFields(cl)[0].type)
        assert target.kind = IRNode.Kind.VARIABLE_REFERENCE
        def index := getName(target.payload->Variable)
        methodHeader.printLine("\{index} = alloca \{indexType}")

        -- extract start value from range
        def start := nextVar()
        out.printLine("\{start} = extractvalue \{range}, 0, 0")

        -- store start value
        def indexValuePtr := nextVar()
        out.printLine("\{indexValuePtr} = getelementptr \{indexType}, \{indexType}* \{index}, " +
                "i64 0, i32 0")
        out.printLine("store \{numberType} \{start}, \{numberType}* \{indexValuePtr}")

        -- extract end value from range
        def end := nextVar()
        out.printLine("\{end} = extractvalue \{range}, 1, 0")

        -- extract inclusive / exclusive from range
        def inclusive := nextVar()
        out.printLine("\{inclusive} = extractvalue \{range}, 2, 0")

        -- start block
        def loopStart := nextLabel()
        def loopBody := nextLabel()
        def loopEnd := nextLabel()
        def loopInc := nextLabel()
        loopDescriptors.push(LoopDescriptor(f.payload->String?, loopEnd, loopInc)) -- FIXME Auto
        def forward := nextLabel()
        def backward := nextLabel()
        out.printLine("br label %\{loopStart}")
        createBlock(loopStart, out)
        def indexValue := nextVar()
        out.printLine("\{indexValue} = load \{numberType}, \{numberType}* \{indexValuePtr}")
        def forwardInclusive := nextLabel()
        def forwardExclusive := nextLabel()
        out.printLine("br i1 \{inclusive}, label %\{forwardInclusive}, " +
                "label %\{forwardExclusive}")
        createBlock(forwardInclusive, out)
        def forwardInclusiveTest := nextVar()
        out.printLine("\{forwardInclusiveTest} = fcmp ole \{numberType} \{indexValue}, \{end}")
        out.printLine("br i1 \{forwardInclusiveTest}, label %\{loopBody}, label %\{loopEnd}")
        createBlock(forwardExclusive, out)
        def forwardExclusiveTest := nextVar()
        out.printLine("\{forwardExclusiveTest} = fcmp olt \{numberType} \{indexValue}, \{end}")
        out.printLine("br i1 \{forwardExclusiveTest}, label %\{loopBody}, label %\{loopEnd}")
        createBlock(loopBody, out)
        writeStatement(block, out)
        if !endsWithBranch(block) {
            out.printLine("br label %\{loopInc}")
        }
        createBlock(loopInc, out)
        def inc := nextVar()
        out.printLine("\{inc} = fadd \{numberType} \{indexValue}, 1.0")
        def incStruct := nextVar()
        out.printLine("\{incStruct} = insertvalue \{indexType} { \{numberType} undef")
        out.printLine(" }, \{numberType} \{inc}, 0")
        out.printLine("store \{indexType} \{incStruct}, \{indexType}* \{index}")
        out.printLine("br label %\{loopStart}")

        createBlock(loopEnd, out)
        loopDescriptors.pop()
    }

    method writeSteppedRealRangeFor(f:IRNode, out:OutputStream) {
        assert f.kind = IRNode.Kind.RANGE_FOR
        assert f.children.get_count() = 3
        def target := f.children[0]
        assert f.children[1].type.typeKind = Type.Kind.GENERIC
        assert f.children[1].type.subtypes.get_count() = 3
        assert f.children[1].type.subtypes[0].name = Compiler.STEPPED_RANGE_NAME
        def range := getTypedReference(f.children[1], out)
        def block := f.children[2]
        def t := f.children[1].type.subtypes[1]
        def llt := type(t)
        def indexType:String
        if t.typeKind = Type.Kind.NULLABLE {
            assert t.subtypes.get_count() = 1
            indexType := type(t.subtypes[0])
        }
        else {
            indexType := llt
        }
        def cl := compiler.getClass(t)
        assert cl != null
        assert compiler.instanceFields(cl).get_count() = 1
        def numberType := type(compiler.instanceFields(cl)[0].type)
        assert target.kind = IRNode.Kind.VARIABLE_REFERENCE
        def index := getName(target.payload->Variable)
        methodHeader.printLine("\{index} = alloca \{indexType}")

        -- extract start value from range
        def start := nextVar()
        out.printLine("\{start} = extractvalue \{range}, 0, 0")

        -- store start value
        def indexValuePtr := nextVar()
        out.printLine("\{indexValuePtr} = getelementptr \{indexType}, \{indexType}* \{index}, " +
                "i64 0, i32 0")
        out.printLine("store \{numberType} \{start}, \{numberType}* \{indexValuePtr}")

        -- extract end value from range
        def end := nextVar()
        out.printLine("\{end} = extractvalue \{range}, 1, 0")

        -- extract step value from range
        def step := nextVar()
        out.printLine("\{step} = extractvalue \{range}, 2, 0")

        -- extract inclusive / exclusive from range
        def inclusive := nextVar()
        out.printLine("\{inclusive} = extractvalue \{range}, 3, 0")

        -- start block
        def loopStart := nextLabel()
        def loopBody := nextLabel()
        def loopEnd := nextLabel()
        def loopInc := nextLabel()
        loopDescriptors.push(LoopDescriptor(f.payload->String?, loopEnd, loopInc)) -- FIXME Auto
        def forward := nextLabel()
        def backward := nextLabel()
        def direction:String
        direction := nextVar()
        out.printLine("\{direction} = fcmp ogt \{numberType} \{step}, 0.0")
        out.printLine("br label %\{loopStart}")
        createBlock(loopStart, out)
        def indexValue := nextVar()
        out.printLine("\{indexValue} = load \{numberType}, \{numberType}* \{indexValuePtr}")
        out.printLine("br i1 \{direction}, label %\{forward}, label %\{backward}")
        createBlock(forward, out)
        def forwardInclusive := nextLabel()
        def forwardExclusive := nextLabel()
        out.printLine("br i1 \{inclusive}, label %\{forwardInclusive}, " +
                "label %\{forwardExclusive}")
        createBlock(forwardInclusive, out)
        def forwardInclusiveTest := nextVar()
        out.printLine("\{forwardInclusiveTest} = fcmp ole \{numberType} \{indexValue}, \{end}")
        out.printLine("br i1 \{forwardInclusiveTest}, label %\{loopBody}, label %\{loopEnd}")
        createBlock(forwardExclusive, out)
        def forwardExclusiveTest := nextVar()
        out.printLine("\{forwardExclusiveTest} = fcmp olt \{numberType} \{indexValue}, \{end}")
        out.printLine("br i1 \{forwardExclusiveTest}, label %\{loopBody}, label %\{loopEnd}")
        createBlock(backward, out)
        def backwardInclusive := nextLabel()
        def backwardExclusive := nextLabel()
        out.printLine("br i1 \{inclusive}, label %\{backwardInclusive}, " +
                "label %\{backwardExclusive}")
        createBlock(backwardInclusive, out)
        def backwardInclusiveTest := nextVar()
        out.printLine("\{backwardInclusiveTest} = fcmp oge \{numberType} \{indexValue}, \{end}")
        out.printLine("br i1 \{backwardInclusiveTest}, label %\{loopBody}, label %\{loopEnd}")
        createBlock(backwardExclusive, out)
        def backwardExclusiveTest := nextVar()
        out.printLine("\{backwardExclusiveTest} = fcmp ogt \{numberType} \{indexValue}, \{end}")
        out.printLine("br i1 \{backwardExclusiveTest}, label %\{loopBody}, label %\{loopEnd}")
        createBlock(loopBody, out)
        writeStatement(block, out)
        if !endsWithBranch(block) {
            out.printLine("br label %\{loopInc}")
        }
        createBlock(loopInc, out)
        def inc := nextVar()
        out.printLine("\{inc} = fadd \{numberType} \{indexValue}, \{step}")
        def incStruct := nextVar()
        out.printLine("\{incStruct} = insertvalue \{indexType} { \{numberType} undef")
        out.printLine(" }, \{numberType} \{inc}, 0")
        out.printLine("store \{indexType} \{incStruct}, \{indexType}* \{index}")
        out.printLine("br label %\{loopStart}")

        createBlock(loopEnd, out)
        loopDescriptors.pop()
    }

    method writeSimpleRangeFor(f:IRNode, out:OutputStream) {
        -- this could probably be simplified quite a bit; it's just a cut-down version of
        -- writeSteppedRangeFor
        assert f.kind = IRNode.Kind.RANGE_FOR
        assert f.children.get_count() = 3
        def target := f.children[0]
        assert f.children[1].type.typeKind = Type.Kind.GENERIC
        assert f.children[1].type.subtypes.get_count() = 2
        assert f.children[1].type.subtypes[0].name = Compiler.RANGE_NAME
        def range := getTypedReference(f.children[1], out)
        def block := f.children[2]
        def t := f.children[1].type.subtypes[1]
        def llt := type(t)
        def indexType:String
        if t.typeKind = Type.Kind.NULLABLE {
            assert t.subtypes.get_count() = 1
            indexType := type(t.subtypes[0])
        }
        else {
            indexType := llt
        }
        def cl := compiler.getClass(t)
        assert cl != null
        assert compiler.instanceFields(cl).get_count() = 1
        def numberType := type(compiler.instanceFields(cl)[0].type)
        assert target.kind = IRNode.Kind.VARIABLE_REFERENCE
        def index := getName(target.payload->Variable)
        methodHeader.printLine("\{index} = alloca \{indexType}")

        -- extract start value from range
        def start := nextVar()
        out.printLine("\{start} = extractvalue \{range}, 0, 0")

        -- store start value
        def indexValuePtr := nextVar()
        out.printLine("\{indexValuePtr} = getelementptr \{indexType}, \{indexType}* \{index}, " +
                "i64 0, i32 0")
        out.printLine("store \{numberType} \{start}, \{numberType}* \{indexValuePtr}")

        -- extract end value from range
        def end := nextVar()
        out.printLine("\{end} = extractvalue \{range}, 1, 0")

        -- extract inclusive / exclusive from range
        def inclusive := nextVar()
        out.printLine("\{inclusive} = extractvalue \{range}, 2, 0")

        -- start block
        def loopStart := nextLabel()
        def loopBody := nextLabel()
        def loopEnd := nextLabel()
        def loopTest := nextLabel()
        loopDescriptors.push(LoopDescriptor(f.payload->String?, loopEnd, loopTest)) -- FIXME Auto
        def forwardEntry := nextLabel()
        def backwardEntry := nextLabel()
        def signPrefix:String
        if t.name.startsWith("panda.core.Int") {
            signPrefix := "s"
        }
        else {
            assert t.name.startsWith("panda.core.UInt") | t.name.startsWith("panda.core.Char")
            signPrefix := "u"
        }
        def forwardEntryInclusive := nextLabel()
        def forwardEntryExclusive := nextLabel()
        out.printLine("br i1 \{inclusive}, label %\{forwardEntryInclusive}, " +
                "label %\{forwardEntryExclusive}")
        createBlock(forwardEntryInclusive, out)
        def forwardEntryInclusiveTest := nextVar()
        out.printLine("\{forwardEntryInclusiveTest} = icmp \{signPrefix}le \{numberType} " +
                "\{start}, \{end}")
        out.printLine("br i1 \{forwardEntryInclusiveTest}, label %\{loopStart}, label %\{loopEnd}")
        createBlock(forwardEntryExclusive, out)
        def forwardEntryExclusiveTest := nextVar()
        out.printLine("\{forwardEntryExclusiveTest} = icmp \{signPrefix}lt \{numberType} " +
                "\{start}, \{end}")
        out.printLine("br i1 \{forwardEntryExclusiveTest}, label %\{loopStart}, label %\{loopEnd}")
        createBlock(loopStart, out)
        def indexValue := nextVar()
        out.printLine("\{indexValue} = load \{numberType}, \{numberType}* \{indexValuePtr}")
        writeStatement(block, out)
        if !endsWithBranch(block) {
            out.printLine("br label %\{loopTest}")
        }
        createBlock(loopTest, out)
        def loopInc := nextLabel()
        def forwardDelta := nextVar()
        out.printLine("\{forwardDelta} = sub \{numberType} \{end}, \{indexValue}")

        -- forward loop; determine inclusive / exclusive
        def forwardInclusiveLabel := nextLabel()
        def forwardExclusiveLabel := nextLabel()
        out.printLine("br i1 \{inclusive}, label %\{forwardInclusiveLabel}, label %" +
                forwardExclusiveLabel)

        -- forward inclusive test
        createBlock(forwardInclusiveLabel, out)
        def forwardInclusiveTest := nextVar()
        -- always use unsigned comparison to avoid overflow; we know both the delta and the step are
        -- the same sign
        out.printLine("\{forwardInclusiveTest} = icmp uge \{numberType} \{forwardDelta}, 1")
        out.printLine("br i1 \{forwardInclusiveTest}, label %\{loopInc}, label %\{loopEnd}")
        createBlock(forwardExclusiveLabel, out)

        -- forward exclusive test
        def forwardExclusiveTest := nextVar()
        out.printLine("\{forwardExclusiveTest} = icmp ugt \{numberType} \{forwardDelta}, 1")
        out.printLine("br i1 \{forwardExclusiveTest}, label %\{loopInc}, label %\{loopEnd}")

        createBlock(loopInc, out)
        def inc := nextVar()
        out.printLine("\{inc} = add \{numberType} \{indexValue}, 1")
        def incStruct := nextVar()
        out.printLine("\{incStruct} = insertvalue \{indexType} { \{numberType} undef")
        out.printLine(" }, \{numberType} \{inc}, 0")
        out.printLine("store \{indexType} \{incStruct}, \{indexType}* \{index}")
        out.printLine("br label %\{loopStart}")

        createBlock(loopEnd, out)
        loopDescriptors.pop()
    }

    method writeSteppedRangeFor(f:IRNode, out:OutputStream) {
        -- I am acutely aware of how horrific this looks.
        --
        -- There's no easy way to produce clean output here, since we have to handle different step
        -- values, different loop directions, and both inclusive and exclusive ranges, all of which
        -- could potentially be determined at runtime. It gets even uglier when you consider the
        -- difficulty of handling the extremes of the numeric types. You can't just add 1 and then
        -- check to see if it's in range when the limit is MAX_INT, because you'll overflow and end
        -- up with an infinite loop. You also can't just check for being equal to the limit before
        -- adding the step, because with a step bigger than 1 (or smaller than -1) you might need to
        -- stop before actually hitting the end. So you instead check the difference between the
        -- current index and the limit, but even there you need to be careful because it could
        -- overflow in a signed test, and we need to handle null values, and... ugh, it's
        -- surprisingly messy and results in a ton of code.
        --
        -- Fortunately, we can just write incredibly awful-but-straightforward code and let LLVM
        -- optimize it to something sensible if it turns out the values are known at compile time.
        -- This works remarkably well, because LLVM is awesome.
        assert f.kind = IRNode.Kind.RANGE_FOR
        assert f.children.get_count() = 3
        def target := f.children[0]
        assert f.children[1].type.typeKind = Type.Kind.GENERIC
        assert f.children[1].type.subtypes.get_count() = 3
        assert f.children[1].type.subtypes[0].name = Compiler.STEPPED_RANGE_NAME
        def range := getTypedReference(f.children[1], out)
        def block := f.children[2]
        def t := f.children[1].type.subtypes[1]
        def stepType := f.children[1].type.subtypes[2]
        def llt := type(t)
        def indexType:String
        if t.typeKind = Type.Kind.NULLABLE {
            assert t.subtypes.get_count() = 1
            indexType := type(t.subtypes[0])
        }
        else {
            indexType := llt
        }
        def cl := compiler.getClass(t)
        assert cl != null
        assert compiler.instanceFields(cl).get_count() = 1
        def numberType := type(compiler.instanceFields(cl)[0].type)
        assert target.kind = IRNode.Kind.VARIABLE_REFERENCE
        def index := getName(target.payload->Variable)
        methodHeader.printLine("\{index} = alloca \{indexType}")

        -- extract start value from range
        def start := nextVar()
        out.printLine("\{start} = extractvalue \{range}, 0, 0")

        -- store start value
        def indexValuePtr := nextVar()
        out.printLine("\{indexValuePtr} = getelementptr \{indexType}, \{indexType}* \{index}, " +
                "i64 0, i32 0")
        out.printLine("store \{numberType} \{start}, \{numberType}* \{indexValuePtr}")

        -- extract end value from range
        def end := nextVar()
        out.printLine("\{end} = extractvalue \{range}, 1, 0")

        -- extract step value from range
        def step := nextVar()
        out.printLine("\{step} = extractvalue \{range}, 2, 0")

        -- extract inclusive / exclusive from range
        def inclusive := nextVar()
        out.printLine("\{inclusive} = extractvalue \{range}, 3, 0")

        -- start block
        def loopStart := nextLabel()
        def loopBody := nextLabel()
        def loopEnd := nextLabel()
        def loopTest := nextLabel()
        loopDescriptors.push(LoopDescriptor(f.payload->String?, loopEnd, loopTest)) -- FIXME Auto
        def forwardEntry := nextLabel()
        def backwardEntry := nextLabel()
        def signPrefix:String
        if stepType.name.startsWith("panda.core.Int") {
            signPrefix := "s"
        }
        else {
            assert stepType.name.startsWith("panda.core.UInt") |
                    stepType.name.startsWith("panda.core.Char")
            signPrefix := "u"
        }
        def direction:String
        if signPrefix = "s" {
            direction := nextVar()
            out.printLine("\{direction} = icmp sge \{numberType} \{step}, 0")
        }
        else {
            direction := "1"
        }
        out.printLine("br i1 \{direction}, label %\{forwardEntry}, label %\{backwardEntry}")
        createBlock(forwardEntry, out)
        def forwardEntryInclusive := nextLabel()
        def forwardEntryExclusive := nextLabel()
        out.printLine("br i1 \{inclusive}, label %\{forwardEntryInclusive}, " +
                "label %\{forwardEntryExclusive}")
        createBlock(forwardEntryInclusive, out)
        def forwardEntryInclusiveTest := nextVar()
        out.printLine("\{forwardEntryInclusiveTest} = icmp \{signPrefix}le \{numberType} " +
                "\{start}, \{end}")
        out.printLine("br i1 \{forwardEntryInclusiveTest}, label %\{loopStart}, label %\{loopEnd}")
        createBlock(forwardEntryExclusive, out)
        def forwardEntryExclusiveTest := nextVar()
        out.printLine("\{forwardEntryExclusiveTest} = icmp \{signPrefix}lt \{numberType} " +
                "\{start}, \{end}")
        out.printLine("br i1 \{forwardEntryExclusiveTest}, label %\{loopStart}, label %\{loopEnd}")
        createBlock(backwardEntry, out)
        def backwardEntryInclusive := nextLabel()
        def backwardEntryExclusive := nextLabel()
        out.printLine("br i1 \{inclusive}, label %\{backwardEntryInclusive}, " +
                "label %\{backwardEntryExclusive}")
        createBlock(backwardEntryInclusive, out)
        def backwardEntryInclusiveTest := nextVar()
        out.printLine("\{backwardEntryInclusiveTest} = icmp \{signPrefix}ge \{numberType} " +
                "\{start}, \{end}")
        out.printLine("br i1 \{backwardEntryInclusiveTest}, label %\{loopStart}, label %\{loopEnd}")
        createBlock(backwardEntryExclusive, out)
        def backwardEntryExclusiveTest := nextVar()
        out.printLine("\{backwardEntryExclusiveTest} = icmp \{signPrefix}gt \{numberType} " +
                "\{start}, \{end}")
        out.printLine("br i1 \{backwardEntryExclusiveTest}, label %\{loopStart}, label %\{loopEnd}")
        createBlock(loopStart, out)
        def indexValue := nextVar()
        out.printLine("\{indexValue} = load \{numberType}, \{numberType}* \{indexValuePtr}")
        writeStatement(block, out)
        if !endsWithBranch(block) {
            out.printLine("br label %\{loopTest}")
        }
        createBlock(loopTest, out)
        def loopInc := nextLabel()
        -- beginning of loop test, determine direction
        def forwardLabel := nextLabel()
        def backwardLabel := nextLabel()
        out.printLine("br i1 \{direction}, label %\{forwardLabel}, label %\{backwardLabel}")

        -- forward loop; perform the test by subtracting index from end and then comparing to step,
        -- to avoid overflows near the maximum value
        createBlock(forwardLabel, out)
        def forwardDelta := nextVar()
        out.printLine("\{forwardDelta} = sub \{numberType} \{end}, \{indexValue}")

        -- forward loop; determine inclusive / exclusive
        def forwardInclusiveLabel := nextLabel()
        def forwardExclusiveLabel := nextLabel()
        out.printLine("br i1 \{inclusive}, label %\{forwardInclusiveLabel}, label %" +
                forwardExclusiveLabel)

        -- forward inclusive test
        createBlock(forwardInclusiveLabel, out)
        def forwardInclusiveTest := nextVar()
        -- always use unsigned comparison to avoid overflow; we know both the delta and the step are
        -- the same sign
        out.printLine("\{forwardInclusiveTest} = icmp uge \{numberType} \{forwardDelta}, \{step}")
        out.printLine("br i1 \{forwardInclusiveTest}, label %\{loopInc}, label %\{loopEnd}")
        createBlock(forwardExclusiveLabel, out)

        -- forward exclusive test
        def forwardExclusiveTest := nextVar()
        out.printLine("\{forwardExclusiveTest} = icmp ugt \{numberType} \{forwardDelta}, \{step}")
        out.printLine("br i1 \{forwardExclusiveTest}, label %\{loopInc}, label %\{loopEnd}")

        -- backward loop; perform the test by subtracting end from index and then comparing to
        -- -step, to avoid overflows near the minimum value
        createBlock(backwardLabel, out)
        def backwardDelta := nextVar()
        out.printLine("\{backwardDelta} = sub \{numberType} \{indexValue}, \{end}")
        def negStep := nextVar()
        out.printLine("\{negStep} = sub \{numberType} 0, \{step}")

        -- backward loop; determine inclusive / exclusive
        def backwardInclusiveLabel := nextLabel()
        def backwardExclusiveLabel := nextLabel()
        out.printLine("br i1 \{inclusive}, label %\{backwardInclusiveLabel}, label %" +
                backwardExclusiveLabel)

        -- backward inclusive test
        createBlock(backwardInclusiveLabel, out)
        def backwardInclusiveTest := nextVar()
        out.printLine("\{backwardInclusiveTest} = icmp uge \{numberType} \{backwardDelta}, " +
                negStep)
        out.printLine("br i1 \{backwardInclusiveTest}, label %\{loopInc}, label %\{loopEnd}")
        createBlock(backwardExclusiveLabel, out)

        -- backward exclusive test
        def backwardExclusiveTest := nextVar()
        out.printLine("\{backwardExclusiveTest} = icmp ugt \{numberType} \{backwardDelta}, " +
                negStep)
        out.printLine("br i1 \{backwardExclusiveTest}, label %\{loopInc}, label %\{loopEnd}")

        createBlock(loopInc, out)
        def inc := nextVar()
        out.printLine("\{inc} = add \{numberType} \{indexValue}, \{step}")
        def incStruct := nextVar()
        out.printLine("\{incStruct} = insertvalue \{indexType} { \{numberType} undef")
        out.printLine(" }, \{numberType} \{inc}, 0")
        out.printLine("store \{indexType} \{incStruct}, \{indexType}* \{index}")
        out.printLine("br label %\{loopStart}")

        createBlock(loopEnd, out)
        loopDescriptors.pop()
    }

    method writeRangeFor(f:IRNode, out:OutputStream) {
        if f.children[1].type.subtypes[1].isReal() {
            if f.children[1].type.isRange() {
                writeSimpleRealRangeFor(f, out)
            }
            else {
                writeSteppedRealRangeFor(f, out)
            }
        }
        else if f.children[1].type.isRange() {
            writeSimpleRangeFor(f, out)
        }
        else {
            writeSteppedRangeFor(f, out)
        }
    }

    method writeWhile(w:IRNode, out:OutputStream) {
        assert w.kind = IRNode.Kind.WHILE
        assert w.children.get_count() = 2
        assert w.children[0].type = Type.Bit()
        def loopStart := nextLabel()
        def loopBody := nextLabel()
        def loopEnd := nextLabel()
        loopDescriptors.push(LoopDescriptor(w.payload->String?, loopEnd, loopStart)) -- FIXME Auto
        out.printLine("br label %\{loopStart}")
        createBlock(loopStart, out)
        def test := getTypedReference(w.children[0], out)
        def testBit := nextVar()
        out.printLine("\{testBit} = extractvalue \{test}, 0")
        out.printLine("br i1 \{testBit}, label %\{loopBody}, label %\{loopEnd}")
        createBlock(loopBody, out)
        writeStatement(w.children[1], out)
        if !endsWithBranch(w.children[1]) {
            out.printLine("br label %\{loopStart}")
        }
        createBlock(loopEnd, out)
        loopDescriptors.pop()
    }

    method writeDo(d:IRNode, out:OutputStream) {
        assert d.kind = IRNode.Kind.DO
        assert d.children.get_count() = 2
        assert d.children[1].type = Type.Bit()
        def loopStart := nextLabel()
        def loopBody := nextLabel()
        def loopEnd := nextLabel()
        loopDescriptors.push(LoopDescriptor(d.payload->String?, loopEnd, loopStart)) -- FIXME Auto
        out.printLine("br label %\{loopBody}")
        createBlock(loopStart, out)
        def test := getTypedReference(d.children[1], out)
        def testBit := nextVar()
        out.printLine("\{testBit} = extractvalue \{test}, 0")
        out.printLine("br i1 \{testBit}, label %\{loopBody}, label %\{loopEnd}")
        createBlock(loopBody, out)
        writeStatement(d.children[0], out)
        if !endsWithBranch(d.children[0]) {
            out.printLine("br label %\{loopStart}")
        }
        createBlock(loopEnd, out)
        loopDescriptors.pop()
    }

    method writeLoop(l:IRNode, out:OutputStream) {
        assert l.kind = IRNode.Kind.LOOP
        assert l.children.get_count() = 1
        def loopStart := nextLabel()
        def loopEnd := nextLabel()
        loopDescriptors.push(LoopDescriptor(l.payload->String?, loopEnd, loopStart))
        out.printLine("br label %\{loopStart}")
        createBlock(loopStart, out)
        writeStatement(l.children[0], out)
        if !endsWithBranch(l.children[0]) {
            out.printLine("br label %\{loopStart}")
        }
        createBlock(loopEnd, out)
        loopDescriptors.pop()
    }

    method writeVarTarget(target:IRNode, value:IRNode?, out:OutputStream) {
        match target.kind {
            when IRNode.Kind.VARIABLE_REFERENCE:
                def v := target.payload->Variable
                methodHeader.printLine("\{getName(v)} = alloca \{type(v.type)}")
                if value != null {
                    def ref := getTypedReference(value, out)
                    out.printLine("store \{ref}, \{type(v.type)}* \{getName(v)}")
                }
            when IRNode.Kind.TUPLE_TARGET:
                assert false
            otherwise:
                assert false
        }
    }

    method writeVar(v:IRNode, out:OutputStream) {
        assert v.kind = IRNode.Kind.VAR |
                v.kind = IRNode.Kind.DEF |
                v.kind = IRNode.Kind.PROPERTY |
                v.kind = IRNode.Kind.CONSTANT
        for decl in v.children {
            assert decl.kind = IRNode.Kind.DECLARATION
            if decl.children.get_count() > 1 {
                writeVarTarget(decl.children[0], decl.children[1], out)
            }
            else {
                writeVarTarget(decl.children[0], null, out)
            }
        }
    }

    method getLValue(lvalue:IRNode, out:OutputStream):String {
        match lvalue.kind {
            when IRNode.Kind.CAST:
                return getLValue(compiler.unwrapCast(lvalue), out)
            when IRNode.Kind.VARIABLE_REFERENCE:
                return getName(lvalue.payload->Variable)
            when IRNode.Kind.FIELD_REFERENCE:
                def base:String
                if lvalue.children[0].kind = IRNode.Kind.SELF {
                    base := getSelfPointer()
                }
                else {
                    base := getReference(lvalue.children[0], out)
                }
                def raw := nextVar()
                def cl := compiler.getClass(lvalue.children[0].type)
                assert cl != null
                def f := lvalue.payload->FieldDecl
                def fields := compiler.instanceFields(cl)
                var index := -1
                for i in 0 .. fields.get_count() {
                    if fields[i].name == f.name {
                        index := i
                        break
                    }
                }
                assert index != -1
                out.printLine("\{raw} = getelementptr inbounds \{typeName(cl.type())}, " +
                        "\{typeName(cl.type())}* \{base}, i64 0, i32 \{index}")
                if !f.type.isClass() | compiler.isValue(compiler.getClass(f.type)) {
                    return raw
                }
                def result := nextVar()
                out.printLine("\{result} = bitcast i8** \{raw} to \{type(lvalue.type)}*")
                return result
            when IRNode.Kind.REUSED_VALUE_DEFINITION:
                def result := getLValue(lvalue.children[0], out)
                def reused := nextVar()
                out.printLine("\{reused} = load \{type(lvalue.type)}, " +
                        "\{type(lvalue.type)}* \{result}")
                reusedValues[lvalue.payload->UInt64] := reused
                return result
            otherwise:
                assert false, "unsupported lvalue: \{lvalue}"
        }
    }

    method writeAssignment(a:IRNode, out:OutputStream) {
        assert a.kind = IRNode.Kind.BINARY
        assert a.children.get_count() = 2
        def lvalue := "\{type(a.children[0].type)}* \{getLValue(a.children[0], out)}"
        def value:String
        def t := type(a.children[0].type)
        def op := a.payload->Int
        if op = Token.Kind.ASSIGNMENT {
            def right := getReference(a.children[1], out)
            value := "\{t} \{right}"
        }
        else {
-*            Operator binOp;
            switch (op) {
                case Operator.ADDEQ:        binOp = Operator.ADD;                         break;
                case Operator.SUBEQ:        binOp = Operator.SUB;                         break;
                case Operator.MULEQ:        binOp = Operator.MUL;                         break;
                case Operator.DIVEQ:        binOp = Operator.DIV;                         break;
                case Operator.INTDIVEQ:     binOp = Operator.INTDIV;                      break;
                case Operator.REMEQ:        binOp = Operator.REM;                         break;
                case Operator.POWEQ:        binOp = Operator.POW;                         break;
                case Operator.XOREQ:        binOp = Operator.XOR;                         break;
                case Operator.BITWISEOREQ:  binOp = Operator.BITWISEOR;                   break;
                case Operator.BITWISEANDEQ: binOp = Operator.BITWISEAND;                  break;
                case Operator.BITWISEXOREQ: binOp = Operator.BITWISEXOR;                  break;
                case Operator.SHIFTLEFTEQ:  binOp = Operator.SHIFTLEFT;                   break;
                case Operator.SHIFTRIGHTEQ: binOp = Operator.SHIFTRIGHT;                  break;
                case Operator.ANDEQ:        this->writeAndEq(lvalue, a.fChildren[1], out); return;
                case Operator.OREQ:         this->writeOrEq(lvalue, a.fChildren[1], out);  return;
                default: abort();
            }
            def left := nextVar()
            out << "    " << left << " = load " << this->llvmType(a.fChildren[0].fType) << ", " <<
                    lvalue << "\n";
            String right = this->getReference(a.fChildren[1], out);
            value = type + " " +
                    this->getBinaryReference(op_class(a.fChildren[0].fType), type + " " + left, binOp,
                            right, out);
            *-
            assert false
        }
        out.printLine("store \{value}, \{lvalue}")
    }

    method writeReturn(r:IRNode, out:OutputStream) {
        if r.children != null & r.children.get_count() > 0 {
            assert r.children.get_count() = 1
            if inlineContext.get_count() > 0 {
                def inline := inlineContext.peek()
                def result := getReference(r.children[0], out)
                inline.returns.add(Pair<String, String>(currentBlock, result))
                out.printLine("br label %\{inline.exitLabel}")
            }
            else {
                out.printLine("ret \{getTypedReference(r.children[0], out)}")
            }
        }
        else {
            if inlineContext.get_count() > 0 {
                out.printLine("br label %\{inlineContext.peek().exitLabel}")
            }
            else {
                out.printLine("ret void")
            }
        }
    }

    function findLoop(name:String?):LoopDescriptor {
        assert loopDescriptors.get_count() > 0
        if name = null {
            return loopDescriptors.peek()
        }
        for i in 0 .. loopDescriptors.get_count() {
            if loopDescriptors.peek(i).loopLabel != null & loopDescriptors.peek(i).loopLabel = name { -- FIXME shouldn't need null check
                return loopDescriptors.peek(i)
            }
        }
        assert false
    }

    method writeBreak(b:IRNode, out:OutputStream) {
        def desc := findLoop(b.payload->String?)
        out.printLine("br label %\{desc.breakLabel}")
    }

    method writeContinue(c:IRNode, out:OutputStream) {
        def desc := findLoop(c.payload->String?)
        out.printLine("br label %\{desc.continueLabel}")
    }

    method writeAssert(a:IRNode, out:OutputStream) {
        assert a.kind = IRNode.Kind.ASSERT
        assert a.children.get_count() = 1 | a.children.get_count() = 2
        if compiler.settings.safetyLevel < 2 {
            return
        }
        def test := getReference(a.children[0], out)
        def ifTrue := nextLabel()
        def ifFalse := nextLabel()
        out.printLine("br i1 \{test}, label %\{ifTrue}, label %\{ifFalse}")
        createBlock(ifFalse, out)
        def name:String
        def path := compiler.currentClass.peek().source.path
        def index := path.lastIndexOf("/")
        if index = null {
            name := path
        }
        else {
            name := path[path.next(index)...]
        }
        def nameRef := getStringReference(name, out)
        def line := "%panda$core$Int64 { i64 \{a.position.line} }"
        def msg:String?
        if a.children.get_count() = 2 {
            msg := getReference(a.children[1], out)
        }
        else {
            msg := null
        }
        out.print("call fastcc void ")
        for m in compiler.getClass(Type.Panda()).methods {
            if m.name = "assertionFailure" {
                compiler.resolve(m)
                writeDeclaration(m)
            }
        }
        if msg != null {
            out.print("@panda$core$Panda$assertionFailure$" +
                    "panda$core$String$panda$core$Int64$panda$core$String")
        }
        else {
            out.print("@panda$core$Panda$assertionFailure$panda$core$String$panda$core$Int64")
        }
        out.print("(%panda$core$String* \{nameRef}, \{line}")
        if msg != null {
            out.print(", %panda$core$String* \{msg}")
        }
        out.printLine(")")
        out.printLine("unreachable")
        createBlock(ifTrue, out)
    }

    method writeMatch(m:IRNode, out:OutputStream) {
        assert m.kind = IRNode.Kind.MATCH
        def valueStruct := getTypedReference(m.children[0], out)
        def numberClass := compiler.getClass(m.children[0].type)
        def value := nextVar()
        out.printLine("\{value} = extractvalue \{valueStruct}, 0")
        def f := numberClass.symbolTable["value"]->FieldDecl
        compiler.resolve(f)
        def switchType := type(f.type)
        out.print("switch \{switchType} \{value}, ")
        def endLabel := nextLabel()
        def whenLabels := Array<String>()
        def otherwiseLabel:String
        if m.children[m.children.get_count() - 1].kind = IRNode.Kind.OTHERWISE {
            otherwiseLabel := nextLabel()
        }
        else {
            otherwiseLabel := endLabel
        }
        out.printLine("label %\{otherwiseLabel} [")
        for i in 1 .. m.children.get_count() {
            def w := m.children[i]
            if w.kind = IRNode.Kind.OTHERWISE {
                continue
            }
            assert w.kind = IRNode.Kind.WHEN
            def label := nextLabel()
            whenLabels.add(label)
            for i in 0 .. w.children.get_count() - 1 {
                def number := compiler.getConstantInt(w.children[i])
                out.printLine("        \{switchType} \{number}, label %\{label}")
            }
        }
        out.printLine("    ]")
        for i in 1 .. m.children.get_count() {
            def w := m.children[i]
            def block := w.children[w.children.get_count() - 1]
            if i - 1 >= whenLabels.get_count() {
                createBlock(otherwiseLabel, out)
            }
            else {
                createBlock(whenLabels[i - 1], out)
            }
            writeBlock(block, out)
            if !endsWithBranch(block) {
                out.printLine("br label %\{endLabel}")
            }
        }
        createBlock(endLabel, out)
    }

    method writeStatement(stmt:IRNode, out:OutputStream) {
        match stmt.kind {
            when IRNode.Kind.BINARY:
                writeAssignment(stmt, out)
            when IRNode.Kind.BLOCK:
                writeBlock(stmt, out)
            when IRNode.Kind.CALL:
                writeCall(stmt, null, out)
            when IRNode.Kind.IF:
                writeIf(stmt, out)
            when IRNode.Kind.RANGE_FOR:
                writeRangeFor(stmt, out)
            when IRNode.Kind.WHILE:
                writeWhile(stmt, out)
            when IRNode.Kind.DO:
                writeDo(stmt, out)
            when IRNode.Kind.LOOP:
                writeLoop(stmt, out)
            when IRNode.Kind.VAR, IRNode.Kind.DEF, IRNode.Kind.CONSTANT, IRNode.Kind.PROPERTY:
                writeVar(stmt, out)
            when IRNode.Kind.RETURN:
                writeReturn(stmt, out)
            when IRNode.Kind.BREAK:
                writeBreak(stmt, out)
            when IRNode.Kind.CONTINUE:
                writeContinue(stmt, out)
            when IRNode.Kind.ASSERT:
                writeAssert(stmt, out)
            when IRNode.Kind.MATCH:
                writeMatch(stmt, out)
            otherwise:
                assert false, "unsupported statement \{stmt}"
        }
    }

    method selfType(m:MethodDecl):String {
        def result := type(m.owner.type())
        if m.methodKind = MethodDecl.Kind.INIT & !result.endsWith("*") {
            return result + "*"
        }
        return result
    }

    @override
    method writeDeclaration(m:MethodDecl) {
        def name := getName(m)
        if declared.contains(name) {
            return
        }
        declared.add(name)
        declarations.print("declare \{callingConvention(m)}")
        def needsIndirection := needsStructIndirection(m)
        if needsIndirection {
            declarations.print("void")
        }
        else {
            declarations.print(type(m.returnType))
        }
        declarations.print(" \{getName(m)}(")
        var separator := ""
        if needsIndirection {
            declarations.print("\{type(m.returnType)}*")
            separator := ", "
        }
        if !m.annotations.isClass() {
            declarations.print("\{separator}\{selfType(m)} %self")
            separator := ", "
        }
        for p in m.parameters {
            declarations.print("\{separator}\{type(p.type)} %\{escapeName(p.name)}")
            separator := ", "
        }
        declarations.printLine(")")
    }

    @override
    method write(m:MethodDecl, body:IRNode) {
        assert compiler.currentClass.peek() == m.owner,
                "compiling \{m.owner.name}.\{m.signature()} from within " +
                compiler.currentClass.peek().name
        currentMethod := m
        currentBlock := "0"
        varCount := 0
        methodHeader := MemoryOutputStream()
        methods.print("define ")
        if m.owner.isSpecialization() {
            methods.print("linkonce_odr ")
        }
        methods.print("\{callingConvention(m)}\{type(m.returnType)} \{getName(m)}(")
        var separator := ""
        if !m.annotations.isClass() {
            methods.print("\{selfType(m)} %self")
            separator := ", "
        }
        for p in m.parameters {
            methods.print("\{separator}\{type(p.type)} %\{escapeName(p.name)}")
            separator := ", "
        }
        methods.printLine(") {")
        assert body.kind = IRNode.Kind.BLOCK
        def bodyBuffer := MemoryOutputStream()
        for s in body.children {
            writeStatement(s, bodyBuffer)
        }
        methods.print(methodHeader.finish())
        methods.print(bodyBuffer.finish())
        if !endsWithBranch(body) {
            if m.returnType = Type.Void() {
                methods.printLine("ret void")
            }
            else {
                methods.printLine("unreachable")
            }
        }
        methods.printLine("}")
        currentMethod := null
    }

    @override
    method start(cl:ClassDecl) {
        if cl.annotations.isSpecialize() {
            return
        }
        writeType(cl.type())
        getClassConstant(cl)
    }

    @override
    method end(cl:ClassDecl) {
    }
}