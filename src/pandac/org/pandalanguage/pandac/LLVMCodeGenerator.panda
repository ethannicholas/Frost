package org.pandalanguage.pandac

uses org.pandalanguage.pandac.parser.Token

class LLVMCodeGenerator (CodeGenerator) {
    class ClassConstant : Immutable {
        def name:String
        def type:String

        init(name:String, type:String) {
            self.name := name
            self.type := type
        }
    }

    class LoopDescriptor : Immutable {
        def loopLabel:String?
        def breakLabel:String
        def continueLabel:String

        init(loopLabel:String?, breakLabel:String, continueLabel:String) {
            self.loopLabel := loopLabel
            self.breakLabel := breakLabel
            self.continueLabel := continueLabel
        }
    }

    constant POINTER_SIZE        := 8
    constant OBJECT_FIELD_COUNT  := 2
    constant CLASS_POINTER_INDEX := 0
    constant ITABLE_INDEX        := 2
    constant VTABLE_INDEX        := 3

    constant INT_TYPE := "i64"
    constant SIZE_T   := "i64"

    def out:OutputStream

    def compiler:Compiler

    def declarations := MemoryOutputStream()

    def types := MemoryOutputStream()

    def methodsBuffer := MemoryOutputStream()

    def methods := IndentedOutputStream(methodsBuffer)

    def methodHeaderBuffer := MemoryOutputStream()

    def methodHeader := IndentedOutputStream(methodHeaderBuffer)

    def strings := MemoryOutputStream()

    def declared := Set<String>()

    def writtenTypes := Set<String>()

    def writtenWrappers := Set<String>()

    def classConstants := HashMap<String, ClassConstant>()

    def variableNames := IdentityMap<Variable, String>()

    var currentBlock:String

    def loopDescriptors := Stack<LoopDescriptor>()

    var varCount := 0

    var labelCount := 0

    def reusedValues := HashMap<UInt64, String>()

    init(out:OutputStream) {
        self.out := IndentedOutputStream(out)

        out.printLine("target datalayout = \"e-p:64:64:64-i1:8:8-i8:8:8-i16:16:16-i32:32:32-i64:" +
                "64:64-f32:32:32-f64:64:64-v64:64:64-v128:128:128-a0:0:64-s0:64:64-f80:128:128-" +
                "n8:16:32:64-S128\"")
        out.printLine("target triple = \"x86_64-apple-macosx10.8.0\"")
--        out.printLine("target triple = \"x86_64-pc-linux-gnu\"")
        out.printLine("declare i8* @malloc(i64)")
        out.printLine("%$itable = type { %panda$core$Class*, %$itable*, [0 x i8*] }")
    }

    @override
    method setCompiler(compiler:Compiler) {
        self.compiler := compiler
    }

    @override
    method finish() {
        type(Type.Class())
        out.print(types.convert())
        out.print(strings.convert())
        out.print(declarations.convert())
        out.print(methodsBuffer.convert())
    }

    method nextVar():String {
        varCount += 1
        return "%\{varCount}"
    }

    method nextLabel():String {
        labelCount += 1
        return "$l\{labelCount}"
    }

    method createBlock(label:String, out:OutputStream) {
        out.printLine("\n\{label}:")
        currentBlock := label
    }

    function endsWithBranch(stmt:IRNode):Bit {
        match stmt.kind {
            when IRNode.Kind.BLOCK:
                if stmt.children.get_count() = 0 {
                    return false
                }
                return endsWithBranch(stmt.children[stmt.children.get_count() - 1])
            when IRNode.Kind.BREAK, IRNode.Kind.CONTINUE, IRNode.Kind.RETURN:
                return true
            otherwise: return false
        }
    }

    function fieldSize(t:Type):Int {
        assert t.resolved
        if t.isBuiltinNumber() {
            if t.name.endsWith("8") {
                return 1
            }
            if t.name.endsWith("16") {
                return 2
            }
            if t.name.endsWith("32") {
                return 4
            }
            assert t.name.endsWith("64")
            return 8
        }
        if t = Type.BuiltinBit() {
            return 1
        }
        def cl := compiler.getClass(t)
        assert cl != null
        if !compiler.isValue(cl) | cl.name = "panda.unsafe.Pointer" {
            return POINTER_SIZE
        }
        var result := 0
        for f in compiler.instanceFields(cl) {
            if f.annotations.isClass() {
                continue
            }
            compiler.resolve(f)
            def size := fieldSize(f.type)
            def align := result % size
            if align != 0 {
                result += size - align
            }
            assert result % size = 0
            result += size
        }
        if t.typeKind = Type.Kind.NULLABLE {
            result += 1
        }
        return result
    }

    function alignment(t:Type):Int {
        return fieldSize(t).min(8)
    }

    function sizeOf(t:Type):Int {
        if !t.isClass() {
            return fieldSize(t)
        }
        def cl := compiler.getClass(t)
        assert cl != null
        var result := 0
        for f in compiler.instanceFields(cl) {
            compiler.resolve(f)
            def size := fieldSize(f.type)
            def align := result % size
            if align != 0 {
                result += size - align
            }
            assert result % size = 0
            result += size
        }
        if compiler.isValue(cl) & t.typeKind = Type.Kind.NULLABLE {
            result += 1
        }
        return result
    }

    function sizeOfWrapper(t:Type):Int {
        def cl := compiler.getClass(t)
        assert cl != null & compiler.isValue(cl)
        var result := sizeOf(Type.Object())
        for f in compiler.instanceFields(cl) {
            compiler.resolve(f)
            def size := fieldSize(f.type)
            def align := result % size
            if align != 0 {
                result += size - align
            }
            assert result % size = 0
            result += size
        }
        if t.typeKind = Type.Kind.NULLABLE {
            result += 1
        }
        return result
    }

    method writeType(t:Type) {
        if writtenTypes.contains(t.name) {
            return
        }
        writtenTypes.add(t.name)
        def code := MutableString("%\{escapeName(t.name)} = type { ")
        def cl := compiler.getClass(t)
        assert cl != null
        var separator := ""
        for f in compiler.instanceFields(cl) {
            compiler.resolve(f)
            code.append("\{separator}\{type(f.type)}")
            separator := ", "
        }
        if t = Type.Class() {
            code.append(", %$itable*, [0 x i8*]")
        }
        code.append(" }")
        types.printLine(code)
    }

    method writeWrapperType(t:Type) {
        if writtenWrappers.contains(t.name) {
            return
        }
        writtenWrappers.add(t.name)
        def code := MutableString("\{type(t)}$wrapper = type { ")
        def object := compiler.getClass(Type.Object())
        assert object != null
        var separator := ""
        for f in compiler.instanceFields(object) {
            compiler.resolve(f)
            code.append("\{separator}\{type(f.type)}")
            separator := ", "
        }
        code.append(", \{type(t)}")
        code.append(" }")
        types.printLine(code)
        types.printLine("\{type(t)}$nullable = type { \{type(t)}, i1 }")
    }

    function typeName(t:Type):String {
        return "%" + escapeName(t.name)
    }

    method type(t:Type):String {
        match t.typeKind {
            when Type.Kind.VOID:
                return "void"
            when Type.Kind.BUILTIN_INT, Type.Kind.BUILTIN_UINT:
                return "i\{sizeOf(t) * 8}"
            when Type.Kind.BUILTIN_BIT:
                return "i1"
            when Type.Kind.CLASS:
                writeType(t)
                def name := "%\{escapeName(t.name)}"
                if t.isClass() {
                    def cl := compiler.getClass(t)
                    assert cl != null
                    if !compiler.isValue(cl) {
                        return name + "*"
                    }
                }
                return name
            when Type.Kind.NULLABLE:
                def cl := compiler.getClass(t)
                assert cl != null
                if compiler.isValue(cl) {
                    return nullableType(t)
                }
                return type(t.subtypes[0])
            when Type.Kind.GENERIC:
                if t.subtypes[0].name = "panda.unsafe.Pointer" {
                    return type(t.subtypes[1]) + "*"
                }
                return type(t.subtypes[0])
            when Type.Kind.GENERIC_PARAMETER:
                return type(t.subtypes[0])
            when Type.Kind.FUNCTION, Type.Kind.METHOD:
                def result := MutableString(type(t.subtypes[t.subtypes.get_count() - 1]))
                result.append(" (")
                for i in 0 .. t.subtypes.get_count() - 1 {
                    if i > 0 {
                        result.append(", ")
                    }
                    result.append(type(t.subtypes[i]))
                }
                result.append(")*")
                return result.convert()
            otherwise:
                assert false, "unsupported type '\{t}'"
        }
    }

    method wrapperTypeName(t:Type):String {
        if t.typeKind = Type.Kind.NULLABLE {
            return wrapperTypeName(t.subtypes[0])
        }
        writeWrapperType(t)
        return "%\{escapeName(t.name)}$wrapper"
    }

    method wrapperType(t:Type):String {
        return wrapperTypeName(t) + "*"
    }

    method nullableType(t:Type):String {
        assert t.typeKind = Type.Kind.NULLABLE, "\{t} is not nullable"
        return "\{type(t.subtypes[0])}$nullable"
    }

    method getITable(cl:ClassDecl):String {
        def interfaces := compiler.allInterfaces(cl.type())
        var previous := "%$itable* null"
        for intfType in interfaces {
            def intf := compiler.getClass(intfType)
            def intfCC := getClassConstant(intf)
            def methods := compiler.interfaceMethods(cl, intfType)
            def name := "@\{escapeName(cl.name)}$.\{escapeName(intf.name)}"
            def t := "{\{type(Type.Class())}, %$itable*, [\{methods.get_count()} x i8*] }"
            def result := MutableString("\{name} = constant \{t} { \{type(Type.Class())} " +
                    "bitcast(\{intfCC.type}* \{intfCC.name} to \{type(Type.Class())}), " +
                    "\{previous}, [\{methods.get_count()} x i8*][")
            var separator := ""
            for m in methods {
                result.append(separator)
                separator := ", "
                if m.annotations.isAbstract() {
                    result.append("i8* null")
                }
                else {
                    def entry := getMethodTableEntry(m)
                    result.append("i8* bitcast(\{entry.second} \{entry.first} to i8*)")
                }
            }
            result.append("] }\n")
            types.printLine(result)
            previous := "%$itable* bitcast(\{t}* \{name} to %$itable*)"
        }
        return previous
    }

    -- FIXME use tuple
    class Pair<A, B> {
        def first:A
        def second:B

        init(first:A, second:B) {
            self.first := first
            self.second := second
        }
    }

    ================================================================================================
    Returns true if this is an external method returning a struct.

    Returning structs from C functions into LLVM code is tricky. I tried it the naive and obvious
    way, and found it didn't work. Some cursory research indicated that C functions that return
    structs are at least sometimes compiled to accept a special pointer ("sret") as an extra
    parameter, and the caller is expected to know to alloca space for the return value and pass in a
    pointer to it.

    Since online sources were complaining about how poorly documented this is, there were
    indications that there may be multiple struct return strategies depending on the nature of
    the struct, people were suggesting looking at the assembly code generated by Clang to figure
    out how one was supposed to call a given function, and this all varies from platform to
    platform, we avoid the whole mess by making it explicit. External functions which wish to
    return structs explicitly receive a pointer to the result structure as their first parameter.
    ================================================================================================
    function needsStructIndirection(m:MethodDecl):Bit {
        def result := m.annotations.isExternal() & m.returnType.isClass() &
                compiler.isValue(compiler.getClass(m.returnType))
        -- if an external method requires struct indirection, it will have a different signature
        -- than a non-external method; this means this feature doesn't play nice with overriding. We
        -- can fix this down the road with shims, but for right now just assert that a method
        -- requiring struct indirection is not an override and cannot be overridden
        assert !result | (!m.annotations.isOverride() & (m.annotations.isFinal() |
                m.annotations.isClass())), "invalid struct indirection on \{m.signature()}"
        return result
    }

    method getMethodTableEntry(m:MethodDecl):Pair<String, String> -* name, type *- {
        compiler.resolve(m)
        if m.owner.external {
            writeDeclaration(m)
        }
        def resultName := getName(m)
        def effective := compiler.inheritedTypeWithSelf(m)
        if needsStructIndirection(m) {
            def resultType := MutableString("void (")
            resultType.append(type(effective.subtypes[effective.subtypes.get_count() - 1]))
            resultType.append("*")
            for i in 0 .. effective.subtypes.get_count() - 1 {
                resultType.append(", ")
                resultType.append(type(effective.subtypes[i]))
            }
            resultType.append(")*")
            return Pair<String, String>(resultName, resultType.convert())
        }
        return Pair<String, String>(resultName, type(effective))
    }

    method getClassConstant(cl:ClassDecl):ClassConstant {
        var result := classConstants[cl.name]
        if result = null {
            compiler.resolve(cl)
            def type:String
            if cl.external {
                result := ClassConstant("@\{escapeName(cl.type().name)}$class",
                        "%panda$core$Class")
                classConstants[cl.name] := result
                types.printLine("\{result.name} = external global \{result.type}")
                return classConstants[cl.name]
            }
            def vtable := compiler.getVTable(cl)
            result := ClassConstant("@\{escapeName(cl.type().name)}$class",
                    "{ i8*, \{INT_TYPE}, %$itable*, [\{vtable.get_count()} x i8*] }")
            classConstants[cl.name] := result
            def superPtr:String
            if cl.rawSuper != Type.Void() {
                def superCC := getClassConstant(compiler.getClass(cl.rawSuper))
                superPtr := "bitcast(\{superCC.type}* \{superCC.name} to i8*)"
            }
            else {
                superPtr := "null"
            }
            def code := MutableString("\{result.name} = constant \{result.type} { " +
                    "i8* \{superPtr}, \{INT_TYPE} 1, \{getITable(cl)}, " +
                    "[\{vtable.get_count()} x i8*] [")
            var separator := ""
            for m in vtable {
                code.append(separator)
                if m.annotations.isAbstract() {
                    code.append("i8* null")
                }
                else {
                    def entry := getMethodTableEntry(m)
                    code.append("i8* bitcast(\{entry.second} \{entry.first} to i8*)")
                }
                separator := ", "
            }
            code.append("] }\n")
            types.printLine(code)
        }
        return result
    }

    method getWrapperClassConstant(cl:ClassDecl):ClassConstant {
        def name := "@\{escapeName(cl.name)}$wrapperclass"
        var result := classConstants[name]
        if result = null {
            if cl.external {
                type(Type.Class())
                def type := "%panda$core$Class"
                types.printLine("\{name} = external global \{type}")
                result := ClassConstant(name, type)
                classConstants[name] := result
            }
            else {
                assert false
            }
        }
        return result
    }

    function escapeName(s:String):String {
        return s.replace(".", "$").replace("?", "$Q").replace("<", "$LT").replace(">", "$GT").
                replace(" ", "").replace(",", "$C")
    }

    function getName(v:Variable):String {
        if v.storage = Variable.Storage.PARAMETER {
            return "%\{v.name}"
        }
        var result := variableNames[v]
        if result = null {
            labelCount += 1
            result := "%\{v.name}\{labelCount}"
            variableNames[v] := result
        }
        return result
    }

    function getName(m:MethodDecl):String {
        if m.name = "main" {
            return "@pandaMain"
        }
        def result := MutableString("@")
        result.append(escapeName(m.owner.name))
        result.append("$")
        match m.name {
            when "+":    result.append("$ADD")
            when "-":    result.append("$SUB")
            when "*":    result.append("$MUL")
            when "/":    result.append("$DIV")
            when "//":   result.append("$INTDIV")
            when "%":    result.append("$REM")
            when "^":    result.append("$POW")
            when "[]":   result.append("$IDX")
            when "[]:=": result.append("$IDXEQ")
            when "=":    result.append("$EQ")
            when "!=":   result.append("$NEQ")
            when ">":    result.append("$GT")
            when "<":    result.append("$LT")
            when ">=":   result.append("$GE")
            when "<=":   result.append("$LE")
            when "|":    result.append("$OR")
            when "||":   result.append("$BOR")
            when "&":    result.append("$AND")
            when "&&":   result.append("$BAND")
            when "~":    result.append("$XOR")
            when "~~":   result.append("$BXOR")
            when "!":    result.append("$NOT")
            when "!!":   result.append("$BNOT")
            when "<<":   result.append("$SHL")
            when ">>":   result.append("$SHR")
            otherwise:   result.append(escapeName(m.name))
        }
        for p in m.parameters {
            result.append("$\{escapeName(p.type.name)}")
        }
        if m.returnType != Type.Void() {
            result.append("$R$")
            result.append(escapeName(m.returnType.name))
        }
        return result.convert()
    }

    class OpClass {
        constant SIGNED   := 10121
        constant UNSIGNED := 10122
        constant FLOAT    := 10123
    }

    function opClass(t:Type):Int {
        match t.typeKind {
            when Type.Kind.BUILTIN_INT:   return OpClass.SIGNED
            when Type.Kind.BUILTIN_UINT:  return OpClass.UNSIGNED
            when Type.Kind.BUILTIN_FLOAT: return OpClass.FLOAT
            otherwise:
                assert false
        }
    }

    method getAndReference(left:IRNode, right:IRNode, out:OutputStream):String {
        var leftRef := getReference(left, out)
        if left.type = Type.Bit() {
            def leftField := nextVar()
            out.printLine("\{leftField} = extractvalue %panda$core$Bit \{leftRef}, 0")
            leftRef := leftField
        }
        def start := currentBlock
        def ifTrue := nextLabel()
        def ifFalse := nextLabel()
        out.printLine("br i1 \{leftRef}, label %\{ifTrue}, label %\{ifFalse}")
        createBlock(ifTrue, out)
        def rightRef := getReference(right, out)
        if right.type = Type.Bit() {
            def rightField := nextVar()
            out.printLine("\{rightField} = extractvalue %panda$core$Bit \{rightRef}, 0")
            rightRef := rightField
        }
        def truePred := currentBlock
        out.printLine("br label %\{ifFalse}")
        createBlock(ifFalse, out)
        def result := nextVar()
        out.printLine("\{result} = phi i1 [0, %\{start}], [\{rightRef}, %\{truePred}]")
        return result
    }

    method getOrReference(left:IRNode, right:IRNode, out:OutputStream):String {
        var leftRef := getReference(left, out)
        if left.type = Type.Bit() {
            def leftField := nextVar()
            out.printLine("\{leftField} = extractvalue %panda$core$Bit \{leftRef}, 0")
            leftRef := leftField
        }
        def start := currentBlock
        def ifTrue := nextLabel()
        def ifFalse := nextLabel()
        out.printLine("br i1 \{leftRef}, label %\{ifTrue}, label %\{ifFalse}")
        createBlock(ifFalse, out)
        def rightRef := getReference(right, out)
        if right.type = Type.Bit() {
            def rightField := nextVar()
            out.printLine("\{rightField} = extractvalue %panda$core$Bit \{rightRef}, 0")
            rightRef := rightField
        }
        def falsePred := currentBlock
        out.printLine("br label %\{ifTrue}")
        createBlock(ifTrue, out)
        def result := nextVar()
        out.printLine("\{result} = phi i1 [1, %\{start}], [\{rightRef}, %\{falsePred}]")
        return result
    }

    method getBinaryReference(cl:Int, leftRef:String, op:Int, rightRef:String,
            out:OutputStream):String {
        def llvmOp:String
        match cl {
            when OpClass.SIGNED:
                match op {
                    when Token.Kind.ADD:        llvmOp := "add"
                    when Token.Kind.SUB:        llvmOp := "sub"
                    when Token.Kind.MUL:        llvmOp := "mul"
                    when Token.Kind.INTDIV:     llvmOp := "sdiv"
                    when Token.Kind.REM:        llvmOp := "srem"
                    when Token.Kind.SHIFTLEFT:  llvmOp := "shl"
                    when Token.Kind.SHIFTRIGHT: llvmOp := "ashr"
                    when Token.Kind.BITWISEAND: llvmOp := "and"
                    when Token.Kind.BITWISEOR:  llvmOp := "or"
                    when Token.Kind.XOR, Token.Kind.BITWISEXOR: 
                                                llvmOp := "xor"
                    when Token.Kind.EQ:         llvmOp := "icmp eq"
                    when Token.Kind.NEQ:        llvmOp := "icmp ne"
                    when Token.Kind.GT:         llvmOp := "icmp sgt"
                    when Token.Kind.LT:         llvmOp := "icmp slt"
                    when Token.Kind.GTEQ:       llvmOp := "icmp sge"
                    when Token.Kind.LTEQ:       llvmOp := "icmp sle"
                    otherwise:
                        assert false
                }
            when OpClass.UNSIGNED:
                match op {
                    when Token.Kind.ADD:        llvmOp := "add"
                    when Token.Kind.SUB:        llvmOp := "sub"
                    when Token.Kind.MUL:        llvmOp := "mul"
                    when Token.Kind.INTDIV:     llvmOp := "udiv"
                    when Token.Kind.REM:        llvmOp := "urem"
                    when Token.Kind.SHIFTLEFT:  llvmOp := "shl"
                    when Token.Kind.SHIFTRIGHT: llvmOp := "lshr"
                    when Token.Kind.BITWISEAND: llvmOp := "and"
                    when Token.Kind.BITWISEOR:  llvmOp := "or"
                    when Token.Kind.XOR, Token.Kind.BITWISEXOR: 
                                                llvmOp := "xor"
                    when Token.Kind.EQ:         llvmOp := "icmp eq"
                    when Token.Kind.NEQ:        llvmOp := "icmp ne"
                    when Token.Kind.GT:         llvmOp := "icmp ugt"
                    when Token.Kind.LT:         llvmOp := "icmp ult"
                    when Token.Kind.GTEQ:       llvmOp := "icmp uge"
                    when Token.Kind.LTEQ:       llvmOp := "icmp ule"
                    otherwise:
                        assert false
                }
            when OpClass.FLOAT:
                match op {
                    when Token.Kind.ADD:        llvmOp := "fadd"
                    when Token.Kind.SUB:        llvmOp := "fsub"
                    when Token.Kind.MUL:        llvmOp := "fmul"
                    when Token.Kind.INTDIV:     llvmOp := "fdiv"
                    when Token.Kind.EQ:         llvmOp := "fcmp oeq"
                    when Token.Kind.NEQ:        llvmOp := "fcmp one"
                    when Token.Kind.GT:         llvmOp := "fcmp ogt"
                    when Token.Kind.LT:         llvmOp := "fcmp olt"
                    when Token.Kind.GTEQ:       llvmOp := "fcmp oge"
                    when Token.Kind.LTEQ:       llvmOp := "fcmp ole"
                    otherwise:
                        assert false
                }
        }
        def result := nextVar()
        out.printLine("\{result} = \{llvmOp} \{leftRef}, \{rightRef}")
        return result
    }

    method getBinaryReference(left:IRNode, op:Int, right:IRNode, out:OutputStream):String {
        assert left.type = right.type
        match op {
            when Token.Kind.AND:       return getAndReference(left, right, out)
            when Token.Kind.OR:        return getOrReference(left, right, out)
            when Token.Kind.IDENTITY:  assert false -- return getIdentityReference(left, right, out)
            when Token.Kind.NIDENTITY: assert false -- return getNIdentityReference(left, right, out)
            otherwise:
                def leftRef := getTypedReference(left, out)
                def rightRef := getReference(right, out)
                return getBinaryReference(opClass(left.type), leftRef, op, rightRef, out)
        }
    }

    method getBinaryReference(b:IRNode, out:OutputStream):String {
        assert b.kind = IRNode.Kind.BINARY
        assert b.children.get_count() = 2
        return getBinaryReference(b.children[0], b.payload->Int, b.children[1], out)
    }

    function callingConvention(m:MethodDecl):String {
        return "fastcc "
    }

    method getVirtualMethodReference(target:String, m:MethodDecl, out:OutputStream):String {
        def cc := getClassConstant(m.owner)
        var index := -1
        def vtable := compiler.getVTable(m.owner)
        for i in 0 .. vtable.get_count() {
            if vtable[i]->MethodDecl == m { -- FIXME unnecessary cast
                index := i
                break
            }
        }
        assert index != -1
        def classPtrPtr := nextVar()
        out.printLine("\{classPtrPtr} = getelementptr inbounds \{typeName(m.owner.type())}, " +
                "\{target}, i64 0, i32 0")
        def classPtr := nextVar()
        out.printLine("\{classPtr} = load %panda$core$Class*, %panda$core$Class** \{classPtrPtr}")
        def cast := nextVar()
        out.printLine("\{cast} = bitcast %panda$core$Class* \{classPtr} to \{cc.type}*")
        def ptr := nextVar()
        out.printLine("\{ptr} = getelementptr inbounds \{cc.type}, \{cc.type}* \{cast}, i64 0, " +
                "i32 \{VTABLE_INDEX}, i64 \{index}")
        def load := nextVar()
        out.printLine("\{load} = load i8*, i8** \{ptr}")
        def result := nextVar()
        out.printLine("\{result} = bitcast i8* \{load} to " +
                type(compiler.inheritedTypeWithSelf(m)))
        return result
    }

    method getInterfaceMethodReference(target:String, m:MethodDecl, out:OutputStream):String {
        def methodType := type(compiler.inheritedTypeWithSelf(m))
        -- load class constant entry
        def entry := nextLabel()
        out.printLine("br label %\{entry}")
        createBlock(entry, out)
        def classPointer := nextVar()
        out.printLine("\{classPointer} = getelementptr inbounds \{typeName(m.owner.type())}, " +
                "\{target}, \{SIZE_T} 0, i32 \{CLASS_POINTER_INDEX}")
        def loadedClass := nextVar()
        def classType := typeName(Type.Class())
        out.printLine("\{loadedClass} = load \{classType}*, \{classType}** \{classPointer}")
        def itableFirst := nextVar()
        out.printLine("\{itableFirst} = getelementptr inbounds \{classType}, \{classType}* " +
                "\{loadedClass}, \{SIZE_T} 0, i32 \{ITABLE_INDEX}")
        def next := nextLabel()
        out.printLine("br label %\{next}")
        def leavingEntryLabel := currentBlock
        createBlock(next, out)
        labelCount += 1
        def itableNext := "%$itable\{labelCount}"
        def itablePtrPtr := nextVar()
        def fail := nextLabel()
        out.printLine("\{itablePtrPtr} = phi %$itable** [ \{itableFirst}, %\{leavingEntryLabel}]," +
                " [ \{itableNext}, %\{fail} ]")
        def itablePtr := nextVar()
        out.printLine("\{itablePtr} = load %$itable*, %$itable** \{itablePtrPtr}")
        def itableClassPtr := nextVar()
        out.printLine("\{itableClassPtr} = getelementptr inbounds %$itable, %$itable* " +
                "\{itablePtr}, \{SIZE_T} 0, i32 0")
        def itableClass := nextVar()
        out.printLine("\{itableClass} = load \{classType}*, \{classType}** \{itableClassPtr}")
        def test := nextVar()
        def intfCC := getClassConstant(m.owner)
        out.printLine("\{test} = icmp eq \{classType}* bitcast(\{intfCC.type}* \{intfCC.name} to " +
                "\{classType}*), \{itableClass}")
        def success := nextLabel()
        out.printLine("br i1 \{test}, label %\{success}, label %\{fail}")

        createBlock(fail, out)
        out.printLine("\{itableNext} = getelementptr inbounds %$itable, %$itable* \{itablePtr}, " +
                "\{SIZE_T} 0, i32 1")
        out.printLine("br label %\{next}")

        createBlock(success, out)
        var index := -1
        def vtable := compiler.getVTable(m.owner)
        for i in 0 .. vtable.get_count() {
            if vtable[i]->MethodDecl == m { -- FIXME unnecessary cast
                index := i
                break
            }
        }
        index -= compiler.getVTable(compiler.getClass(Type.Object())).get_count()
        assert index != -1
        def methodPtrPtr := nextVar()
        out.printLine("\{methodPtrPtr} = getelementptr inbounds %$itable, %$itable* " +
                "\{itablePtr}, \{SIZE_T} 0, i32 2, i32 \{index}")
        def cast := nextVar()
        out.printLine("\{cast} = bitcast i8** \{methodPtrPtr} to \{methodType}*")
        def methodPtr := nextVar()
        out.printLine("\{methodPtr} = load \{methodType}, \{methodType}* \{cast}")
        return methodPtr
    }

    method getMethodReference(target:String?, m:MethodDecl, isSuper:Bit, out:OutputStream):String {
        if !isSuper & m.isVirtual() {
            assert target != null
            if m.owner.classKind = ClassDecl.Kind.INTERFACE {
                return getInterfaceMethodReference(target, m, out)
            }
            else {
                return getVirtualMethodReference(target, m, out)
            }
        }
        else {
            if m.owner.external {
                writeDeclaration(m)
            }
            return getName(m)
        }
    }

    method getCallReference(call:IRNode, out:OutputStream):String {
        assert call.kind = IRNode.Kind.CALL
        def m := (call.payload->MethodRef).value
        if m.owner.external {
            writeDeclaration(m)
        }
        if m.owner.name = "panda.core.Bit" {
            if m.name = "&" {
                assert call.children.get_count() = 2
                def bit := getAndReference(call.children[0], call.children[1], out)
                def result := nextVar()
                out.printLine("\{result} = insertvalue %panda$core$Bit { i1 undef }, i1 " +
                        "\{bit}, 0")
                return result
            }
            if m.name = "|" {
                assert call.children.get_count() = 2
                def bit := getOrReference(call.children[0], call.children[1], out)
                def result := nextVar()
                out.printLine("\{result} = insertvalue %panda$core$Bit { i1 undef }, i1 " +
                        "\{bit}, 0")
                return result
            }
        }
        def args := Array<String>(call.children.get_count())
        for a in call.children {
            args.add(getTypedReference(a, out))
        }
        def target:String?
        if args.get_count() > 0 {
            -- this isn't actually correct - args[0] could be the target of an instance method, or
            -- just the first parameter to a class method. But getMethodReference ignores target for
            -- class methods, so this works and is easier than doing it the right way.
            target := args[0]
        }
        else {
            target := null
        }
        def methodRef := getMethodReference(target, m, false, out)
        def result:String
        def resultType := type(call.type)
        def indirect := needsStructIndirection(m)
        if indirect {
            out.print("call \{callingConvention(m)}void")
        }
        else {
            result := nextVar()
            out.print("\{result} = call \{callingConvention(m)}\{resultType}")
        }
        out.print(" \{methodRef}(")
        var separator := ""
        def indirectVar:String
        if indirect {
            labelCount += 1
            indirectVar := "%$tmp" + labelCount
            methodHeader.printLine("\{indirectVar} = alloca \{resultType}")
            out.print("\{resultType}* \{indirectVar}")
            separator := ", "
        }
        for arg in args {
            out.printLine("\{separator}\{arg}")
            separator := ", "
        }
        out.printLine(")")
        if indirect {
            result := nextVar()
            out.printLine("\{result} = load \{resultType}, \{resultType}* \{indirectVar}")
        }
        return result
    }

    method wrapValue(value:String, srcType:Type, dstType:Type, out:OutputStream):String {
        out.printLine("; wrapping \{value}")
        def src := compiler.getClass(srcType)
        assert src != null
        if srcType.typeKind = Type.Kind.NULLABLE {
            -- casting nullable value to nullable wrapper, need to special-case null
            def testStart := currentBlock
            def isNonNull := nextVar()
            out.printLine("\{isNonNull} = extractvalue \{nullableType(srcType)} \{value}, 1")
            def nonNullLabel := nextLabel()
            def endLabel := nextLabel()
            out.printLine("br i1 \{isNonNull}, label %\{nonNullLabel}, label %\{endLabel}")
            createBlock(nonNullLabel, out)
            def unwrapped := toNonNullableValue(value, srcType, srcType.subtypes[0], out)
            def nonNullValue := wrapValue(unwrapped, srcType.subtypes[0], dstType, out)
            out.printLine("br label %\{endLabel}")
            createBlock(endLabel, out)
            def result := nextVar()
            out.printLine("\{result} = phi \{type(dstType)} [null, %\{testStart}], " +
                    "[\{nonNullValue}, %\{nonNullLabel}]")
            return result
        }
        def mallocRef := nextVar()
        out.printLine("\{mallocRef} = call i8* @malloc(i64 \{sizeOfWrapper(src.type())})")
        def wrapperTypeName := wrapperTypeName(src.type())
        def wrapperType := wrapperType(src.type())
        def wrapperCast := nextVar()
        out.printLine("\{wrapperCast} = bitcast i8* \{mallocRef} to \{wrapperType}")
        def classPtr := nextVar()
        out.printLine("\{classPtr} = getelementptr \{wrapperTypeName}, " +
                "\{wrapperType} \{wrapperCast}, i64 0, i32 0")
        def cc := getWrapperClassConstant(src)
        out.printLine("store %panda$core$Class* bitcast(\{cc.type}* \{cc.name} to " +
                "%panda$core$Class*), %panda$core$Class** \{classPtr}")
        def refCount := nextVar()
        out.printLine("\{refCount} = getelementptr \{wrapperTypeName}, " +
                "\{wrapperType} \{wrapperCast}, i64 0, i32 1, i32 0")
        out.printLine("store i32 0, i32* \{refCount}")
        def target := nextVar()
        out.printLine("\{target} = getelementptr \{wrapperTypeName}, " +
                "\{wrapperType} \{wrapperCast}, i64 0, i32 2")
        out.printLine("store \{type(srcType)} \{value}, \{type(srcType)}* \{target}")
        if wrapperType != type(dstType) {
            def result := nextVar()
            out.printLine("\{result} = bitcast \{wrapperType} \{wrapperCast} to \{type(dstType)}")
            return result
        }
        return wrapperCast
    }

    method getFieldReference(fieldRef:IRNode, out:OutputStream):String {
        assert fieldRef.kind = IRNode.Kind.FIELD_REFERENCE
        assert fieldRef.children.get_count() = 1
        def field := fieldRef.payload->FieldDecl
        def t := type(field.type)
        if field.annotations.isClass() {
-*            if (field->fValue && !is_constant_number(*field->fValue) &&
                        fInitializedClasses.find(&field->fOwner) == fInitializedClasses.end()) {
                fInitializedClasses.insert(&field->fOwner);
                if (fDeclaredClassInitializers.find(field->fOwner.fName) == fDeclaredClassInitializers.end()) {
                    fMethodDeclarations << "declare fastcc void @" << escape_type_name(field->fOwner.fName) <<
                            "$$classInit()\n";
                    fDeclaredClassInitializers.insert(field->fOwner.fName);
                }
                fMethodHeader << "    call fastcc void @" << escape_type_name(field->fOwner.fName) <<
                        "$$classInit()\n";
            }
            def load := nextVar()
            out << "    " << load << " = load " << type << ", " << type << "* " <<
                    this->fieldName(*field) << "\n";
            return load;*-
            assert false
        }
        def cl := compiler.getClass(fieldRef.children[0].type)
        assert cl != null
        if compiler.isValue(cl) {
            def base := getReference(fieldRef.children[0], out)
            def fields := compiler.instanceFields(cl)
            def index:Int? := null
            for i in 0 .. fields.get_count() {
                if fields[i]->FieldDecl == field { -- FIXME unnecessary cast
                    index := i
                    break
                }
            }
            assert index != null
            def result := nextVar()
            out.printLine("\{result} = extractvalue \{type(fieldRef.children[0].type)} \{base}" +
                    ", \{index}")
            return result
        }
        def ptr := "\{t}* \{getLValue(fieldRef, out)}"
        def result := nextVar()
        out.printLine("\{result} = load \{t}, \{ptr}")
        return result
    }

    method unwrapValue(value:String, srcType:Type, dstType:Type, out:OutputStream):String {
        def target := compiler.getClass(dstType)
        assert target != null
        if dstType.typeKind = Type.Kind.NULLABLE {
            -- casting nullable wrapper to nullable value, need to special-case null
            def testStart := currentBlock
            def isNonNull := nextVar()
            out.printLine("\{isNonNull} = icmp ne \{type(srcType)} \{value}, null")
            def nonNullLabel := nextLabel()
            def endLabel := nextLabel()
            out.printLine("br i1 \{isNonNull}, label %\{nonNullLabel}, label %\{endLabel}")
            createBlock(nonNullLabel, out)
            def wrapped := unwrapValue(value, srcType, dstType.subtypes[0], out)
            def nonNullValue := toNullableValue(wrapped, dstType.subtypes[0], dstType, out)
            out.printLine("br label %\{endLabel}")
            createBlock(endLabel, out)
            def result := nextVar()
            out.print("\{result} = phi \{type(dstType)} " +
                    "[{ \{type(dstType.subtypes[0])} undef, i1 0 }, " +
                    "%\{testStart}], [\{nonNullValue}, %\{nonNullLabel}]")
            return result
        }
        def targetType := type(dstType)
        def wrapperTypeName := wrapperTypeName(dstType)
        def wrapperType := wrapperType(dstType)
        def srcCast := nextVar()
        out.printLine("\{srcCast} = bitcast \{type(srcType)} \{value} to \{wrapperType}")
        def load := nextVar()
        out.printLine("\{load} = load \{wrapperTypeName}, \{wrapperType} \{srcCast}")
        def result := nextVar()
        out.printLine("\{result} = extractvalue \{wrapperTypeName} \{load}, \{OBJECT_FIELD_COUNT}")
        return result
    }

    method toNullableValue(value:String, srcType:Type, dstType:Type, out:OutputStream):String {
        def nullableType := nullableType(dstType)
        def result := nextVar()
        out.printLine("\{result} = insertvalue \{nullableType} " +
                "{ \{type(srcType)} undef, i1 true }, \{type(srcType)} \{value}, 0")
        return result
    }

    method toNonNullableValue(value:String, srcType:Type, dstType:Type, out:OutputStream):String {
        def result := nextVar()
        out.printLine("\{result} = extractvalue \{type(srcType)} \{value}, 0")
        return result
    }

    method getCastReference(value:String, src:Type, target:Type, out:OutputStream):String {
        def op:String
        if target.isBuiltinNumber() {
            assert src.isBuiltinNumber()
            def size1 := sizeOf(src)
            def size2 := sizeOf(target)
            if size1 > size2 {
                op := "trunc"
            }
            else if size1 < size2 {
                if target.typeKind = Type.Kind.BUILTIN_INT {
                    op := "sext"
                }
                else {
                    op := "zext"
                }
            }
            else {
                return value
            }
        }
        else {
            def srcClass := compiler.getClass(src)
            assert srcClass != null
            def targetClass := compiler.getClass(target)
            assert targetClass != null
            if compiler.isValue(srcClass) & !compiler.isValue(targetClass) {
                return wrapValue(value, src, target, out)
            }
            else if !compiler.isValue(srcClass) & compiler.isValue(targetClass) {
                return unwrapValue(value, src, target, out)
            }
            else if compiler.isValue(srcClass) & target.typeKind = Type.Kind.NULLABLE &
                    target.subtypes[0] = src {
                return toNullableValue(value, src, target, out)
            }
            else if compiler.isValue(targetClass) & src.typeKind = Type.Kind.NULLABLE &
                    src.subtypes[0] = target {
                return toNonNullableValue(value, src, target, out)
            }
            op := "bitcast"
        }
        def srcType := type(src)
        def dstType := type(target)
        if srcType = dstType {
            return value
        }
        def result := nextVar()
        out.printLine("\{result} = \{op} \{srcType} \{value} to \{dstType}")
        return result
    }

    method getCastReference(cast:IRNode, out:OutputStream):String {
        assert cast.kind = IRNode.Kind.CAST
        assert cast.children.get_count() = 1
        def base := getReference(cast.children[0], out)
        return getCastReference(base, cast.children[0].type, cast.type, out)
    }

    method getConstructReference(construct:IRNode, out:OutputStream):String {
        assert construct.kind = IRNode.Kind.CONSTRUCT
        assert construct.children.get_count() >= 1
        def cl := compiler.getClass(construct.type)
        assert cl != null
        def t := type(construct.type)
        if construct.type.isNumber() {
            assert construct.children.get_count() = 1
            assert construct.children[0].children.get_count() = 1
            def value := getTypedReference(construct.children[0].children[0], out)
            if construct.children[0].children[0].kind = IRNode.Kind.INT {
                return "{ " + value + " }"
            }
            def result := nextVar()
            def lastField := cl.fields[cl.fields.get_count() - 1]
            assert !lastField.annotations.isClass()
            out.printLine("\{result} = insertvalue \{t} { \{type(lastField.type)} undef }, " +
                    "\{value}, 0\n")
            return result
        }
        if construct.type = Type.Bit() {
            assert construct.children.get_count() = 1
            assert construct.children[0].children.get_count() = 1
            def value := getTypedReference(construct.children[0].children[0], out)
            if construct.children[0].children[0].kind = IRNode.Kind.BIT {
                return "{ " + value + " }"
            }
            def result := nextVar()
            def lastField := cl.fields[cl.fields.get_count() - 1]
            assert !lastField.annotations.isClass()
            out.printLine("\{result} = insertvalue \{t} { \{type(lastField.type)} undef }, " +
                    "\{value}, 0\n")
            return result
        }
        if compiler.isValue(cl) {
            labelCount += 1
            def alloca := "%$tmp\{labelCount}"
            methodHeader.printLine("\{alloca} = alloca \{t}")
            writeCall(construct.children[0], "\{t}* \{alloca}", out)
            def result := nextVar()
            out.printLine("\{result} = load \{t}, \{t}* \{alloca}")
            return result
        }
        def callRef := nextVar()
        out.printLine("\{callRef} = call i8* @malloc(i64 \{sizeOf(construct.type)})")
        def result := nextVar()
        out.printLine("\{result} = bitcast i8* \{callRef} to \{type(construct.type)}")
        def classPtr := nextVar()
        def className:String
        if construct.type.typeKind = Type.Kind.GENERIC {
            className := typeName(construct.type.subtypes[0])
        }
        else {
            className := typeName(construct.type)
        }
        out.printLine("\{classPtr} = getelementptr inbounds \{className}, \{t} \{result}, i64 0, " +
                "i32 0")
        def cc := getClassConstant(cl)
        out.printLine("store %panda$core$Class* bitcast(\{cc.type}* \{cc.name} to " +
                "%panda$core$Class*), %panda$core$Class** \{classPtr}")
        writeCall(construct.children[0], "\{t} \{result}", out)
        return result
    }

    method getIntReference(int:IRNode, out:OutputStream):String {
        return (int.payload->Int).convert() -- FIXME parens
    }

    method getNegatedIntReference(int:IRNode, out:OutputStream):String {
        return "-" + (int.payload->Int).convert() -- FIXME parens
    }

    method getBitReference(bit:IRNode, out:OutputStream):String {
        if bit.payload->Bit {
            return "true"
        }
        return "false"
    }

    method getVariableReference(v:Variable, out:OutputStream):String {
        if v.storage = Variable.Storage.PARAMETER {
            return getName(v)
        }
        def result := nextVar()
        def t := type(v.type)
        out.printLine("\{result} = load \{t}, \{t}* \{getName(v)}")
        return result
    }

    method getStringReference(s:String, out:OutputStream):String {
        labelCount += 1
        def chars := "@$chars\{labelCount}"
        def charsType := "[\{s.utf8().get_count()} x i8]"
        strings.print("\{chars} = private unnamed_addr constant \{charsType} [ ")
        var separator := ""
        for c in s.utf8() {
            strings.print("\{separator}i8 \{c.convert()->Int8}")
            separator := ", "
        }
        strings.printLine(" ]")
        labelCount += 1
        def result := "@$str\{labelCount}"
        def string := compiler.getClass(Type.StringType())
        assert string != null
        def cc := getClassConstant(string)
        strings.printLine("\{result} = private unnamed_addr constant %panda$core$String { " +
                "%panda$core$Class* bitcast(\{cc.type}* \{cc.name} to " +
                "%panda$core$Class*), %panda$core$Int32 insertvalue(%panda$core$Int32 " +
                "{ i32 undef }, i32 1, 0), %panda$core$Char8* bitcast(\{charsType}* \{chars}" +
                " to %panda$core$Char8*), %panda$core$Int64 insertvalue(%panda$core$Int64 " +
                "{ i64 undef }, i64 \{s.utf8().get_count()}, 0) }")
        return result
    }

    method getSelfReference(s:IRNode, out:OutputStream):String {
        return "%self"
    }

    method getIsNullReference(test:IRNode, out:OutputStream):String {
        assert test.kind = IRNode.Kind.IS_NULL
        assert test.children.get_count() = 1
        def value := getTypedReference(test.children[0], out)
        def cl := compiler.getClass(test.children[0].type)
        def resultValue:String
        if compiler.isValue(cl) {
            if test.children[0].type.typeKind != Type.Kind.NULLABLE {
                return "{ i1 0 }"
            }
            def field := nextVar()
            out.printLine("\{field} = extractvalue \{value}, 1")
            resultValue := nextVar()
            out.printLine("\{resultValue} = xor i1 \{field}, -1")
        }
        else {
            resultValue := nextVar()
            out.printLine("\{resultValue} = icmp eq \{value}, null")
        }
        def result := nextVar()
        out.printLine("\{result} = insertvalue %panda$core$Bit { i1 undef }, i1 \{resultValue}, 0")
        return result
    }

    method getIsNonNullReference(test:IRNode, out:OutputStream):String {
        assert test.kind = IRNode.Kind.IS_NONNULL
        assert test.children.get_count() = 1
        def value := getTypedReference(test.children[0], out)
        def cl := compiler.getClass(test.children[0].type)
        def resultValue:String
        if compiler.isValue(cl) {
            if test.children[0].type.typeKind != Type.Kind.NULLABLE {
                return "{ i1 1 }"
            }
            resultValue := nextVar()
            out.printLine("\{resultValue} = extractvalue \{value}, 1")
        }
        else {
            resultValue := nextVar()
            out.printLine("\{resultValue} = icmp neq \{value}, null")
        }
        def result := nextVar()
        out.printLine("\{result} = insertvalue %panda$core$Bit { i1 undef }, i1 \{resultValue}, 0")
        return result
    }

    method getReference(expr:IRNode, out:OutputStream):String {
        match expr.kind {
            when IRNode.Kind.BINARY:
                return getBinaryReference(expr, out)
            when IRNode.Kind.CALL:
                return getCallReference(expr, out)
            when IRNode.Kind.CAST:
                return getCastReference(expr, out)
            when IRNode.Kind.INT:
                return getIntReference(expr, out)
            when IRNode.Kind.NEGATED_INT:
                return getNegatedIntReference(expr, out)
            when IRNode.Kind.BIT:
                return getBitReference(expr, out)
            when IRNode.Kind.CONSTRUCT:
                return getConstructReference(expr, out)
            when IRNode.Kind.VARIABLE_REFERENCE:
                return getVariableReference(expr.payload->Variable, out)
            when IRNode.Kind.FIELD_REFERENCE:
                return getFieldReference(expr, out)
            when IRNode.Kind.STRING:
                return getStringReference(expr.payload->String, out)
            when IRNode.Kind.SELF:
                return getSelfReference(expr, out)
            when IRNode.Kind.REUSED_VALUE_DEFINITION:
                def value := getReference(expr.children[0], out)
                reusedValues[expr.payload->UInt64] := value
                return value
            when IRNode.Kind.REUSED_VALUE:
                return reusedValues[expr.payload->UInt64]
            when IRNode.Kind.NULL:
                return "null"
            when IRNode.Kind.IS_NULL:
                return getIsNullReference(expr, out)
            when IRNode.Kind.IS_NONNULL:
                return getIsNonNullReference(expr, out)
            otherwise:
                assert false, "unsupported expression \{expr}"
        }
    }

    method getTypedReference(expr:IRNode, out:OutputStream):String {
        return "\{type(expr.type)} \{getReference(expr, out)}"
    }

    method writeBlock(block:IRNode, out:OutputStream) {
        assert block.kind = IRNode.Kind.BLOCK
        for s in block.children {
            writeStatement(s, out)
        }
    }

    -- if target is non-null, it is inserted as a hidden first parameter to the call. This is used
    -- for init() calls, which require a self parameter but do not have a target in the IR.
    method writeCall(call:IRNode, target:String?, out:OutputStream) {
        assert call.kind = IRNode.Kind.CALL
        def m := (call.payload->MethodRef).value
        if m.owner.external {
            writeDeclaration(m)
        }
        def args := Array<String>()
        if target != null {
            args.add(target)
        }
        for a in call.children {
            args.add(getTypedReference(a, out))
        }
        def refTarget:String?
        assert !needsStructIndirection(m) -- FIXME unimplemented
        if args.get_count() > 0 {
            -- this isn't actually correct - args[0] could be the target of an instance method, or
            -- just the first parameter to a class method. But getMethodReference ignores target for
            -- non-virtual methods, so this works and is easier than doing it the right way.
            refTarget := args[0]
        }
        else {
            refTarget := null
        }
        def methodRef := getMethodReference(refTarget, m, false, out)
        out.printLine("call \{callingConvention(m)}\{type(call.type)} " +
                "\{methodRef}(\{args.join()})")
    }

    method writeIf(s:IRNode, out:OutputStream) {
        assert s.kind = IRNode.Kind.IF
        assert s.children.get_count() = 2 | s.children.get_count() = 3
        assert s.children[0].type = Type.Bit()
        def test := getTypedReference(s.children[0], out)
        def testBit := nextVar()
        out.printLine("\{testBit} = extractvalue \{test}, 0")
        def ifTrue := nextLabel()
        def ifFalse := nextLabel()
        out.printLine("br i1 \{testBit}, label %\{ifTrue}, label %\{ifFalse}")
        createBlock(ifTrue, out)
        writeStatement(s.children[1], out)
        def end:String
        if s.children.get_count() = 3 {
            end := nextLabel()
        }
        else {
            end := ifFalse
        }
        if !endsWithBranch(s.children[1]) {
            out.printLine("br label %\{end}")
        }
        if s.children.get_count() = 3 {
            createBlock(ifFalse, out)
            writeStatement(s.children[2], out)
            if !endsWithBranch(s.children[2]) {
                out.printLine("br label %\{end}")
            }
        }
        createBlock(end, out)
    }

    method writeRangeFor(f:IRNode, out:OutputStream) {
        -- I am acutely aware of how horrific this looks.
        --
        -- There's no easy way to produce clean output here, since we have to handle different step
        -- values, different loop directions, and both inclusive and exclusive ranges, all of which
        -- could potentially be determined at runtime. It gets even uglier when you consider the
        -- difficulty of handling the extremes of the numeric types. You can't just add 1 and then
        -- check to see if it's in range when the limit is MAX_INT, because you'll overflow and end
        -- up with an infinite loop. You also can't just check for being equal to the limit before
        -- adding the step, because with a step bigger than 1 (or smaller than -1) you might need to
        -- stop before actually hitting the end. So you instead check the difference between the
        -- current index and the limit, but even there you need to be careful because it could
        -- overflow in a signed test, and we need to handle null values, and... ugh, it's
        -- surprisingly messy and results in a ton of code.
        --
        -- Fortunately, we can just write incredibly awful-but-straightforward code and let LLVM
        -- optimize it to something sensible if it turns out the values are known at compile time.
        -- This works remarkably well, because LLVM is awesome.
        assert f.kind = IRNode.Kind.RANGE_FOR
        assert f.children.get_count() = 3
        def target := f.children[0]
        assert f.children[1].type.typeKind = Type.Kind.GENERIC
        assert f.children[1].type.subtypes.get_count() = 2
        assert f.children[1].type.subtypes[0].name = "panda.core.Range"
        def range := getTypedReference(f.children[1], out)
        def block := f.children[2]
        def t := f.children[1].type.subtypes[1]
        def llt := type(t)
        def indexType:String
        if t.typeKind == Type.Kind.NULLABLE {
            assert t.subtypes.get_count() = 1
            indexType := type(t.subtypes[0])
        }
        else {
            indexType := llt
        }
        def cl := compiler.getClass(t)
        assert cl != null
        assert compiler.instanceFields(cl).get_count() = 1
        def numberType := type(compiler.instanceFields(cl)[0].type)
        assert target.kind = IRNode.Kind.VARIABLE_REFERENCE
        def index := getName(target.payload->Variable)
        methodHeader.printLine("\{index} = alloca \{indexType}")

        -- extract start value from range
        def startPtr := nextVar()
        out.printLine("\{startPtr} = extractvalue \{range}, 0")
        def startPtrCast := nextVar()
        out.printLine("\{startPtrCast} = bitcast \{type(Type.Object())} \{startPtr} to " +
                "\{wrapperType(t)}")
        def startFieldPtr := nextVar()
        out.printLine("\{startFieldPtr} = getelementptr \{wrapperTypeName(t)}, " +
                "\{wrapperType(t)} \{startPtrCast}, i64 0, i32 \{OBJECT_FIELD_COUNT}, i32 0")
        def start := nextVar()
        out.printLine("\{start} = load \{numberType}, \{numberType}* \{startFieldPtr}")

        -- store start value
        def indexValuePtr := nextVar()
        out.printLine("\{indexValuePtr} = getelementptr \{indexType}, \{indexType}* \{index}, " +
                "i64 0, i32 0")
        out.printLine("store \{numberType} \{start}, \{numberType}* \{indexValuePtr}")

        -- extract end value from range
        def endPtr := nextVar()
        out.printLine("\{endPtr} = extractvalue \{range}, 1")
        def endPtrCast := nextVar()
        out.printLine("\{endPtrCast} = bitcast \{type(Type.Object())} \{endPtr} to " +
                "\{wrapperType(t)}")
        def endFieldPtr := nextVar()
        out.printLine("\{endFieldPtr} = getelementptr \{wrapperTypeName(t)}, \{wrapperType(t)} " +
                "\{endPtrCast}, i64 0, i32 \{OBJECT_FIELD_COUNT}, i32 0")
        def end := nextVar()
        out.printLine("\{end} = load \{numberType}, \{numberType}* \{endFieldPtr}")

        -- extract step value from range
        def rawStep := nextVar()
        out.printLine("\{rawStep} = extractvalue \{range}, 2, 0")
        def step:String
        if numberType != "i64" {
            step := nextVar()
            out.printLine("\{step} = trunc i64 \{rawStep} to \{numberType}")
        }
        else {
            step := rawStep
        }

        -- extract inclusive / exclusive from range
        def inclusive := nextVar()
        out.printLine("\{inclusive} = extractvalue \{range}, 3, 0")

        -- start block
        def loopStart := nextLabel()
        def loopBody := nextLabel()
        def loopEnd := nextLabel()
        def loopTest := nextLabel()
        loopDescriptors.push(LoopDescriptor(f.payload->String?, loopEnd, loopTest)) -- FIXME Auto
        def forwardEntry := nextLabel()
        def backwardEntry := nextLabel()
        def signPrefix := "s"
        def direction:String
        if signPrefix = "s" {
            direction := nextVar()
            out.printLine("\{direction} = icmp sge \{numberType} \{step}, 0")
        }
        else {
            direction := "1"
        }
        out.printLine("br i1 \{direction}, label %\{forwardEntry}, label %\{backwardEntry}")
        createBlock(forwardEntry, out)
        def forwardEntryInclusive := nextLabel()
        def forwardEntryExclusive := nextLabel()
        out.printLine("br i1 \{inclusive}, label %\{forwardEntryInclusive}, " +
                "label %\{forwardEntryExclusive}")
        createBlock(forwardEntryInclusive, out)
        def forwardEntryInclusiveTest := nextVar()
        out.printLine("\{forwardEntryInclusiveTest} = icmp \{signPrefix}le \{numberType} " +
                "\{start}, \{end}")
        out.printLine("br i1 \{forwardEntryInclusiveTest}, label %\{loopStart}, label %\{loopEnd}")
        createBlock(forwardEntryExclusive, out)
        def forwardEntryExclusiveTest := nextVar()
        out.printLine("\{forwardEntryExclusiveTest} = icmp \{signPrefix}lt \{numberType} " +
                "\{start}, \{end}")
        out.printLine("br i1 \{forwardEntryExclusiveTest}, label %\{loopStart}, label %\{loopEnd}")
        createBlock(backwardEntry, out)
        def backwardEntryInclusive := nextLabel()
        def backwardEntryExclusive := nextLabel()
        out.printLine("br i1 \{inclusive}, label %\{backwardEntryInclusive}, " +
                "label %\{backwardEntryExclusive}")
        createBlock(backwardEntryInclusive, out)
        def backwardEntryInclusiveTest := nextVar()
        out.printLine("\{backwardEntryInclusiveTest} = icmp \{signPrefix}ge \{numberType} " +
                "\{start}, \{end}")
        out.printLine("br i1 \{backwardEntryInclusiveTest}, label %\{loopStart}, label %\{loopEnd}")
        createBlock(backwardEntryExclusive, out)
        def backwardEntryExclusiveTest := nextVar()
        out.printLine("\{backwardEntryExclusiveTest} = icmp \{signPrefix}gt \{numberType} " +
                "\{start}, \{end}")
        out.printLine("br i1 \{backwardEntryExclusiveTest}, label %\{loopStart}, label %\{loopEnd}")
        createBlock(loopStart, out)
        def indexValue := nextVar()
        out.printLine("\{indexValue} = load \{numberType}, \{numberType}* \{indexValuePtr}")
        writeStatement(block, out)
        if !endsWithBranch(block) {
            out.printLine("br label %\{loopTest}")
        }
        createBlock(loopTest, out)
        def loopInc := nextLabel()
        -- beginning of loop test, determine direction
        def forwardLabel := nextLabel()
        def backwardLabel := nextLabel()
        out.printLine("br i1 \{direction}, label %\{forwardLabel}, label %\{backwardLabel}")

        -- forward loop; perform the test by subtracting index from end and then comparing to step,
        -- to avoid overflows near the maximum value
        createBlock(forwardLabel, out)
        def forwardDelta := nextVar()
        out.printLine("\{forwardDelta} = sub \{numberType} \{end}, \{indexValue}")

        -- forward loop; determine inclusive / exclusive
        def forwardInclusiveLabel := nextLabel()
        def forwardExclusiveLabel := nextLabel()
        out.printLine("br i1 \{inclusive}, label %\{forwardInclusiveLabel}, label %" +
                forwardExclusiveLabel)

        -- forward inclusive test
        createBlock(forwardInclusiveLabel, out)
        def forwardInclusiveTest := nextVar()
        -- always use unsigned comparison to avoid overflow; we know both the delta and the step are
        -- the same sign
        out.printLine("\{forwardInclusiveTest} = icmp uge \{numberType} \{forwardDelta}, \{step}")
        out.printLine("br i1 \{forwardInclusiveTest}, label %\{loopInc}, label %\{loopEnd}")
        createBlock(forwardExclusiveLabel, out)

        -- forward exclusive test
        def forwardExclusiveTest := nextVar()
        out.printLine("\{forwardExclusiveTest} = icmp ugt \{numberType} \{forwardDelta}, \{step}")
        out.printLine("br i1 \{forwardExclusiveTest}, label %\{loopInc}, label %\{loopEnd}")

        -- backward loop; perform the test by subtracting end from index and then comparing to
        -- -step, to avoid overflows near the minimum value
        createBlock(backwardLabel, out)
        def backwardDelta := nextVar()
        out.printLine("\{backwardDelta} = sub \{numberType} \{indexValue}, \{end}")
        def negStep := nextVar()
        out.printLine("\{negStep} = sub \{numberType} 0, \{step}")

        -- backward loop; determine inclusive / exclusive
        def backwardInclusiveLabel := nextLabel()
        def backwardExclusiveLabel := nextLabel()
        out.printLine("br i1 \{inclusive}, label %\{backwardInclusiveLabel}, label %" +
                backwardExclusiveLabel)

        -- backward inclusive test
        createBlock(backwardInclusiveLabel, out)
        def backwardInclusiveTest := nextVar()
        out.printLine("\{backwardInclusiveTest} = icmp uge \{numberType} \{backwardDelta}, " +
                negStep)
        out.printLine("br i1 \{backwardInclusiveTest}, label %\{loopInc}, label %\{loopEnd}")
        createBlock(backwardExclusiveLabel, out)

        -- backward exclusive test
        def backwardExclusiveTest := nextVar()
        out.printLine("\{backwardExclusiveTest} = icmp ugt \{numberType} \{backwardDelta}, " +
                negStep)
        out.printLine("br i1 \{backwardExclusiveTest}, label %\{loopInc}, label %\{loopEnd}")

        createBlock(loopInc, out)
        def inc := nextVar()
        out.printLine("\{inc} = add \{numberType} \{indexValue}, \{step}")
        def incStruct := nextVar()
        out.printLine("\{incStruct} = insertvalue \{indexType} { \{numberType} undef")
        out.printLine(" }, \{numberType} \{inc}, 0")
        out.printLine("store \{indexType} \{incStruct}, \{indexType}* \{index}")
        out.printLine("br label %\{loopStart}")

        createBlock(loopEnd, out)
    }

    method writeWhile(w:IRNode, out:OutputStream) {
        assert w.kind = IRNode.Kind.WHILE
        assert w.children.get_count() = 2
        assert w.children[0].type = Type.Bit()
        def loopStart := nextLabel()
        def loopBody := nextLabel()
        def loopEnd := nextLabel()
        loopDescriptors.push(LoopDescriptor(w.payload->String?, loopEnd, loopStart)) -- FIXME Auto
        out.printLine("br label %\{loopStart}")
        createBlock(loopStart, out)
        def test := getTypedReference(w.children[0], out)
        def testBit := nextVar()
        out.printLine("\{testBit} = extractvalue \{test}, 0")
        out.printLine("br i1 \{testBit}, label %\{loopBody}, label %\{loopEnd}")
        createBlock(loopBody, out)
        writeStatement(w.children[1], out)
        if !endsWithBranch(w.children[1]) {
            out.printLine("br label %\{loopStart}")
        }
        createBlock(loopEnd, out)
        loopDescriptors.pop()
    }

    method writeDo(d:IRNode, out:OutputStream) {
        assert d.kind = IRNode.Kind.DO
        assert d.children.get_count() = 2
        assert d.children[1].type = Type.Bit()
        def loopStart := nextLabel()
        def loopBody := nextLabel()
        def loopEnd := nextLabel()
        loopDescriptors.push(LoopDescriptor(d.payload->String?, loopEnd, loopStart)) -- FIXME Auto
        out.printLine("br label %\{loopBody}")
        createBlock(loopStart, out)
        def test := getTypedReference(d.children[1], out)
        def testBit := nextVar()
        out.printLine("\{testBit} = extractvalue \{test}, 0")
        out.printLine("br i1 \{testBit}, label %\{loopBody}, label %\{loopEnd}")
        createBlock(loopBody, out)
        writeStatement(d.children[0], out)
        if !endsWithBranch(d.children[0]) {
            out.printLine("br label %\{loopStart}")
        }
        createBlock(loopEnd, out)
        loopDescriptors.pop()
    }

    method writeLoop(l:IRNode, out:OutputStream) {
        assert l.kind = IRNode.Kind.LOOP
        assert l.children.get_count() = 1
        def loopStart := nextLabel()
        def loopEnd := nextLabel()
        loopDescriptors.push(LoopDescriptor(l.payload->String?, loopEnd, loopStart))
        out.printLine("br label %\{loopStart}")
        createBlock(loopStart, out)
        writeStatement(l.children[0], out)
        if !endsWithBranch(l.children[0]) {
            out.printLine("br label %\{loopStart}")
        }
        createBlock(loopEnd, out)
        loopDescriptors.pop()
    }

    method writeVarTarget(target:IRNode, value:IRNode?, out:OutputStream) {
        match target.kind {
            when IRNode.Kind.VARIABLE_REFERENCE:
                def v := target.payload->Variable
                methodHeader.printLine("\{getName(v)} = alloca \{type(v.type)}")
                if value != null {
                    def ref := getTypedReference(value, out)
                    out.printLine("store \{ref}, \{type(v.type)}* \{getName(v)}")
                }
            when IRNode.Kind.TUPLE_TARGET:
                assert false
            otherwise:
                assert false
        }
    }

    method writeVar(v:IRNode, out:OutputStream) {
        assert v.kind = IRNode.Kind.VAR |
                v.kind = IRNode.Kind.DEF |
                v.kind = IRNode.Kind.PROPERTY |
                v.kind = IRNode.Kind.CONSTANT
        for decl in v.children {
            assert decl.kind = IRNode.Kind.DECLARATION
            if decl.children.get_count() > 1 {
                writeVarTarget(decl.children[0], decl.children[1], out)
            }
            else {
                writeVarTarget(decl.children[0], null, out)
            }
        }
    }

    method getLValue(lvalue:IRNode, out:OutputStream):String {
        match lvalue.kind {
            when IRNode.Kind.VARIABLE_REFERENCE:
                return getName(lvalue.payload->Variable)
            when IRNode.Kind.FIELD_REFERENCE:
                def base := getReference(lvalue.children[0], out)
                def ptr := nextVar()
                def cl := compiler.getClass(lvalue.children[0].type)
                assert cl != null
                def fields := compiler.instanceFields(cl)
                var index := -1
                for i in 0 .. fields.get_count() {
                    if fields[i].name == (lvalue.payload->FieldDecl).name { -- FIXME parens
                        index := i
                        break
                    }
                }
                assert index != -1
                out.printLine("\{ptr} = getelementptr inbounds \{typeName(cl.type())}, " +
                        "\{typeName(cl.type())}* \{base}, i64 0, i32 \{index}")
                return ptr
            when IRNode.Kind.REUSED_VALUE_DEFINITION:
                def result := getLValue(lvalue.children[0], out)
                def reused := nextVar()
                out.printLine("\{reused} = load \{type(lvalue.type)}, " +
                        "\{type(lvalue.type)}* \{result}")
                reusedValues[lvalue.payload->UInt64] := reused
                return result
            otherwise:
                assert false
        }
    }

    method writeAssignment(a:IRNode, out:OutputStream) {
        assert a.kind = IRNode.Kind.BINARY
        assert a.children.get_count() = 2
        def lvalue := "\{type(a.children[0].type)}* \{getLValue(a.children[0], out)}"
        def value:String
        def t := type(a.children[0].type)
        def op := a.payload->Int
        if op = Token.Kind.ASSIGNMENT {
            def right := getReference(a.children[1], out)
            value := "\{t} \{right}"
        }
        else {
-*            Operator binOp;
            switch (op) {
                case Operator.ADDEQ:        binOp = Operator.ADD;                         break;
                case Operator.SUBEQ:        binOp = Operator.SUB;                         break;
                case Operator.MULEQ:        binOp = Operator.MUL;                         break;
                case Operator.DIVEQ:        binOp = Operator.DIV;                         break;
                case Operator.INTDIVEQ:     binOp = Operator.INTDIV;                      break;
                case Operator.REMEQ:        binOp = Operator.REM;                         break;
                case Operator.POWEQ:        binOp = Operator.POW;                         break;
                case Operator.XOREQ:        binOp = Operator.XOR;                         break;
                case Operator.BITWISEOREQ:  binOp = Operator.BITWISEOR;                   break;
                case Operator.BITWISEANDEQ: binOp = Operator.BITWISEAND;                  break;
                case Operator.BITWISEXOREQ: binOp = Operator.BITWISEXOR;                  break;
                case Operator.SHIFTLEFTEQ:  binOp = Operator.SHIFTLEFT;                   break;
                case Operator.SHIFTRIGHTEQ: binOp = Operator.SHIFTRIGHT;                  break;
                case Operator.ANDEQ:        this->writeAndEq(lvalue, a.fChildren[1], out); return;
                case Operator.OREQ:         this->writeOrEq(lvalue, a.fChildren[1], out);  return;
                default: abort();
            }
            def left := nextVar()
            out << "    " << left << " = load " << this->llvmType(a.fChildren[0].fType) << ", " <<
                    lvalue << "\n";
            String right = this->getReference(a.fChildren[1], out);
            value = type + " " +
                    this->getBinaryReference(op_class(a.fChildren[0].fType), type + " " + left, binOp,
                            right, out);
            *-
            assert false
        }
        out.printLine("store \{value}, \{lvalue}")
    }

    method writeReturn(r:IRNode, out:OutputStream) {
        if r.children.get_count() = 1 {
            out.printLine("ret \{getTypedReference(r.children[0], out)}")
        }
        else {
            assert r.children.get_count() = 0
            out.printLine("ret void")
        }
    }

    function findLoop(name:String?):LoopDescriptor {
        assert loopDescriptors.get_count() > 0
        if name = null {
            return loopDescriptors.peek()
        }
        for i in 0 .. loopDescriptors.get_count() {
            if loopDescriptors.peek(i).loopLabel = name {
                return loopDescriptors.peek(i)
            }
        }
        assert false
    }

    method writeBreak(b:IRNode, out:OutputStream) {
        def desc := findLoop(b.payload->String?)
        out.printLine("br label %\{desc.breakLabel}")
    }

    method writeContinue(c:IRNode, out:OutputStream) {
        def desc := findLoop(c.payload->String?)
        out.printLine("br label %\{desc.continueLabel}")
    }

    method writeAssert(a:IRNode, out:OutputStream) {
        assert a.kind = IRNode.Kind.ASSERT
        assert a.children.get_count() = 1 | a.children.get_count() = 2
        def test := getReference(a.children[0], out)
        def ifTrue := nextLabel()
        def ifFalse := nextLabel()
        out.printLine("br i1 \{test}, label %\{ifTrue}, label %\{ifFalse}")
        createBlock(ifFalse, out)
        def p := compiler.position(a.offset)
        def name:String
        def index := p.file.lastIndexOf("/")
        if index = null {
            name := p.file
        }
        else {
            name := p.file[index...]
        }
        def nameRef := getStringReference(name, out)
        def line := "%panda$core$Int64 { i64 \{p.line} }"
        def msg:String?
        if a.children.get_count() = 2 {
            msg := getReference(a.children[1], out)
        }
        else {
            msg := null
        }
        out.print("call fastcc void ")
        for m in compiler.getClass(Type.Panda()).methods {
            if m.name = "assertionFailure" {
                compiler.resolve(m)
                writeDeclaration(m)
            }
        }
        if msg != null {
            out.print("@panda$core$Panda$assertionFailure$" +
                    "panda$core$String$panda$core$Int64$panda$core$String")
        }
        else {
            out.print("@panda$core$Panda$assertionFailure$panda$core$String$panda$core$Int64")
        }
        out.print("(%panda$core$String* \{nameRef}, \{line}")
        if msg != null {
            out.print(", %panda$core$String* \{msg}")
        }
        out.printLine(")")
        out.printLine("unreachable")
        createBlock(ifTrue, out)
    }

    method writeStatement(stmt:IRNode, out:OutputStream) {
        match stmt.kind {
            when IRNode.Kind.BINARY:
                writeAssignment(stmt, out)
            when IRNode.Kind.BLOCK:
                writeBlock(stmt, out)
            when IRNode.Kind.CALL:
                writeCall(stmt, null, out)
            when IRNode.Kind.IF:
                writeIf(stmt, out)
            when IRNode.Kind.RANGE_FOR:
                writeRangeFor(stmt, out)
            when IRNode.Kind.WHILE:
                writeWhile(stmt, out)
            when IRNode.Kind.DO:
                writeDo(stmt, out)
            when IRNode.Kind.LOOP:
                writeLoop(stmt, out)
            when IRNode.Kind.VAR, IRNode.Kind.DEF, IRNode.Kind.CONSTANT, IRNode.Kind.PROPERTY:
                writeVar(stmt, out)
            when IRNode.Kind.RETURN:
                writeReturn(stmt, out)
            when IRNode.Kind.BREAK:
                writeReturn(stmt, out)
            when IRNode.Kind.CONTINUE:
                writeReturn(stmt, out)
            when IRNode.Kind.ASSERT:
                writeAssert(stmt, out)
            otherwise:
                assert false, "unsupported statement \{stmt}"
        }
    }

    method selfType(m:MethodDecl):String {
        def result := type(m.owner.type())
        if m.methodKind = MethodDecl.Kind.INIT & !result.endsWith("*") {
            return result + "*"
        }
        return result
    }

    method writeDeclaration(m:MethodDecl) {
        def name := getName(m)
        if declared.contains(name) {
            return
        }
        declared.add(name)
        declarations.print("declare \{callingConvention(m)}")
        def needsIndirection := needsStructIndirection(m)
        if needsIndirection {
            declarations.print("void")
        }
        else {
            declarations.print(type(m.returnType))
        }
        declarations.print(" \{getName(m)}(")
        var separator := ""
        if needsIndirection {
            declarations.print("\{type(m.returnType)}*")
            separator := ", "
        }
        if !m.annotations.isClass() {
            declarations.print("\{separator}\{selfType(m)} %self")
            separator := ", "
        }
        for p in m.parameters {
            declarations.print("\{separator}\{type(p.type)} %\{escapeName(p.name)}")
            separator := ", "
        }
        declarations.printLine(")")
    }

    @override
    method write(m:MethodDecl, body:IRNode) {
        currentBlock := "0"
        varCount := 0
        methodHeaderBuffer.clear()
        methods.print("define \{callingConvention(m)}\{type(m.returnType)} \{getName(m)}(")
        var separator := ""
        if !m.annotations.isClass() {
            methods.print("\{selfType(m)} %self")
            separator := ", "
        }
        for p in m.parameters {
            methods.print("\{separator}\{type(p.type)} %\{escapeName(p.name)}")
            separator := ", "
        }
        methods.printLine(") {")
        methods.level += 1
        assert body.kind = IRNode.Kind.BLOCK
        def bodyBuffer := MemoryOutputStream()
        for s in body.children {
            writeStatement(s, bodyBuffer)
        }
        methods.print(methodHeaderBuffer.convert())
        methods.print(bodyBuffer.convert())
        if !endsWithBranch(body) {
            if m.returnType = Type.Void() {
                methods.printLine("ret void")
            }
            else {
                methods.printLine("unreachable")
            }
        }
        methods.level -= 1
        methods.printLine("}")
    }
}