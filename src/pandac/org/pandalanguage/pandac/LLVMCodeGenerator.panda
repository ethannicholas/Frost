package org.pandalanguage.pandac

uses org.pandalanguage.pandac.Compiler.Expression
uses org.pandalanguage.pandac.parser.Token

@final
class LLVMCodeGenerator : CodeGenerator {
    constant NO_REFCNT := -999

    class ClassConstant : Immutable {
        def name:String
        def type:String

        init(name:String, type:String) {
            self.name := name
            self.type := type
        }
    }

    class MethodShim {
        def name:String
        def type:String

        init(name:String, type:String) {
            self.name := name
            self.type := type
        }
    }

    constant POINTER_SIZE        := 8
    constant OBJECT_FIELD_COUNT  := 2
    constant CLASS_POINTER_INDEX := 0
    constant ITABLE_INDEX        := 4
    constant VTABLE_INDEX        := 5

    constant INT_TYPE  := "i64"
    constant SIZE_TYPE := "i64"

    def physicalOut:OutputStream

    def out:OutputStream

    @weak
    def compiler:Compiler?

    def declarations := MemoryOutputStream()

    def types := MemoryOutputStream()

    def methods := MemoryOutputStream()

    def methodHeader := MemoryOutputStream()

    def shims := MemoryOutputStream()

    def strings := MemoryOutputStream()

    def declared := HashSet<String>()

    def writtenTypes := HashSet<String>()

    def writtenWrappers := HashSet<String>()

    def classConstants := HashMap<String, ClassConstant>()

    var varCount := 0

    var labelCount := 0

    var currentBlock := ""

    def sizes := IdentityMap<ClassDecl, Int>()

    def choiceDataSizes := IdentityMap<ClassDecl, Int>()

    def methodShims := IdentityMap<MethodDecl, MethodShim>()

    def refs := HashMap<Int, String>()

    init(triple:String, out:OutputStream) {
        self.physicalOut := out

        out.printLine("target datalayout = \"e-m:o-i64:64-f80:128-n8:16:32:64-S128\"")
        out.printLine("target triple = \"\{triple}\"")
        out.printLine("declare i8* @pandaZAlloc(\{SIZE_TYPE})")
        out.printLine("declare i8* @pandaObjectAlloc(\{SIZE_TYPE}, %panda$core$Class*)")
        out.printLine("declare i8* @pandaRealloc(i8*, \{SIZE_TYPE}, \{SIZE_TYPE})")
        out.printLine("declare void @pandaFree(i8*)")
        out.printLine("declare i8* @memset(i8*, i8, \{SIZE_TYPE})")
        out.printLine("%$itable = type { %panda$core$Class*, %$itable*, [0 x i8*] }")
    }

    @override
    method setCompiler(compiler:Compiler) {
        self.compiler := compiler
    }

    @override
    method finish() {
        llvmType(Type.Class())
        physicalOut.print(types.finish())
        physicalOut.print(strings.finish())
        physicalOut.print(declarations.finish())
        physicalOut.print(shims.finish())
        physicalOut.print(methods.finish())
    }

    method nextVar():String {
        varCount += 1
        return "%\{varCount}"
    }

    method nextLabel():String {
        labelCount += 1
        return "$l\{labelCount}"
    }

    method createBlock(label:String, out:OutputStream) {
        out.printLine("\n\{label}:")
        currentBlock := label
    }

    function fieldSize(t:Type):Int {
        assert t.resolved
        if t = Type.Void() {
             -- void as the result of an error which should have been reported elsewhere
            return 1
        }
        if t.isBuiltinNumber() {
            if t.name.endsWith("8") {
                return 1
            }
            if t.name.endsWith("16") {
                return 2
            }
            if t.name.endsWith("32") {
                return 4
            }
            assert t.name.endsWith("64")
            return 8
        }
        if t = Type.BuiltinBit() {
            return 1
        }
        def cl := compiler.getClass(t)
        assert cl != null
        if !compiler.isValue(cl) | cl.name = "panda.unsafe.Pointer" {
            return POINTER_SIZE
        }
        var result := 0
        for f in compiler.instanceFields(cl) {
            if f.annotations.isClass() {
                continue
            }
            compiler.resolve(f)
            if f.type = Type.ChoiceData() {
                -- FIXME need to respect alignment!
                result += getChoiceDataSize(cl)
            }
            else {
                def size := fieldSize(f.type)
                def align := result % size
                if align != 0 {
                    result += size - align
                }
                assert result % size = 0
                result += size
            }
        }
        if t.typeKind = Type.Kind.NULLABLE {
            result += 1
        }
        return result
    }

    function alignment(t:Type):Int {
        return fieldSize(t).min(8)
    }

    function sizeOf(t:Type):Int {
        if !t.isClass() {
            return fieldSize(t)
        }
        def cl := compiler.getClass(t)
        assert cl != null
        if cl.name = "panda.unsafe.Pointer" {
            return POINTER_SIZE
        }
        var cached := sizes[cl]
        if cached != null {
            return cached
        }
        var result := 0
        for f in compiler.instanceFields(cl) {
            compiler.resolve(f)
            if f.type = Type.ChoiceData() {
                -- FIXME need to respect alignment!
                result += getChoiceDataSize(cl)
            }
            else {
                def size := fieldSize(f.type)
                def align := result % size
                if align != 0 {
                    result += size - align
                }
                assert result % size = 0
                result += size
            }
        }
        if compiler.isValue(cl) & t.typeKind = Type.Kind.NULLABLE {
            result += 1
        }
        sizes[cl] := result
        return result
    }

    function stride(t:Type):Int {
        def s := fieldSize(t)
        def a := alignment(t)
        if s % a = 0 {
            return s
        }
        return s + a - s % a
    }

    function sizeOfWrapper(t:Type):Int {
        def cl := compiler.getClass(t)
        assert cl != null & compiler.isValue(cl)
        var result := sizeOf(Type.Object())
        for f in compiler.instanceFields(cl) {
            compiler.resolve(f)
            if f.type = Type.ChoiceData() {
                 -- FIXME need to respect alignment!
                result += getChoiceDataSize(cl)
            }
            else {
                def size := fieldSize(f.type)
                def align := result % size
                if align != 0 {
                    result += size - align
                }
                assert result % size = 0
                result += size
            }
        }
        if t.typeKind = Type.Kind.NULLABLE {
            result += 1
        }
        return result
    }

    method getChoiceDataSize(cl:ClassDecl):Int {
        var result := choiceDataSizes[cl]
        if result = null {
            result := 0
            for entry in cl.choiceCases {
                compiler.resolve(entry)
                var current := 0
                for f in entry.fields {
                    -- FIXME need to respect alignment!
                    current += fieldSize(f)
                }
                result := result.max(current)
            }
            choiceDataSizes[cl] := result
        }
        return result
    }

    @post(compiler.currentClass.count = @pre(compiler.currentClass.count))
    method writeType(t:Type) {
        if !t.resolved {
            out.print("<unresolved type: \{t}>")
            return
        }
        if writtenTypes.contains(t.name) {
            return
        }
        writtenTypes.add(t.name)
        def cl := compiler.getClass(t)
        assert cl != null
        assert !cl.annotations.isSpecialize()
        compiler.resolve(cl)
        if cl.resolved != Compiler.Resolution.RESOLVED {
            out.print("<error resolving \{t}>")
            return
        }
        def code := MutableString("%\{escapeName(t.name)} = type { ")
        compiler.currentClass.push(cl)
        assert cl != null
        var separator := ""
        for f in compiler.instanceFields(cl) {
            compiler.resolve(f)
            if !f.type.resolved {
                Console.printLine("can't resolve: \{f.owner.name}:\{f}")
                compiler.currentClass.pop()
                return
            }
            if f.type.isClass() {
                def fCl := compiler.getClass(f.type)
                if !compiler.isValue(fCl) {
                    -- If we write the correct type definition here, we end up loading and parsing a
                    -- ton of otherwise-unused classes, for no other reason than to figure out their
                    -- type definitions (which we likely never use for anything else). Handling all
                    -- pointers as opaque i8* pointers massively reduces the number of files we need
                    -- to parse.
                    code.append("\{separator}i8*")
                    separator := ", "
                    continue
                }
            }
            if f.type = Type.ChoiceData() {
                code.append("\{separator}[\{getChoiceDataSize(cl)} x i8]")
                separator := ", "
                continue
            }
            code.append("\{separator}\{llvmType(f.type)}")
            separator := ", "
        }
        if t = Type.Class() {
            code.append(", %$itable*, [0 x i8*]")
        }
        code.append(" }")
        types.printLine(code.finish())
        if compiler.isValue(cl) {
            getWrapperClassConstant(cl)
        }
        compiler.currentClass.pop()
    }

    method writeWrapperType(t:Type) {
        if writtenWrappers.contains(t.name) {
            return
        }
        writtenWrappers.add(t.name)
        def code := MutableString("\{llvmType(t)}$wrapper = type { ")
        def object := compiler.getClass(Type.Object())
        assert object != null
        var separator := ""
        for f in compiler.instanceFields(object) {
            compiler.resolve(f)
            code.append("\{separator}\{llvmType(f.type)}")
            separator := ", "
        }
        code.append(", \{llvmType(t)}")
        code.append(" }")
        types.printLine(code.finish())
        types.printLine("\{llvmType(t)}$nullable = type { \{llvmType(t)}, i1 }")
    }

    function typeName(t:Type):String {
        return "%" + escapeName(t.name)
    }

    method llvmType(t:Type):String {
        if !t.resolved {
            return "<unresolved type: \{t}>"
        }
        match t.typeKind {
            when Type.Kind.VOID:
                return "void"
            when Type.Kind.BUILTIN_INT, Type.Kind.BUILTIN_UINT:
                return "i\{sizeOf(t) * 8}"
            when Type.Kind.BUILTIN_BIT:
                return "i1"
            when Type.Kind.BUILTIN_FLOAT:
                match sizeOf(t) {
                    when 4: return "float"
                    when 8: return "double"
                    otherwise: assert false
                }
            when Type.Kind.CLASS:
                writeType(t)
                def name := "%\{escapeName(t.name)}"
                def cl := compiler.getClass(t)
                assert cl != null
                if !compiler.isValue(cl) {
                    return name + "*"
                }
                return name
            when Type.Kind.NULLABLE:
                def cl := compiler.getClass(t)
                assert cl != null
                if compiler.isValue(cl) {
                    return nullableType(t)
                }
                return llvmType(t.subtypes[0])
            when Type.Kind.GENERIC:
                if t.subtypes[0].name = "panda.unsafe.Pointer" {
                    return llvmType(t.subtypes[1]) + "*"
                }
                def cl := compiler.getClass(t)
                if cl.isSpecialization() {
                    def name := "%\{escapeName(t.name)}"
                    def cl := compiler.getClass(t)
                    assert cl != null
                    if !compiler.isValue(cl) {
                        return name + "*"
                    }
                    return name
                }
                return llvmType(t.subtypes[0])
            when Type.Kind.GENERIC_PARAMETER:
                return llvmType(t.parameter.bound)
            when Type.Kind.FUNCTION, Type.Kind.METHOD:
                return llvmType(Type.MutableMethod())
            when Type.Kind.IMMUTABLE_FUNCTION, Type.Kind.IMMUTABLE_METHOD:
                return llvmType(Type.Method())
            otherwise:
                assert false, "unsupported type '\{t}'"
        }
    }

    ================================================================================================
    Returns the signature of a method type. Methods in Panda have two different types: normally they
    are manipulated as instances of [Method] or [MutableMethod], but sometimes we need the actual
    type signature of the underlying method. The [type()] function always returns
    `%panda.core.Method*` or `%panda.core.MutableMethod*`, whereas `methodType` returns the call
    signature of the method.
    ================================================================================================
    @pre(t.typeKind = Type.Kind.FUNCTION | t.typeKind = Type.Kind.METHOD |
            t.typeKind = Type.Kind.IMMUTABLE_FUNCTION | t.typeKind = Type.Kind.IMMUTABLE_METHOD |
            t.typeKind = Type.Kind.NULLABLE)
    method methodType(t:Type, selfType:Type?):String {
        def result := MutableString(llvmType(t.subtypes[t.subtypes.count - 1]))
        result.append(" (")
        var separator := ""
        if selfType != null {
            result.append(llvmType(selfType))
            separator := ", "
        }
        for i in 0 .. t.subtypes.count - 1 {
            result.append(separator)
            result.append(llvmType(t.subtypes[i]))
            separator := ", "
        }
        result.append(")*")
        return result.finish()
    }

    method wrapperTypeName(t:Type):String {
        if t.typeKind = Type.Kind.NULLABLE {
            return wrapperTypeName(t.subtypes[0])
        }
        writeWrapperType(t)
        return "%\{escapeName(t.name)}$wrapper"
    }

    method wrapperType(t:Type):String {
        return wrapperTypeName(t) + "*"
    }

    method wrapperType(m:MethodDecl):String {
        def inheritedType := compiler.inheritedType(m)
        def result := MutableString()
        result.append(llvmType(inheritedType.returnType()))
        result.append("(")
        assert m.isInstance()
        result.append("%\{escapeName(m.owner.name)}")
        if compiler.isValue(m.owner) {
            result.append("$wrapper")
        }
        result.append("*")
        for i in 0 .. inheritedType.subtypes.count - 1 { 
            result.append(", ")
            result.append(llvmType(inheritedType.subtypes[i]))
        }
        result.append(")*")
        return result.finish()
    }

    method nullableType(t:Type):String {
        assert t.typeKind = Type.Kind.NULLABLE, "\{t} is not nullable"
        writeWrapperType(t.subtypes[0])
        return "\{llvmType(t.subtypes[0])}$nullable"
    }

    method getITable(cl:ClassDecl):String {
        def interfaces := compiler.allInterfaces(cl.type())
        var previous := "%$itable* null"
        for intfType in interfaces {
            def intf := compiler.getClass(intfType)
            def intfCC := getClassConstant(intf)
            def methods := compiler.interfaceMethods(cl, intfType)
            def name := "@\{escapeName(cl.name)}$.\{escapeName(intf.name)}"
            def classType := llvmType(Type.Class())
            def t := "{\{classType}, %$itable*, [\{methods.count} x i8*] }"
            def intfCCCast:String
            if intfCC.type != llvmType(Type.Class()) {
                intfCCCast := "bitcast(\{intfCC.type}* \{intfCC.name} to \{classType})"
            }
            else {
                intfCCCast := intfCC.name
            }
            def result := MutableString("\{name} = ")
            if cl.isSpecialization() {
                result.append("linkonce_odr ")
            }
            result.append("constant \{t} { \{classType} \{intfCCCast}, \{previous}, " +
                    "[\{methods.count} x i8*][")
            var separator := ""
            for m in methods {
                result.append(separator)
                separator := ", "
                if m.annotations.isAbstract() {
                    result.append("i8* null")
                }
                else {
                    def entry := getMethodTableEntry(m)
                    result.append("i8* bitcast(\{entry.second} \{entry.first} to i8*)")
                }
            }
            result.append("] }\n")
            types.printLine(result.finish())
            previous := "%$itable* bitcast(\{t}* \{name} to %$itable*)"
        }
        return previous
    }

    method createMethodShim(raw:MethodDecl, effective:Type, rawOut:OutputStream):MethodShim {
        Console.printLine("need to change main out")
        def out := MemoryOutputStream()
        def found := methodShims[raw]
        if found != null {
            return found
        }
        assert effective.isMethod()
        assert effective.subtypes.count = raw.parameters.count + 2 -- self and return
        assert raw.isInstance()
        def unrefs := MemoryOutputStream()
        def oldVarCount := varCount
        varCount := 0
        def effectiveReturnType := effective.returnType()
        def resultName := getName(raw) + "$shim"
        def resultType := MutableString(llvmType(effectiveReturnType))
        out.print("define linkonce_odr ")
        out.print("\{resultType} \{resultName}(")
        resultType.append("(")
        var separator := ""
        for i in 0 .. effective.subtypes.count - 1 {
            def pType := llvmType(effective.subtypes[i])
            resultType.append(", ")
            resultType.append(pType)
            out.print("\{separator}\{pType} %p\{i}")
            separator := ", "
        }
        resultType.append(")*")
        out.printLine(") {")
        def casts := Array<String>()
        for i in 0 .. effective.subtypes.count - 1 {
            def p := "%p\{i}"
            def rawType:Type
            if i = 0 {
                rawType := raw.owner.type()
            }
            else {
                rawType := raw.parameters[i - 1].type
            }
            if rawType != effective.subtypes[i] {
                def cast := getCastReference(p, effective.subtypes[i], rawType)
                casts.add(cast)
                if compiler.isValue(effective.subtypes[i]) & !compiler.isValue(rawType) {
                    labelCount += 1
                    def objectCast := "%objectCast\{labelCount}"
                    unrefs.printLine("\{objectCast} = bitcast \{llvmType(rawType)} \{cast} to " +
                            "%panda$core$Object*")
                    unrefs.printLine("call void @panda$core$Panda$unref$panda$core$Object(" +
                            "%panda$core$Object* \{objectCast})")

                }
            }
            else {
                casts.add(p)
            }
        }
        def returnValue:String
        if raw.returnType != Type.Void() {
            returnValue := nextVar()
            out.print("\{returnValue} = ")
        }
        else {
            returnValue := "void"
        }
        out.print("call \{llvmType(raw.returnType)} \{getName(raw)}(")
        separator := ""
        for i in 0 .. effective.subtypes.count - 1 {
            def rawType:Type
            if i = 0 {
                rawType := raw.owner.type()
            }
            else {
                rawType := raw.parameters[i - 1].type
            }
            out.print("\{separator}\{llvmType(rawType)} \{casts[i]}")
            separator := ", "
        }
        out.printLine(")")
        if raw.returnType != Type.Void() {
            returnValue := llvmType(effectiveReturnType) + " " +
                    getCastReference(returnValue, raw.returnType, effectiveReturnType)
        }
        out.printLine(unrefs)
        out.printLine("ret \{returnValue}")
        out.printLine("}")
        varCount := oldVarCount
        def result := MethodShim(resultName, resultType.finish())
        methodShims[raw] := result
        rawOut.print(out.finish())
        return result
    }

    method getWrapperITable(cl:ClassDecl):String {
        def interfaces := compiler.allInterfaces(cl.type())
        var previous := "%$itable* null"
        for intfType in interfaces {
            def intf := compiler.getClass(intfType)
            def intfCC := getClassConstant(intf)
            def methods := compiler.interfaceMethods(cl, intfType)
            def name := "@\{escapeName(cl.name)}$wrapper.\{escapeName(intf.name)}"
            def t := "{\{llvmType(Type.Class())}, %$itable*, [\{methods.count} x i8*] }"
            def intfCCCast:String
            if intfCC.type != llvmType(Type.Class()) {
                intfCCCast := "bitcast(\{intfCC.type}* \{intfCC.name} to \{llvmType(Type.Class())})"
            }
            else {
                intfCCCast := intfCC.name
            }
            def result := MutableString("\{name} = ")
            if cl.isSpecialization() {
                result.append("linkonce_odr ")
            }
            result.append("constant \{t} { \{llvmType(Type.Class())} \{intfCCCast}, \{previous}, " +
                    "[\{methods.count} x i8*][")
            var separator := ""
            for m in methods {
                result.append(separator)
                separator := ", "
                if m.annotations.isAbstract() {
                    result.append("i8* null")
                }
                else {
                    def entry := getMethodTableEntry(m)
                    result.append("i8* bitcast(\{entry.second} \{entry.first} to i8*)")
                }
            }
            result.append("] }\n")
            types.printLine(result.finish())
            previous := "%$itable* bitcast(\{t}* \{name} to %$itable*)"
        }
        return previous
    }

    ================================================================================================
    Returns true if this is an external method returning a struct.

    Returning structs from C functions into LLVM code is tricky. I tried it the naive and obvious
    way, and found it didn't work. Some cursory research indicated that C functions that return
    structs are at least sometimes compiled to accept a special pointer ("sret") as an extra
    parameter, and the caller is expected to know to alloca space for the return value and pass in a
    pointer to it.

    Since online sources were complaining about how poorly documented this is, there were
    indications that there may be multiple struct return strategies depending on the nature of
    the struct, people were suggesting looking at the assembly code generated by Clang to figure
    out how one was supposed to call a given function, and this all varies from platform to
    platform, we avoid the whole mess by making it explicit. External functions which wish to
    return structs explicitly receive a pointer to the result structure as their first parameter.
    ================================================================================================
    function needsStructIndirection(m:MethodDecl):Bit {
        if !m.returnType.isClass() {
            return false
        }
        def result := m.annotations.isExternal() & m.returnType.isClass() &
                compiler.isValue(compiler.getClass(m.returnType))
        -- if an external method requires struct indirection, it will have a different signature
        -- than a non-external method; this means this feature doesn't play nice with overriding. We
        -- can fix this down the road with shims, but for right now just assert that a method
        -- requiring struct indirection is not an override and cannot be overridden
        assert !result | (!m.annotations.isOverride() & (m.annotations.isFinal() |
                m.annotations.isClass())), "invalid struct indirection on \{m.signature()}"
        return result
    }

    method getMethodTableEntry(m:MethodDecl):Pair<String, String> -* name, type *- {
        compiler.resolve(m)
        if m.owner.external {
            writeDeclaration(m)
        }
        def resultName:String
        def declared := compiler.declaredTypeWithSelf(m, m.owner.type())
        def effectiveSelf:Type
        if compiler.isValue(m.owner) {
            effectiveSelf := Type.Object()
        }
        else {
            effectiveSelf := m.owner.type()
        }
        def inherited := compiler.inheritedTypeWithSelf(m, effectiveSelf)
        if declared != inherited {
            def shim := createMethodShim(m, inherited, shims)
            resultName := shim.name
        }
        else {
            resultName := getName(m)
        }
        if needsStructIndirection(m) {
            def resultType := MutableString("void (")
            resultType.append(llvmType(inherited.subtypes[inherited.subtypes.count - 1]))
            resultType.append("*")
            for i in 0 .. inherited.subtypes.count - 1 {
                resultType.append(", ")
                resultType.append(llvmType(inherited.subtypes[i]))
            }
            resultType.append(")*")
            return Pair<String, String>(resultName, resultType.finish())
        }
        return Pair<String, String>(resultName, methodType(inherited, null))
    }

    method getClassConstant(cl:ClassDecl):ClassConstant {
        assert !cl.annotations.isSpecialize()
        var result := classConstants[cl.name]
        if result = null {
            compiler.resolve(cl)
            def type:String
            if cl.external {
                result := ClassConstant("@\{escapeName(cl.type().name)}$class",
                        "%panda$core$Class")
                classConstants[cl.name] := result
                types.printLine("\{result.name} = external global \{result.type}")
                return classConstants[cl.name]
            }
            def vtable := compiler.getVTable(cl)
            result := ClassConstant("@\{escapeName(cl.type().name)}$class",
                    "{ %panda$core$Class*, \{INT_TYPE}, %panda$core$String*, %panda$core$Class*, " +
                    "%$itable*, [\{vtable.count} x i8*] }")
            classConstants[cl.name] := result
            def superPtr:String
            if cl.rawSuper != null {
                def superCC := getClassConstant(compiler.getClass(cl.rawSuper))
                superPtr := "bitcast(\{superCC.type}* \{superCC.name} to %panda$core$Class*)"
            }
            else {
                superPtr := "null"
            }
            def clConstant := getClassConstant(compiler.getClass(Type.Class()))
            def code := MutableString("\{result.name} = ")
            if cl.isSpecialization() {
                code.append("linkonce_odr ")
            }
            code.append("constant \{result.type} { " +
                    "%panda$core$Class* bitcast(\{clConstant.type}* \{clConstant.name} to " +
                    "%panda$core$Class*), \{INT_TYPE} \{NO_REFCNT}, %panda$core$String* " +
                    getStringReference(cl.name) + ", %panda$core$Class* \{superPtr}, " +
                    "\{getITable(cl)}, [\{vtable.count} x i8*] [")
            var separator := ""
            for m in vtable {
                code.append(separator)
                if m.annotations.isAbstract() {
                    code.append("i8* null")
                }
                else {
                    def entry := getMethodTableEntry(m)
                    code.append("i8* bitcast(\{entry.second} \{entry.first} to i8*)")
                }
                separator := ", "
            }
            code.append("] }\n")
            types.printLine(code.finish())
        }
        return result
    }

    method getWrapperClassConstant(cl:ClassDecl):ClassConstant {
        compiler.resolve(cl)
        def name := "@\{escapeName(cl.name)}$wrapperclass"
        var result := classConstants[name]
        if result = null {
            if cl.external {
                llvmType(Type.Class())
                def type := "%panda$core$Class"
                types.printLine("\{name} = external global \{type}")
                result := ClassConstant(name, type)
                classConstants[name] := result
            }
            else {
                def value := compiler.getClass(Type.Value())
                def valueVTable := compiler.getVTable(value)
                result := ClassConstant("@\{escapeName(cl.name)}$wrapperclass",
                        "{ %panda$core$Class*, \{INT_TYPE}, %panda$core$String*, " +
                        "%panda$core$Class*, %$itable*, [\{valueVTable.count} x i8*] }")
                classConstants[name] := result
                def vtable := compiler.getVTable(cl)
                def superCC := getClassConstant(compiler.getClass(cl.rawSuper))
                def superCast:String
                if superCC.type != llvmType(Type.Class()) {
                    superCast := "bitcast(\{superCC.type}* \{superCC.name} to %panda$core$Class*)"
                }
                else {
                    superCast := superCC.name
                }
                def itable := getWrapperITable(cl)
                def clConstant := getClassConstant(compiler.getClass(Type.Class()))
                def code := MutableString("\{result.name} = ")
                if cl.isSpecialization() {
                    code.append("linkonce_odr ")
                }
                code.append("constant \{result.type} { " +
                        "%panda$core$Class* bitcast(\{clConstant.type}* \{clConstant.name} to " +
                        "%panda$core$Class*), \{INT_TYPE} \{NO_REFCNT}, %panda$core$String* " +
                        "\{getStringReference(cl.name)}, \{llvmType(Type.Class())} \{superCast}, " +
                        "\{itable}, [\{valueVTable.count} x i8*] [")
                var separator := ""
                for i in 0 .. valueVTable.count {
                    def m := vtable[i]
                    def entry := getMethodTableEntry(m)
                    code.append("\{separator}i8* bitcast(\{entry.second} \{entry.first} to i8*)")
                    separator := ", "
                }
                code.append("] }\n")
                types.print(code.finish())
            }
        }
        return result
    }

    function escapeName(s:String):String {
        def result := MutableString(s.byteLength() * 2)
        var current := s.start()
        def end := s.end()
        while current != end {
            def c := s[current]
            match c {
                when ".": result.append("$")
                when "?": result.append("$Q")
                when "<": result.append("$LT")
                when ">": result.append("$GT")
                when " ": -- do nothing
                when ",": result.append("$C")
                when "(": result.append("$LP")
                when ")": result.append("$RP")
                when "=": result.append("$EQ")
                when "&": result.append("$AM")
                when "*": result.append("$ST")
                otherwise: result.append(c)
            }
            current := s.next(current)
        }
        return result.finish()
    }

    function getName(v:Variable):String {
        return "%\{v.name}"
    }

    function getName(m:MethodDecl):String {
        if m.name = "main" {
            return "@pandaMain"
        }
        def result := MutableString("@")
        result.append(escapeName(m.owner.name))
        result.append("$")
        match m.name {
            when "+":    result.append("$ADD")
            when "-":    result.append("$SUB")
            when "*":    result.append("$MUL")
            when "/":    result.append("$DIV")
            when "//":   result.append("$INTDIV")
            when "%":    result.append("$REM")
            when "^":    result.append("$POW")
            when "[]":   result.append("$IDX")
            when "[]:=": result.append("$IDXEQ")
            when "=":    result.append("$EQ")
            when "!=":   result.append("$NEQ")
            when ">":    result.append("$GT")
            when "<":    result.append("$LT")
            when ">=":   result.append("$GE")
            when "<=":   result.append("$LE")
            when "|":    result.append("$OR")
            when "||":   result.append("$BOR")
            when "&":    result.append("$AND")
            when "&&":   result.append("$BAND")
            when "~":    result.append("$XOR")
            when "~~":   result.append("$BXOR")
            when "!":    result.append("$NOT")
            when "!!":   result.append("$BNOT")
            when "<<":   result.append("$SHL")
            when ">>":   result.append("$SHR")
            otherwise:   result.append(escapeName(m.name))
        }
        for p in m.parameters {
            result.append("$\{escapeName(p.type.name)}")
        }
        if m.returnType != Type.Void() {
            result.append("$R$")
            result.append(escapeName(m.returnType.name))
        }
        return result.finish()
    }

    function getName(f:FieldDecl):String {
        assert f.annotations.isClass()
        return "@\{escapeName(f.owner.name)}$\{f.name}"
    }

    class OpClass {
        constant SIGNED   := 10121
        constant UNSIGNED := 10122
        constant FLOAT    := 10123
    }

    function opClass(t:Type):Int {
        match t.typeKind {
            when Type.Kind.BUILTIN_INT:
                return OpClass.SIGNED
            when Type.Kind.BUILTIN_UINT, Type.Kind.BUILTIN_BIT:
                return OpClass.UNSIGNED
            when Type.Kind.BUILTIN_FLOAT:
                return OpClass.FLOAT
            otherwise:
                assert false
        }
    }

    method getVirtualMethodReference(target:String, m:MethodDecl, out:OutputStream):String {
        def cc := getClassConstant(m.owner)
        var index := -1
        def vtable := compiler.getVTable(m.owner)
        for i in 0 .. vtable.count {
            if vtable[i]->MethodDecl == m { -- FIXME unnecessary cast
                index := i
                break
            }
        }
        assert index != -1
        def classPtrPtr := nextVar()
        out.printLine("\{classPtrPtr} = getelementptr inbounds \{typeName(m.owner.type())}, " +
                "\{target}, i64 0, i32 0")
        def classPtr := nextVar()
        out.printLine("\{classPtr} = load i8*, i8** \{classPtrPtr}")
        def cast := nextVar()
        out.printLine("\{cast} = bitcast i8* \{classPtr} to \{cc.type}*")
        def ptr := nextVar()
        out.printLine("\{ptr} = getelementptr inbounds \{cc.type}, \{cc.type}* \{cast}, i64 0, " +
                "i32 \{VTABLE_INDEX}, i64 \{index}")
        def load := nextVar()
        out.printLine("\{load} = load i8*, i8** \{ptr}")
        def result := nextVar()
        out.printLine("\{result} = bitcast i8* \{load} to " +
                methodType(compiler.inheritedTypeWithSelf(m), null))
        return result
    }

    method getInterfaceMethodReference(target:String, m:MethodDecl,
            out:OutputStream):String {
        def methodTypeString := methodType(compiler.inheritedTypeWithSelf(m), null)
        -- load class constant entry
        def entry := nextLabel()
        out.printLine("br label %\{entry}")
        createBlock(entry, out)
        def rawClassPointer := nextVar()
        out.printLine("\{rawClassPointer} = getelementptr inbounds \{typeName(m.owner.type())}, " +
                "\{target}, \{SIZE_TYPE} 0, i32 \{CLASS_POINTER_INDEX}")
        def classPointer := nextVar()
        def classType := typeName(Type.Class())
        out.printLine("\{classPointer} = bitcast i8** \{rawClassPointer} to \{classType}**")
        def loadedClass := nextVar()
        out.printLine("\{loadedClass} = load \{classType}*, \{classType}** \{classPointer}")
        def itableFirst := nextVar()
        out.printLine("\{itableFirst} = getelementptr inbounds \{classType}, \{classType}* " +
                "\{loadedClass}, \{SIZE_TYPE} 0, i32 \{ITABLE_INDEX}")
        def next := nextLabel()
        out.printLine("br label %\{next}")
        def leavingEntryLabel := currentBlock
        createBlock(next, out)
        labelCount += 1
        def itableNext := "%$itable\{labelCount}"
        def itablePtrPtr := nextVar()
        def fail := nextLabel()
        out.printLine("\{itablePtrPtr} = phi %$itable** [ \{itableFirst}, %\{leavingEntryLabel}]," +
                " [ \{itableNext}, %\{fail} ]")
        def itablePtr := nextVar()
        out.printLine("\{itablePtr} = load %$itable*, %$itable** \{itablePtrPtr}")
        def itableClassPtr := nextVar()
        out.printLine("\{itableClassPtr} = getelementptr inbounds %$itable, %$itable* " +
                "\{itablePtr}, \{SIZE_TYPE} 0, i32 0")
        def itableClass := nextVar()
        out.printLine("\{itableClass} = load \{classType}*, \{classType}** \{itableClassPtr}")
        def test := nextVar()
        def intfCC := getClassConstant(m.owner)
        out.printLine("\{test} = icmp eq \{classType}* bitcast(\{intfCC.type}* \{intfCC.name} to " +
                "\{classType}*), \{itableClass}")
        def success := nextLabel()
        out.printLine("br i1 \{test}, label %\{success}, label %\{fail}")

        createBlock(fail, out)
        out.printLine("\{itableNext} = getelementptr inbounds %$itable, %$itable* \{itablePtr}, " +
                "\{SIZE_TYPE} 0, i32 1")
        out.printLine("br label %\{next}")

        createBlock(success, out)
        var index := -1
        def vtable := compiler.getVTable(m.owner)
        for i in 0 .. vtable.count {
            if vtable[i]->MethodDecl == m { -- FIXME unnecessary cast
                index := i
                break
            }
        }
        index -= compiler.getVTable(compiler.getClass(Type.Object())).count
        assert index != -1
        def methodPtrPtr := nextVar()
        out.printLine("\{methodPtrPtr} = getelementptr inbounds %$itable, %$itable* " +
                "\{itablePtr}, \{SIZE_TYPE} 0, i32 2, i32 \{index}")
        def cast := nextVar()
        out.printLine("\{cast} = bitcast i8** \{methodPtrPtr} to \{methodTypeString}*")
        def methodPtr := nextVar()
        out.printLine("\{methodPtr} = load \{methodTypeString}, \{methodTypeString}* \{cast}")
        return methodPtr
    }

    method getMethodReference(target:String?, m:MethodDecl, isSuper:Bit,
            out:OutputStream):String {
        if !isSuper & m.isVirtual() {
            assert target != null, "calling instance \{m.signature()} without a target"
            if m.owner.classKind = ClassDecl.Kind.INTERFACE {
                return getInterfaceMethodReference(target, m, out)
            }
            else {
                return getVirtualMethodReference(target, m, out)
            }
        }
        else {
            if m.owner.external {
                writeDeclaration(m)
            }
            return getName(m)
        }
    }

    method wrapValue(value:String, srcType:Type, dstType:Type, out:OutputStream):String {
        def src := compiler.getClass(srcType)
        assert src != null
        if srcType.typeKind = Type.Kind.NULLABLE {
            -- casting nullable value to nullable wrapper, need to special-case null
            def testStart := currentBlock
            def isNonNull := nextVar()
            out.printLine("\{isNonNull} = extractvalue \{nullableType(srcType)} \{value}, 1")
            def nonNullLabel := nextLabel()
            def endLabel := nextLabel()
            out.printLine("br i1 \{isNonNull}, label %\{nonNullLabel}, label %\{endLabel}")
            createBlock(nonNullLabel, out)
            def unwrapped := toNonNullableValue(value, srcType, srcType.subtypes[0], out)
            def nonNullValue := wrapValue(unwrapped, srcType.subtypes[0], dstType, out)
            out.printLine("br label %\{endLabel}")
            createBlock(endLabel, out)
            def result := nextVar()
            out.printLine("\{result} = phi \{llvmType(dstType)} [null, %\{testStart}], " +
                    "[\{nonNullValue}, %\{nonNullLabel}]")
            return result
        }
        def cc := getWrapperClassConstant(src)
        def ccCast:String
        if cc.type != "%panda$core$Class" {
            ccCast := "bitcast(\{cc.type}* \{cc.name} to %panda$core$Class*)"
        }
        else {
            ccCast := cc.name
        }
        def mallocRef := nextVar()
        out.printLine("\{mallocRef} = call i8* @pandaObjectAlloc(" +
                "i64 \{sizeOfWrapper(src.type())}, %panda$core$Class* \{ccCast})")
        def wrapperTypeName := wrapperTypeName(src.type())
        def wrapperType := wrapperType(src.type())
        def wrapperCast := nextVar()
        out.printLine("\{wrapperCast} = bitcast i8* \{mallocRef} to \{wrapperType}")
        def target := nextVar()
        out.printLine("\{target} = getelementptr \{wrapperTypeName}, " +
                "\{wrapperType} \{wrapperCast}, i64 0, i32 2")
        out.printLine("store \{llvmType(srcType)} \{value}, \{llvmType(srcType)}* \{target}")
        if wrapperType != llvmType(dstType) {
            def result := nextVar()
            out.printLine("\{result} = bitcast \{wrapperType} \{wrapperCast} to " +
                    llvmType(dstType))
            return result
        }
        return wrapperCast
    }

    method unwrapValue(value:String, srcType:Type, dstType:Type, out:OutputStream):String {
        def target := compiler.getClass(dstType)
        assert target != null
        if dstType.typeKind = Type.Kind.NULLABLE {
            -- casting nullable wrapper to nullable value, need to special-case null
            def testStart := currentBlock
            def isNonNull := nextVar()
            out.printLine("\{isNonNull} = icmp ne \{llvmType(srcType)} \{value}, null")
            def nonNullLabel := nextLabel()
            def endLabel := nextLabel()
            out.printLine("br i1 \{isNonNull}, label %\{nonNullLabel}, label %\{endLabel}")
            createBlock(nonNullLabel, out)
            def wrapped := unwrapValue(value, srcType, dstType.subtypes[0], out)
            def nonNullValue := toNullableValue(wrapped, dstType.subtypes[0], dstType, out)
            out.printLine("br label %\{endLabel}")
            createBlock(endLabel, out)
            def result := nextVar()
            out.printLine("\{result} = phi \{llvmType(dstType)} " +
                    "[{ \{llvmType(dstType.subtypes[0])} undef, i1 0 }, " +
                    "%\{testStart}], [\{nonNullValue}, %\{nonNullLabel}]")
            return result
        }
        def targetType := llvmType(dstType)
        def wrapperTypeName := wrapperTypeName(dstType)
        def wrapperType := wrapperType(dstType)
        def srcCast := nextVar()
        out.printLine("\{srcCast} = bitcast \{llvmType(srcType)} \{value} to \{wrapperType}")
        def load := nextVar()
        out.printLine("\{load} = load \{wrapperTypeName}, \{wrapperType} \{srcCast}")
        def result := nextVar()
        out.printLine("\{result} = extractvalue \{wrapperTypeName} \{load}, \{OBJECT_FIELD_COUNT}")
        return result
    }

    method toNullableValue(value:String, srcType:Type, dstType:Type,
            out:OutputStream):String {
        def nullableType := nullableType(dstType)
        def result := nextVar()
        out.printLine("\{result} = insertvalue \{nullableType} " +
                "{ \{llvmType(srcType)} undef, i1 true }, \{llvmType(srcType)} \{value}, 0")
        return result
    }

    method toNonNullableValue(value:String, srcType:Type, dstType:Type,
            out:OutputStream):String {
        def result := nextVar()
        out.printLine("\{result} = extractvalue \{llvmType(srcType)} \{value}, 0")
        return result
    }

    method getCastReference(value:String, src:Type, target:Type):String {
        def op:String
        if target.isBuiltinNumber() {
            assert src.isBuiltinNumber()
            def size1 := sizeOf(src)
            def size2 := sizeOf(target)
            if src.typeKind = Type.Kind.BUILTIN_FLOAT {
                if target.typeKind = Type.Kind.BUILTIN_FLOAT {
                    if size1 > size2 {
                        op := "fptrunc"
                    }
                    else if size1 < size2 {
                        op := "fpext"
                    }
                    else {
                        return value
                    }
                }
                else if target.typeKind = Type.Kind.BUILTIN_INT {
                    op := "fptosi"
                }
                else {
                    assert target.typeKind = Type.Kind.BUILTIN_UINT
                    op := "fptoui"
                }
            }
            else if target.typeKind = Type.Kind.BUILTIN_FLOAT {
                if src.typeKind = Type.Kind.BUILTIN_INT {
                    op := "sitofp"
                }
                else {
                    assert src.typeKind = Type.Kind.BUILTIN_UINT
                    op := "uitofp"
                }
            }
            else {
                if size1 > size2 {
                    op := "trunc"
                }
                else if size1 < size2 {
                    if src.typeKind = Type.Kind.BUILTIN_INT {
                        op := "sext"
                    }
                    else {
                        op := "zext"
                    }
                }
                else {
                    return value
                }
            }
        }
        else {
            def srcClass := compiler.getClass(src)
            assert srcClass != null
            def targetClass := compiler.getClass(target)
            assert targetClass != null
            if compiler.isValue(srcClass) & !compiler.isValue(targetClass) {
                return wrapValue(value, src, target, out)
            }
            else if !compiler.isValue(srcClass) & compiler.isValue(targetClass) {
                return unwrapValue(value, src, target, out)
            }
            else if compiler.isValue(srcClass) & target.typeKind = Type.Kind.NULLABLE &
                    target.subtypes[0] = src {
                return toNullableValue(value, src, target, out)
            }
            else if compiler.isValue(targetClass) & src.typeKind = Type.Kind.NULLABLE &
                    src.subtypes[0] = target {
                return toNonNullableValue(value, src, target, out)
            }
            op := "bitcast"
        }
        def srcType := llvmType(src)
        def dstType := llvmType(target)
        if srcType = dstType {
            return value
        }
        def result := nextVar()
        out.printLine("\{result} = \{op} \{srcType} \{value} to \{dstType}")
        return result
    }

    method getIntReference(int:UInt64, out:OutputStream):String {
        return int.convert()
    }

    method getNegatedIntReference(int:UInt64, out:OutputStream):String {
        return "-" + int.convert()
    }

    method getRealReference(t:Type, r64:Real64, out:OutputStream):String {
        if t.size() = 32 {
            -- LLVM has a bizarre representation of float. You still use a double, but must ensure
            -- that said double is exactly representable as a float. We convert through Real32 to
            -- ensure this.
            def r32 := r64.convert()->panda.core.Real32.convert()->Real64
            return "0x\{Panda.floatToIntBits(r32):x}"
        }
        return "0x\{Panda.floatToIntBits(r64):x}"
    }

    method getBitReference(bit:Bit, out:OutputStream):String {
        if bit {
            return "true"
        }
        return "false"
    }

    method getVariableReference(v:Variable, out:OutputStream):String {
        if v.storage = Variable.Storage.PARAMETER {
            return getName(v)
        }
        def result := nextVar()
        def t := llvmType(v.type)
        out.printLine("\{result} = load \{t}, \{t}* \{getName(v)}")
        return result
    }

    method getStringReference(s:String):String {
        labelCount += 1
        def chars := "@$chars\{labelCount}"
        def charsType := "[\{s.utf8().count} x i8]"
        strings.print("\{chars} = private unnamed_addr constant \{charsType} [ ")
        var separator := ""
        for c in s.utf8() {
            strings.print("\{separator}i8 \{c.convert()->Int8}")
            separator := ", "
        }
        strings.printLine(" ]")
        labelCount += 1
        def result := "@$str\{labelCount}"
        def string := compiler.getClass(Type.StringType())
        assert string != null
        def cc := getClassConstant(string)
        strings.printLine("\{result} = private unnamed_addr constant %panda$core$String { " +
                "i8* bitcast(\{cc.type}* \{cc.name} to " +
                "i8*), %panda$core$Int32 insertvalue(%panda$core$Int32 " +
                "{ i32 undef }, i32 \{NO_REFCNT}, 0), " +
                "%panda$core$Char8* bitcast(\{charsType}* \{chars} " +
                "to %panda$core$Char8*), %panda$core$Int64 { i64 \{s.utf8().count} }, " +
                "%panda$core$Int64 { i64 \{s.hash()} }, i8* null }")
        return result
    }

    ================================================================================================
    In init methods, %self must be a pointer rather than a value, so that we can modify our fields.
    This returns true if our current %self is a pointer to a value.
    ================================================================================================
    function haveSelfValuePointer():Bit {
        return compiler.currentMethod[0].methodKind = MethodDecl.Kind.INIT &
                compiler.isValue(compiler.currentMethod[0].owner)
    }

    ================================================================================================
    Returns the current %self, as a pointer. For values, this pointer is only available from within
    init methods.
    ================================================================================================
    method getSelfPointer():String {
        assert compiler.currentMethod[0].methodKind = MethodDecl.Kind.INIT |
                !compiler.isValue(compiler.currentMethod[0].owner),
                "self pointer for values is only accessible from init methods " +
                "(in \{compiler.currentMethod[0].declaration()})"
        return "%self"
    }

    ================================================================================================
    Returns the current %self, as a value if the current object is a value. For non-value objects
    %self is always a pointer.
    ================================================================================================
    method getSelfValue(out:OutputStream):String {
        assert compiler.currentMethod[0] != null
        if haveSelfValuePointer() {
            def load := nextVar()
            out.printLine("\{load} = load \{llvmType(compiler.currentMethod[0].owner.type())}, " +
                    "\{llvmType(compiler.currentMethod[0].owner.type())}* \{getSelfPointer()}")
            return load
        }
        return "%self"
    }

    method getSelfReference(out:OutputStream):String {
        return getSelfValue(out)
    }

    method getSuperReference(t:Type, out:OutputStream):String {
        def ref := getSelfReference(out)
        def result := nextVar()
        out.printLine("\{result} = bitcast \{selfType(compiler.currentMethod[0])} \{ref} to " +
                "\{llvmType(t)}")
        return result
    }

    method getNullReference(t:Type, out:OutputStream):String {
        assert t.typeKind = Type.Kind.NULLABLE
        def cl := compiler.getClass(t.subtypes[0])
        assert cl != null
        if compiler.isValue(cl) {
            return "{ \{llvmType(t.subtypes[0])} undef, i1 0 }"
        }
        else {
            return "null"
        }
    }

    method getTypeReference(type:Type, out:OutputStream):String {
        def cc := getClassConstant(compiler.getClass(type))
        return "bitcast(\{cc.type}* \{cc.name} to %panda$core$Class*)"
    }

    method getChoiceFieldOffset(e:ChoiceCase, index:Int):Int {
        var result := 0
        for i in 0 .. index {
            -- FIXME need to respect alignment!
            result += fieldSize(e.fields[i])
        }
        return result
    }

    method selfType(m:MethodDecl):String {
        def result := llvmType(m.owner.type())
        if m.methodKind = MethodDecl.Kind.INIT & !result.endsWith("*") {
            return result + "*"
        }
        return result
    }

    @override
    method writeDeclaration(m:MethodDecl) {
        def name := getName(m)
        if declared.contains(name) {
            return
        }
        declared.add(name)
        declarations.print("declare ")
        def needsIndirection := needsStructIndirection(m)
        if needsIndirection {
            declarations.print("void")
        }
        else {
            declarations.print(llvmType(compiler.returnType(null, m)))
        }
        declarations.print(" \{getName(m)}(")
        var separator := ""
        if needsIndirection {
            declarations.print("\{llvmType(m.returnType)}*")
            separator := ", "
        }
        if !m.annotations.isClass() & !compiler.isValueInit(m) {
            declarations.print("\{separator}\{selfType(m)} %self")
            separator := ", "
        }
        for p in m.parameters {
            declarations.print("\{separator}\{llvmType(p.type)} %\{escapeName(p.name)}")
            separator := ", "
        }
        declarations.printLine(")")
    }

    method getReference(v:IR.Value):String {
        match v {
            when IR.Value.INT(value, _):
                return value.convert()
            when IR.Value.REF(id, _):
                assert refs[id] != null, "id \{id} has not been defined"
                return refs[id]
            when IR.Value.STRING(s):
                return getStringReference(s)
            otherwise:
                assert false, "unsupported value \{v}"
        }
    }

    method getTypedReference(v:IR.Value):String {
        return "\{llvmType(v.type())} \{getReference(v)}"
    }

    method writeBranch(target:Int) {
        out.printLine("br label %block\{target}")
    }

    method writeCast(id:Int, value:IR.Value, target:Type) {
        refs[id] := getCastReference(getReference(value), value.type(), target)
    }

    method writeConditionalBranch(test:IR.Value, ifTrue:Int, ifFalse:Int) {
        out.printLine("br \{getTypedReference(test)}, label %block\{ifTrue}, " +
                "label %block\{ifFalse}")
    }

    method writeConstruct(id:Int, cl:ClassDecl) {
        if compiler.isValue(cl) {
            labelCount += 1
            def alloca := "%$tmp\{labelCount}"
            methodHeader.printLine("\{alloca} = alloca \{cl.type()}")
            refs[id] := alloca
            return
        }
        def cc := getClassConstant(cl)
        def ccCast:String
        if cc.type != "%panda$core$Class" {
            ccCast := "bitcast(\{cc.type}* \{cc.name} to %panda$core$Class*)"
        }
        else {
            ccCast := cc.name
        }
        def callRef := nextVar()
        def target := cl.type()
        out.printLine("\{callRef} = call i8* @pandaObjectAlloc(i64 \{sizeOf(target)}, " +
                "%panda$core$Class* \{ccCast})")
        def result := nextVar()
        out.printLine("\{result} = bitcast i8* \{callRef} to \{llvmType(target)}")
        refs[id] := result
    }

    method writeGetField(id:Int, value:IR.Value, type:Type, field:Int) {
        def result := nextVar()
        out.printLine("\{result} = extractvalue \{getTypedReference(value)}, \{field}")
        refs[id] := result
    }

    method writeReturn(value:IR.Value?) {
        if value != null {
            out.printLine("ret \{getTypedReference(value)}")
        }
        else {
            out.printLine("ret void")
        }
    }

    method writeStaticCall(id:Int, m:MethodDecl, args:ListView<IR.Value>) {
        if m.owner.external {
            writeDeclaration(m)
        }
        def type := compiler.returnType(null, m)
        if type != Type.Void() {
            def result := nextVar()
            out.print("\{result} = ")
            refs[id] := result
        }
        out.print("call \{llvmType(type)} \{getName(m)}(")
        var separator := ""
        for a in args {
            out.print(separator)
            out.print(getTypedReference(a))
            separator := ", "
        }
        out.printLine(")")
    }

    method writeStatement(id:Int, s:IR.Statement) {
        match s {
            when IR.Statement.BRANCH(target):
                writeBranch(target)
            when IR.Statement.CAST(value, type):
                writeCast(id, value, type)
            when IR.Statement.CONDITIONAL_BRANCH(test, ifTrue, ifFalse):
                writeConditionalBranch(test, ifTrue, ifFalse)
            when IR.Statement.CONSTRUCT(cl):
                writeConstruct(id, cl)
            when IR.Statement.GET_FIELD(value, type, field):
                writeGetField(id, value, type, field)
            when IR.Statement.RETURN(value):
                writeReturn(value)
            when IR.Statement.STATIC_CALL(m, args):
                writeStaticCall(id, m, args)
            otherwise:
                assert false, "unsupported statement \{s}"
        }
    }

    method writeBlock(blockId:Int, statementStartId:Int, block:ListView<IR.Statement>) {
        if blockId != 0 {
            out.printLine("block\{blockId}:")
        }
        var id := statementStartId
        for s in block {
            writeStatement(id, s)
            id += 1
        }
    }

    method writeIR(ir:IR) {
        var blockId := 0
        var statementId := 0
        for bl in ir.blocks {
            writeBlock(blockId, statementId, bl)
            statementId += bl.count
            blockId += 1
        }
    }

    @override
    method write(m:MethodDecl, ir:IR) {
        out := methods
        out.print("define ")
        if m.owner.isSpecialization() {
            out.print("linkonce_odr ")
        }
        out.print("\{llvmType(m.returnType)} \{getName(m)}(")
        var separator := ""
        if !m.annotations.isClass() {
            out.print("\{selfType(m)} %self")
            separator := ", "
        }
        for p in m.parameters {
            out.print("\{separator}\{llvmType(p.type)} %\{escapeName(p.name)}")
            separator := ", "
        }
        out.printLine(") {")
        writeIR(ir)
        out.printLine("}")
    }

    @override
    method start(cl:ClassDecl) {
        if cl.annotations.isSpecialize() {
            return
        }
        writeType(cl.type())
        getClassConstant(cl)
    }

    @override
    method end(cl:ClassDecl) {
    }
}