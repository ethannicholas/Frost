package org.pandalanguage.pandac

@final
class Annotations {
    class Flag {
        constant PRIVATE    := 1 << 1
        constant PROTECTED  := 1 << 2
        constant PACKAGE    := 1 << 3
        constant CLASS      := 1 << 4
        constant OVERRIDE   := 1 << 5
        constant EXTERNAL   := 1 << 6
        constant IMPLICIT   := 1 << 7
        constant FINAL      := 1 << 8
        constant ABSTRACT   := 1 << 9
        constant INLINE     := 1 << 10
        constant SPECIALIZE := 1 << 11
        constant WEAK       := 1 << 12
        constant SYNTHETIC  := 1 << 13
    }

    choice Expression {
        PRE(ASTNode)
        PRE_OR(ASTNode)
        POST(ASTNode)
        POST_AND(ASTNode)

        @override
        function convert():String {
            match self {
                when PRE(expr):      return "@pre(\{expr})"
                when PRE_OR(expr):   return "@preOr(\{expr})"
                when POST(expr):     return "@post(\{expr})"
                when POST_AND(expr): return "@postAnd(\{expr})"
            }
        }
    }

    def flags:Int

    def expressions:Array<Expression>?

    init() {
        init(0)
    }

    init(flags:Int) {
        init(flags, null)
    }

    init(flags:Int, expressions:ListView<Expression>?) {
        self.flags := flags
        if expressions != null {
            self.expressions := Array<Expression>(expressions)
        }
        else {
            self.expressions := null
        }
    }

    function isPrivate():Bit {
        return flags && Flag.PRIVATE != 0
    }

    function isProtected():Bit {
        return flags && Flag.PROTECTED != 0
    }

    function isPackage():Bit {
        return flags && Flag.PACKAGE != 0
    }

    function isClass():Bit {
        return flags && Flag.CLASS != 0
    }

    function isOverride():Bit {
        return flags && Flag.OVERRIDE != 0
    }

    function isExternal():Bit {
        return flags && Flag.EXTERNAL != 0
    }

    function isImplicit():Bit {
        return flags && Flag.IMPLICIT != 0
    }

    function isFinal():Bit {
        return flags && Flag.FINAL != 0
    }

    function isAbstract():Bit {
        return flags && Flag.ABSTRACT != 0
    }

    function isInline():Bit {
        return flags && Flag.INLINE != 0
    }

    function isSpecialize():Bit {
        return flags && Flag.SPECIALIZE != 0
    }

    function isWeak():Bit {
        return flags && Flag.WEAK != 0
    }

    function isSynthetic():Bit {
        return flags && Flag.SYNTHETIC != 0
    }

    @override
    function convert():String {
        def result := MutableString()
        if isPrivate() {
            result.append("@private\n")
        }
        if isProtected() {
            result.append("@protected\n")
        }
        if isPackage() {
            result.append("@package\n")
        }
        if isClass() {
            result.append("@class\n")
        }
        if isOverride() {
            result.append("@override\n")
        }
        if isExternal() {
            result.append("@external\n")
        }
        if isImplicit() {
            result.append("@implicit\n")
        }
        if isFinal() {
            result.append("@final\n")
        }
        if isAbstract() {
            result.append("@abstract\n")
        }
        if isInline() {
            result.append("@inline\n")
        }
        if isSpecialize() {
            result.append("@specialize\n")
        }
        if isWeak() {
            result.append("@weak\n")
        }
        if isSynthetic() {
            result.append("@synthetic\n")
        }
        if expressions != null {
            for expr in expressions {
                result.append("\{expr}\n")
            }
        }
        return result.finish()
    }
}