package org.pandalanguage.pandac

uses org.pandalanguage.pandac.parser.Lexer
uses org.pandalanguage.pandac.parser.Parser
uses org.pandalanguage.pandac.parser.TokenKind

@final
class Main {
    class Format {
        constant LLVM       := 917
        constant EXECUTABLE := 918
        constant OBJECT     := 919
        constant C_HEADER   := 920
        constant C          := 921
    }

    var llvmDir := File(Config.LLVM_DIR)
    var triple := Config.LLVM_TRIPLE

    var opt:File
    var llc:File
    var gcc:File
    def pandaHome:File

    init() {
        pandaHome := File("../src")
    }

    class Arguments {
        @private
        def args:ListView<String>

        @private
        def index := 1

        init(args:ListView<String>) {
            self.args := args
        }

        function get_done():Bit {
            return index = args.get_count()
        }

        method next():String {
            assert !get_done()
            index += 1
            return args[index - 1]
        }

        method next(label:String):String {
            if get_done() {
                Console.errorStream().printLine("expected \{label} after " +
                        "'\{args[args.get_count() - 1]}'")
                System.exit(1)
            }
            return next()
        }
    }

    method optimize(llvm:File, level:Int):File {
        if level = 0 {
            return llvm
        }
        def dest := llvm.changeExtension(".opt")
        def args := Array<String>() -- FIXME literal
        args.add("-lint")
        args.add("-O\{level}")
        args.add("-S")
        args.add(llvm.path)
        args.add("-o")
        args.add(dest.path)
        def p := System.exec(opt, args)
        Console.errorStream().print(p.error.readFully())
        if p.waitFor() != 0 {
            System.exit(1)
        }
        return dest
    }

    method toAssembly(llvm:File):File {
        def dest := llvm.changeExtension(".s")
        def args := Array<String>() -- FIXME literal
        args.add(llvm.path)
        args.add("-relocation-model=pic")
        args.add("-o")
        args.add(dest.path)
        def p := System.exec(llc, args)
        Console.errorStream().print(p.error.readFully())
        if p.waitFor() != 0 {
            System.exit(1)
        }
        return dest
    }

    method toObject(assembly:File, dest:File):File {
        def args := Array<String>() -- FIXME literal
        args.add(assembly.path)
        args.add("-m64")
        args.add("-fPIC")
        args.add("-c")
        args.add("-o")
        args.add(dest.path)
        def p := System.exec(gcc, args)
        Console.errorStream().print(p.output.readFully())
        Console.errorStream().print(p.error.readFully())
        if p.waitFor() != 0 {
            System.exit(1)
        }
        return dest
    }

    method toExecutable(assembly:File, dest:File):File {
        def args := Array<String>() -- FIXME literal
        args.add(assembly.path)
        args.add("-L.")
        args.add("-lpanda")
        args.add("-lm")
        args.add("-lpthread")
        def icuLibs := Config.ICU_LIBRARIES.split(";")
        for lib in icuLibs {
            def libFile := File(lib)
            args.add("-L" + libFile.parent())
            var simpleName := libFile.simpleName()
            assert simpleName.startsWith("lib")
            simpleName := simpleName[3..]
            args.add("-l" + simpleName)
        }
        args.add("-m64")
        args.add("-fPIC")
        args.add("-o")
        args.add(dest.path)
        def p := System.exec(gcc, args)
        Console.errorStream().print(p.output.readFully())
        Console.errorStream().print(p.error.readFully())
        if p.waitFor() != 0 {
            System.exit(1)
        }
        return dest
    }

    method printUsage(out:OutputStream) {
        out.printLine("Usage: pandac [options] <sources>")
        out.printLine()
        out.printLine("Source filenames must end in '.panda'.")
        out.printLine()
        out.printLine("Options:")
        out.printLine("  -o <path>    output path")
    }

    method run(rawArgs:ListView<String>) {
        def args := Arguments(rawArgs)
        def sources := Array<File>()
        def imports := Array<File>() -- FIXME literal
        imports.add(pandaHome)
        var outFile:File? := null
        var optimizationLevel := 3
        var safetyLevel := 3
        var format:Int? := null
        def err := Console.errorStream()
        while !args.get_done() {
            def a := args.next()
            match a {
                when "--fuzz":
                    def path := File("/tmp/fuzz.panda")
                    Console.inputStream().sendTo(path.openOutputStream())
                    sources.add(path)
                when "-o":
                    if outFile != null {
                        err.printLine("'-o' may only be specified once")
                        System.exit(1)
                    }
                    outFile := File(args.next("a filename"))
                    outFile.parent().createDirectories()
                when "-O":
                    def level := args.next("a number from 0-3")
                    optimizationLevel := level.convert()->Int
                    if optimizationLevel > 3 | optimizationLevel < 0 {
                        Console.errorStream().printLine("expected a number from 0-3 after '-O'")
                        System.exit(1)
                    }
                when "-S":
                    def level := args.next("a number from 0-3")
                    safetyLevel := level.convert()->Int
                    if safetyLevel > 3 | safetyLevel < 0 {
                        Console.errorStream().printLine("expected a number from 0-3 after '-S'")
                        System.exit(1)
                    }
                when "-f":
                    if format != null {
                        err.printLine("'-f' may only be specified once")
                        System.exit(1)
                    }
                    def f := args.next("an output format")
                    match f {
                        when "exe": format := Format.EXECUTABLE
                        when "o":   format := Format.OBJECT
                        when "ll":  format := Format.LLVM
                        when "h":   format := Format.C_HEADER
                        when "c":   format := Format.C
                        otherwise:
                            err.printLine("unsupported output format '\{f}'")
                            System.exit(1)
                    }
                when "-i":
                    imports.add(File(args.next("a path to an import directory")))
                when "--llvm_dir":
                    llvmDir := File(args.next("a path to the LLVM directory"))
                when "--triple":
                    triple := args.next("LLVM target triple")
                when "-pause":
                    Console.printLine("Press enter to continue...")
                    Console.readLine()
                otherwise:
                    if a.endsWith(".panda") {
                        sources.add(File(a))
                    }
                    else {
                        err.printLine("unrecognized argument '\{a}'")
                        System.exit(1)
                    }
            }
        }
        opt := llvmDir.resolve("bin/opt")
        llc := llvmDir.resolve("bin/llc")
        gcc := File("/usr/bin/gcc")
        if sources.get_count() = 0 {
            err.printLine("no input files specified")
            System.exit(1)
        }
        if format = null {
            format := Format.EXECUTABLE
        }
        if outFile = null {
            if sources.get_count() = 1 {
                def extension:String
                match format {
                    when Format.EXECUTABLE: extension := ""
                    when Format.OBJECT:     extension := ".o"
                    when Format.C_HEADER:   extension := ".h"
                    when Format.C:          extension := ".c"
                    when Format.LLVM:       extension := ".ll"
                    otherwise: assert false
                }
                outFile := sources[0].changeExtension(extension)
            }
            else {
                err.printLine("multiple input files specified, must use '-o' to specify output " +
                        "file")
                System.exit(1)
            }
        }
        def errorCount:Int
        {
            def cg:CodeGenerator
            match format {
                when Format.LLVM, Format.EXECUTABLE, Format.OBJECT:
                    cg := LLVMCodeGenerator(triple,
                                            outFile.changeExtension(".ll").openOutputStream())
                when Format.C_HEADER:
                    cg := HCodeGenerator(outFile)
                when Format.C:
                    cg := CCodeGenerator(outFile)
                otherwise:
                    assert false
            }
            def settings := Compiler.Settings(pandaHome, imports, optimizationLevel, safetyLevel)
            def errorQueue := MessageQueue<Compiler.Error>()
            def compiler := Compiler(errorQueue, cg, settings)
            for s in sources {
                for cl in compiler.scan(s) {
                    compiler.markNonExternal(cl)
                }
            }
            for s in sources {
                compiler.compile(s)
            }
            compiler.finish()
            errorCount := errorQueue.pendingMessages()
            for i in 0 .. errorCount {
                def error := errorQueue.getMessage()
                Console.printLine("\{error.file.name()}:\{error.position}: error: \{error.message}")
            }
        }
        if errorCount = 0 {
            match format {
                when Format.EXECUTABLE:
                    def optimized := optimize(outFile.changeExtension(".ll"), optimizationLevel)
                    def assembly := toAssembly(optimized)
                    toExecutable(assembly, outFile)
                when Format.OBJECT:
                    def optimized := optimize(outFile.changeExtension(".ll"), optimizationLevel)
                    def assembly := toAssembly(optimized)
                    toObject(assembly, outFile)
            }
        }
        else {
            if errorCount = 1 {
                Console.printLine("1 error")
            }
            else {
                Console.printLine("\{errorCount} errors")
            }
            System.exit(1)
        }
    }
    
    @class
    function containsError(s:String):Bit {
        return s.contains("error")
    }

    @class
    method main(args:ListView<String>) {
        Main().run(args)
    }
}
