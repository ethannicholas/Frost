package org.pandalanguage.pandac

class ClassDecl : Symbol {
    class GenericParameter : Symbol {
        def owner:String

        def bound:org.pandalanguage.pandac.Type -- FIXME unnecessary qualification

        init(offset:Int, owner:String, name:String, bound:org.pandalanguage.pandac.Type) { -- FIXME qualification
            self.owner := owner
            self.bound := bound
            super.init(Kind.GENERIC_PARAMETER, offset, name)
        }

        @override
        function convert():String {
            return "\{owner}.\{name}:\{bound}"
        }
    }

    def source:File

    def aliases:MapView<String, String>

    def doccomment:String?

    def annotations:Annotations

    def rawSuper:Type?

    def rawInterfaces:Array<Type>

    def parameters:ListView<GenericParameter>

    def fields := Array<FieldDecl>()

    def methods := Array<MethodDecl>()

    def symbolTable:SymbolTable

    var external := true

    var resolved:Bit

    init(source:File, offset:Int, aliases:MapView<String, String>, doccomment:String?,
            annotations:Annotations, name:String, rawSuper:Type?, rawInterfaces:Array<Type>,
            parameters:ListView<GenericParameter>, parent:SymbolTable) {
        super.init(Kind.CLASS, offset, name)
        self.source := source
        self.aliases := aliases
        self.doccomment := doccomment
        self.annotations := annotations
        self.rawSuper := rawSuper
        self.rawInterfaces := rawInterfaces
        self.symbolTable := SymbolTable(parent)
        self.resolved := false
        for p in parameters {
            symbolTable.add(p)
        }
    }

    function type():Type {
        return Type(name, Type.Kind.CLASS, -1, true)
    }

    @override
    function convert():String {
        def result := MutableString("class \{name}")
        if rawSuper != Type.Void() {
            result.append(":\{rawSuper}")
        }
        if rawInterfaces.get_count() > 0 {
            result.append(" (")
            var separator := ""
            for intf in rawInterfaces {
                result.append("\{separator}\{intf}")
                separator := ", "
            }
            result.append(")")
        }
        result.append(" {\n")
        for f in fields {
            result.append("\{f}\n")
        }
        for m in methods {
            result.append("\{m}\n")
        }
        result.append("}")
        return result.convert()
    }
}