package org.pandalanguage.pandac

@final
class MethodDecl : Symbol {
    choice Kind {
        METHOD
        FUNCTION
        INIT
    }

    class Parameter {
        def name:String

        def type:Type

        @weak
        var owner:MethodDecl?

        init(name:String, type:org.pandalanguage.pandac.Type) {
            self.name := name
            self.type := type
        }

        @override
        function convert():String {
            return "\{name}:\{type}"
        }
    }

    @weak
    def owner:ClassDecl

    def doccomment:String?

    def annotations:Annotations

    def methodKind:Kind

    def genericParameters:Array<ClassDecl.GenericParameter>?

    def parameters:Array<Parameter>

    var returnType:Type

    def body:ImmutableArray<ASTNode>?

    var resolved := Compiler.Resolution.UNRESOLVED

    var overrideKnown := false

    @weak
    var overridden:MethodDecl? := null

    property isVirtual:Bit

    init(owner:ClassDecl, position:Position, doccomment:String?, annotations:Annotations,
            methodKind:Kind, name:String, genericParameters:Array<ClassDecl.GenericParameter>?,
            parameters:Array<Parameter>, returnType:Type,
            body:ImmutableArray<ASTNode>?) {
        super.init(Symbol.Kind.METHOD, position, name)
        self.owner := owner
        self.doccomment := doccomment
        self.annotations := annotations
        self.methodKind := methodKind
        self.genericParameters := genericParameters
        for p in parameters {
            p.owner := self
        }
        self.parameters := parameters
        self.returnType := returnType
        self.body := body
    }

    @override
    function get_heritable():Bit {
        return methodKind != Kind.INIT
    }

    function get_isVirtual():Bit {
        return !annotations.isClass() & methodKind != Kind.INIT & !annotations.isFinal()
    }

    function isInstance():Bit {
        return !annotations.isClass()
    }

    function matches(other:MethodDecl):Bit {
        assert resolved != Compiler.Resolution.UNRESOLVED &
                other.resolved != Compiler.Resolution.UNRESOLVED
        if name != other.name {
            return false
        }
        if returnType != other.returnType {
            return false
        }
        if parameters.count != other.parameters.count {
            return false
        }
        for i in 0 .. parameters.count {
            if parameters[i].type != other.parameters[i].type {
                return false
            }
        }
        return true
    }

    function type():Type {
        def paramTypes := Array<Type>(parameters.count) -- FIXME use map
        for p in parameters {
            paramTypes.add(p.type)
        }
        def kind:Type.Kind
        if methodKind = Kind.FUNCTION {
            kind := Type.Kind.IMMUTABLE_FUNCTION
        }
         else {
            kind := Type.Kind.IMMUTABLE_METHOD
        }
        return Type.methodType(position, kind, paramTypes, returnType)
    }

    function signature():String {
        def result := MutableString("\{name}(")
        var separator := ""
        for p in parameters {
            result.append(separator)
            result.append(p)
            separator := ", "
        }
        result.append(")")
        if returnType != Type.Void() {
            result.append(":\{returnType}")
        }
        return result.finish()
    }

    function declaration():String {
        match methodKind {
            when Kind.METHOD:
                return("method \{owner.name}.\{signature()}")
            when Kind.FUNCTION:
                return("function \{owner.name}.\{signature()}")
            when Kind.INIT:
                return("\{owner.name}.\{signature()}")
        }
    }

    @override
    function convert():String {
        if body !== null {
            return "\{annotations}\{signature()} \{body}"
        }
        return signature()
    }
}