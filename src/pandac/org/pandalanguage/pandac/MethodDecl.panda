package org.pandalanguage.pandac

@final
class MethodDecl : Symbol {
    class Parameter {
        def name:String

        def type:org.pandalanguage.pandac.Type -- FIXME shouldn't have to fully qualify this

        init(name:String, type:org.pandalanguage.pandac.Type) {
            self.name := name
            self.type := type
        }

        @override
        function convert():String {
            return "\{name}:\{type}"
        }
    }

    class Kind {
        constant METHOD   := 57
        constant FUNCTION := 58
        constant INIT     := 59
    }

    def owner:ClassDecl -- FIXME weak

    def doccomment:String?

    def annotations:Annotations

    def methodKind:Int

    def parameters:Array<Parameter>

    def returnType:Type

    def body:ASTNode?

    -- only set for @inline methods
    def compiledBody:IRNode? := null

    var resolved:Bit

    init(owner:ClassDecl, position:Position, doccomment:String?, annotations:Annotations,
            methodKind:Int, name:String, parameters:Array<Parameter>, returnType:Type,
            body:ASTNode?) {
        super.init(Symbol.Kind.METHOD, position, name)
        self.owner := owner
        self.doccomment := doccomment
        self.annotations := annotations
        self.methodKind := methodKind
        self.parameters := parameters
        self.returnType := returnType
        self.body := body
        self.resolved := false
    }

    @override
    function get_heritable():Bit {
        return methodKind != Kind.INIT
    }

    function isVirtual():Bit {
        return !annotations.isClass() & methodKind != Kind.INIT & !annotations.isFinal()
    }

    function isInstance():Bit {
        return !annotations.isClass()
    }

    function matches(other:MethodDecl):Bit {
        assert resolved & other.resolved
        if name != other.name {
            return false
        }
        if returnType != other.returnType {
            return false
        }
        if parameters.get_count() != other.parameters.get_count() {
            return false
        }
        for i in 0 .. parameters.get_count() {
            if parameters[i].type != other.parameters[i].type {
                return false
            }
        }
        return true
    }

    function signature():String {
        def result := MutableString("\{name}(")
        var separator := ""
        for p in parameters {
            result.append(separator)
            result.append(p)
            separator := ", "
        }
        result.append(")")
        if returnType != Type.Void() {
            result.append(":\{returnType}")
        }
        return result.finish()
    }

    function declaration():String {
        match methodKind {
            when Kind.METHOD:
                return("method \{owner.name}.\{signature()}")
            when Kind.FUNCTION:
                return("function \{owner.name}.\{signature()}")
            when Kind.INIT:
                return("\{owner.name}.\{signature()}")
        }
    }

    @override
    function convert():String {
        if body != null {
            return "\{signature()} \{body}"
        }
        return signature()
    }
}