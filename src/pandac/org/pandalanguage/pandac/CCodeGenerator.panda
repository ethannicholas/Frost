package org.pandalanguage.pandac

uses org.pandalanguage.pandac.parser.Token

class CCodeGenerator (CodeGenerator) {
    var compiler:Compiler?

    def out:IndentedOutputStream

    def strings := MemoryOutputStream()

    def imports := Set<String>()

    def hCodeGen := HCodeGenerator(MemoryOutputStream())

    init(out:OutputStream) {
        self.out := IndentedOutputStream(out)
    }

    function escapeName(s:String):String {
        return hCodeGen.escapeName(s)
    }

    function getName(m:MethodDecl):String {
        return hCodeGen.getName(m)
    }

    function sizeOf(t:Type):Int {
        return hCodeGen.sizeOf(t)
    }

    method writeImport(cl:ClassDecl) {
        if cl.name = "panda.unsafe.Pointer" {
            return
        }
        def includePath := hCodeGen.getIncludePath(cl)
        if !imports.contains(includePath) {
            out.printLine("#include \"\{includePath}\"")
            imports.add(includePath)
        }
    }

    method type(t:Type):String {
        if t.isClass() {
            def cl := compiler.getClass(t)
            assert cl != null
            writeImport(cl)
        }
        return hCodeGen.type(t)
    }

    @override
    method setCompiler(compiler:Compiler) {
        self.compiler := compiler
        hCodeGen.setCompiler(compiler)
    }

    class ClassConstant : Immutable {
        def name:String
        def type:String

        init(name:String, type:String) {
            self.name := name
            self.type := type
        }
    }

    class MethodShim {
        def name:String
        def type:String

        init(name:String, type:String) {
            self.name := name
            self.type := type
        }
    }

    class LoopDescriptor : Immutable {
        def loopLabel:String?
        def breakLabel:String
        def continueLabel:String

        init(loopLabel:String?, breakLabel:String, continueLabel:String) {
            self.loopLabel := loopLabel
            self.breakLabel := breakLabel
            self.continueLabel := continueLabel
        }

        @override
        function convert():String {
            if loopLabel != null {
                return "LoopDescriptor<\{loopLabel}>"
            }
            else {
                return "LoopDescriptor<>"
            }
        }
    }

    ================================================================================================
    Overrides features such as method arguments and return handling for use in compiling inline
    methods.
    ================================================================================================
    class InlineContext {
        ============================================================================================
        Local variable name suffix.
        ============================================================================================
        def varSuffix:String

        ============================================================================================
        Reference to use instead of the normal "self".
        ============================================================================================
        def selfRef:String

        ============================================================================================
        Reference to use instead of the normal method parameter names.
        ============================================================================================
        def argRefs:ImmutableArray<String>

        ============================================================================================
        Contains pairs of (source block, return value), which can be turned into the actual return
        value using a phi node. Initially empty, filled in as the inline call is written.
        ============================================================================================
        def returns := Array<Pair<String, String>>()

        ============================================================================================
        Label to jump to after returning.
        ============================================================================================
        def exitLabel:String

        init(varSuffix:String, selfRef:String, argRefs:ListView<String>, exitLabel:String) {
            self.varSuffix := varSuffix
            self.selfRef := selfRef
            self.argRefs := ImmutableArray<String>(argRefs)
            self.exitLabel := exitLabel
        }
    }

    constant POINTER_SIZE        := 8
    constant OBJECT_FIELD_COUNT  := 2
    constant CLASS_POINTER_INDEX := 0
    constant ITABLE_INDEX        := 2
    constant VTABLE_INDEX        := 3

    constant INT_TYPE  := "i64"
    constant SIZE_TYPE := "i64"

    def declarations := MemoryOutputStream()

    def types := MemoryOutputStream()

    def methodsBuffer := MemoryOutputStream()

    def methods := IndentedOutputStream(methodsBuffer)

    def methodHeaderBuffer := MemoryOutputStream()

    def methodHeader := IndentedOutputStream(methodHeaderBuffer)

    def wrapperShimsBuffer := MemoryOutputStream()

    def wrapperShims := IndentedOutputStream(wrapperShimsBuffer)

    def shimsBuffer := MemoryOutputStream()

    def shims := IndentedOutputStream(shimsBuffer)

    def declared := Set<String>()

    def writtenTypes := Set<String>()

    def writtenWrappers := Set<String>()

    def classConstants := HashMap<String, ClassConstant>()

    def variableNames := IdentityMap<Variable, String>()

    var currentBlock:String

    var currentMethod:MethodDecl?

    def loopDescriptors := Stack<LoopDescriptor>()

    var varCount := 0

    def reusedValues := HashMap<UInt64, String>()

    def methodShims := IdentityMap<MethodDecl, MethodShim>()

    def inlineContext := Stack<InlineContext>()

    def currentlyInlining := IdentityMap<MethodDecl, MethodDecl>() -- FIXME need IdentitySet

    method nextVar():String {
        varCount += 1
        return "$tmp\{varCount}"
    }

    method nextLabel():String {
        varCount += 1
        return "$l\{varCount}"
    }

    method createBlock(label:String, out:IndentedOutputStream) {
        out.printLine("\n\{label}:")
        currentBlock := label
    }

    function endsWithBranch(stmt:IRNode):Bit {
        match stmt.kind {
            when IRNode.Kind.BLOCK:
                if stmt.children.get_count() = 0 {
                    return false
                }
                return endsWithBranch(stmt.children[stmt.children.get_count() - 1])
            when IRNode.Kind.BREAK, IRNode.Kind.CONTINUE, IRNode.Kind.RETURN:
                return true
            otherwise: return false
        }
    }

    function fieldSize(t:Type):Int {
        assert t.resolved
        if t.isBuiltinNumber() {
            if t.name.endsWith("8") {
                return 1
            }
            if t.name.endsWith("16") {
                return 2
            }
            if t.name.endsWith("32") {
                return 4
            }
            assert t.name.endsWith("64")
            return 8
        }
        if t = Type.BuiltinBit() {
            return 1
        }
        def cl := compiler.getClass(t)
        assert cl != null
        if !compiler.isValue(cl) | cl.name = "panda.unsafe.Pointer" {
            return POINTER_SIZE
        }
        var result := 0
        for f in compiler.instanceFields(cl) {
            if f.annotations.isClass() {
                continue
            }
            compiler.resolve(f)
            def size := fieldSize(f.type)
            def align := result % size
            if align != 0 {
                result += size - align
            }
            assert result % size = 0
            result += size
        }
        if t.typeKind = Type.Kind.NULLABLE {
            result += 1
        }
        return result
    }

    function alignment(t:Type):Int {
        return fieldSize(t).min(8)
    }

    function sizeOfWrapper(t:Type):Int {
        def cl := compiler.getClass(t)
        assert cl != null & compiler.isValue(cl)
        var result := sizeOf(Type.Object())
        for f in compiler.instanceFields(cl) {
            compiler.resolve(f)
            def size := fieldSize(f.type)
            def align := result % size
            if align != 0 {
                result += size - align
            }
            assert result % size = 0
            result += size
        }
        if t.typeKind = Type.Kind.NULLABLE {
            result += 1
        }
        return result
    }

    method writeType(t:Type) {
        if writtenTypes.contains(t.name) {
            return
        }
    }

    function typeName(t:Type):String {
        return escapeName(t.name)
    }

    method wrapperTypeName(t:Type):String {
        if t.typeKind = Type.Kind.NULLABLE {
            return wrapperTypeName(t.subtypes[0])
        }
        return "\{escapeName(t.name)}$wrapper"
    }

    method wrapperType(t:Type):String {
        return wrapperTypeName(t) + "*"
    }

    method wrapperType(m:MethodDecl):String {
        def inheritedType := compiler.inheritedType(m)
        def result := MutableString()
        result.append(type(inheritedType.subtypes[inheritedType.subtypes.get_count() - 1]))
        result.append("(")
        assert m.isInstance()
        result.append("\{escapeName(m.owner.name)}")
        if compiler.isValue(m.owner) {
            result.append("$wrapper")
        }
        result.append("*")
        for i in 0 .. inheritedType.subtypes.get_count() - 1 { 
            result.append(", ")
            result.append(type(inheritedType.subtypes[i]))
        }
        result.append(")*")
        return result.convert()
    }

    method nullableType(t:Type):String {
        assert t.typeKind = Type.Kind.NULLABLE, "\{t} is not nullable"
        return "\{type(t.subtypes[0])}$nullable"
    }

    method getITable(cl:ClassDecl):String {
        def interfaces := compiler.allInterfaces(cl.type())
        var previous := "NULL"
        for intfType in interfaces {
            def intf := compiler.getClass(intfType)
            def intfCC := getClassConstant(intf)
            def methods := compiler.interfaceMethods(cl, intfType)
            def name := "\{escapeName(cl.name)}$_\{escapeName(intf.name)}"
            def result := MutableString("struct { \{type(Type.Class())} cl; ITable* next; " +
                    "void* methods[\{methods.get_count()}]; } \{name} = { " +
                    "(panda$core$Class*) &\{intfCC.name}, \{previous}, { ")
            var separator := ""
            for m in methods {
                result.append(separator)
                separator := ", "
                if m.annotations.isAbstract() {
                    result.append("NULL")
                }
                else {
                    result.append(getMethodTableEntry(m))
                }
            }
            result.append("} };\n")
            types.printLine(result)
            previous := "(ITable*) &\{name}"
        }
        return previous
    }

    method createMethodShim(raw:MethodDecl, effective:Type, rawOut:OutputStream):MethodShim {
        def outBuffer := MemoryOutputStream()
        def out := IndentedOutputStream(outBuffer)
        def found := methodShims[raw]
        if found != null {
            return found
        }
        assert effective.isMethod()
        assert effective.subtypes.get_count() = raw.parameters.get_count() + 1
        assert raw.isInstance()
        def oldVarCount := varCount
        varCount := 0
        def effectiveReturnType := effective.subtypes[effective.subtypes.get_count() - 1]
        def resultName := getName(raw) + "$shim"
        def resultType := MutableString(type(effectiveReturnType))
        out.print("\{resultType} \{resultName}(")
        def self_t := selfType(raw)
        out.print("\{self_t} self")
        resultType.append("(")
        resultType.append(self_t)
        for i in 0 .. raw.parameters.get_count() {
            def pType := type(effective.subtypes[i])
            resultType.append(", ")
            resultType.append(pType)
            out.print(", \{pType} p\{i}")
        }
        out.printLine(") {")
        out.level +=1
        resultType.append(")*")
        def casts := Array<String>()
        for i in 0 .. raw.parameters.get_count() {
            def p := "p\{i}"
            if raw.parameters[i].type != effective.subtypes[i] {
                casts.add(getCastReference(p, effective.subtypes[i],
                        raw.parameters[i].type, out))
            }
            else {
                casts.add(p)
            }
        }
        if raw.returnType != Type.Void() {
            out.print("\{type(raw.returnType)} result = ")
        }
        out.print("\{getName(raw)}(self")
        for i in 0 .. raw.parameters.get_count() {
            out.print(", \{casts[i]}")
        }
        out.printLine(");")
        if raw.returnType != Type.Void() {
            out.printLine("return " + getCastReference("result", raw.returnType,
                    effectiveReturnType, out) + ";")
        }
        out.level -= 1
        out.printLine("}")
        varCount := oldVarCount
        def result := MethodShim(resultName, resultType.convert())
        methodShims[raw] := result
        rawOut.print(outBuffer)
        return result
    }

    method createWrapperShim(m:MethodDecl, out:IndentedOutputStream):String {
        assert m.isInstance()
        def oldMethod := currentMethod
        currentMethod := m
        def oldVarCount := varCount
        varCount := 0
        def result := "\{getName(m)}$wrappershim"
        def selfType := "\{escapeName(m.owner.name)}$wrapper*"
        out.print("\{type(m.returnType)} \{result}(\{selfType} self")
        def actualMethodType := compiler.declaredType(m)
        def inheritedMethodType := compiler.inheritedType(m)
        for i in 0 .. m.parameters.get_count() {
            out.print(", \{type(inheritedMethodType.subtypes[i])} \{m.parameters[i].name}")
        }
        out.printLine(") {")
        out.level += 1
        def parameters := Array<String>()
        for i in 0 .. m.parameters.get_count() {
            parameters.add(getCastReference(m.parameters[i].name, inheritedMethodType.subtypes[i],
                    actualMethodType.subtypes[i], out))
        }
        def children := Array<IRNode>()
        children.add(IRNode(IRNode.Kind.SELF, -1, Type.Object()))
        if m.returnType != Type.Void() {
            out.print("return ")
        }
        out.print("\{getName(m)}(self->value")
        for i in 0 .. m.parameters.get_count() {
            out.print(", \{parameters[i]}")
        }
        out.printLine(");")
        out.level -= 1
        out.printLine("}")
        varCount := oldVarCount
        currentMethod := oldMethod
        return result
    }

    method getWrapperITable(cl:ClassDecl):String {
        def interfaces := compiler.allInterfaces(cl.type())
        var previous := "NULL"
        for intfType in interfaces {
            def intf := compiler.getClass(intfType)
            def intfCC := getClassConstant(intf)
            def methods := compiler.interfaceMethods(cl, intfType)
            def name := "\{escapeName(cl.name)}$wrapper_\{escapeName(intf.name)}"
            def result := MutableString("struct { \{type(Type.Class())} cl; ITable* itable; " +
                    "void* methods[\{methods.get_count()}]; } \{name} = { " +
                    "(\{type(Type.Class())}) &\{intfCC.name}, \{previous}, { ")
            var separator := ""
            for m in methods {
                result.append(separator)
                separator := ", "
                if m.annotations.isAbstract() {
                    result.append("NULL")
                }
                else {
                    result.append(createWrapperShim(m, wrapperShims))
                }
            }
            result.append("} };\n")
            types.printLine(result)
            previous := "(ITable*) &\{name}"
        }
        return previous
    }

    -- FIXME use tuple
    class Pair<A, B> {
        def first:A
        def second:B

        init(first:A, second:B) {
            self.first := first
            self.second := second
        }
    }

    ================================================================================================
    Returns true if this is an external method returning a struct.

    Returning structs from C functions into LLVM code is tricky. I tried it the naive and obvious
    way, and found it didn't work. Some cursory research indicated that C functions that return
    structs are at least sometimes compiled to accept a special pointer ("sret") as an extra
    parameter, and the caller is expected to know to alloca space for the return value and pass in a
    pointer to it.

    Since online sources were complaining about how poorly documented this is, there were
    indications that there may be multiple struct return strategies depending on the nature of
    the struct, people were suggesting looking at the assembly code generated by Clang to figure
    out how one was supposed to call a given function, and this all varies from platform to
    platform, we avoid the whole mess by making it explicit. External functions which wish to
    return structs explicitly receive a pointer to the result structure as their first parameter.
    ================================================================================================
    function needsStructIndirection(m:MethodDecl):Bit {
        if !m.returnType.isClass() {
            return false
        }
        def result := m.annotations.isExternal() & m.returnType.isClass() &
                compiler.isValue(compiler.getClass(m.returnType))
        -- if an external method requires struct indirection, it will have a different signature
        -- than a non-external method; this means this feature doesn't play nice with overriding. We
        -- can fix this down the road with shims, but for right now just assert that a method
        -- requiring struct indirection is not an override and cannot be overridden
        assert !result | (!m.annotations.isOverride() & (m.annotations.isFinal() |
                m.annotations.isClass())), "invalid struct indirection on \{m.signature()}"
        return result
    }

    method getMethodTableEntry(m:MethodDecl):String {
        compiler.resolve(m)
        if m.owner.external {
            writeDeclaration(m)
        }
        def result:String
        def declared := compiler.declaredTypeWithSelf(m, m.owner.type())
        def inherited := compiler.inheritedTypeWithSelf(m)
        if declared != inherited {
            def shim := createMethodShim(m, compiler.inheritedType(m), shims)
            result := shim.name
        }
        else {
            result := getName(m)
        }
        return result
    }

    method getClassConstant(cl:ClassDecl):ClassConstant {
        var result := classConstants[cl.name]
        if result = null {
            writeImport(cl)
            compiler.resolve(cl)
            def type:String
            if cl.external {
                result := ClassConstant("\{escapeName(cl.type().name)}$class",
                        "%panda$core$Class")
                classConstants[cl.name] := result
                return classConstants[cl.name]
            }
            def vtable := compiler.getVTable(cl)
            result := ClassConstant("\{escapeName(cl.type().name)}$class", "<error>")
            classConstants[cl.name] := result
            def superPtr:String
            if cl.rawSuper != null {
                def superCC := getClassConstant(compiler.getClass(cl.rawSuper))
                superPtr := "(panda$core$Class*) &\{superCC.name}"
            }
            else {
                superPtr := "null"
            }
            def clConstant := getClassConstant(compiler.getClass(Type.Class()))
            def code := MutableString("\{result.name}_type \{result.name} = { " +
                    "(panda$core$Class*) &\{clConstant.name}, 1, \{superPtr}, \{getITable(cl)}, { ")
            var separator := ""
            for m in vtable {
                code.append(separator)
                if m.annotations.isAbstract() {
                    code.append("NULL")
                }
                else {
                    code.append(getMethodTableEntry(m))
                }
                separator := ", "
            }
            code.append("} };\n")
            types.printLine(code)
        }
        return result
    }

    method getWrapperClassConstant(cl:ClassDecl):ClassConstant {
        def name := "\{escapeName(cl.name)}$wrapperclass"
        var result := classConstants[name]
        if result = null {
            if cl.external {
                type(Type.Class())
                def type := "%panda$core$Class"
                types.printLine("\{name} = external global \{type}")
                result := ClassConstant(name, type)
            }
            else {
                def value := compiler.getClass(Type.Value())
                def valueVTable := compiler.getVTable(value)
                result := ClassConstant("\{escapeName(cl.name)}$wrapperclass", "<error>")
                def vtable := compiler.getVTable(cl)
                def superCC := getClassConstant(compiler.getClass(cl.rawSuper))
                def superCast := "(panda$core$Class*) &\{superCC.name}"
                def itable := getWrapperITable(cl)
                def clConstant := getClassConstant(compiler.getClass(Type.Class()))
                def code := MutableString("\{result.name}_type \{result.name} = { " +
                        "(panda$core$Class*) &\{clConstant.name}, 1, \{superCast}, \{itable}, { ")
                var separator := ""
                for i in 0 .. valueVTable.get_count() {
                    def m := vtable[i]
                    def methodName:String
                    if m.owner == cl {
                        methodName := createWrapperShim(m, wrapperShims)
                    }
                    else {
                        methodName := getName(m)
                        if m.owner.external {
                            writeDeclaration(m)
                        }
                    }
                    code.append("\{separator}\{methodName}")
                    separator := ", "
                }
                code.append("} };")
                types.print(code)
            }
            classConstants[name] := result
        }
        return result
    }

    function getName(v:Variable):String {
        if v.storage = Variable.Storage.PARAMETER {
            return "\{v.name}"
        }
        var result := variableNames[v]
        if result = null {
            varCount += 1
            result := "\{v.name}\{varCount}"
            variableNames[v] := result
        }
        return result
    }

    function getName(f:FieldDecl):String {
        assert f.annotations.isClass()
        return "\{escapeName(f.owner.name)}$\{f.name}"
    }

    class OpClass {
        constant SIGNED   := 10121
        constant UNSIGNED := 10122
        constant FLOAT    := 10123
    }

    function opClass(t:Type):Int {
        match t.typeKind {
            when Type.Kind.BUILTIN_INT:
                return OpClass.SIGNED
            when Type.Kind.BUILTIN_UINT, Type.Kind.BUILTIN_BIT:
                return OpClass.UNSIGNED
            when Type.Kind.BUILTIN_FLOAT:
                return OpClass.FLOAT
            otherwise:
                assert false
        }
    }

    method getAndReference(left:IRNode, right:IRNode, out:IndentedOutputStream):String {
        var leftRef := getReference(left, out)
        if left.type = Type.Bit() {
            def leftField := nextVar()
            out.printLine("\{leftField} = extractvalue1 %panda$core$Bit \{leftRef}, 0")
            leftRef := leftField
        }
        def start := currentBlock
        def ifTrue := nextLabel()
        def ifFalse := nextLabel()
        out.printLine("br i1 \{leftRef}, label %\{ifTrue}, label %\{ifFalse}")
        createBlock(ifTrue, out)
        def rightRef := getReference(right, out)
        if right.type = Type.Bit() {
            def rightField := nextVar()
            out.printLine("\{rightField} = extractvalue2 %panda$core$Bit \{rightRef}, 0")
            rightRef := rightField
        }
        def truePred := currentBlock
        out.printLine("br label %\{ifFalse}")
        createBlock(ifFalse, out)
        def result := nextVar()
        out.printLine("\{result} = phi i1 [0, %\{start}], [\{rightRef}, %\{truePred}]")
        return result
    }

    method getOrReference(left:IRNode, right:IRNode, out:IndentedOutputStream):String {
        var leftRef := getReference(left, out)
        if left.type = Type.Bit() {
            def leftField := nextVar()
            out.printLine("\{leftField} = extractvalue3 %panda$core$Bit \{leftRef}, 0")
            leftRef := leftField
        }
        def start := currentBlock
        def ifTrue := nextLabel()
        def ifFalse := nextLabel()
        out.printLine("br i1 \{leftRef}, label %\{ifTrue}, label %\{ifFalse}")
        createBlock(ifFalse, out)
        def rightRef := getReference(right, out)
        if right.type = Type.Bit() {
            def rightField := nextVar()
            out.printLine("\{rightField} = extractvalue4 %panda$core$Bit \{rightRef}, 0")
            rightRef := rightField
        }
        def falsePred := currentBlock
        out.printLine("br label %\{ifTrue}")
        createBlock(ifTrue, out)
        def result := nextVar()
        out.printLine("\{result} = phi i1 [1, %\{start}], [\{rightRef}, %\{falsePred}]")
        return result
    }

    method getBinaryReference(cl:Int, t:Type, leftRef:String, op:Int, rightRef:String,
            out:IndentedOutputStream):String {
        def cOp:String
        match op {
            when Token.Kind.ADD:        cOp := "+"
            when Token.Kind.SUB:        cOp := "-"
            when Token.Kind.MUL:        cOp := "*"
            when Token.Kind.INTDIV:     cOp := "/"
            when Token.Kind.DIV:        cOp := "/"
            when Token.Kind.REM:        cOp := "%"
            when Token.Kind.SHIFTLEFT:  cOp := "<<"
            when Token.Kind.SHIFTRIGHT: cOp := ">>"
            when Token.Kind.BITWISEAND: cOp := "&"
            when Token.Kind.BITWISEOR:  cOp := "|"
            when Token.Kind.XOR, Token.Kind.BITWISEXOR: 
                                        cOp := "^"
            when Token.Kind.EQ:         cOp := "=="
            when Token.Kind.NEQ:        cOp := "!="
            when Token.Kind.GT:         cOp := ">"
            when Token.Kind.LT:         cOp := "<"
            when Token.Kind.GTEQ:       cOp := ">="
            when Token.Kind.LTEQ:       cOp := "<="
            otherwise:
                assert false
        }
        def result := nextVar()
        out.printLine("\{type(t)} \{result} = \{leftRef} \{cOp} \{rightRef};")
        return result
    }

    method getIdentityReference(left:IRNode, right:IRNode, out:IndentedOutputStream):String {
        def leftRef := getTypedReference(left, out)
        def rightRef := getReference(right, out)
        def raw := nextVar()
        out.printLine("\{raw} = icmp eq \{leftRef}, \{rightRef}")
        def result := nextVar()
        out.printLine("\{result} = insertvalue %panda$core$Bit { i1 undef }, i1 \{raw}, 0")
        return result
    }

    method getNIdentityReference(left:IRNode, right:IRNode, out:IndentedOutputStream):String {
        def leftRef := getTypedReference(left, out)
        def rightRef := getReference(right, out)
        def raw := nextVar()
        out.printLine("\{raw} = icmp ne \{leftRef}, \{rightRef}")
        def result := nextVar()
        out.printLine("\{result} = insertvalue %panda$core$Bit { i1 undef }, i1 \{raw}, 0")
        return result
    }

    method getBinaryReference(left:IRNode, op:Int, right:IRNode, out:IndentedOutputStream):String {
        assert left.type = right.type
        match op {
            when Token.Kind.AND:       return getAndReference(left, right, out)
            when Token.Kind.OR:        return getOrReference(left, right, out)
            when Token.Kind.IDENTITY:  return getIdentityReference(left, right, out)
            when Token.Kind.NIDENTITY: return getNIdentityReference(left, right, out)
            otherwise:
                def leftRef := getReference(left, out)
                def rightRef := getReference(right, out)
                return getBinaryReference(opClass(left.type), left.type, leftRef, op, rightRef, out)
        }
    }

    method getBinaryReference(b:IRNode, out:IndentedOutputStream):String {
        assert b.kind = IRNode.Kind.BINARY
        assert b.children.get_count() = 2
        return getBinaryReference(b.children[0], b.payload->Int, b.children[1], out)
    }

    method getVirtualMethodReference(target:String, m:MethodDecl, out:IndentedOutputStream):String {
        def cc := getClassConstant(m.owner)
        var index := -1
        def vtable := compiler.getVTable(m.owner)
        for i in 0 .. vtable.get_count() {
            if vtable[i]->MethodDecl == m { -- FIXME unnecessary cast
                index := i
                break
            }
        }
        assert index != -1
        def classPtrPtr := nextVar()
        out.printLine("\{classPtrPtr} = getelementptr5 inbounds \{typeName(m.owner.type())}, " +
                "\{target}, i64 0, i32 0")
        def classPtr := nextVar()
        out.printLine("\{classPtr} = load1 %panda$core$Class*, %panda$core$Class** \{classPtrPtr}")
        def cast := nextVar()
        out.printLine("\{cast} = bitcast %panda$core$Class* \{classPtr} to \{cc.type}*")
        def ptr := nextVar()
        out.printLine("\{ptr} = getelementptr6 inbounds \{cc.type}, \{cc.type}* \{cast}, i64 0, " +
                "i32 \{VTABLE_INDEX}, i64 \{index}")
        def load := nextVar()
        out.printLine("\{load} = load2 i8*, i8** \{ptr}")
        def result := nextVar()
        out.printLine("\{result} = bitcast i8* \{load} to " +
                type(compiler.inheritedTypeWithSelf(m)))
        return result
    }

    method getInterfaceMethodReference(target:String, m:MethodDecl,
            out:IndentedOutputStream):String {
        def methodType := type(compiler.inheritedTypeWithSelf(m))
        -- load class constant entry
        def entry := nextLabel()
        out.printLine("br label %\{entry}")
        createBlock(entry, out)
        def classPointer := nextVar()
        out.printLine("\{classPointer} = getelementptr7 inbounds \{typeName(m.owner.type())}, " +
                "\{target}, \{SIZE_TYPE} 0, i32 \{CLASS_POINTER_INDEX}")
        def loadedClass := nextVar()
        def classType := typeName(Type.Class())
        out.printLine("\{loadedClass} = load3 \{classType}*, \{classType}** \{classPointer}")
        def itableFirst := nextVar()
        out.printLine("\{itableFirst} = getelementptr8 inbounds \{classType}, \{classType}* " +
                "\{loadedClass}, \{SIZE_TYPE} 0, i32 \{ITABLE_INDEX}")
        def next := nextLabel()
        out.printLine("br label %\{next}")
        def leavingEntryLabel := currentBlock
        createBlock(next, out)
        varCount += 1
        def itableNext := "%$itable\{varCount}"
        def itablePtrPtr := nextVar()
        def fail := nextLabel()
        out.printLine("\{itablePtrPtr} = phi %$itable** [ \{itableFirst}, %\{leavingEntryLabel}]," +
                " [ \{itableNext}, %\{fail} ]")
        def itablePtr := nextVar()
        out.printLine("\{itablePtr} = load4 %$itable*, %$itable** \{itablePtrPtr}")
        def itableClassPtr := nextVar()
        out.printLine("\{itableClassPtr} = getelementptr9 inbounds %$itable, %$itable* " +
                "\{itablePtr}, \{SIZE_TYPE} 0, i32 0")
        def itableClass := nextVar()
        out.printLine("\{itableClass} = load5 \{classType}*, \{classType}** \{itableClassPtr}")
        def test := nextVar()
        def intfCC := getClassConstant(m.owner)
        out.printLine("\{test} = icmp eq \{classType}* bitcast(\{intfCC.type}* \{intfCC.name} to " +
                "\{classType}*), \{itableClass}")
        def success := nextLabel()
        out.printLine("br i1 \{test}, label %\{success}, label %\{fail}")

        createBlock(fail, out)
        out.printLine("\{itableNext} = getelementptr10 inbounds %$itable, %$itable* \{itablePtr}, " +
                "\{SIZE_TYPE} 0, i32 1")
        out.printLine("br label %\{next}")

        createBlock(success, out)
        var index := -1
        def vtable := compiler.getVTable(m.owner)
        for i in 0 .. vtable.get_count() {
            if vtable[i]->MethodDecl == m { -- FIXME unnecessary cast
                index := i
                break
            }
        }
        index -= compiler.getVTable(compiler.getClass(Type.Object())).get_count()
        assert index != -1
        def methodPtrPtr := nextVar()
        out.printLine("\{methodPtrPtr} = getelementptr11 inbounds %$itable, %$itable* " +
                "\{itablePtr}, \{SIZE_TYPE} 0, i32 2, i32 \{index}")
        def cast := nextVar()
        out.printLine("\{cast} = bitcast i8** \{methodPtrPtr} to \{methodType}*")
        def methodPtr := nextVar()
        out.printLine("\{methodPtr} = load6 \{methodType}, \{methodType}* \{cast}")
        return methodPtr
    }

    method getMethodReference(target:String?, m:MethodDecl, isSuper:Bit,
            out:IndentedOutputStream):String {
        if !isSuper & m.isVirtual() {
            assert target != null, "calling instance \{m.signature()} without a target"
            if m.owner.classKind = ClassDecl.Kind.INTERFACE {
                return getInterfaceMethodReference(target, m, out)
            }
            else {
                return getVirtualMethodReference(target, m, out)
            }
        }
        else {
            if m.owner.external {
                writeDeclaration(m)
            }
            return getName(m)
        }
    }

    method getPointerCallReference(call:IRNode, out:IndentedOutputStream):String {
        def m := call.payload->MethodRef
        match m.value.name {
            when "alloc":
                assert call.children.get_count() = 1
                def count := getReference(call.children[0], out)
                assert m.returnType().subtypes.get_count() = 2
                def elementSize := sizeOf(m.returnType().subtypes[1])
                return "((\{type(call.type)}) malloc(\{count}.value * \{elementSize}))"
            when "get":
                assert call.children.get_count() = 1
                def ptr := getReference(call.children[0], out)
                return "(*\{ptr})"
            when "[]":
                assert call.children.get_count() = 2
                def ptr := getReference(call.children[0], out)
                def index := getReference(call.children[1], out)
                return "\{ptr}[\{index}.value]"
            when "realloc":
                assert call.children.get_count() = 2
                def ptr := getTypedReference(call.children[0], out)
                def ptrCast := nextVar()
                out.printLine("\{ptrCast} = bitcast \{ptr} to i8*")
                def countStruct := getTypedReference(call.children[1], out)
                def count := nextVar()
                out.printLine("\{count} = extractvalue5 \{countStruct}, 0")
                def size := nextVar()
                out.printLine("\{size} = mul \{SIZE_TYPE} \{count}, " +
                        sizeOf(m.returnType().subtypes[1]))
                def realloc := nextVar()
                out.printLine("\{realloc} = call i8* @realloc(i8* \{ptrCast}, \{SIZE_TYPE} " +
                        "\{size})")
                def result := nextVar()
                out.printLine("\{result} = bitcast i8* \{realloc} to \{type(m.returnType())}")
                return result
            otherwise:
                assert false
        }
    }

    method getCallReference(call:IRNode, out:IndentedOutputStream):String {
        assert call.kind = IRNode.Kind.CALL
        def m := (call.payload->MethodRef).value
        if m.owner.name = "panda.unsafe.Pointer" {
            return getPointerCallReference(call, out)
        }
        if m.owner.external {
            writeDeclaration(m)
        }
        if m.owner.name = "panda.core.Bit" {
            if m.name = "&" {
                assert call.children.get_count() = 2
                def bit := getAndReference(call.children[0], call.children[1], out)
                def result := nextVar()
                out.printLine("\{result} = insertvalue %panda$core$Bit { i1 undef }, i1 " +
                        "\{bit}, 0")
                return result
            }
            if m.name = "|" {
                assert call.children.get_count() = 2
                def bit := getOrReference(call.children[0], call.children[1], out)
                def result := nextVar()
                out.printLine("\{result} = insertvalue %panda$core$Bit { i1 undef }, i1 " +
                        "\{bit}, 0")
                return result
            }
        }
        def args := Array<String>(call.children.get_count())
        def actualMethodType:Type
        def actualResultType:String
        def isSuper := call.children.get_count() >= 1 & call.children[0].kind = IRNode.Kind.SUPER
        if !isSuper & m.isVirtual() {
            actualMethodType := compiler.inheritedType(m)
            actualResultType := type(actualMethodType.subtypes[actualMethodType.subtypes.get_count() - 1])
        }
        else {
            actualMethodType := compiler.declaredType(m)
            actualResultType := type(call.type)
        }
        def offset := call.children.get_count() - actualMethodType.subtypes.get_count() + 1
        for i in 0 .. call.children.get_count() {
            def arg := getReference(call.children[i], out)
            if i >= offset & actualMethodType.subtypes[i - offset] != call.children[i].type {
                arg := getCastReference(arg, call.children[i].type,
                        actualMethodType.subtypes[i - offset], out)
            }
            args.add(arg)
        }
        def target:String?
        if args.get_count() > 0 {
            -- this isn't actually correct - args[0] could be the target of an instance method, or
            -- just the first parameter to a class method. But getMethodReference ignores target for
            -- class methods, so this works and is easier than doing it the right way.
            target := args[0]
        }
        else {
            target := null
        }
        def methodRef := getMethodReference(target, m, isSuper, out)
        def indirect := needsStructIndirection(m)
        def result := MutableString("\{methodRef}(")
        var separator := ""
        def indirectVar:String
        if indirect {
            varCount += 1
            indirectVar := "$tmp" + varCount
            methodHeader.printLine("\{actualResultType} \{indirectVar};")
            out.print(indirectVar)
            separator := ", "
        }
        for arg in args {
            result.append("\{separator}\{arg}")
            separator := ", "
        }
        result.append(")")
        if type(call.type) != actualResultType {
            return getCastReference(result.convert(), 
                        actualMethodType.subtypes[actualMethodType.subtypes.get_count() - 1],
                        call.type,
                        out)
        }
        return result.convert()
    }

    method wrapValue(value:String, srcType:Type, dstType:Type, out:IndentedOutputStream):String {
        return "((\{type(dstType)}) wrap_\{escapeName(compiler.getClass(srcType).name)}(\{value}))"
    }

    function isConstantNumber(expr:IRNode):Bit {
        return expr.kind = IRNode.Kind.CONSTRUCT & expr.type.isNumber() &
                expr.children[0].children[0].kind = IRNode.Kind.INT
    }

    method getFieldReference(fieldRef:IRNode, out:IndentedOutputStream):String {
        assert fieldRef.kind = IRNode.Kind.FIELD_REFERENCE
        assert fieldRef.children.get_count() = 1
        def field := fieldRef.payload->FieldDecl
        def cl := compiler.getClass(fieldRef.children[0].type)
        def base := getReference(fieldRef.children[0], out)
        assert cl != null
        if compiler.isValue(cl) {
            return "\{base}.\{escapeName(field.name)}"
        }
        return "\{base}->\{escapeName(field.name)}"
    }


    method unwrapValue(value:String, srcType:Type, dstType:Type, out:IndentedOutputStream):String {
        return "((\{wrapperType(dstType)}) \{value})->value"
    }

    method toNullableValue(value:String, srcType:Type, dstType:Type,
            out:IndentedOutputStream):String {
        return "((\{nullableType(dstType)}) { \{value}, true })"
    }

    method toNonNullableValue(value:String, srcType:Type, dstType:Type,
            out:IndentedOutputStream):String {
        return "\{value}.value"
    }

    method getCastReference(value:String, src:Type, target:Type, out:IndentedOutputStream):String {
        def op:String
        if target.isBuiltinNumber() {
            assert src.isBuiltinNumber()
            return "((\{type(target)}) \{value})"
        }
        else {
            def srcClass := compiler.getClass(src)
            assert srcClass != null
            def targetClass := compiler.getClass(target)
            assert targetClass != null
            if compiler.isValue(srcClass) & !compiler.isValue(targetClass) {
                return wrapValue(value, src, target, out)
            }
            else if !compiler.isValue(srcClass) & compiler.isValue(targetClass) {
                return unwrapValue(value, src, target, out)
            }
            else if compiler.isValue(srcClass) & target.typeKind = Type.Kind.NULLABLE &
                    target.subtypes[0] = src {
                return toNullableValue(value, src, target, out)
            }
            else if compiler.isValue(targetClass) & src.typeKind = Type.Kind.NULLABLE &
                    src.subtypes[0] = target {
                return toNonNullableValue(value, src, target, out)
            }
            op := "bitcast"
        }
        def srcType := type(src)
        def dstType := type(target)
        if srcType = dstType {
            return value
        }
        return "((\{dstType}) \{value})"
    }

    method getCastReference(cast:IRNode, out:IndentedOutputStream):String {
        assert cast.kind = IRNode.Kind.CAST
        assert cast.children.get_count() = 1
        def base := getReference(cast.children[0], out)
        return getCastReference(base, cast.children[0].type, cast.type, out)
    }

    method getConstructReference(construct:IRNode, out:IndentedOutputStream):String {
        assert construct.kind = IRNode.Kind.CONSTRUCT
        assert construct.children.get_count() >= 1
        def cl := compiler.getClass(construct.type)
        assert cl != null
        def t := type(construct.type)
        if construct.type.isNumber() | construct.type = Type.Bit() {
            assert construct.children.get_count() = 1
            assert construct.children[0].children.get_count() = 1
            def value := getTypedReference(construct.children[0].children[0], out)
            return "((\{type(construct.type)}) { " + value + " })"
        }
        if compiler.isValue(cl) {
            varCount += 1
            def tmp := "$tmp\{varCount}"
            methodHeader.printLine("\{t} \{tmp};")
            writeCall(construct.children[0], "&\{tmp}", out)
            return tmp
        }
        def result := nextVar()
        out.printLine("\{type(construct.type)} \{result} = (\{type(construct.type)}) " +
                    "malloc(\{sizeOf(construct.type)});")
        def classPtr := nextVar()
        def className:String
        if construct.type.typeKind = Type.Kind.GENERIC {
            className := typeName(construct.type.subtypes[0])
        }
        else {
            className := typeName(construct.type)
        }
        out.printLine("\{result}->$class = (panda$core$Class*) &\{escapeName(cl.name)}$class;")
        out.printLine("\{result}->refCount.value = 1;")
        writeCall(construct.children[0], "\{result}", out)
        return result
    }

    method getIntReference(int:IRNode, out:IndentedOutputStream):String {
        return (int.payload->Int).convert() -- FIXME parens
    }

    method getNegatedIntReference(int:IRNode, out:IndentedOutputStream):String {
        return "-" + (int.payload->Int).convert() -- FIXME parens
    }

    method getBitReference(bit:IRNode, out:IndentedOutputStream):String {
        if bit.payload->Bit {
            return "true"
        }
        return "false"
    }

    method getVariableReference(v:Variable, out:IndentedOutputStream):String {
        return getName(v)
    }

    method getStringReference(s:String, out:IndentedOutputStream):String {
        varCount += 1
        def result := "$s\{varCount}"
        type(Type.StringType())
        strings.print("static panda$core$String \{result} = { " +
                "(panda$core$Class*) &panda$core$String$class, 2, (panda$core$Char8*) \"")
        for raw in s.utf8() {
            def c := raw.convert()->UInt8
            if c = 34 { -- FIXME char literal
                strings.print("\"")
            }
            else if c < 32 | c > 126 {
                strings.print("\\x")
                strings.print("0123456789ABCDEF".utf8()[(c // 16).convert()])
                strings.print("0123456789ABCDEF".utf8()[(c % 16).convert()])
            }
            else {
                strings.print(raw)
            }
        }
        strings.printLine("\", \{s.utf8().get_count()} };")
        return "&\{result}"
    }

    method getSelfReference(s:IRNode, out:IndentedOutputStream):String {
        if currentMethod.methodKind = MethodDecl.Kind.INIT {
            return "(*self)"
        }
        return "self"
    }

    method getSuperReference(s:IRNode, out:IndentedOutputStream):String {
        def result := nextVar()
        out.printLine("\{result} = bitcast \{type(currentMethod.owner.type())} %self to " +
                type(s.type))
        return result
    }

    method getIsNullReference(test:IRNode, out:IndentedOutputStream):String {
        assert test.kind = IRNode.Kind.IS_NULL
        assert test.children.get_count() = 1
        def value := getTypedReference(test.children[0], out)
        def cl := compiler.getClass(test.children[0].type)
        def resultValue:String
        if compiler.isValue(cl) {
            if test.children[0].type.typeKind != Type.Kind.NULLABLE {
                return "{ i1 0 }"
            }
            def field := nextVar()
            out.printLine("\{field} = extractvalue6 \{value}, 1")
            resultValue := nextVar()
            out.printLine("\{resultValue} = xor i1 \{field}, -1")
        }
        else {
            resultValue := nextVar()
            out.printLine("\{resultValue} = icmp eq \{value}, null")
        }
        def result := nextVar()
        out.printLine("\{result} = insertvalue %panda$core$Bit { i1 undef }, i1 \{resultValue}, 0")
        return result
    }

    method getIsNonNullReference(test:IRNode, out:IndentedOutputStream):String {
        assert test.kind = IRNode.Kind.IS_NONNULL
        assert test.children.get_count() = 1
        def value := getTypedReference(test.children[0], out)
        def cl := compiler.getClass(test.children[0].type)
        def resultValue:String
        if compiler.isValue(cl) {
            if test.children[0].type.typeKind != Type.Kind.NULLABLE {
                return "{ i1 1 }"
            }
            resultValue := nextVar()
            out.printLine("\{resultValue} = extractvalue7 \{value}, 1")
        }
        else {
            resultValue := nextVar()
            out.printLine("\{resultValue} = icmp ne \{value}, null")
        }
        def result := nextVar()
        out.printLine("\{result} = insertvalue %panda$core$Bit { i1 undef }, i1 \{resultValue}, 0")
        return result
    }

    method getNullReference(expr:IRNode, out:IndentedOutputStream):String {
        assert expr.type.typeKind = Type.Kind.NULLABLE
        def cl := compiler.getClass(expr.type.subtypes[0])
        assert cl != null
        if compiler.isValue(cl) {
            return "{ \{type(expr.type.subtypes[0])} undef, i1 0 }"
        }
        else {
            return "null"
        }
    }

    method getPrefixReference(expr:IRNode, out:IndentedOutputStream):String {
        assert expr.kind = IRNode.Kind.PREFIX
        assert expr.children.get_count() = 1
        def base := getReference(expr.children[0], out)
        def result := nextVar()
        match (expr.payload->UInt64).convert()->Int64 {
            when Token.Kind.SUB:
                return "-\{base}"
            when Token.Kind.NOT:
                return "!\{base}"
            when Token.Kind.BITWISENOT:
                return "~\{base}"
            otherwise:
                assert false, expr.convert()
        }
    }

    method getReference(expr:IRNode, out:IndentedOutputStream):String {
        match expr.kind {
            when IRNode.Kind.BINARY:
                return getBinaryReference(expr, out)
            when IRNode.Kind.CALL:
                return getCallReference(expr, out)
            when IRNode.Kind.CAST:
                return getCastReference(expr, out)
            when IRNode.Kind.INT:
                return getIntReference(expr, out)
            when IRNode.Kind.NEGATED_INT:
                return getNegatedIntReference(expr, out)
            when IRNode.Kind.BIT:
                return getBitReference(expr, out)
            when IRNode.Kind.CONSTRUCT:
                return getConstructReference(expr, out)
            when IRNode.Kind.VARIABLE_REFERENCE:
                return getVariableReference(expr.payload->Variable, out)
            when IRNode.Kind.FIELD_REFERENCE:
                return getFieldReference(expr, out)
            when IRNode.Kind.STRING:
                return getStringReference(expr.payload->String, out)
            when IRNode.Kind.SELF:
                return getSelfReference(expr, out)
            when IRNode.Kind.SUPER:
                return getSuperReference(expr, out)
            when IRNode.Kind.REUSED_VALUE_DEFINITION:
                def value := getReference(expr.children[0], out)
                reusedValues[expr.payload->UInt64] := value
                return value
            when IRNode.Kind.REUSED_VALUE:
                def result := reusedValues[expr.payload->UInt64]
                assert result != null
                return result
            when IRNode.Kind.NULL:
                return getNullReference(expr, out)
            when IRNode.Kind.IS_NULL:
                return getIsNullReference(expr, out)
            when IRNode.Kind.IS_NONNULL:
                return getIsNonNullReference(expr, out)
            when IRNode.Kind.PREFIX:
                return getPrefixReference(expr, out)
            otherwise:
                assert false, "unsupported expression \{expr}:\{compiler.position(expr.offset)}"
        }
    }

    method getTypedReference(expr:IRNode, out:IndentedOutputStream):String {
        return getReference(expr, out)
    }

    method writeBlock(block:IRNode, out:IndentedOutputStream) {
        assert block.kind = IRNode.Kind.BLOCK
        out.printLine("{")
        out.level += 1
        for s in block.children {
            writeStatement(s, out)
        }
        out.level -= 1
        out.printLine("}")
    }

    method writePointerCall(stmt:IRNode, out:IndentedOutputStream) {
        def m := stmt.payload->MethodRef
        match m.value.name {
            when "set":
                assert stmt.children.get_count() = 2
                def ptr := getTypedReference(stmt.children[0], out)
                def arg := getTypedReference(compiler.unwrapCast(stmt.children[1]), out)
                out.printLine("store2 \{arg}, \{ptr}")
            when "[]:=":
                assert stmt.children.get_count() = 3
                assert compiler.unwrapCast(stmt.children[0]).type.subtypes.get_count() = 2
                def base := getReference(stmt.children[0], out)
                def index := getReference(stmt.children[1], out)
                def value := getReference(compiler.unwrapCast(stmt.children[2]), out)
                out.printLine("\{base}[\{index}.value] = \{value};")
            when "destroy":
                assert stmt.children.get_count() = 1
                out.printLine("free(\{getReference(stmt.children[0], out)});")
            otherwise:
                assert false
        }
    }

    -- if 'target' is non-null, it is inserted as a hidden first parameter to the call. This is used
    -- for init() calls, which require a self parameter but do not have a target in the IR.
    method writeCall(call:IRNode, target:String?, out:IndentedOutputStream) {
        assert call.kind = IRNode.Kind.CALL
        def m := (call.payload->MethodRef).value
        if m.owner.name = "panda.unsafe.Pointer" {
            writePointerCall(call, out)
            return
        }
        if m.owner.external {
            writeDeclaration(m)
        }
        def actualMethodType:Type
        def actualResultType:String
        def isSuper := call.children.get_count() >= 1 & call.children[0].kind = IRNode.Kind.SUPER
        if !isSuper & m.isVirtual() {
            actualMethodType := compiler.inheritedType(m)
            actualResultType := type(actualMethodType.subtypes[actualMethodType.subtypes.get_count() - 1])
        }
        else {
            actualMethodType := compiler.declaredType(m)
            actualResultType := type(call.type)
        }
        def args := Array<String>()
        if target != null {
            args.add(target)
        }
        def offset := call.children.get_count() - actualMethodType.subtypes.get_count() + 1
        for i in 0 .. call.children.get_count() {
            var arg := getReference(call.children[i], out)
            if i >= offset & actualMethodType.subtypes[i - offset] != call.children[i].type {
                arg := getCastReference(arg, call.children[i].type,
                            actualMethodType.subtypes[i - offset], out)
            }
            args.add(arg)
        }
        def refTarget:String?
        if args.get_count() > 0 {
            -- this isn't actually correct - args[0] could be the target of an instance method, or
            -- just the first parameter to a class method. But getMethodReference ignores target for
            -- non-virtual methods, so this works and is easier than doing it the right way.
            refTarget := args[0]
        }
        else {
            refTarget := null
        }
        def methodRef := getMethodReference(refTarget, m, isSuper, out)
        var separator := ""
        if needsStructIndirection(m) {
            varCount += 1
            def indirectVar := "$tmp" + varCount
            def resultType := type(call.type)
            methodHeader.printLine("\{resultType} \{indirectVar};")
            out.print("\{methodRef}(\{resultType}* \{indirectVar}")
            separator := ", "
        }
        else {
            out.print("\{methodRef}(")
        }
        for a in args {
            out.print(separator)
            out.print(a)
            separator := ", "
        }
        out.printLine(");")
    }

    method writeIf(s:IRNode, out:IndentedOutputStream) {
        assert s.kind = IRNode.Kind.IF
        assert s.children.get_count() = 2 | s.children.get_count() = 3
        assert s.children[0].type = Type.Bit()
        def test := getReference(s.children[0], out)
        out.print("if (\{test}.value) ")
        writeStatement(s.children[1], out)
        if s.children.get_count() = 3 {
            out.print("else ")
            writeStatement(s.children[2], out)
        }
    }

    method writeRangeFor(f:IRNode, out:IndentedOutputStream) {
        -- See LLVMCodeGenerator.writeRangeFor for an overview of why this code is so terrible.
        -- Here, we double down on the awful by keeping the LLVM structure completely intact and
        -- using gotos instead of anything resembling idiomatic C code, mostly to help ensure the
        -- behavior is identical.
        assert f.kind = IRNode.Kind.RANGE_FOR
        assert f.children.get_count() = 3
        def target := f.children[0]
        assert f.children[1].type.typeKind = Type.Kind.GENERIC
        assert f.children[1].type.subtypes.get_count() = 2
        assert f.children[1].type.subtypes[0].name = "panda.core.Range"
        def range := getTypedReference(f.children[1], out)
        def block := f.children[2]
        def t := f.children[1].type.subtypes[1]
        def llt := type(t)
        def indexType:String
        if t.typeKind = Type.Kind.NULLABLE {
            assert t.subtypes.get_count() = 1
            indexType := type(t.subtypes[0])
        }
        else {
            indexType := llt
        }
        def cl := compiler.getClass(t)
        assert cl != null
        assert compiler.instanceFields(cl).get_count() = 1
        def numberType := type(compiler.instanceFields(cl)[0].type)
        assert target.kind = IRNode.Kind.VARIABLE_REFERENCE
        def index := getName(target.payload->Variable)

        -- extract start value from range
        def start := nextVar()
        out.printLine("\{numberType} \{start} = ((\{wrapperType(t)}) \{range}.start)->value.value;")

        -- store start value
        def indexValuePtr := nextVar()
        out.printLine("\{type(cl.type())} \{index} = { \{start} };")

        -- extract end value from range
        def end := nextVar()
        out.printLine("\{numberType} \{end} = ((\{wrapperType(t)}) \{range}.end)->value.value;")

        -- extract step value from range
        def step := nextVar()
        out.printLine("\{numberType} \{step} = \{range}.step.value;")

        -- extract inclusive / exclusive from range
        def inclusive := nextVar()
        out.printLine("bool \{inclusive} = \{range}.inclusive.value;")

        -- start block
        def loopStart := nextLabel()
        def loopBody := nextLabel()
        def loopEnd := nextLabel()
        def loopTest := nextLabel()
        loopDescriptors.push(LoopDescriptor(f.payload->String?, loopEnd, loopTest)) -- FIXME Auto
        def forwardEntry := nextLabel()
        def backwardEntry := nextLabel()
        def signPrefix:String
        if t.name.startsWith("panda.core.Int") {
            signPrefix := "s"
        }
        else {
            assert t.name.startsWith("panda.core.UInt") | t.name.startsWith("panda.core.Char")
            signPrefix := "u"
        }
        def direction:String
        if signPrefix = "s" {
            direction := nextVar()
            out.printLine("bool \{direction} = \{step} > 0;")
        }
        else {
            direction := "true"
        }
        out.printLine("if (\{direction}) goto \{forwardEntry}; else goto \{backwardEntry};")
        out.printLine("\{forwardEntry}:")
        def forwardEntryInclusive := nextLabel()
        def forwardEntryExclusive := nextLabel()
        out.printLine("if (\{inclusive}) goto \{forwardEntryInclusive}; else goto " +
                "\{forwardEntryExclusive};")
        out.printLine("\{forwardEntryInclusive}:")
        out.printLine("if (\{start} <= \{end}) goto \{loopStart}; else goto \{loopEnd};")
        out.printLine("\{forwardEntryExclusive}:")
        out.printLine("if (\{start} < \{end}) goto \{loopStart}; else goto \{loopEnd};")
        out.printLine("\{backwardEntry}:")
        def backwardEntryInclusive := nextLabel()
        def backwardEntryExclusive := nextLabel()
        out.printLine("if (\{inclusive}) goto \{backwardEntryInclusive}; else goto " +
                "\{backwardEntryExclusive};")
        out.printLine("\{backwardEntryInclusive}:")
        out.printLine("if (\{start} >= \{end}) goto \{loopStart}; else goto \{loopEnd};")
        out.printLine("\{backwardEntryExclusive}:")
        def backwardEntryExclusiveTest := nextVar()
        out.printLine("if (\{start} > \{end}) goto \{loopStart}; else goto \{loopEnd};")
        out.printLine("\{loopStart}:")
        writeStatement(block, out)
        out.printLine("\{loopTest}:")
        def loopInc := nextLabel()
        -- beginning of loop test, determine direction
        def forwardLabel := nextLabel()
        def backwardLabel := nextLabel()
        out.printLine("if (\{direction}) goto \{forwardLabel}; else goto \{backwardLabel};")

        -- forward loop; perform the test by subtracting index from end and then comparing to step,
        -- to avoid overflows near the maximum value
        out.printLine("\{forwardLabel}:;")
        def forwardDelta := nextVar()
        out.printLine("\{numberType} \{forwardDelta} = \{end} - \{index}.value;")

        -- forward loop; determine inclusive / exclusive
        def forwardInclusiveLabel := nextLabel()
        def forwardExclusiveLabel := nextLabel()
        out.printLine("if (\{inclusive}) goto \{forwardInclusiveLabel}; else goto " +
                "\{forwardExclusiveLabel};")

        -- forward inclusive test
        out.printLine("\{forwardInclusiveLabel}:")
        -- always use unsigned comparison to avoid overflow; we know both the delta and the step are
        -- the same sign
        out.printLine("if (\{forwardDelta} >= \{step}) goto \{loopInc}; else goto \{loopEnd};")

        -- forward exclusive test
        out.printLine("\{forwardExclusiveLabel}:")
        def forwardExclusiveTest := nextVar()
        out.printLine("if (\{forwardDelta} > \{step}) goto \{loopInc}; else goto \{loopEnd};")

        -- backward loop; perform the test by subtracting end from index and then comparing to
        -- -step, to avoid overflows near the minimum value
        out.printLine("\{backwardLabel}:; // BACKWARD LABEL")
        def backwardDelta := nextVar()
        out.printLine("\{numberType} \{backwardDelta} = \{index}.value - \{end};")

        -- backward loop; determine inclusive / exclusive
        def backwardInclusiveLabel := nextLabel()
        def backwardExclusiveLabel := nextLabel()
        out.printLine("if (\{inclusive}) goto \{backwardInclusiveLabel}; else goto " +
                "\{backwardExclusiveLabel};")

        -- backward inclusive test
        out.printLine("\{backwardInclusiveLabel}:")
        out.printLine("if (\{backwardDelta} >= -\{step}) goto \{loopInc}; else goto \{loopEnd};")

        -- backward exclusive test
        out.printLine("\{backwardExclusiveLabel}:")
        out.printLine("if (\{backwardDelta} > -\{step}) goto \{loopInc}; else goto \{loopEnd};")

        out.printLine("\{loopInc}:")
        def inc := nextVar()
        out.printLine("\{index}.value += \{step};")
        out.printLine("goto \{loopStart};")
        out.printLine("\{loopEnd}:;")
        loopDescriptors.pop()
    }

    method writeWhile(w:IRNode, out:IndentedOutputStream) {
        assert w.kind = IRNode.Kind.WHILE
        assert w.children.get_count() = 2
        assert w.children[0].type = Type.Bit()
        def loopStart := nextLabel()
        def loopBody := nextLabel()
        def loopEnd := nextLabel()
        loopDescriptors.push(LoopDescriptor(w.payload->String?, loopEnd, loopStart)) -- FIXME Auto
        out.printLine("br label %\{loopStart}")
        createBlock(loopStart, out)
        def test := getTypedReference(w.children[0], out)
        def testBit := nextVar()
        out.printLine("\{testBit} = extractvalue12 \{test}, 0")
        out.printLine("br i1 \{testBit}, label %\{loopBody}, label %\{loopEnd}")
        createBlock(loopBody, out)
        writeStatement(w.children[1], out)
        if !endsWithBranch(w.children[1]) {
            out.printLine("br label %\{loopStart}")
        }
        createBlock(loopEnd, out)
        loopDescriptors.pop()
    }

    method writeDo(d:IRNode, out:IndentedOutputStream) {
        assert d.kind = IRNode.Kind.DO
        assert d.children.get_count() = 2
        assert d.children[1].type = Type.Bit()
        def loopStart := nextLabel()
        def loopEnd := nextLabel()
        loopDescriptors.push(LoopDescriptor(d.payload->String?, loopEnd, loopStart)) -- FIXME Auto
        out.printLine("\{loopStart}: do ")
        writeStatement(d.children[0], out)
        out.printLine("while (\{getReference(d.children[1], out)}.value);")
        out.printLine("\{loopEnd}:")
        loopDescriptors.pop()
    }

    method writeLoop(l:IRNode, out:IndentedOutputStream) {
        assert l.kind = IRNode.Kind.LOOP
        assert l.children.get_count() = 1
        def loopStart := nextLabel()
        def loopEnd := nextLabel()
        loopDescriptors.push(LoopDescriptor(l.payload->String?, loopEnd, loopStart))
        out.printLine("br label %\{loopStart}")
        createBlock(loopStart, out)
        writeStatement(l.children[0], out)
        if !endsWithBranch(l.children[0]) {
            out.printLine("br label %\{loopStart}")
        }
        createBlock(loopEnd, out)
        loopDescriptors.pop()
    }

    method writeVarTarget(target:IRNode, value:IRNode?, out:IndentedOutputStream) {
        match target.kind {
            when IRNode.Kind.VARIABLE_REFERENCE:
                def v := target.payload->Variable
                methodHeader.printLine("\{type(v.type)} \{getName(v)};")
                if value != null {
                    out.printLine("\{getName(v)} = \{getReference(value, out)};")
                }
            when IRNode.Kind.TUPLE_TARGET:
                assert false
            otherwise:
                assert false
        }
    }

    method writeVar(v:IRNode, out:IndentedOutputStream) {
        assert v.kind = IRNode.Kind.VAR |
                v.kind = IRNode.Kind.DEF |
                v.kind = IRNode.Kind.PROPERTY |
                v.kind = IRNode.Kind.CONSTANT
        for decl in v.children {
            assert decl.kind = IRNode.Kind.DECLARATION
            if decl.children.get_count() > 1 {
                writeVarTarget(decl.children[0], decl.children[1], out)
            }
            else {
                writeVarTarget(decl.children[0], null, out)
            }
        }
    }

    method getLValue(lvalue:IRNode, out:IndentedOutputStream):String {
        match lvalue.kind {
            when IRNode.Kind.CAST:
                return getLValue(compiler.unwrapCast(lvalue), out)
            when IRNode.Kind.VARIABLE_REFERENCE:
                return getName(lvalue.payload->Variable)
            when IRNode.Kind.FIELD_REFERENCE:
                def base := getReference(lvalue.children[0], out)
                return "\{base}.\{(lvalue.payload->FieldDecl).name}" -- FIXME parens
            when IRNode.Kind.REUSED_VALUE_DEFINITION:
                def result := getLValue(lvalue.children[0], out)
                reusedValues[lvalue.payload->UInt64] := result
                return result
            otherwise:
                assert false, "unsupported lvalue: \{lvalue}"
        }
    }

    method writeAssignment(a:IRNode, out:IndentedOutputStream) {
        assert a.kind = IRNode.Kind.BINARY
        assert a.children.get_count() = 2
        def lvalue := getLValue(a.children[0], out)
        def value:String
        def t := type(a.children[0].type)
        def op := a.payload->Int
        if op = Token.Kind.ASSIGNMENT {
            def right := getReference(a.children[1], out)
            value := right
        }
        else {
-*            Operator binOp;
            switch (op) {
                case Operator.ADDEQ:        binOp = Operator.ADD;                         break;
                case Operator.SUBEQ:        binOp = Operator.SUB;                         break;
                case Operator.MULEQ:        binOp = Operator.MUL;                         break;
                case Operator.DIVEQ:        binOp = Operator.DIV;                         break;
                case Operator.INTDIVEQ:     binOp = Operator.INTDIV;                      break;
                case Operator.REMEQ:        binOp = Operator.REM;                         break;
                case Operator.POWEQ:        binOp = Operator.POW;                         break;
                case Operator.XOREQ:        binOp = Operator.XOR;                         break;
                case Operator.BITWISEOREQ:  binOp = Operator.BITWISEOR;                   break;
                case Operator.BITWISEANDEQ: binOp = Operator.BITWISEAND;                  break;
                case Operator.BITWISEXOREQ: binOp = Operator.BITWISEXOR;                  break;
                case Operator.SHIFTLEFTEQ:  binOp = Operator.SHIFTLEFT;                   break;
                case Operator.SHIFTRIGHTEQ: binOp = Operator.SHIFTRIGHT;                  break;
                case Operator.ANDEQ:        this->writeAndEq(lvalue, a.fChildren[1], out); return;
                case Operator.OREQ:         this->writeOrEq(lvalue, a.fChildren[1], out);  return;
                default: abort();
            }
            def left := nextVar()
            out << "    " << left << " = load12 " << this->llvmType(a.fChildren[0].fType) << ", " <<
                    lvalue << "\n";
            String right = this->getReference(a.fChildren[1], out);
            value = type + " " +
                    this->getBinaryReference(op_class(a.fChildren[0].fType), type + " " + left, binOp,
                            right, out);
            *-
            assert false
        }
        out.printLine("\{lvalue} = \{value};")
    }

    method writeReturn(r:IRNode, out:IndentedOutputStream) {
        if r.children.get_count() = 1 {
            if inlineContext.get_count() > 0 {
                def inline := inlineContext.peek()
                def result := getReference(r.children[0], out)
                inline.returns.add(Pair<String, String>(currentBlock, result))
                out.printLine("br label %\{inline.exitLabel} ; inline return (\{compiler.position(r.offset)})")
            }
            else {
                out.printLine("return \{getReference(r.children[0], out)};")
            }
        }
        else {
            assert r.children.get_count() = 0
            if inlineContext.get_count() > 0 {
                out.printLine("br label %\{inlineContext.peek().exitLabel}")
            }
            else {
                out.printLine("return;")
            }
        }
    }

    function findLoop(name:String?):LoopDescriptor {
        assert loopDescriptors.get_count() > 0
        if name = null {
            return loopDescriptors.peek()
        }
        for i in 0 .. loopDescriptors.get_count() {
            if loopDescriptors.peek(i).loopLabel != null & loopDescriptors.peek(i).loopLabel = name { -- FIXME shouldn't need null check
                return loopDescriptors.peek(i)
            }
        }
        assert false
    }

    method writeBreak(b:IRNode, out:IndentedOutputStream) {
        def desc := findLoop(b.payload->String?)
        out.printLine("br label %\{desc.breakLabel}")
    }

    method writeContinue(c:IRNode, out:IndentedOutputStream) {
        def desc := findLoop(c.payload->String?)
        out.printLine("br label %\{desc.continueLabel}")
    }

    method writeAssert(a:IRNode, out:IndentedOutputStream) {
        assert a.kind = IRNode.Kind.ASSERT
        assert a.children.get_count() = 1 | a.children.get_count() = 2
        if compiler.settings.safetyLevel < 2 {
            return
        }
        def test := getReference(a.children[0], out)
        def ifTrue := nextLabel()
        def ifFalse := nextLabel()
        out.printLine("br i1 \{test}, label %\{ifTrue}, label %\{ifFalse}")
        createBlock(ifFalse, out)
        def p := compiler.position(a.offset)
        def name:String
        def index := p.file.lastIndexOf("/")
        if index = null {
            name := p.file
        }
        else {
            name := p.file[index...]
        }
        def nameRef := getStringReference(name, out)
        def line := "panda$core$Int64 { i64 \{p.line} }"
        def msg:String?
        if a.children.get_count() = 2 {
            msg := getReference(a.children[1], out)
        }
        else {
            msg := null
        }
        out.print("call fastcc void ")
        for m in compiler.getClass(Type.Panda()).methods {
            if m.name = "assertionFailure" {
                compiler.resolve(m)
                writeDeclaration(m)
            }
        }
        if msg != null {
            out.print("@panda$core$Panda$assertionFailure$" +
                    "panda$core$String$panda$core$Int64$panda$core$String")
        }
        else {
            out.print("@panda$core$Panda$assertionFailure$panda$core$String$panda$core$Int64")
        }
        out.print("(%panda$core$String* \{nameRef}, \{line}")
        if msg != null {
            out.print(", %panda$core$String* \{msg}")
        }
        out.printLine(")")
        out.printLine("unreachable")
        createBlock(ifTrue, out)
    }

    method writeStatement(stmt:IRNode, out:IndentedOutputStream) {
        match stmt.kind {
            when IRNode.Kind.BINARY:
                writeAssignment(stmt, out)
            when IRNode.Kind.BLOCK:
                writeBlock(stmt, out)
            when IRNode.Kind.CALL:
                writeCall(stmt, null, out)
            when IRNode.Kind.IF:
                writeIf(stmt, out)
            when IRNode.Kind.RANGE_FOR:
                writeRangeFor(stmt, out)
            when IRNode.Kind.WHILE:
                writeWhile(stmt, out)
            when IRNode.Kind.DO:
                writeDo(stmt, out)
            when IRNode.Kind.LOOP:
                writeLoop(stmt, out)
            when IRNode.Kind.VAR, IRNode.Kind.DEF, IRNode.Kind.CONSTANT, IRNode.Kind.PROPERTY:
                writeVar(stmt, out)
            when IRNode.Kind.RETURN:
                writeReturn(stmt, out)
            when IRNode.Kind.BREAK:
                writeBreak(stmt, out)
            when IRNode.Kind.CONTINUE:
                writeContinue(stmt, out)
            when IRNode.Kind.ASSERT:
                writeAssert(stmt, out)
            otherwise:
                assert false, "unsupported statement \{stmt}"
        }
    }

    method selfType(m:MethodDecl):String {
        def result := type(m.owner.type())
        if m.methodKind = MethodDecl.Kind.INIT & !result.endsWith("*") {
            return result + "*"
        }
        return result
    }

    @override
    method writeDeclaration(m:MethodDecl) {
        writeImport(m.owner)
    }

    @override
    method write(m:MethodDecl, body:IRNode) {
        assert compiler.currentClass.peek() == m.owner
        currentMethod := m
        currentBlock := "0"
        varCount := 0
        methodHeaderBuffer.clear()
        methods.print("\{type(m.returnType)} \{getName(m)}(")
        var separator := ""
        if !m.annotations.isClass() {
            methods.print("\{selfType(m)} self")
            separator := ", "
        }
        for p in m.parameters {
            methods.print("\{separator}\{type(p.type)} \{escapeName(p.name)}")
            separator := ", "
        }
        methods.printLine(") {")
        methods.level += 1
        assert body.kind = IRNode.Kind.BLOCK
        def bodyBuffer := MemoryOutputStream()
        def indentedBody := IndentedOutputStream(bodyBuffer)
        for s in body.children {
            writeStatement(s, indentedBody)
        }
        methods.print(methodHeaderBuffer.convert())
        methods.print(bodyBuffer.convert())
        methods.level -= 1
        methods.printLine("}")
        currentMethod := null
    }

    @override
    method write(cl:ClassDecl) {
        getClassConstant(cl)
        if compiler.isValue(cl) {
            getWrapperClassConstant(cl)
            out.printLine("\{escapeName(cl.name)}$wrapper* wrap_\{escapeName(cl.name)}(" +
                    "\{escapeName(cl.name)} self) {")
            out.printLine("    \{escapeName(cl.name)}$wrapper* result = " +
                    "(\{escapeName(cl.name)}$wrapper*) malloc(\{sizeOfWrapper(cl.type())});")
            out.printLine("    result->cl = (panda$core$Class*) " +
                    "&\{escapeName(cl.name)}$wrapperclass;")
            out.printLine("    result->value = self;")
            out.printLine("    return result;")
            out.printLine("}")
        }
    }

    @override
    method finish() {
        out.printLine(shimsBuffer)
        out.printLine(wrapperShimsBuffer)
        out.printLine(types)
        out.printLine(strings)
        out.printLine(methodsBuffer)
        out.out.cleanup() -- FIXME shouldn't be necessary
    }
}