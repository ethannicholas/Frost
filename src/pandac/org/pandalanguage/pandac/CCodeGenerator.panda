package org.pandalanguage.pandac

uses org.pandalanguage.pandac.parser.Token

class CCodeGenerator (CodeGenerator) {
    var compiler:Compiler?

    def out:IndentedOutputStream

    def imports := Set<String>()

    def hCodeGen := HCodeGenerator(MemoryOutputStream())

    init(out:OutputStream) {
        self.out := IndentedOutputStream(out)
    }

    function escapeName(s:String):String {
        return hCodeGen.escapeName(s)
    }

    function getName(m:MethodDecl):String {
        return hCodeGen.getName(m)
    }

    function sizeOf(t:Type):Int {
        return hCodeGen.sizeOf(t)
    }

    method writeImport(cl:ClassDecl) {
        def includePath := hCodeGen.getIncludePath(cl)
        if !imports.contains(includePath) {
            out.printLine("#include \"\{includePath}\"")
            imports.add(includePath)
        }
    }

    method type(t:Type):String {
        if t.isClass() {
            def cl := compiler.getClass(t)
            assert cl != null
            writeImport(cl)
        }
        return hCodeGen.type(t)
    }

    @override
    method setCompiler(compiler:Compiler) {
        self.compiler := compiler
        hCodeGen.setCompiler(compiler)
    }

    class ClassConstant : Immutable {
        def name:String
        def type:String

        init(name:String, type:String) {
            self.name := name
            self.type := type
        }
    }

    class MethodShim {
        def name:String
        def type:String

        init(name:String, type:String) {
            self.name := name
            self.type := type
        }
    }

    class LoopDescriptor : Immutable {
        def loopLabel:String?
        def breakLabel:String
        def continueLabel:String

        init(loopLabel:String?, breakLabel:String, continueLabel:String) {
            self.loopLabel := loopLabel
            self.breakLabel := breakLabel
            self.continueLabel := continueLabel
        }

        @override
        function convert():String {
            if loopLabel != null {
                return "LoopDescriptor<\{loopLabel}>"
            }
            else {
                return "LoopDescriptor<>"
            }
        }
    }

    ================================================================================================
    Overrides features such as method arguments and return handling for use in compiling inline
    methods.
    ================================================================================================
    class InlineContext {
        ============================================================================================
        Local variable name suffix.
        ============================================================================================
        def varSuffix:String

        ============================================================================================
        Reference to use instead of the normal "%self".
        ============================================================================================
        def selfRef:String

        ============================================================================================
        Reference to use instead of the normal method parameter names.
        ============================================================================================
        def argRefs:ImmutableArray<String>

        ============================================================================================
        Contains pairs of (source block, return value), which can be turned into the actual return
        value using a phi node. Initially empty, filled in as the inline call is written.
        ============================================================================================
        def returns := Array<Pair<String, String>>()

        ============================================================================================
        Label to jump to after returning.
        ============================================================================================
        def exitLabel:String

        init(varSuffix:String, selfRef:String, argRefs:ListView<String>, exitLabel:String) {
            self.varSuffix := varSuffix
            self.selfRef := selfRef
            self.argRefs := ImmutableArray<String>(argRefs)
            self.exitLabel := exitLabel
        }
    }

    constant POINTER_SIZE        := 8
    constant OBJECT_FIELD_COUNT  := 2
    constant CLASS_POINTER_INDEX := 0
    constant ITABLE_INDEX        := 2
    constant VTABLE_INDEX        := 3

    constant INT_TYPE  := "i64"
    constant SIZE_TYPE := "i64"

    def declarations := MemoryOutputStream()

    def types := MemoryOutputStream()

    def methodsBuffer := MemoryOutputStream()

    def methods := IndentedOutputStream(methodsBuffer)

    def methodHeaderBuffer := MemoryOutputStream()

    def methodHeader := IndentedOutputStream(methodHeaderBuffer)

    def wrapperShimsBuffer := MemoryOutputStream()

    def wrapperShims := IndentedOutputStream(wrapperShimsBuffer)

    def shimsBuffer := MemoryOutputStream()

    def shims := IndentedOutputStream(shimsBuffer)

    def strings := MemoryOutputStream()

    def declared := Set<String>()

    def writtenTypes := Set<String>()

    def writtenWrappers := Set<String>()

    def classConstants := HashMap<String, ClassConstant>()

    def variableNames := IdentityMap<Variable, String>()

    var currentBlock:String

    var currentMethod:MethodDecl?

    def loopDescriptors := Stack<LoopDescriptor>()

    var varCount := 0

    var labelCount := 0

    def reusedValues := HashMap<UInt64, String>()

    def methodShims := IdentityMap<MethodDecl, MethodShim>()

    def inlineContext := Stack<InlineContext>()

    def currentlyInlining := IdentityMap<MethodDecl, MethodDecl>() -- FIXME need IdentitySet

    method nextVar():String {
        varCount += 1
        return "%\{varCount}"
    }

    method nextLabel():String {
        labelCount += 1
        return "$l\{labelCount}"
    }

    method createBlock(label:String, out:IndentedOutputStream) {
        out.printLine("\n\{label}:")
        currentBlock := label
    }

    function endsWithBranch(stmt:IRNode):Bit {
        match stmt.kind {
            when IRNode.Kind.BLOCK:
                if stmt.children.get_count() = 0 {
                    return false
                }
                return endsWithBranch(stmt.children[stmt.children.get_count() - 1])
            when IRNode.Kind.BREAK, IRNode.Kind.CONTINUE, IRNode.Kind.RETURN:
                return true
            otherwise: return false
        }
    }

    function fieldSize(t:Type):Int {
        assert t.resolved
        if t.isBuiltinNumber() {
            if t.name.endsWith("8") {
                return 1
            }
            if t.name.endsWith("16") {
                return 2
            }
            if t.name.endsWith("32") {
                return 4
            }
            assert t.name.endsWith("64")
            return 8
        }
        if t = Type.BuiltinBit() {
            return 1
        }
        def cl := compiler.getClass(t)
        assert cl != null
        if !compiler.isValue(cl) | cl.name = "panda.unsafe.Pointer" {
            return POINTER_SIZE
        }
        var result := 0
        for f in compiler.instanceFields(cl) {
            if f.annotations.isClass() {
                continue
            }
            compiler.resolve(f)
            def size := fieldSize(f.type)
            def align := result % size
            if align != 0 {
                result += size - align
            }
            assert result % size = 0
            result += size
        }
        if t.typeKind = Type.Kind.NULLABLE {
            result += 1
        }
        return result
    }

    function alignment(t:Type):Int {
        return fieldSize(t).min(8)
    }

    function sizeOfWrapper(t:Type):Int {
        def cl := compiler.getClass(t)
        assert cl != null & compiler.isValue(cl)
        var result := sizeOf(Type.Object())
        for f in compiler.instanceFields(cl) {
            compiler.resolve(f)
            def size := fieldSize(f.type)
            def align := result % size
            if align != 0 {
                result += size - align
            }
            assert result % size = 0
            result += size
        }
        if t.typeKind = Type.Kind.NULLABLE {
            result += 1
        }
        return result
    }

    method writeType(t:Type) {
        if writtenTypes.contains(t.name) {
            return
        }
        writtenTypes.add(t.name)
        def code := MutableString("%\{escapeName(t.name)} = type { ")
        def cl := compiler.getClass(t)
        compiler.currentClass.push(cl)
        assert cl != null
        var separator := ""
        for f in compiler.instanceFields(cl) {
            compiler.resolve(f)
            code.append("\{separator}\{type(f.type)}")
            separator := ", "
        }
        if t = Type.Class() {
            code.append(", %$itable*, [0 x i8*]")
        }
        code.append(" }")
        types.printLine(code)
        if compiler.isValue(cl) {
            getWrapperClassConstant(cl)
        }
        compiler.currentClass.pop()
    }

    method writeWrapperType(t:Type) {
        if writtenWrappers.contains(t.name) {
            return
        }
        writtenWrappers.add(t.name)
        def code := MutableString("\{type(t)}$wrapper = type { ")
        def object := compiler.getClass(Type.Object())
        assert object != null
        var separator := ""
        for f in compiler.instanceFields(object) {
            compiler.resolve(f)
            code.append("\{separator}\{type(f.type)}")
            separator := ", "
        }
        code.append(", \{type(t)}")
        code.append(" }")
        types.printLine(code)
        types.printLine("\{type(t)}$nullable = type { \{type(t)}, i1 }")
    }

    function typeName(t:Type):String {
        return "%" + escapeName(t.name)
    }

    method wrapperTypeName(t:Type):String {
        if t.typeKind = Type.Kind.NULLABLE {
            return wrapperTypeName(t.subtypes[0])
        }
        writeWrapperType(t)
        return "%\{escapeName(t.name)}$wrapper"
    }

    method wrapperType(t:Type):String {
        return wrapperTypeName(t) + "*"
    }

    method wrapperType(m:MethodDecl):String {
        def inheritedType := compiler.inheritedType(m)
        def result := MutableString()
        result.append(type(inheritedType.subtypes[inheritedType.subtypes.get_count() - 1]))
        result.append("(")
        assert m.isInstance()
        result.append("%\{escapeName(m.owner.name)}")
        if compiler.isValue(m.owner) {
            result.append("$wrapper")
        }
        result.append("*")
        for i in 0 .. inheritedType.subtypes.get_count() - 1 { 
            result.append(", ")
            result.append(type(inheritedType.subtypes[i]))
        }
        result.append(")*")
        return result.convert()
    }

    method nullableType(t:Type):String {
        assert t.typeKind = Type.Kind.NULLABLE, "\{t} is not nullable"
        writeWrapperType(t.subtypes[0])
        return "\{type(t.subtypes[0])}$nullable"
    }

    method getITable(cl:ClassDecl):String {
        def interfaces := compiler.allInterfaces(cl.type())
        var previous := "%$itable* null"
        for intfType in interfaces {
            def intf := compiler.getClass(intfType)
            def intfCC := getClassConstant(intf)
            def methods := compiler.interfaceMethods(cl, intfType)
            def name := "@\{escapeName(cl.name)}$.\{escapeName(intf.name)}"
            def t := "{\{type(Type.Class())}, %$itable*, [\{methods.get_count()} x i8*] }"
            def result := MutableString("\{name} = constant \{t} { \{type(Type.Class())} " +
                    "bitcast(\{intfCC.type}* \{intfCC.name} to \{type(Type.Class())}), " +
                    "\{previous}, [\{methods.get_count()} x i8*][")
            var separator := ""
            for m in methods {
                result.append(separator)
                separator := ", "
                if m.annotations.isAbstract() {
                    result.append("i8* null")
                }
                else {
                    def entry := getMethodTableEntry(m)
                    result.append("i8* bitcast(\{entry.second} \{entry.first} to i8*)")
                }
            }
            result.append("] }\n")
            types.printLine(result)
            previous := "%$itable* bitcast(\{t}* \{name} to %$itable*)"
        }
        return previous
    }

    method createMethodShim(raw:MethodDecl, effective:Type, rawOut:OutputStream):MethodShim {
        def outBuffer := MemoryOutputStream()
        def out := IndentedOutputStream(outBuffer)
        def found := methodShims[raw]
        if found != null {
            return found
        }
        assert effective.isMethod()
        assert effective.subtypes.get_count() = raw.parameters.get_count() + 1
        assert raw.isInstance()
        def oldVarCount := varCount
        varCount := 0
        def effectiveReturnType := effective.subtypes[effective.subtypes.get_count() - 1]
        def resultName := getName(raw) + "$shim"
        def resultType := MutableString(type(effectiveReturnType))
        out.print("define \{resultType} \{resultName}(")
        def self_t := selfType(raw)
        out.print("\{self_t} %self")
        resultType.append("(")
        resultType.append(self_t)
        for i in 0 .. raw.parameters.get_count() {
            def pType := type(effective.subtypes[i])
            resultType.append(", ")
            resultType.append(pType)
            out.print(", \{pType} %p\{i}")
        }
        out.printLine(") {")
        resultType.append(")*")
        def casts := Array<String>()
        for i in 0 .. raw.parameters.get_count() {
            def p := "%p\{i}"
            if raw.parameters[i].type != effective.subtypes[i] {
                casts.add(getCastReference(p, effective.subtypes[i],
                        raw.parameters[i].type, out))
            }
            else {
                casts.add(p)
            }
        }
        def returnValue:String
        if raw.returnType != Type.Void() {
            returnValue := nextVar()
            out.print("\{returnValue} = ")
        }
        else {
            returnValue := "void"
        }
        out.print("call \{type(raw.returnType)} \{getName(raw)}(" +
                "\{self_t} %self")
        for i in 0 .. raw.parameters.get_count() {
            out.print(", \{type(raw.parameters[i].type)} \{casts[i]}")
        }
        out.printLine(")")
        if raw.returnType != Type.Void() {
            returnValue := type(effectiveReturnType) + " " +
                    getCastReference(returnValue, raw.returnType, effectiveReturnType, out)
        }
        out.printLine("ret \{returnValue}")
        out.printLine("}")
        varCount := oldVarCount
        def result := MethodShim(resultName, resultType.convert())
        methodShims[raw] := result
        rawOut.print(outBuffer)
        return result
    }

    method createWrapperShim(m:MethodDecl, out:IndentedOutputStream):String {
        assert m.isInstance()
        def oldVarCount := varCount
        varCount := 0
        def result := "\{getName(m)}$wrappershim"
        def selfType := "%\{escapeName(m.owner.name)}$wrapper*"
        out.print("define ccc \{type(m.returnType)} \{result}(\{selfType} %actualSelf")
        def actualMethodType := compiler.declaredType(m)
        def inheritedMethodType := compiler.inheritedType(m)
        for i in 0 .. m.parameters.get_count() {
            out.print(", \{type(inheritedMethodType.subtypes[i])} %\{m.parameters[i].name}")
        }
        out.printLine(") {")
        out.level += 1
        out.printLine("%self = bitcast \{selfType} %actualSelf to %panda$core$Object*")
        def parameters := Array<String>()
        for i in 0 .. m.parameters.get_count() {
            parameters.add(getCastReference("%" + m.parameters[i].name,
                    inheritedMethodType.subtypes[i], actualMethodType.subtypes[i], out))
        }
        def children := Array<IRNode>()
        children.add(IRNode(IRNode.Kind.SELF, -1, Type.Object()))
        def unwrapped := getTypedReference(IRNode(IRNode.Kind.CAST, -1, m.owner.type(), children),
                out)
        def returnValue:String
        if m.returnType != Type.Void() {
            returnValue := nextVar()
            out.print("\{returnValue} = ")
            returnValue := "\{type(m.returnType)} \{returnValue}"
        }
        else {
            returnValue := "void"
        }
        out.print("call \{type(m.returnType)} \{getName(m)}(\{unwrapped}")
        for i in 0 .. m.parameters.get_count() {
            out.print(", \{type(actualMethodType.subtypes[i])} \{parameters[i]}")
        }
        out.printLine(")")
        out.printLine("ret \{returnValue}")
        out.level -= 1
        out.printLine("}")
        varCount := oldVarCount
        return result
    }

    method getWrapperITable(cl:ClassDecl):String {
        def interfaces := compiler.allInterfaces(cl.type())
        var previous := "%$itable* null"
        for intfType in interfaces {
            def intf := compiler.getClass(intfType)
            def intfCC := getClassConstant(intf)
            def methods := compiler.interfaceMethods(cl, intfType)
            def name := "@\{escapeName(cl.name)}$wrapper.\{escapeName(intf.name)}"
            def t := "{\{type(Type.Class())}, %$itable*, [\{methods.get_count()} x i8*] }"
            def result := MutableString("\{name} = constant \{t} { \{type(Type.Class())} " +
                    "bitcast(\{intfCC.type}* \{intfCC.name} to \{type(Type.Class())}), " +
                    "\{previous}, [\{methods.get_count()} x i8*][")
            var separator := ""
            for m in methods {
                result.append(separator)
                separator := ", "
                if m.annotations.isAbstract() {
                    result.append("i8* null")
                }
                else {
                    def shim := createWrapperShim(m, wrapperShims)
                    result.append("i8* bitcast(\{wrapperType(m)} \{shim} to i8*)")
                }
            }
            result.append("] }\n")
            types.printLine(result)
            previous := "%$itable* bitcast(\{t}* \{name} to %$itable*)"
        }
        return previous
    }

    -- FIXME use tuple
    class Pair<A, B> {
        def first:A
        def second:B

        init(first:A, second:B) {
            self.first := first
            self.second := second
        }
    }

    ================================================================================================
    Returns true if this is an external method returning a struct.

    Returning structs from C functions into LLVM code is tricky. I tried it the naive and obvious
    way, and found it didn't work. Some cursory research indicated that C functions that return
    structs are at least sometimes compiled to accept a special pointer ("sret") as an extra
    parameter, and the caller is expected to know to alloca space for the return value and pass in a
    pointer to it.

    Since online sources were complaining about how poorly documented this is, there were
    indications that there may be multiple struct return strategies depending on the nature of
    the struct, people were suggesting looking at the assembly code generated by Clang to figure
    out how one was supposed to call a given function, and this all varies from platform to
    platform, we avoid the whole mess by making it explicit. External functions which wish to
    return structs explicitly receive a pointer to the result structure as their first parameter.
    ================================================================================================
    function needsStructIndirection(m:MethodDecl):Bit {
        if !m.returnType.isClass() {
            return false
        }
        def result := m.annotations.isExternal() & m.returnType.isClass() &
                compiler.isValue(compiler.getClass(m.returnType))
        -- if an external method requires struct indirection, it will have a different signature
        -- than a non-external method; this means this feature doesn't play nice with overriding. We
        -- can fix this down the road with shims, but for right now just assert that a method
        -- requiring struct indirection is not an override and cannot be overridden
        assert !result | (!m.annotations.isOverride() & (m.annotations.isFinal() |
                m.annotations.isClass())), "invalid struct indirection on \{m.signature()}"
        return result
    }

    method getMethodTableEntry(m:MethodDecl):Pair<String, String> -* name, type *- {
        compiler.resolve(m)
        if m.owner.external {
            writeDeclaration(m)
        }
        def resultName:String
        def declared := compiler.declaredTypeWithSelf(m, m.owner.type())
        def inherited := compiler.inheritedTypeWithSelf(m)
        if declared != inherited {
            def shim := createMethodShim(m, compiler.inheritedType(m), shims)
            resultName := shim.name
        }
        else {
            resultName := getName(m)
        }
        if needsStructIndirection(m) {
            def resultType := MutableString("void (")
            resultType.append(type(inherited.subtypes[inherited.subtypes.get_count() - 1]))
            resultType.append("*")
            for i in 0 .. inherited.subtypes.get_count() - 1 {
                resultType.append(", ")
                resultType.append(type(inherited.subtypes[i]))
            }
            resultType.append(")*")
            return Pair<String, String>(resultName, resultType.convert())
        }
        return Pair<String, String>(resultName, type(inherited))
    }

    method getClassConstant(cl:ClassDecl):ClassConstant {
        var result := classConstants[cl.name]
        if result = null {
            compiler.resolve(cl)
            def type:String
            if cl.external {
                result := ClassConstant("@\{escapeName(cl.type().name)}$class",
                        "%panda$core$Class")
                classConstants[cl.name] := result
                types.printLine("\{result.name} = external global \{result.type}")
                return classConstants[cl.name]
            }
            def vtable := compiler.getVTable(cl)
            result := ClassConstant("@\{escapeName(cl.type().name)}$class",
                    "{ i8*, \{INT_TYPE}, %$itable*, [\{vtable.get_count()} x i8*] }")
            classConstants[cl.name] := result
            def superPtr:String
            if cl.rawSuper != null {
                def superCC := getClassConstant(compiler.getClass(cl.rawSuper))
                superPtr := "bitcast(\{superCC.type}* \{superCC.name} to i8*)"
            }
            else {
                superPtr := "null"
            }
            def code := MutableString("\{result.name} = constant \{result.type} { " +
                    "i8* \{superPtr}, \{INT_TYPE} 1, \{getITable(cl)}, " +
                    "[\{vtable.get_count()} x i8*] [")
            var separator := ""
            for m in vtable {
                code.append(separator)
                if m.annotations.isAbstract() {
                    code.append("i8* null")
                }
                else {
                    def entry := getMethodTableEntry(m)
                    code.append("i8* bitcast(\{entry.second} \{entry.first} to i8*)")
                }
                separator := ", "
            }
            code.append("] }\n")
            types.printLine(code)
        }
        return result
    }

    method getWrapperClassConstant(cl:ClassDecl):ClassConstant {
        def name := "@\{escapeName(cl.name)}$wrapperclass"
        var result := classConstants[name]
        if result = null {
            if cl.external {
                type(Type.Class())
                def type := "%panda$core$Class"
                types.printLine("\{name} = external global \{type}")
                result := ClassConstant(name, type)
            }
            else {
                def value := compiler.getClass(Type.Value())
                def valueVTable := compiler.getVTable(value)
                result := ClassConstant("@\{escapeName(cl.name)}$wrapperclass",
                        "{ i8*, \{INT_TYPE}, %$itable*, [\{valueVTable.get_count()} x i8*] }")
                def vtable := compiler.getVTable(cl)
                def superCC := getClassConstant(compiler.getClass(cl.rawSuper))
                def superCast := "bitcast(\{superCC.type}* \{superCC.name} to i8*)"
                def itable := getWrapperITable(cl)
                def code := MutableString("\{result.name} = constant \{result.type} { i8* " +
                        "\{superCast}, \{INT_TYPE} 1, \{itable}, [\{valueVTable.get_count()} x " +
                        "i8*] [")
                var separator := ""
                for i in 0 .. valueVTable.get_count() {
                    def m := vtable[i]
                    def methodName:String
                    if m.owner == cl {
                        methodName := createWrapperShim(m, wrapperShims)
                    }
                    else {
                        methodName := getName(m)
                        if m.owner.external {
                            writeDeclaration(m)
                        }
                    }
                    code.append("\{separator}i8* bitcast(\{wrapperType(m)} \{methodName} to i8*)")
                    separator := ", "
                }
                code.append("] }")
                types.print(code)
            }
            classConstants[name] := result
        }
        return result
    }

    function getName(v:Variable):String {
        if v.storage = Variable.Storage.PARAMETER {
            if inlineContext.get_count() > 0 {
                for i in 0 .. currentMethod.parameters.get_count() {
                    if v.name == currentMethod.parameters[i].name {
                        return inlineContext.peek().argRefs[i]
                    }
                }
                assert false
            }
            return "%\{v.name}"
        }
        var result := variableNames[v]
        if result = null {
            labelCount += 1
            result := "%\{v.name}\{labelCount}"
            variableNames[v] := result
        }
        if inlineContext.get_count() > 0 {
            result += inlineContext.peek().varSuffix
        }
        return result
    }

    function getName(f:FieldDecl):String {
        assert f.annotations.isClass()
        return "@\{escapeName(f.owner.name)}$\{f.name}"
    }

    class OpClass {
        constant SIGNED   := 10121
        constant UNSIGNED := 10122
        constant FLOAT    := 10123
    }

    function opClass(t:Type):Int {
        match t.typeKind {
            when Type.Kind.BUILTIN_INT:
                return OpClass.SIGNED
            when Type.Kind.BUILTIN_UINT, Type.Kind.BUILTIN_BIT:
                return OpClass.UNSIGNED
            when Type.Kind.BUILTIN_FLOAT:
                return OpClass.FLOAT
            otherwise:
                assert false
        }
    }

    method getAndReference(left:IRNode, right:IRNode, out:IndentedOutputStream):String {
        var leftRef := getReference(left, out)
        if left.type = Type.Bit() {
            def leftField := nextVar()
            out.printLine("\{leftField} = extractvalue %panda$core$Bit \{leftRef}, 0")
            leftRef := leftField
        }
        def start := currentBlock
        def ifTrue := nextLabel()
        def ifFalse := nextLabel()
        out.printLine("br i1 \{leftRef}, label %\{ifTrue}, label %\{ifFalse}")
        createBlock(ifTrue, out)
        def rightRef := getReference(right, out)
        if right.type = Type.Bit() {
            def rightField := nextVar()
            out.printLine("\{rightField} = extractvalue %panda$core$Bit \{rightRef}, 0")
            rightRef := rightField
        }
        def truePred := currentBlock
        out.printLine("br label %\{ifFalse}")
        createBlock(ifFalse, out)
        def result := nextVar()
        out.printLine("\{result} = phi i1 [0, %\{start}], [\{rightRef}, %\{truePred}]")
        return result
    }

    method getOrReference(left:IRNode, right:IRNode, out:IndentedOutputStream):String {
        var leftRef := getReference(left, out)
        if left.type = Type.Bit() {
            def leftField := nextVar()
            out.printLine("\{leftField} = extractvalue %panda$core$Bit \{leftRef}, 0")
            leftRef := leftField
        }
        def start := currentBlock
        def ifTrue := nextLabel()
        def ifFalse := nextLabel()
        out.printLine("br i1 \{leftRef}, label %\{ifTrue}, label %\{ifFalse}")
        createBlock(ifFalse, out)
        def rightRef := getReference(right, out)
        if right.type = Type.Bit() {
            def rightField := nextVar()
            out.printLine("\{rightField} = extractvalue %panda$core$Bit \{rightRef}, 0")
            rightRef := rightField
        }
        def falsePred := currentBlock
        out.printLine("br label %\{ifTrue}")
        createBlock(ifTrue, out)
        def result := nextVar()
        out.printLine("\{result} = phi i1 [1, %\{start}], [\{rightRef}, %\{falsePred}]")
        return result
    }

    method getBinaryReference(cl:Int, leftRef:String, op:Int, rightRef:String,
            out:IndentedOutputStream):String {
        def llvmOp:String
        match cl {
            when OpClass.SIGNED:
                match op {
                    when Token.Kind.ADD:        llvmOp := "add"
                    when Token.Kind.SUB:        llvmOp := "sub"
                    when Token.Kind.MUL:        llvmOp := "mul"
                    when Token.Kind.INTDIV:     llvmOp := "sdiv"
                    when Token.Kind.REM:        llvmOp := "srem"
                    when Token.Kind.SHIFTLEFT:  llvmOp := "shl"
                    when Token.Kind.SHIFTRIGHT: llvmOp := "ashr"
                    when Token.Kind.BITWISEAND: llvmOp := "and"
                    when Token.Kind.BITWISEOR:  llvmOp := "or"
                    when Token.Kind.XOR, Token.Kind.BITWISEXOR: 
                                                llvmOp := "xor"
                    when Token.Kind.EQ:         llvmOp := "icmp eq"
                    when Token.Kind.NEQ:        llvmOp := "icmp ne"
                    when Token.Kind.GT:         llvmOp := "icmp sgt"
                    when Token.Kind.LT:         llvmOp := "icmp slt"
                    when Token.Kind.GTEQ:       llvmOp := "icmp sge"
                    when Token.Kind.LTEQ:       llvmOp := "icmp sle"
                    otherwise:
                        assert false
                }
            when OpClass.UNSIGNED:
                match op {
                    when Token.Kind.ADD:        llvmOp := "add"
                    when Token.Kind.SUB:        llvmOp := "sub"
                    when Token.Kind.MUL:        llvmOp := "mul"
                    when Token.Kind.INTDIV:     llvmOp := "udiv"
                    when Token.Kind.REM:        llvmOp := "urem"
                    when Token.Kind.SHIFTLEFT:  llvmOp := "shl"
                    when Token.Kind.SHIFTRIGHT: llvmOp := "lshr"
                    when Token.Kind.BITWISEAND: llvmOp := "and"
                    when Token.Kind.BITWISEOR:  llvmOp := "or"
                    when Token.Kind.XOR, Token.Kind.BITWISEXOR: 
                                                llvmOp := "xor"
                    when Token.Kind.EQ:         llvmOp := "icmp eq"
                    when Token.Kind.NEQ:        llvmOp := "icmp ne"
                    when Token.Kind.GT:         llvmOp := "icmp ugt"
                    when Token.Kind.LT:         llvmOp := "icmp ult"
                    when Token.Kind.GTEQ:       llvmOp := "icmp uge"
                    when Token.Kind.LTEQ:       llvmOp := "icmp ule"
                    otherwise:
                        assert false
                }
            when OpClass.FLOAT:
                match op {
                    when Token.Kind.ADD:        llvmOp := "fadd"
                    when Token.Kind.SUB:        llvmOp := "fsub"
                    when Token.Kind.MUL:        llvmOp := "fmul"
                    when Token.Kind.INTDIV:     llvmOp := "fdiv"
                    when Token.Kind.EQ:         llvmOp := "fcmp oeq"
                    when Token.Kind.NEQ:        llvmOp := "fcmp one"
                    when Token.Kind.GT:         llvmOp := "fcmp ogt"
                    when Token.Kind.LT:         llvmOp := "fcmp olt"
                    when Token.Kind.GTEQ:       llvmOp := "fcmp oge"
                    when Token.Kind.LTEQ:       llvmOp := "fcmp ole"
                    otherwise:
                        assert false
                }
        }
        def result := nextVar()
        out.printLine("\{result} = \{llvmOp} \{leftRef}, \{rightRef}")
        return result
    }

    method getIdentityReference(left:IRNode, right:IRNode, out:IndentedOutputStream):String {
        def leftRef := getTypedReference(left, out)
        def rightRef := getReference(right, out)
        def raw := nextVar()
        out.printLine("\{raw} = icmp eq \{leftRef}, \{rightRef}")
        def result := nextVar()
        out.printLine("\{result} = insertvalue %panda$core$Bit { i1 undef }, i1 \{raw}, 0")
        return result
    }

    method getNIdentityReference(left:IRNode, right:IRNode, out:IndentedOutputStream):String {
        def leftRef := getTypedReference(left, out)
        def rightRef := getReference(right, out)
        def raw := nextVar()
        out.printLine("\{raw} = icmp ne \{leftRef}, \{rightRef}")
        def result := nextVar()
        out.printLine("\{result} = insertvalue %panda$core$Bit { i1 undef }, i1 \{raw}, 0")
        return result
    }

    method getBinaryReference(left:IRNode, op:Int, right:IRNode, out:IndentedOutputStream):String {
        assert left.type = right.type
        match op {
            when Token.Kind.AND:       return getAndReference(left, right, out)
            when Token.Kind.OR:        return getOrReference(left, right, out)
            when Token.Kind.IDENTITY:  return getIdentityReference(left, right, out)
            when Token.Kind.NIDENTITY: return getNIdentityReference(left, right, out)
            otherwise:
                def leftRef := getTypedReference(left, out)
                def rightRef := getReference(right, out)
                return getBinaryReference(opClass(left.type), leftRef, op, rightRef, out)
        }
    }

    method getBinaryReference(b:IRNode, out:IndentedOutputStream):String {
        assert b.kind = IRNode.Kind.BINARY
        assert b.children.get_count() = 2
        return getBinaryReference(b.children[0], b.payload->Int, b.children[1], out)
    }

    method getVirtualMethodReference(target:String, m:MethodDecl, out:IndentedOutputStream):String {
        def cc := getClassConstant(m.owner)
        var index := -1
        def vtable := compiler.getVTable(m.owner)
        for i in 0 .. vtable.get_count() {
            if vtable[i]->MethodDecl == m { -- FIXME unnecessary cast
                index := i
                break
            }
        }
        assert index != -1
        def classPtrPtr := nextVar()
        out.printLine("\{classPtrPtr} = getelementptr inbounds \{typeName(m.owner.type())}, " +
                "\{target}, i64 0, i32 0")
        def classPtr := nextVar()
        out.printLine("\{classPtr} = load %panda$core$Class*, %panda$core$Class** \{classPtrPtr}")
        def cast := nextVar()
        out.printLine("\{cast} = bitcast %panda$core$Class* \{classPtr} to \{cc.type}*")
        def ptr := nextVar()
        out.printLine("\{ptr} = getelementptr inbounds \{cc.type}, \{cc.type}* \{cast}, i64 0, " +
                "i32 \{VTABLE_INDEX}, i64 \{index}")
        def load := nextVar()
        out.printLine("\{load} = load i8*, i8** \{ptr}")
        def result := nextVar()
        out.printLine("\{result} = bitcast i8* \{load} to " +
                type(compiler.inheritedTypeWithSelf(m)))
        return result
    }

    method getInterfaceMethodReference(target:String, m:MethodDecl,
            out:IndentedOutputStream):String {
        def methodType := type(compiler.inheritedTypeWithSelf(m))
        -- load class constant entry
        def entry := nextLabel()
        out.printLine("br label %\{entry}")
        createBlock(entry, out)
        def classPointer := nextVar()
        out.printLine("\{classPointer} = getelementptr inbounds \{typeName(m.owner.type())}, " +
                "\{target}, \{SIZE_TYPE} 0, i32 \{CLASS_POINTER_INDEX}")
        def loadedClass := nextVar()
        def classType := typeName(Type.Class())
        out.printLine("\{loadedClass} = load \{classType}*, \{classType}** \{classPointer}")
        def itableFirst := nextVar()
        out.printLine("\{itableFirst} = getelementptr inbounds \{classType}, \{classType}* " +
                "\{loadedClass}, \{SIZE_TYPE} 0, i32 \{ITABLE_INDEX}")
        def next := nextLabel()
        out.printLine("br label %\{next}")
        def leavingEntryLabel := currentBlock
        createBlock(next, out)
        labelCount += 1
        def itableNext := "%$itable\{labelCount}"
        def itablePtrPtr := nextVar()
        def fail := nextLabel()
        out.printLine("\{itablePtrPtr} = phi %$itable** [ \{itableFirst}, %\{leavingEntryLabel}]," +
                " [ \{itableNext}, %\{fail} ]")
        def itablePtr := nextVar()
        out.printLine("\{itablePtr} = load %$itable*, %$itable** \{itablePtrPtr}")
        def itableClassPtr := nextVar()
        out.printLine("\{itableClassPtr} = getelementptr inbounds %$itable, %$itable* " +
                "\{itablePtr}, \{SIZE_TYPE} 0, i32 0")
        def itableClass := nextVar()
        out.printLine("\{itableClass} = load \{classType}*, \{classType}** \{itableClassPtr}")
        def test := nextVar()
        def intfCC := getClassConstant(m.owner)
        out.printLine("\{test} = icmp eq \{classType}* bitcast(\{intfCC.type}* \{intfCC.name} to " +
                "\{classType}*), \{itableClass}")
        def success := nextLabel()
        out.printLine("br i1 \{test}, label %\{success}, label %\{fail}")

        createBlock(fail, out)
        out.printLine("\{itableNext} = getelementptr inbounds %$itable, %$itable* \{itablePtr}, " +
                "\{SIZE_TYPE} 0, i32 1")
        out.printLine("br label %\{next}")

        createBlock(success, out)
        var index := -1
        def vtable := compiler.getVTable(m.owner)
        for i in 0 .. vtable.get_count() {
            if vtable[i]->MethodDecl == m { -- FIXME unnecessary cast
                index := i
                break
            }
        }
        index -= compiler.getVTable(compiler.getClass(Type.Object())).get_count()
        assert index != -1
        def methodPtrPtr := nextVar()
        out.printLine("\{methodPtrPtr} = getelementptr inbounds %$itable, %$itable* " +
                "\{itablePtr}, \{SIZE_TYPE} 0, i32 2, i32 \{index}")
        def cast := nextVar()
        out.printLine("\{cast} = bitcast i8** \{methodPtrPtr} to \{methodType}*")
        def methodPtr := nextVar()
        out.printLine("\{methodPtr} = load \{methodType}, \{methodType}* \{cast}")
        return methodPtr
    }

    method getMethodReference(target:String?, m:MethodDecl, isSuper:Bit,
            out:IndentedOutputStream):String {
        if !isSuper & m.isVirtual() {
            assert target != null, "calling instance \{m.signature()} without a target"
            if m.owner.classKind = ClassDecl.Kind.INTERFACE {
                return getInterfaceMethodReference(target, m, out)
            }
            else {
                return getVirtualMethodReference(target, m, out)
            }
        }
        else {
            if m.owner.external {
                writeDeclaration(m)
            }
            return getName(m)
        }
    }

    method getPointerCallReference(call:IRNode, out:IndentedOutputStream):String {
        def m := call.payload->MethodRef
        match m.value.name {
            when "alloc":
                assert call.children.get_count() = 1
                def countStruct := getTypedReference(call.children[0], out)
                def count := nextVar()
                out.printLine("\{count} = extractvalue \{countStruct}, 0")
                def size := nextVar()
                def elementSize := sizeOf(m.returnType().subtypes[1])
                assert elementSize > 0, "invalid size for type \{m.returnType().subtypes[1]}"
                out.printLine("\{size} = mul \{SIZE_TYPE} \{count}, \{elementSize}")
                def malloc := nextVar()
                out.printLine("\{malloc} = call i8* @malloc(\{SIZE_TYPE} \{size})")
                def result := nextVar()
                out.printLine("\{result} = bitcast i8* \{malloc} to \{type(m.returnType())}")
                return result
            when "get":
                assert call.children.get_count() = 1
                def ptr := getTypedReference(call.children[0], out)
                def baseType := type(m.returnType())
                def ptrType := baseType + "*"
                def cast := nextVar()
                out.printLine("\{cast} = bitcast \{ptr} to \{ptrType}")
                def load := nextVar()
                out.printLine("\{load} = load \{baseType}, \{ptrType} \{cast}")
                return load
            when "[]":
                assert call.children.get_count() = 2
                def ptr := getTypedReference(call.children[0], out)
                def baseType := type(m.returnType())
                def ptrType := baseType + "*"
                def cast := nextVar()
                out.printLine("\{cast} = bitcast \{ptr} to \{ptrType}")
                def indexStruct := getTypedReference(call.children[1], out)
                def index := nextVar()
                out.printLine("\{index} = extractvalue \{indexStruct}, 0")
                def offsetPtr := nextVar()
                out.printLine("\{offsetPtr} = getelementptr \{baseType}, \{ptrType} \{cast}, " +
                        "i64 \{index}")
                def load := nextVar()
                out.printLine("\{load} = load \{baseType}, \{ptrType} \{offsetPtr}")
                return load
            when "realloc":
                assert call.children.get_count() = 2
                def ptr := getTypedReference(call.children[0], out)
                def ptrCast := nextVar()
                out.printLine("\{ptrCast} = bitcast \{ptr} to i8*")
                def countStruct := getTypedReference(call.children[1], out)
                def count := nextVar()
                out.printLine("\{count} = extractvalue \{countStruct}, 0")
                def size := nextVar()
                out.printLine("\{size} = mul \{SIZE_TYPE} \{count}, " +
                        sizeOf(m.returnType().subtypes[1]))
                def realloc := nextVar()
                out.printLine("\{realloc} = call i8* @realloc(i8* \{ptrCast}, \{SIZE_TYPE} " +
                        "\{size})")
                def result := nextVar()
                out.printLine("\{result} = bitcast i8* \{realloc} to \{type(m.returnType())}")
                return result
            otherwise:
                assert false
        }
    }

    method getInlineCallReference(call:IRNode, body:IRNode, out:IndentedOutputStream):String {
        def m := (call.payload->MethodRef).value
        compiler.currentFile.push(m.owner.source)
        currentlyInlining[m] := m
        def selfRef := "<inline call self error>"
        def argStart:Int
        if m.isInstance() {
            argStart := 1
            selfRef := getReference(call.children[0], out)
        }
        else {
            argStart := 0
        }
        def args := Array<String>()
        for i in argStart .. call.children.get_count() {
            args.add(getReference(call.children[i], out))
        }
        def end := nextLabel()
        def inline := InlineContext("$inline\{varCount}", selfRef, args, end)
        inlineContext.push(inline)
        def old := currentMethod
        currentMethod := m
        writeBlock(body, out)
        currentMethod := old
        inlineContext.pop()
        if !endsWithBranch(body) {
            out.printLine("unreachable")
        }
        createBlock(end, out)
        currentlyInlining.remove(m)
        compiler.currentFile.pop()
        if inline.returns.get_count() = 1 {
            return inline.returns[0].second
        }
        def phi := nextVar()
        out.print("\{phi} = phi \{type(m.returnType)} ")
        var separator := ""
        for ret in inline.returns {
            out.print("\{separator}[\{ret.second}, %\{ret.first}]")
            separator := ", "
        }
        out.printLine()
        return phi
    }

    method getCallReference(call:IRNode, out:IndentedOutputStream):String {
        assert call.kind = IRNode.Kind.CALL
        def m := (call.payload->MethodRef).value
        if m.owner.name = "panda.unsafe.Pointer" {
            return getPointerCallReference(call, out)
        }
        if m.owner.external {
            writeDeclaration(m)
        }
        if m.owner.name = "panda.core.Bit" {
            if m.name = "&" {
                assert call.children.get_count() = 2
                def bit := getAndReference(call.children[0], call.children[1], out)
                def result := nextVar()
                out.printLine("\{result} = insertvalue %panda$core$Bit { i1 undef }, i1 " +
                        "\{bit}, 0")
                return result
            }
            if m.name = "|" {
                assert call.children.get_count() = 2
                def bit := getOrReference(call.children[0], call.children[1], out)
                def result := nextVar()
                out.printLine("\{result} = insertvalue %panda$core$Bit { i1 undef }, i1 " +
                        "\{bit}, 0")
                return result
            }
        }
        if m.annotations.isInline() & currentlyInlining[m] = null {
            def block := compiler.compileBody(m)
            if block != null {
                return getInlineCallReference(call, block, out)
            }
            return "<error>"
        }
        def args := Array<String>(call.children.get_count())
        def actualMethodType:Type
        def actualResultType:String
        def isSuper := call.children.get_count() >= 1 & call.children[0].kind = IRNode.Kind.SUPER
        if !isSuper & m.isVirtual() {
            actualMethodType := compiler.inheritedType(m)
            actualResultType := type(actualMethodType.subtypes[actualMethodType.subtypes.get_count() - 1])
        }
        else {
            actualMethodType := compiler.declaredType(m)
            actualResultType := type(call.type)
        }
        def offset := call.children.get_count() - actualMethodType.subtypes.get_count() + 1
        for i in 0 .. call.children.get_count() {
            def arg := getReference(call.children[i], out)
            if i >= offset & actualMethodType.subtypes[i - offset] != call.children[i].type {
                arg := type(actualMethodType.subtypes[i - offset]) + " " +
                        getCastReference(arg, call.children[i].type,
                            actualMethodType.subtypes[i - offset], out)
            }
            else {
                arg := type(call.children[i].type) + " " + arg
            }
            args.add(arg)
        }
        def target:String?
        if args.get_count() > 0 {
            -- this isn't actually correct - args[0] could be the target of an instance method, or
            -- just the first parameter to a class method. But getMethodReference ignores target for
            -- class methods, so this works and is easier than doing it the right way.
            target := args[0]
        }
        else {
            target := null
        }
        def methodRef := getMethodReference(target, m, isSuper, out)
        def result:String
        def indirect := needsStructIndirection(m)
        if indirect {
            out.print("call void")
        }
        else {
            result := nextVar()
            out.print("\{result} = call \{actualResultType}")
        }
        out.print(" \{methodRef}(")
        var separator := ""
        def indirectVar:String
        if indirect {
            labelCount += 1
            indirectVar := "%$tmp" + labelCount
            methodHeader.printLine("\{indirectVar} = alloca \{actualResultType}")
            out.print("\{actualResultType}* \{indirectVar}")
            separator := ", "
        }
        for arg in args {
            out.print("\{separator}\{arg}")
            separator := ", "
        }
        out.printLine(")")
        if indirect {
            result := nextVar()
            out.printLine("\{result} = load \{actualResultType}, \{actualResultType}* " +
                        indirectVar)
        }
        if type(call.type) != actualResultType {
            return getCastReference(result, 
                        actualMethodType.subtypes[actualMethodType.subtypes.get_count() - 1],
                        call.type,
                        out)
        }
        return result
    }

    method wrapValue(value:String, srcType:Type, dstType:Type, out:IndentedOutputStream):String {
        def src := compiler.getClass(srcType)
        assert src != null
        if srcType.typeKind = Type.Kind.NULLABLE {
            -- casting nullable value to nullable wrapper, need to special-case null
            def testStart := currentBlock
            def isNonNull := nextVar()
            out.printLine("\{isNonNull} = extractvalue \{nullableType(srcType)} \{value}, 1")
            def nonNullLabel := nextLabel()
            def endLabel := nextLabel()
            out.printLine("br i1 \{isNonNull}, label %\{nonNullLabel}, label %\{endLabel}")
            createBlock(nonNullLabel, out)
            def unwrapped := toNonNullableValue(value, srcType, srcType.subtypes[0], out)
            def nonNullValue := wrapValue(unwrapped, srcType.subtypes[0], dstType, out)
            out.printLine("br label %\{endLabel}")
            createBlock(endLabel, out)
            def result := nextVar()
            out.printLine("\{result} = phi \{type(dstType)} [null, %\{testStart}], " +
                    "[\{nonNullValue}, %\{nonNullLabel}]")
            return result
        }
        def mallocRef := nextVar()
        out.printLine("\{mallocRef} = call i8* @malloc(i64 \{sizeOfWrapper(src.type())})")
        def wrapperTypeName := wrapperTypeName(src.type())
        def wrapperType := wrapperType(src.type())
        def wrapperCast := nextVar()
        out.printLine("\{wrapperCast} = bitcast i8* \{mallocRef} to \{wrapperType}")
        def classPtr := nextVar()
        out.printLine("\{classPtr} = getelementptr \{wrapperTypeName}, " +
                "\{wrapperType} \{wrapperCast}, i64 0, i32 0")
        def cc := getWrapperClassConstant(src)
        out.printLine("store %panda$core$Class* bitcast(\{cc.type}* \{cc.name} to " +
                "%panda$core$Class*), %panda$core$Class** \{classPtr}")
        def refCount := nextVar()
        out.printLine("\{refCount} = getelementptr \{wrapperTypeName}, " +
                "\{wrapperType} \{wrapperCast}, i64 0, i32 1, i32 0")
        out.printLine("store i32 0, i32* \{refCount}")
        def target := nextVar()
        out.printLine("\{target} = getelementptr \{wrapperTypeName}, " +
                "\{wrapperType} \{wrapperCast}, i64 0, i32 2")
        out.printLine("store \{type(srcType)} \{value}, \{type(srcType)}* \{target}")
        if wrapperType != type(dstType) {
            def result := nextVar()
            out.printLine("\{result} = bitcast \{wrapperType} \{wrapperCast} to \{type(dstType)}")
            return result
        }
        return wrapperCast
    }

    function isConstantNumber(expr:IRNode):Bit {
        return expr.kind = IRNode.Kind.CONSTRUCT & expr.type.isNumber() &
                expr.children[0].children[0].kind = IRNode.Kind.INT
    }

    method getFieldReference(fieldRef:IRNode, out:IndentedOutputStream):String {
        assert fieldRef.kind = IRNode.Kind.FIELD_REFERENCE
        assert fieldRef.children.get_count() = 1
        def field := fieldRef.payload->FieldDecl
        def t := type(field.type)
        if field.annotations.isClass() {
            assert field.value != null
            return getReference(field.value, out)
        }
        def cl := compiler.getClass(fieldRef.children[0].type)
        assert cl != null
        if compiler.isValue(cl) {
            def base := getReference(fieldRef.children[0], out)
            def fields := compiler.instanceFields(cl)
            def index:Int? := null
            for i in 0 .. fields.get_count() {
                if fields[i]->FieldDecl == field { -- FIXME unnecessary cast
                    index := i
                    break
                }
            }
            assert index != null
            def result := nextVar()
            out.printLine("\{result} = extractvalue \{type(fieldRef.children[0].type)} \{base}" +
                    ", \{index}")
            return result
        }
        def ptr := "\{t}* \{getLValue(fieldRef, out)}"
        def result := nextVar()
        out.printLine("\{result} = load \{t}, \{ptr}")
        return result
    }

    method unwrapValue(value:String, srcType:Type, dstType:Type, out:IndentedOutputStream):String {
        def target := compiler.getClass(dstType)
        assert target != null
        if dstType.typeKind = Type.Kind.NULLABLE {
            -- casting nullable wrapper to nullable value, need to special-case null
            def testStart := currentBlock
            def isNonNull := nextVar()
            out.printLine("\{isNonNull} = icmp ne \{type(srcType)} \{value}, null")
            def nonNullLabel := nextLabel()
            def endLabel := nextLabel()
            out.printLine("br i1 \{isNonNull}, label %\{nonNullLabel}, label %\{endLabel}")
            createBlock(nonNullLabel, out)
            def wrapped := unwrapValue(value, srcType, dstType.subtypes[0], out)
            def nonNullValue := toNullableValue(wrapped, dstType.subtypes[0], dstType, out)
            out.printLine("br label %\{endLabel}")
            createBlock(endLabel, out)
            def result := nextVar()
            out.printLine("\{result} = phi \{type(dstType)} " +
                    "[{ \{type(dstType.subtypes[0])} undef, i1 0 }, " +
                    "%\{testStart}], [\{nonNullValue}, %\{nonNullLabel}]")
            return result
        }
        def targetType := type(dstType)
        def wrapperTypeName := wrapperTypeName(dstType)
        def wrapperType := wrapperType(dstType)
        def srcCast := nextVar()
        out.printLine("\{srcCast} = bitcast \{type(srcType)} \{value} to \{wrapperType}")
        def load := nextVar()
        out.printLine("\{load} = load \{wrapperTypeName}, \{wrapperType} \{srcCast}")
        def result := nextVar()
        out.printLine("\{result} = extractvalue \{wrapperTypeName} \{load}, \{OBJECT_FIELD_COUNT}")
        return result
    }

    method toNullableValue(value:String, srcType:Type, dstType:Type,
            out:IndentedOutputStream):String {
        def nullableType := nullableType(dstType)
        def result := nextVar()
        out.printLine("\{result} = insertvalue \{nullableType} " +
                "{ \{type(srcType)} undef, i1 true }, \{type(srcType)} \{value}, 0")
        return result
    }

    method toNonNullableValue(value:String, srcType:Type, dstType:Type,
            out:IndentedOutputStream):String {
        def result := nextVar()
        out.printLine("\{result} = extractvalue \{type(srcType)} \{value}, 0")
        return result
    }

    method getCastReference(value:String, src:Type, target:Type, out:IndentedOutputStream):String {
        def op:String
        if target.isBuiltinNumber() {
            assert src.isBuiltinNumber()
            def size1 := sizeOf(src)
            def size2 := sizeOf(target)
            if size1 > size2 {
                op := "trunc"
            }
            else if size1 < size2 {
                if target.typeKind = Type.Kind.BUILTIN_INT {
                    op := "sext"
                }
                else {
                    op := "zext"
                }
            }
            else {
                return value
            }
        }
        else {
            def srcClass := compiler.getClass(src)
            assert srcClass != null
            def targetClass := compiler.getClass(target)
            assert targetClass != null
            if compiler.isValue(srcClass) & !compiler.isValue(targetClass) {
                return wrapValue(value, src, target, out)
            }
            else if !compiler.isValue(srcClass) & compiler.isValue(targetClass) {
                return unwrapValue(value, src, target, out)
            }
            else if compiler.isValue(srcClass) & target.typeKind = Type.Kind.NULLABLE &
                    target.subtypes[0] = src {
                return toNullableValue(value, src, target, out)
            }
            else if compiler.isValue(targetClass) & src.typeKind = Type.Kind.NULLABLE &
                    src.subtypes[0] = target {
                return toNonNullableValue(value, src, target, out)
            }
            op := "bitcast"
        }
        def srcType := type(src)
        def dstType := type(target)
        if srcType = dstType {
            return value
        }
        return "((\{dstType}) \{value})"
    }

    method getCastReference(cast:IRNode, out:IndentedOutputStream):String {
        assert cast.kind = IRNode.Kind.CAST
        assert cast.children.get_count() = 1
        def base := getReference(cast.children[0], out)
        return getCastReference(base, cast.children[0].type, cast.type, out)
    }

    method getConstructReference(construct:IRNode, out:IndentedOutputStream):String {
        assert construct.kind = IRNode.Kind.CONSTRUCT
        assert construct.children.get_count() >= 1
        def cl := compiler.getClass(construct.type)
        assert cl != null
        def t := type(construct.type)
        if construct.type.isNumber() {
            assert construct.children.get_count() = 1
            assert construct.children[0].children.get_count() = 1
            def value := getTypedReference(construct.children[0].children[0], out)
            if construct.children[0].children[0].kind = IRNode.Kind.INT {
                return "{ " + value + " }"
            }
            def result := nextVar()
            def lastField := cl.fields[cl.fields.get_count() - 1]
            assert !lastField.annotations.isClass()
            out.printLine("\{result} = insertvalue \{t} { \{type(lastField.type)} undef }, " +
                    "\{value}, 0\n")
            return result
        }
        if construct.type = Type.Bit() {
            assert construct.children.get_count() = 1
            assert construct.children[0].children.get_count() = 1
            def value := getTypedReference(construct.children[0].children[0], out)
            if construct.children[0].children[0].kind = IRNode.Kind.BIT {
                return "{ " + value + " }"
            }
            def result := nextVar()
            def lastField := cl.fields[cl.fields.get_count() - 1]
            assert !lastField.annotations.isClass()
            out.printLine("\{result} = insertvalue \{t} { \{type(lastField.type)} undef }, " +
                    "\{value}, 0\n")
            return result
        }
        if compiler.isValue(cl) {
            labelCount += 1
            def alloca := "%$tmp\{labelCount}"
            methodHeader.printLine("\{alloca} = alloca \{t}")
            writeCall(construct.children[0], "\{t}* \{alloca}", out)
            def result := nextVar()
            out.printLine("\{result} = load \{t}, \{t}* \{alloca}")
            return result
        }
        def callRef := nextVar()
        out.printLine("\{callRef} = call i8* @malloc(i64 \{sizeOf(construct.type)})")
        def result := nextVar()
        out.printLine("\{result} = bitcast i8* \{callRef} to \{type(construct.type)}")
        def classPtr := nextVar()
        def className:String
        if construct.type.typeKind = Type.Kind.GENERIC {
            className := typeName(construct.type.subtypes[0])
        }
        else {
            className := typeName(construct.type)
        }
        out.printLine("\{classPtr} = getelementptr inbounds \{className}, \{t} \{result}, i64 0, " +
                "i32 0")
        def cc := getClassConstant(cl)
        out.printLine("store %panda$core$Class* bitcast(\{cc.type}* \{cc.name} to " +
                "%panda$core$Class*), %panda$core$Class** \{classPtr}")
        writeCall(construct.children[0], "\{t} \{result}", out)
        return result
    }

    method getIntReference(int:IRNode, out:IndentedOutputStream):String {
        return (int.payload->Int).convert() -- FIXME parens
    }

    method getNegatedIntReference(int:IRNode, out:IndentedOutputStream):String {
        return "-" + (int.payload->Int).convert() -- FIXME parens
    }

    method getBitReference(bit:IRNode, out:IndentedOutputStream):String {
        if bit.payload->Bit {
            return "true"
        }
        return "false"
    }

    method getVariableReference(v:Variable, out:IndentedOutputStream):String {
        if v.storage = Variable.Storage.PARAMETER {
            return getName(v)
        }
        def result := nextVar()
        def t := type(v.type)
        out.printLine("\{result} = load \{t}, \{t}* \{getName(v)}")
        return result
    }

    method getStringReference(s:String, out:IndentedOutputStream):String {
        varCount += 1
        def result := "$s\{varCount}"
        out.print("panda$core$String \{result} = { &panda$core$String$class, 2, " +
                "(panda$core$Char8*) \"")
        for raw in s.utf8() {
            def c := raw.convert()->UInt8
            if c = 34 { -- FIXME char literal
                out.print("\"")
            }
            else if c < 32 | c > 126 {
                out.print("\\x")
                out.print("0123456789ABCDEF".utf8()[(c // 16).convert()])
                out.print("0123456789ABCDEF".utf8()[(c % 16).convert()])
            }
            else {
                out.print(raw)
            }
        }
        out.printLine("\", \{s.utf8().get_count()} };")
        return "&\{result}"
    }

    method getSelfReference(s:IRNode, out:IndentedOutputStream):String {
        return "self"
    }

    method getSuperReference(s:IRNode, out:IndentedOutputStream):String {
        def result := nextVar()
        out.printLine("\{result} = bitcast \{type(currentMethod.owner.type())} %self to " +
                type(s.type))
        return result
    }

    method getIsNullReference(test:IRNode, out:IndentedOutputStream):String {
        assert test.kind = IRNode.Kind.IS_NULL
        assert test.children.get_count() = 1
        def value := getTypedReference(test.children[0], out)
        def cl := compiler.getClass(test.children[0].type)
        def resultValue:String
        if compiler.isValue(cl) {
            if test.children[0].type.typeKind != Type.Kind.NULLABLE {
                return "{ i1 0 }"
            }
            def field := nextVar()
            out.printLine("\{field} = extractvalue \{value}, 1")
            resultValue := nextVar()
            out.printLine("\{resultValue} = xor i1 \{field}, -1")
        }
        else {
            resultValue := nextVar()
            out.printLine("\{resultValue} = icmp eq \{value}, null")
        }
        def result := nextVar()
        out.printLine("\{result} = insertvalue %panda$core$Bit { i1 undef }, i1 \{resultValue}, 0")
        return result
    }

    method getIsNonNullReference(test:IRNode, out:IndentedOutputStream):String {
        assert test.kind = IRNode.Kind.IS_NONNULL
        assert test.children.get_count() = 1
        def value := getTypedReference(test.children[0], out)
        def cl := compiler.getClass(test.children[0].type)
        def resultValue:String
        if compiler.isValue(cl) {
            if test.children[0].type.typeKind != Type.Kind.NULLABLE {
                return "{ i1 1 }"
            }
            resultValue := nextVar()
            out.printLine("\{resultValue} = extractvalue \{value}, 1")
        }
        else {
            resultValue := nextVar()
            out.printLine("\{resultValue} = icmp ne \{value}, null")
        }
        def result := nextVar()
        out.printLine("\{result} = insertvalue %panda$core$Bit { i1 undef }, i1 \{resultValue}, 0")
        return result
    }

    method getNullReference(expr:IRNode, out:IndentedOutputStream):String {
        assert expr.type.typeKind = Type.Kind.NULLABLE
        def cl := compiler.getClass(expr.type.subtypes[0])
        assert cl != null
        if compiler.isValue(cl) {
            return "{ \{type(expr.type.subtypes[0])} undef, i1 0 }"
        }
        else {
            return "null"
        }
    }

    method getPrefixReference(expr:IRNode, out:IndentedOutputStream):String {
        assert expr.kind = IRNode.Kind.PREFIX
        assert expr.children.get_count() = 1
        def base := getReference(expr.children[0], out)
        def result := nextVar()
        match (expr.payload->UInt64).convert()->Int64 {
            when Token.Kind.SUB:
                out.printLine("\{result} = sub \{type(expr.type)} 0, \{base}")
                return result
            when Token.Kind.NOT, Token.Kind.BITWISENOT:
                out.printLine("\{result} = xor \{type(expr.type)} -1, \{base}")
                return result
            otherwise:
                assert false, expr.convert()
        }
    }

    method getReference(expr:IRNode, out:IndentedOutputStream):String {
        match expr.kind {
            when IRNode.Kind.BINARY:
                return getBinaryReference(expr, out)
            when IRNode.Kind.CALL:
                return getCallReference(expr, out)
            when IRNode.Kind.CAST:
                return getCastReference(expr, out)
            when IRNode.Kind.INT:
                return getIntReference(expr, out)
            when IRNode.Kind.NEGATED_INT:
                return getNegatedIntReference(expr, out)
            when IRNode.Kind.BIT:
                return getBitReference(expr, out)
            when IRNode.Kind.CONSTRUCT:
                return getConstructReference(expr, out)
            when IRNode.Kind.VARIABLE_REFERENCE:
                return getVariableReference(expr.payload->Variable, out)
            when IRNode.Kind.FIELD_REFERENCE:
                return getFieldReference(expr, out)
            when IRNode.Kind.STRING:
                return getStringReference(expr.payload->String, out)
            when IRNode.Kind.SELF:
                return getSelfReference(expr, out)
            when IRNode.Kind.SUPER:
                return getSuperReference(expr, out)
            when IRNode.Kind.REUSED_VALUE_DEFINITION:
                def value := getReference(expr.children[0], out)
                reusedValues[expr.payload->UInt64] := value
                return value
            when IRNode.Kind.REUSED_VALUE:
                def result := reusedValues[expr.payload->UInt64]
                assert result != null
                return result
            when IRNode.Kind.NULL:
                return getNullReference(expr, out)
            when IRNode.Kind.IS_NULL:
                return getIsNullReference(expr, out)
            when IRNode.Kind.IS_NONNULL:
                return getIsNonNullReference(expr, out)
            when IRNode.Kind.PREFIX:
                return getPrefixReference(expr, out)
            otherwise:
                assert false, "unsupported expression \{expr}:\{compiler.position(expr.offset)}"
        }
    }

    method getTypedReference(expr:IRNode, out:IndentedOutputStream):String {
        return "\{type(expr.type)} \{getReference(expr, out)}"
    }

    method writeBlock(block:IRNode, out:IndentedOutputStream) {
        assert block.kind = IRNode.Kind.BLOCK
        out.level += 1
        for s in block.children {
            writeStatement(s, out)
        }
        out.level -= 1
    }

    method writePointerCall(stmt:IRNode, out:IndentedOutputStream) {
        def m := stmt.payload->MethodRef
        match m.value.name {
            when "set":
                assert stmt.children.get_count() = 2
                def ptr := getTypedReference(stmt.children[0], out)
                def arg := getTypedReference(compiler.unwrapCast(stmt.children[1]), out)
                out.printLine("store \{arg}, \{ptr}")
            when "[]:=":
                assert stmt.children.get_count() = 3
                assert compiler.unwrapCast(stmt.children[0]).type.subtypes.get_count() = 2
                def baseType := compiler.unwrapCast(stmt.children[0]).type.subtypes[1]
                def base := getTypedReference(stmt.children[0], out)
                def indexStruct := getTypedReference(stmt.children[1], out)
                def index := nextVar()
                out.printLine("\{index} = extractvalue \{indexStruct}, 0")
                def value := getTypedReference(compiler.unwrapCast(stmt.children[2]), out)
                def ptr := nextVar()
                out.printLine("\{ptr} = getelementptr inbounds \{type(baseType)}, \{base}, " +
                        "\{SIZE_TYPE} \{index}")
                out.printLine("store \{value}, \{type(baseType)}* \{ptr}")
            when "destroy":
                assert stmt.children.get_count() = 1
                def ptr := getTypedReference(stmt.children[0], out)
                def cast := nextVar()
                out.printLine("\{cast} = bitcast \{ptr} to i8*")
                out.printLine("call void @free(i8* \{cast})")
            otherwise:
                assert false
        }
    }

    -- if 'target' is non-null, it is inserted as a hidden first parameter to the call. This is used
    -- for init() calls, which require a self parameter but do not have a target in the IR.
    method writeCall(call:IRNode, target:String?, out:IndentedOutputStream) {
        assert call.kind = IRNode.Kind.CALL
        def m := (call.payload->MethodRef).value
        if m.owner.name = "panda.unsafe.Pointer" {
            writePointerCall(call, out)
            return
        }
        if m.owner.external {
            writeDeclaration(m)
        }
        def actualMethodType:Type
        def actualResultType:String
        def isSuper := call.children.get_count() >= 1 & call.children[0].kind = IRNode.Kind.SUPER
        if !isSuper & m.isVirtual() {
            actualMethodType := compiler.inheritedType(m)
            actualResultType := type(actualMethodType.subtypes[actualMethodType.subtypes.get_count() - 1])
        }
        else {
            actualMethodType := compiler.declaredType(m)
            actualResultType := type(call.type)
        }
        def args := Array<String>()
        if target != null {
            args.add(target)
        }
        def offset := call.children.get_count() - actualMethodType.subtypes.get_count() + 1
        for i in 0 .. call.children.get_count() {
            var arg := getReference(call.children[i], out)
            if i >= offset & actualMethodType.subtypes[i - offset] != call.children[i].type {
                arg := getCastReference(arg, call.children[i].type,
                            actualMethodType.subtypes[i - offset], out)
            }
            args.add(arg)
        }
        def refTarget:String?
        if args.get_count() > 0 {
            -- this isn't actually correct - args[0] could be the target of an instance method, or
            -- just the first parameter to a class method. But getMethodReference ignores target for
            -- non-virtual methods, so this works and is easier than doing it the right way.
            refTarget := args[0]
        }
        else {
            refTarget := null
        }
        def methodRef := getMethodReference(refTarget, m, isSuper, out)
        var separator := ""
        if needsStructIndirection(m) {
            labelCount += 1
            def indirectVar := "%$tmp" + labelCount
            def resultType := type(call.type)
            methodHeader.printLine("\{resultType} \{indirectVar};")
            out.print("\{methodRef}(\{resultType}* \{indirectVar}")
            separator := ", "
        }
        else {
            out.print("\{methodRef}(")
        }
        for a in args {
            out.print(separator)
            out.print(a)
            separator := ", "
        }
        out.printLine(");")
    }

    method writeIf(s:IRNode, out:IndentedOutputStream) {
        assert s.kind = IRNode.Kind.IF
        assert s.children.get_count() = 2 | s.children.get_count() = 3
        assert s.children[0].type = Type.Bit()
        def test := getTypedReference(s.children[0], out)
        def testBit := nextVar()
        out.printLine("\{testBit} = extractvalue \{test}, 0")
        def ifTrue := nextLabel()
        def ifFalse := nextLabel()
        out.printLine("br i1 \{testBit}, label %\{ifTrue}, label %\{ifFalse}")
        createBlock(ifTrue, out)
        writeStatement(s.children[1], out)
        def end:String
        if s.children.get_count() = 3 {
            end := nextLabel()
        }
        else {
            end := ifFalse
        }
        if !endsWithBranch(s.children[1]) {
            out.printLine("br label %\{end}")
        }
        if s.children.get_count() = 3 {
            createBlock(ifFalse, out)
            writeStatement(s.children[2], out)
            if !endsWithBranch(s.children[2]) {
                out.printLine("br label %\{end}")
            }
        }
        createBlock(end, out)
    }

    method writeRangeFor(f:IRNode, out:IndentedOutputStream) {
        -- I am acutely aware of how horrific this looks.
        --
        -- There's no easy way to produce clean output here, since we have to handle different step
        -- values, different loop directions, and both inclusive and exclusive ranges, all of which
        -- could potentially be determined at runtime. It gets even uglier when you consider the
        -- difficulty of handling the extremes of the numeric types. You can't just add 1 and then
        -- check to see if it's in range when the limit is MAX_INT, because you'll overflow and end
        -- up with an infinite loop. You also can't just check for being equal to the limit before
        -- adding the step, because with a step bigger than 1 (or smaller than -1) you might need to
        -- stop before actually hitting the end. So you instead check the difference between the
        -- current index and the limit, but even there you need to be careful because it could
        -- overflow in a signed test, and we need to handle null values, and... ugh, it's
        -- surprisingly messy and results in a ton of code.
        --
        -- Fortunately, we can just write incredibly awful-but-straightforward code and let LLVM
        -- optimize it to something sensible if it turns out the values are known at compile time.
        -- This works remarkably well, because LLVM is awesome.
        assert f.kind = IRNode.Kind.RANGE_FOR
        assert f.children.get_count() = 3
        def target := f.children[0]
        assert f.children[1].type.typeKind = Type.Kind.GENERIC
        assert f.children[1].type.subtypes.get_count() = 2
        assert f.children[1].type.subtypes[0].name = "panda.core.Range"
        def range := getTypedReference(f.children[1], out)
        def block := f.children[2]
        def t := f.children[1].type.subtypes[1]
        def llt := type(t)
        def indexType:String
        if t.typeKind = Type.Kind.NULLABLE {
            assert t.subtypes.get_count() = 1
            indexType := type(t.subtypes[0])
        }
        else {
            indexType := llt
        }
        def cl := compiler.getClass(t)
        assert cl != null
        assert compiler.instanceFields(cl).get_count() = 1
        def numberType := type(compiler.instanceFields(cl)[0].type)
        assert target.kind = IRNode.Kind.VARIABLE_REFERENCE
        def index := getName(target.payload->Variable)
        methodHeader.printLine("\{index} = alloca \{indexType}")

        -- extract start value from range
        def startPtr := nextVar()
        out.printLine("\{startPtr} = extractvalue \{range}, 0")
        def startPtrCast := nextVar()
        out.printLine("\{startPtrCast} = bitcast \{type(Type.Object())} \{startPtr} to " +
                "\{wrapperType(t)}")
        def startFieldPtr := nextVar()
        out.printLine("\{startFieldPtr} = getelementptr \{wrapperTypeName(t)}, " +
                "\{wrapperType(t)} \{startPtrCast}, i64 0, i32 \{OBJECT_FIELD_COUNT}, i32 0")
        def start := nextVar()
        out.printLine("\{start} = load \{numberType}, \{numberType}* \{startFieldPtr}")

        -- store start value
        def indexValuePtr := nextVar()
        out.printLine("\{indexValuePtr} = getelementptr \{indexType}, \{indexType}* \{index}, " +
                "i64 0, i32 0")
        out.printLine("store \{numberType} \{start}, \{numberType}* \{indexValuePtr}")

        -- extract end value from range
        def endPtr := nextVar()
        out.printLine("\{endPtr} = extractvalue \{range}, 1")
        def endPtrCast := nextVar()
        out.printLine("\{endPtrCast} = bitcast \{type(Type.Object())} \{endPtr} to " +
                "\{wrapperType(t)}")
        def endFieldPtr := nextVar()
        out.printLine("\{endFieldPtr} = getelementptr \{wrapperTypeName(t)}, \{wrapperType(t)} " +
                "\{endPtrCast}, i64 0, i32 \{OBJECT_FIELD_COUNT}, i32 0")
        def end := nextVar()
        out.printLine("\{end} = load \{numberType}, \{numberType}* \{endFieldPtr}")

        -- extract step value from range
        def rawStep := nextVar()
        out.printLine("\{rawStep} = extractvalue \{range}, 2, 0")
        def step:String
        if numberType != "i64" {
            step := nextVar()
            out.printLine("\{step} = trunc i64 \{rawStep} to \{numberType}")
        }
        else {
            step := rawStep
        }

        -- extract inclusive / exclusive from range
        def inclusive := nextVar()
        out.printLine("\{inclusive} = extractvalue \{range}, 3, 0")

        -- start block
        def loopStart := nextLabel()
        def loopBody := nextLabel()
        def loopEnd := nextLabel()
        def loopTest := nextLabel()
        loopDescriptors.push(LoopDescriptor(f.payload->String?, loopEnd, loopTest)) -- FIXME Auto
        def forwardEntry := nextLabel()
        def backwardEntry := nextLabel()
        def signPrefix:String
        if t.name.startsWith("panda.core.Int") {
            signPrefix := "s"
        }
        else {
            assert t.name.startsWith("panda.core.UInt") | t.name.startsWith("panda.core.Char")
            signPrefix := "u"
        }
        def direction:String
        if signPrefix = "s" {
            direction := nextVar()
            out.printLine("\{direction} = icmp sge \{numberType} \{step}, 0")
        }
        else {
            direction := "1"
        }
        out.printLine("br i1 \{direction}, label %\{forwardEntry}, label %\{backwardEntry}")
        createBlock(forwardEntry, out)
        def forwardEntryInclusive := nextLabel()
        def forwardEntryExclusive := nextLabel()
        out.printLine("br i1 \{inclusive}, label %\{forwardEntryInclusive}, " +
                "label %\{forwardEntryExclusive}")
        createBlock(forwardEntryInclusive, out)
        def forwardEntryInclusiveTest := nextVar()
        out.printLine("\{forwardEntryInclusiveTest} = icmp \{signPrefix}le \{numberType} " +
                "\{start}, \{end}")
        out.printLine("br i1 \{forwardEntryInclusiveTest}, label %\{loopStart}, label %\{loopEnd}")
        createBlock(forwardEntryExclusive, out)
        def forwardEntryExclusiveTest := nextVar()
        out.printLine("\{forwardEntryExclusiveTest} = icmp \{signPrefix}lt \{numberType} " +
                "\{start}, \{end}")
        out.printLine("br i1 \{forwardEntryExclusiveTest}, label %\{loopStart}, label %\{loopEnd}")
        createBlock(backwardEntry, out)
        def backwardEntryInclusive := nextLabel()
        def backwardEntryExclusive := nextLabel()
        out.printLine("br i1 \{inclusive}, label %\{backwardEntryInclusive}, " +
                "label %\{backwardEntryExclusive}")
        createBlock(backwardEntryInclusive, out)
        def backwardEntryInclusiveTest := nextVar()
        out.printLine("\{backwardEntryInclusiveTest} = icmp \{signPrefix}ge \{numberType} " +
                "\{start}, \{end}")
        out.printLine("br i1 \{backwardEntryInclusiveTest}, label %\{loopStart}, label %\{loopEnd}")
        createBlock(backwardEntryExclusive, out)
        def backwardEntryExclusiveTest := nextVar()
        out.printLine("\{backwardEntryExclusiveTest} = icmp \{signPrefix}gt \{numberType} " +
                "\{start}, \{end}")
        out.printLine("br i1 \{backwardEntryExclusiveTest}, label %\{loopStart}, label %\{loopEnd}")
        createBlock(loopStart, out)
        def indexValue := nextVar()
        out.printLine("\{indexValue} = load \{numberType}, \{numberType}* \{indexValuePtr}")
        writeStatement(block, out)
        if !endsWithBranch(block) {
            out.printLine("br label %\{loopTest}")
        }
        createBlock(loopTest, out)
        def loopInc := nextLabel()
        -- beginning of loop test, determine direction
        def forwardLabel := nextLabel()
        def backwardLabel := nextLabel()
        out.printLine("br i1 \{direction}, label %\{forwardLabel}, label %\{backwardLabel}")

        -- forward loop; perform the test by subtracting index from end and then comparing to step,
        -- to avoid overflows near the maximum value
        createBlock(forwardLabel, out)
        def forwardDelta := nextVar()
        out.printLine("\{forwardDelta} = sub \{numberType} \{end}, \{indexValue}")

        -- forward loop; determine inclusive / exclusive
        def forwardInclusiveLabel := nextLabel()
        def forwardExclusiveLabel := nextLabel()
        out.printLine("br i1 \{inclusive}, label %\{forwardInclusiveLabel}, label %" +
                forwardExclusiveLabel)

        -- forward inclusive test
        createBlock(forwardInclusiveLabel, out)
        def forwardInclusiveTest := nextVar()
        -- always use unsigned comparison to avoid overflow; we know both the delta and the step are
        -- the same sign
        out.printLine("\{forwardInclusiveTest} = icmp uge \{numberType} \{forwardDelta}, \{step}")
        out.printLine("br i1 \{forwardInclusiveTest}, label %\{loopInc}, label %\{loopEnd}")
        createBlock(forwardExclusiveLabel, out)

        -- forward exclusive test
        def forwardExclusiveTest := nextVar()
        out.printLine("\{forwardExclusiveTest} = icmp ugt \{numberType} \{forwardDelta}, \{step}")
        out.printLine("br i1 \{forwardExclusiveTest}, label %\{loopInc}, label %\{loopEnd}")

        -- backward loop; perform the test by subtracting end from index and then comparing to
        -- -step, to avoid overflows near the minimum value
        createBlock(backwardLabel, out)
        def backwardDelta := nextVar()
        out.printLine("\{backwardDelta} = sub \{numberType} \{indexValue}, \{end}")
        def negStep := nextVar()
        out.printLine("\{negStep} = sub \{numberType} 0, \{step}")

        -- backward loop; determine inclusive / exclusive
        def backwardInclusiveLabel := nextLabel()
        def backwardExclusiveLabel := nextLabel()
        out.printLine("br i1 \{inclusive}, label %\{backwardInclusiveLabel}, label %" +
                backwardExclusiveLabel)

        -- backward inclusive test
        createBlock(backwardInclusiveLabel, out)
        def backwardInclusiveTest := nextVar()
        out.printLine("\{backwardInclusiveTest} = icmp uge \{numberType} \{backwardDelta}, " +
                negStep)
        out.printLine("br i1 \{backwardInclusiveTest}, label %\{loopInc}, label %\{loopEnd}")
        createBlock(backwardExclusiveLabel, out)

        -- backward exclusive test
        def backwardExclusiveTest := nextVar()
        out.printLine("\{backwardExclusiveTest} = icmp ugt \{numberType} \{backwardDelta}, " +
                negStep)
        out.printLine("br i1 \{backwardExclusiveTest}, label %\{loopInc}, label %\{loopEnd}")

        createBlock(loopInc, out)
        def inc := nextVar()
        out.printLine("\{inc} = add \{numberType} \{indexValue}, \{step}")
        def incStruct := nextVar()
        out.printLine("\{incStruct} = insertvalue \{indexType} { \{numberType} undef")
        out.printLine(" }, \{numberType} \{inc}, 0")
        out.printLine("store \{indexType} \{incStruct}, \{indexType}* \{index}")
        out.printLine("br label %\{loopStart}")

        createBlock(loopEnd, out)
        loopDescriptors.pop()
    }

    method writeWhile(w:IRNode, out:IndentedOutputStream) {
        assert w.kind = IRNode.Kind.WHILE
        assert w.children.get_count() = 2
        assert w.children[0].type = Type.Bit()
        def loopStart := nextLabel()
        def loopBody := nextLabel()
        def loopEnd := nextLabel()
        loopDescriptors.push(LoopDescriptor(w.payload->String?, loopEnd, loopStart)) -- FIXME Auto
        out.printLine("br label %\{loopStart}")
        createBlock(loopStart, out)
        def test := getTypedReference(w.children[0], out)
        def testBit := nextVar()
        out.printLine("\{testBit} = extractvalue \{test}, 0")
        out.printLine("br i1 \{testBit}, label %\{loopBody}, label %\{loopEnd}")
        createBlock(loopBody, out)
        writeStatement(w.children[1], out)
        if !endsWithBranch(w.children[1]) {
            out.printLine("br label %\{loopStart}")
        }
        createBlock(loopEnd, out)
        loopDescriptors.pop()
    }

    method writeDo(d:IRNode, out:IndentedOutputStream) {
        assert d.kind = IRNode.Kind.DO
        assert d.children.get_count() = 2
        assert d.children[1].type = Type.Bit()
        def loopStart := nextLabel()
        def loopBody := nextLabel()
        def loopEnd := nextLabel()
        loopDescriptors.push(LoopDescriptor(d.payload->String?, loopEnd, loopStart)) -- FIXME Auto
        out.printLine("br label %\{loopBody}")
        createBlock(loopStart, out)
        def test := getTypedReference(d.children[1], out)
        def testBit := nextVar()
        out.printLine("\{testBit} = extractvalue \{test}, 0")
        out.printLine("br i1 \{testBit}, label %\{loopBody}, label %\{loopEnd}")
        createBlock(loopBody, out)
        writeStatement(d.children[0], out)
        if !endsWithBranch(d.children[0]) {
            out.printLine("br label %\{loopStart}")
        }
        createBlock(loopEnd, out)
        loopDescriptors.pop()
    }

    method writeLoop(l:IRNode, out:IndentedOutputStream) {
        assert l.kind = IRNode.Kind.LOOP
        assert l.children.get_count() = 1
        def loopStart := nextLabel()
        def loopEnd := nextLabel()
        loopDescriptors.push(LoopDescriptor(l.payload->String?, loopEnd, loopStart))
        out.printLine("br label %\{loopStart}")
        createBlock(loopStart, out)
        writeStatement(l.children[0], out)
        if !endsWithBranch(l.children[0]) {
            out.printLine("br label %\{loopStart}")
        }
        createBlock(loopEnd, out)
        loopDescriptors.pop()
    }

    method writeVarTarget(target:IRNode, value:IRNode?, out:IndentedOutputStream) {
        match target.kind {
            when IRNode.Kind.VARIABLE_REFERENCE:
                def v := target.payload->Variable
                methodHeader.printLine("\{getName(v)} = alloca \{type(v.type)}")
                if value != null {
                    def ref := getTypedReference(value, out)
                    out.printLine("store \{ref}, \{type(v.type)}* \{getName(v)}")
                }
            when IRNode.Kind.TUPLE_TARGET:
                assert false
            otherwise:
                assert false
        }
    }

    method writeVar(v:IRNode, out:IndentedOutputStream) {
        assert v.kind = IRNode.Kind.VAR |
                v.kind = IRNode.Kind.DEF |
                v.kind = IRNode.Kind.PROPERTY |
                v.kind = IRNode.Kind.CONSTANT
        for decl in v.children {
            assert decl.kind = IRNode.Kind.DECLARATION
            if decl.children.get_count() > 1 {
                writeVarTarget(decl.children[0], decl.children[1], out)
            }
            else {
                writeVarTarget(decl.children[0], null, out)
            }
        }
    }

    method getLValue(lvalue:IRNode, out:IndentedOutputStream):String {
        match lvalue.kind {
            when IRNode.Kind.CAST:
                return getLValue(compiler.unwrapCast(lvalue), out)
            when IRNode.Kind.VARIABLE_REFERENCE:
                return getName(lvalue.payload->Variable)
            when IRNode.Kind.FIELD_REFERENCE:
                def base := getReference(lvalue.children[0], out)
                def ptr := nextVar()
                def cl := compiler.getClass(lvalue.children[0].type)
                assert cl != null
                def fields := compiler.instanceFields(cl)
                var index := -1
                for i in 0 .. fields.get_count() {
                    if fields[i].name == (lvalue.payload->FieldDecl).name { -- FIXME parens
                        index := i
                        break
                    }
                }
                assert index != -1
                out.printLine("\{ptr} = getelementptr inbounds \{typeName(cl.type())}, " +
                        "\{typeName(cl.type())}* \{base}, i64 0, i32 \{index}")
                return ptr
            when IRNode.Kind.REUSED_VALUE_DEFINITION:
                def result := getLValue(lvalue.children[0], out)
                def reused := nextVar()
                out.printLine("\{reused} = load \{type(lvalue.type)}, " +
                        "\{type(lvalue.type)}* \{result}")
                reusedValues[lvalue.payload->UInt64] := reused
                return result
            otherwise:
                assert false, "unsupported lvalue: \{lvalue}"
        }
    }

    method writeAssignment(a:IRNode, out:IndentedOutputStream) {
        assert a.kind = IRNode.Kind.BINARY
        assert a.children.get_count() = 2
        def lvalue := "\{type(a.children[0].type)}* \{getLValue(a.children[0], out)}"
        def value:String
        def t := type(a.children[0].type)
        def op := a.payload->Int
        if op = Token.Kind.ASSIGNMENT {
            def right := getReference(a.children[1], out)
            value := "\{t} \{right}"
        }
        else {
-*            Operator binOp;
            switch (op) {
                case Operator.ADDEQ:        binOp = Operator.ADD;                         break;
                case Operator.SUBEQ:        binOp = Operator.SUB;                         break;
                case Operator.MULEQ:        binOp = Operator.MUL;                         break;
                case Operator.DIVEQ:        binOp = Operator.DIV;                         break;
                case Operator.INTDIVEQ:     binOp = Operator.INTDIV;                      break;
                case Operator.REMEQ:        binOp = Operator.REM;                         break;
                case Operator.POWEQ:        binOp = Operator.POW;                         break;
                case Operator.XOREQ:        binOp = Operator.XOR;                         break;
                case Operator.BITWISEOREQ:  binOp = Operator.BITWISEOR;                   break;
                case Operator.BITWISEANDEQ: binOp = Operator.BITWISEAND;                  break;
                case Operator.BITWISEXOREQ: binOp = Operator.BITWISEXOR;                  break;
                case Operator.SHIFTLEFTEQ:  binOp = Operator.SHIFTLEFT;                   break;
                case Operator.SHIFTRIGHTEQ: binOp = Operator.SHIFTRIGHT;                  break;
                case Operator.ANDEQ:        this->writeAndEq(lvalue, a.fChildren[1], out); return;
                case Operator.OREQ:         this->writeOrEq(lvalue, a.fChildren[1], out);  return;
                default: abort();
            }
            def left := nextVar()
            out << "    " << left << " = load " << this->llvmType(a.fChildren[0].fType) << ", " <<
                    lvalue << "\n";
            String right = this->getReference(a.fChildren[1], out);
            value = type + " " +
                    this->getBinaryReference(op_class(a.fChildren[0].fType), type + " " + left, binOp,
                            right, out);
            *-
            assert false
        }
        out.printLine("store \{value}, \{lvalue}")
    }

    method writeReturn(r:IRNode, out:IndentedOutputStream) {
        if r.children.get_count() = 1 {
            if inlineContext.get_count() > 0 {
                def inline := inlineContext.peek()
                def result := getReference(r.children[0], out)
                inline.returns.add(Pair<String, String>(currentBlock, result))
                out.printLine("br label %\{inline.exitLabel} ; inline return (\{compiler.position(r.offset)})")
            }
            else {
                out.printLine("return \{getReference(r.children[0], out)};")
            }
        }
        else {
            assert r.children.get_count() = 0
            if inlineContext.get_count() > 0 {
                out.printLine("br label %\{inlineContext.peek().exitLabel}")
            }
            else {
                out.printLine("return;")
            }
        }
    }

    function findLoop(name:String?):LoopDescriptor {
        assert loopDescriptors.get_count() > 0
        if name = null {
            return loopDescriptors.peek()
        }
        for i in 0 .. loopDescriptors.get_count() {
            if loopDescriptors.peek(i).loopLabel != null & loopDescriptors.peek(i).loopLabel = name { -- FIXME shouldn't need null check
                return loopDescriptors.peek(i)
            }
        }
        assert false
    }

    method writeBreak(b:IRNode, out:IndentedOutputStream) {
        def desc := findLoop(b.payload->String?)
        out.printLine("br label %\{desc.breakLabel}")
    }

    method writeContinue(c:IRNode, out:IndentedOutputStream) {
        def desc := findLoop(c.payload->String?)
        out.printLine("br label %\{desc.continueLabel}")
    }

    method writeAssert(a:IRNode, out:IndentedOutputStream) {
        assert a.kind = IRNode.Kind.ASSERT
        assert a.children.get_count() = 1 | a.children.get_count() = 2
        if compiler.settings.safetyLevel < 2 {
            return
        }
        def test := getReference(a.children[0], out)
        def ifTrue := nextLabel()
        def ifFalse := nextLabel()
        out.printLine("br i1 \{test}, label %\{ifTrue}, label %\{ifFalse}")
        createBlock(ifFalse, out)
        def p := compiler.position(a.offset)
        def name:String
        def index := p.file.lastIndexOf("/")
        if index = null {
            name := p.file
        }
        else {
            name := p.file[index...]
        }
        def nameRef := getStringReference(name, out)
        def line := "%panda$core$Int64 { i64 \{p.line} }"
        def msg:String?
        if a.children.get_count() = 2 {
            msg := getReference(a.children[1], out)
        }
        else {
            msg := null
        }
        out.print("call fastcc void ")
        for m in compiler.getClass(Type.Panda()).methods {
            if m.name = "assertionFailure" {
                compiler.resolve(m)
                writeDeclaration(m)
            }
        }
        if msg != null {
            out.print("@panda$core$Panda$assertionFailure$" +
                    "panda$core$String$panda$core$Int64$panda$core$String")
        }
        else {
            out.print("@panda$core$Panda$assertionFailure$panda$core$String$panda$core$Int64")
        }
        out.print("(%panda$core$String* \{nameRef}, \{line}")
        if msg != null {
            out.print(", %panda$core$String* \{msg}")
        }
        out.printLine(")")
        out.printLine("unreachable")
        createBlock(ifTrue, out)
    }

    method writeStatement(stmt:IRNode, out:IndentedOutputStream) {
        match stmt.kind {
            when IRNode.Kind.BINARY:
                writeAssignment(stmt, out)
            when IRNode.Kind.BLOCK:
                writeBlock(stmt, out)
            when IRNode.Kind.CALL:
                writeCall(stmt, null, out)
            when IRNode.Kind.IF:
                writeIf(stmt, out)
            when IRNode.Kind.RANGE_FOR:
                writeRangeFor(stmt, out)
            when IRNode.Kind.WHILE:
                writeWhile(stmt, out)
            when IRNode.Kind.DO:
                writeDo(stmt, out)
            when IRNode.Kind.LOOP:
                writeLoop(stmt, out)
            when IRNode.Kind.VAR, IRNode.Kind.DEF, IRNode.Kind.CONSTANT, IRNode.Kind.PROPERTY:
                writeVar(stmt, out)
            when IRNode.Kind.RETURN:
                writeReturn(stmt, out)
            when IRNode.Kind.BREAK:
                writeBreak(stmt, out)
            when IRNode.Kind.CONTINUE:
                writeContinue(stmt, out)
            when IRNode.Kind.ASSERT:
                writeAssert(stmt, out)
            otherwise:
                assert false, "unsupported statement \{stmt}"
        }
    }

    method selfType(m:MethodDecl):String {
        def result := type(m.owner.type())
        if m.methodKind = MethodDecl.Kind.INIT & !result.endsWith("*") {
            return result + "*"
        }
        return result
    }

    @override
    method writeDeclaration(m:MethodDecl) {
        writeImport(m.owner)
    }

    @override
    method write(m:MethodDecl, body:IRNode) {
        assert compiler.currentClass.peek() == m.owner
        currentMethod := m
        currentBlock := "0"
        varCount := 0
        methodHeaderBuffer.clear()
        methods.print("\{type(m.returnType)} \{getName(m)}(")
        var separator := ""
        if !m.annotations.isClass() {
            methods.print("\{selfType(m)} self")
            separator := ", "
        }
        for p in m.parameters {
            methods.print("\{separator}\{type(p.type)} %\{escapeName(p.name)}")
            separator := ", "
        }
        methods.printLine(") {")
        methods.level += 1
        assert body.kind = IRNode.Kind.BLOCK
        def bodyBuffer := MemoryOutputStream()
        def indentedBody := IndentedOutputStream(bodyBuffer)
        for s in body.children {
            writeStatement(s, indentedBody)
        }
        methods.print(methodHeaderBuffer.convert())
        methods.print(bodyBuffer.convert())
        methods.level -= 1
        methods.printLine("}")
        currentMethod := null
    }

    @override
    method write(cl:ClassDecl) {
    }

    @override
    method finish() {
        out.printLine(methodsBuffer)
        out.cleanup() -- FIXME shouldn't be necessary
    }
}