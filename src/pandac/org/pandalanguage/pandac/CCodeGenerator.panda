package org.pandalanguage.pandac

uses org.pandalanguage.pandac.parser.Token

@final
class CCodeGenerator : CodeGenerator {
    var compiler:Compiler?

    def outDir:File

    def out:IndentedOutputStream

    def strings := MemoryOutputStream()

    def imports := Set<String>()

    def hCodeGen:HCodeGenerator

    var currentClass:ClassDecl? := null

    init(outDir:File) {
        self.outDir := outDir
        self.out := IndentedOutputStream(MemoryOutputStream())
        self.hCodeGen := HCodeGenerator(outDir)
    }

    function escapeName(s:String):String {
        return hCodeGen.escapeName(s)
    }

    function getName(m:MethodDecl):String {
        return hCodeGen.getName(m)
    }

    function sizeOf(t:Type):Int {
        return hCodeGen.sizeOf(t)
    }

    function isExternal(cl:ClassDecl):Bit {
        return cl !== currentClass
    }

    method writeImport(cl:ClassDecl) {
        if cl.name = "panda.unsafe.Pointer" {
            return
        }
        def includePath := hCodeGen.getRelativePath(cl, ".h")
        if !imports.contains(includePath) {
            out.printLine("#include \"\{includePath}\"")
            imports.add(includePath)
        }
    }

    method type(t:Type):String {
        if t.isClass() {
            def cl := compiler.getClass(t)
            assert cl != null
            writeImport(cl)
        }
        if t.typeKind = Type.Kind.METHOD | t.typeKind = Type.Kind.FUNCTION {
            varCount += 1
            def result := "$fn\{varCount}"
            def code := MutableString("typedef ")
            code.append(type(t.subtypes[t.subtypes.get_count() - 1]))
            code.append(" (*")
            code.append(result)
            code.append(")(")
            var separator := ""
            for i in 0 .. t.subtypes.get_count() - 1 {
                code.append(separator)
                code.append(type(t.subtypes[i]))
                separator := ", "
            }
            code.append(");")
            types.printLine(code)
            return result
        }
        return hCodeGen.type(t)
    }

    @override
    method setCompiler(compiler:Compiler) {
        self.compiler := compiler
        hCodeGen.setCompiler(compiler)
    }

    class ClassConstant : Immutable {
        def name:String
        def type:String

        init(name:String, type:String) {
            self.name := name
            self.type := type
        }
    }

    class MethodShim {
        def name:String
        def type:String

        init(name:String, type:String) {
            self.name := name
            self.type := type
        }
    }

    class LoopDescriptor : Immutable {
        def loopLabel:String?
        def breakLabel:String
        def continueLabel:String

        init(loopLabel:String?, breakLabel:String, continueLabel:String) {
            self.loopLabel := loopLabel
            self.breakLabel := breakLabel
            self.continueLabel := continueLabel
        }

        @override
        function convert():String {
            if loopLabel != null {
                return "LoopDescriptor<\{loopLabel}>"
            }
            else {
                return "LoopDescriptor<>"
            }
        }
    }

    ================================================================================================
    Overrides features such as method arguments and return handling for use in compiling inline
    methods.
    ================================================================================================
    class InlineContext {
        ============================================================================================
        Local variable name suffix.
        ============================================================================================
        def varSuffix:String

        ============================================================================================
        Reference to use instead of the normal "self".
        ============================================================================================
        def selfRef:String

        ============================================================================================
        Reference to use instead of the normal method parameter names.
        ============================================================================================
        def argRefs:ImmutableArray<String>

        ============================================================================================
        Contains pairs of (source block, return value), which can be turned into the actual return
        value using a phi node. Initially empty, filled in as the inline call is written.
        ============================================================================================
        def returns := Array<Pair<String, String>>()

        ============================================================================================
        Label to jump to after returning.
        ============================================================================================
        def exitLabel:String

        init(varSuffix:String, selfRef:String, argRefs:ListView<String>, exitLabel:String) {
            self.varSuffix := varSuffix
            self.selfRef := selfRef
            self.argRefs := ImmutableArray<String>(argRefs)
            self.exitLabel := exitLabel
        }
    }

    constant POINTER_SIZE        := 8
    constant OBJECT_FIELD_COUNT  := 2
    constant CLASS_POINTER_INDEX := 0
    constant ITABLE_INDEX        := 2
    constant VTABLE_INDEX        := 3

    constant INT_TYPE  := "i64"
    constant SIZE_TYPE := "i64"

    def declarations := MemoryOutputStream()

    def types := MemoryOutputStream()

    def methodsBuffer := MemoryOutputStream()

    def methods := IndentedOutputStream(methodsBuffer)

    def methodHeaderBuffer := MemoryOutputStream()

    def methodHeader := IndentedOutputStream(methodHeaderBuffer)

    def wrapperShimsBuffer := MemoryOutputStream()

    def wrapperShims := IndentedOutputStream(wrapperShimsBuffer)

    def shimsBuffer := MemoryOutputStream()

    def shims := IndentedOutputStream(shimsBuffer)

    def declared := Set<String>()

    def writtenTypes := Set<String>()

    def writtenWrappers := Set<String>()

    def classConstants := HashMap<String, ClassConstant>()

    def variableNames := IdentityMap<Variable, String>()

    var currentBlock:String

    var currentMethod:MethodDecl?

    def loopDescriptors := Stack<LoopDescriptor>()

    var varCount := 0

    def reusedValues := HashMap<UInt64, String>()

    def methodShims := IdentityMap<MethodDecl, MethodShim>()

    def inlineContext := Stack<InlineContext>()

    def currentlyInlining := IdentityMap<MethodDecl, MethodDecl>() -- FIXME need IdentitySet

    method nextVar():String {
        varCount += 1
        return "$tmp\{varCount}"
    }

    method nextLabel():String {
        varCount += 1
        return "$l\{varCount}"
    }

    method createBlock(label:String, out:IndentedOutputStream) {
        out.printLine("\{label}:;")
        currentBlock := label
    }

    function endsWithBranch(stmt:IRNode):Bit {
        match stmt.kind {
            when IRNode.Kind.BLOCK:
                if stmt.children.get_count() = 0 {
                    return false
                }
                return endsWithBranch(stmt.children[stmt.children.get_count() - 1])
            when IRNode.Kind.BREAK, IRNode.Kind.CONTINUE, IRNode.Kind.RETURN:
                return true
            otherwise: return false
        }
    }

    function fieldSize(t:Type):Int {
        assert t.resolved
        if t.isBuiltinNumber() {
            if t.name.endsWith("8") {
                return 1
            }
            if t.name.endsWith("16") {
                return 2
            }
            if t.name.endsWith("32") {
                return 4
            }
            assert t.name.endsWith("64")
            return 8
        }
        if t = Type.BuiltinBit() {
            return 1
        }
        def cl := compiler.getClass(t)
        assert cl != null
        if !compiler.isValue(cl) | cl.name = "panda.unsafe.Pointer" {
            return POINTER_SIZE
        }
        var result := 0
        for f in compiler.instanceFields(cl) {
            if f.annotations.isClass() {
                continue
            }
            compiler.resolve(f)
            def size := fieldSize(f.type)
            def align := result % size
            if align != 0 {
                result += size - align
            }
            assert result % size = 0
            result += size
        }
        if t.typeKind = Type.Kind.NULLABLE {
            result += 1
        }
        return result
    }

    function alignment(t:Type):Int {
        return fieldSize(t).min(8)
    }

    function sizeOfWrapper(t:Type):Int {
        def cl := compiler.getClass(t)
        assert cl != null & compiler.isValue(cl)
        var result := sizeOf(Type.Object())
        for f in compiler.instanceFields(cl) {
            compiler.resolve(f)
            def size := fieldSize(f.type)
            def align := result % size
            if align != 0 {
                result += size - align
            }
            assert result % size = 0
            result += size
        }
        if t.typeKind = Type.Kind.NULLABLE {
            result += 1
        }
        return result
    }

    method writeType(t:Type) {
        if writtenTypes.contains(t.name) {
            return
        }
    }

    function typeName(t:Type):String {
        return escapeName(t.name)
    }

    method wrapperTypeName(t:Type):String {
        if t.typeKind = Type.Kind.NULLABLE {
            return wrapperTypeName(t.subtypes[0])
        }
        return "\{escapeName(t.name)}$wrapper"
    }

    method wrapperType(t:Type):String {
        return wrapperTypeName(t) + "*"
    }

    method wrapperType(m:MethodDecl):String {
        def inheritedType := compiler.inheritedType(m)
        def result := MutableString()
        result.append(type(inheritedType.subtypes[inheritedType.subtypes.get_count() - 1]))
        result.append("(")
        assert m.isInstance()
        result.append("\{escapeName(m.owner.name)}")
        if compiler.isValue(m.owner) {
            result.append("$wrapper")
        }
        result.append("*")
        for i in 0 .. inheritedType.subtypes.get_count() - 1 { 
            result.append(", ")
            result.append(type(inheritedType.subtypes[i]))
        }
        result.append(")*")
        return result.convert()
    }

    method nullableType(t:Type):String {
        assert t.typeKind = Type.Kind.NULLABLE, "\{t} is not nullable"
        return "\{type(t.subtypes[0])}$nullable"
    }

    method getITable(cl:ClassDecl):String {
        def interfaces := compiler.allInterfaces(cl.type())
        var previous := "NULL"
        for intfType in interfaces {
            def intf := compiler.getClass(intfType)
            def intfCC := getClassConstant(intf)
            def methods := compiler.interfaceMethods(cl, intfType)
            def name := "\{escapeName(cl.name)}$_\{escapeName(intf.name)}"
            def result := MutableString("struct { \{type(Type.Class())} cl; ITable* next; " +
                    "void* methods[\{methods.get_count()}]; } \{name} = { " +
                    "(panda$core$Class*) &\{intfCC.name}, \{previous}, { ")
            var separator := ""
            for m in methods {
                result.append(separator)
                separator := ", "
                if m.annotations.isAbstract() {
                    result.append("NULL")
                }
                else {
                    result.append(getMethodTableEntry(m))
                }
            }
            result.append("} };\n")
            types.printLine(result)
            previous := "(ITable*) &\{name}"
        }
        return previous
    }

    method createMethodShim(raw:MethodDecl, effective:Type, rawOut:OutputStream):MethodShim {
        def outBuffer := MemoryOutputStream()
        def out := IndentedOutputStream(outBuffer)
        def found := methodShims[raw]
        if found != null {
            return found
        }
        assert effective.isMethod()
        assert effective.subtypes.get_count() = raw.parameters.get_count() + 1
        assert raw.isInstance()
        def effectiveReturnType := effective.subtypes[effective.subtypes.get_count() - 1]
        def resultName := getName(raw) + "$shim"
        def resultType := MutableString(type(effectiveReturnType))
        out.print("\{resultType} \{resultName}(")
        def self_t := selfType(raw)
        out.print("\{self_t} self")
        resultType.append("(")
        resultType.append(self_t)
        for i in 0 .. raw.parameters.get_count() {
            def pType := type(effective.subtypes[i])
            resultType.append(", ")
            resultType.append(pType)
            out.print(", \{pType} p\{i}")
        }
        out.printLine(") {")
        out.level +=1
        resultType.append(")*")
        def casts := Array<String>()
        for i in 0 .. raw.parameters.get_count() {
            def p := "p\{i}"
            if raw.parameters[i].type != effective.subtypes[i] {
                casts.add(getCastReference(p, effective.subtypes[i],
                        raw.parameters[i].type, out))
            }
            else {
                casts.add(p)
            }
        }
        if raw.returnType != Type.Void() {
            out.print("\{type(raw.returnType)} result = ")
        }
        out.print("\{getName(raw)}(self")
        for i in 0 .. raw.parameters.get_count() {
            out.print(", \{casts[i]}")
        }
        out.printLine(");")
        if raw.returnType != Type.Void() {
            out.printLine("return " + getCastReference("result", raw.returnType,
                    effectiveReturnType, out) + ";")
        }
        out.level -= 1
        out.printLine("}")
        def result := MethodShim(resultName, resultType.convert())
        methodShims[raw] := result
        rawOut.print(outBuffer)
        return result
    }

    method createWrapperShim(m:MethodDecl, out:IndentedOutputStream):String {
        assert m.isInstance()
        def oldMethod := currentMethod
        currentMethod := m
        def result := "\{getName(m)}$wrappershim"
        def selfType := "\{escapeName(m.owner.name)}$wrapper*"
        out.print("\{type(m.returnType)} \{result}(\{selfType} self")
        def actualMethodType := compiler.declaredType(m)
        def inheritedMethodType := compiler.inheritedType(m)
        for i in 0 .. m.parameters.get_count() {
            out.print(", \{type(inheritedMethodType.subtypes[i])} \{m.parameters[i].name}")
        }
        out.printLine(") {")
        out.level += 1
        def parameters := Array<String>()
        for i in 0 .. m.parameters.get_count() {
            parameters.add(getCastReference(m.parameters[i].name, inheritedMethodType.subtypes[i],
                    actualMethodType.subtypes[i], out))
        }
        def children := Array<IRNode>()
        children.add(IRNode(IRNode.Kind.SELF, -1, Type.Object()))
        if m.returnType != Type.Void() {
            out.print("return ")
        }
        out.print("\{getName(m)}(self->value")
        for i in 0 .. m.parameters.get_count() {
            out.print(", \{parameters[i]}")
        }
        out.printLine(");")
        out.level -= 1
        out.printLine("}")
        currentMethod := oldMethod
        return result
    }

    method getWrapperITable(cl:ClassDecl):String {
        def interfaces := compiler.allInterfaces(cl.type())
        var previous := "NULL"
        for intfType in interfaces {
            def intf := compiler.getClass(intfType)
            def intfCC := getClassConstant(intf)
            def methods := compiler.interfaceMethods(cl, intfType)
            def name := "\{escapeName(cl.name)}$wrapper_\{escapeName(intf.name)}"
            def result := MutableString("struct { \{type(Type.Class())} cl; ITable* itable; " +
                    "void* methods[\{methods.get_count()}]; } \{name} = { " +
                    "(\{type(Type.Class())}) &\{intfCC.name}, \{previous}, { ")
            var separator := ""
            for m in methods {
                result.append(separator)
                separator := ", "
                if m.annotations.isAbstract() {
                    result.append("NULL")
                }
                else {
                    result.append(createWrapperShim(m, wrapperShims))
                }
            }
            result.append("} };\n")
            types.printLine(result)
            previous := "(ITable*) &\{name}"
        }
        return previous
    }

    -- FIXME use tuple
    class Pair<A, B> {
        def first:A
        def second:B

        init(first:A, second:B) {
            self.first := first
            self.second := second
        }
    }

    function needsStructIndirection(m:MethodDecl):Bit {
        return hCodeGen.needsStructIndirection(m)
    }

    method getMethodTableEntry(m:MethodDecl):String {
        compiler.resolve(m)
        if isExternal(m.owner) {
            writeDeclaration(m)
        }
        def result:String
        def declared := compiler.declaredTypeWithSelf(m, m.owner.type())
        def inherited := compiler.inheritedTypeWithSelf(m)
        if declared != inherited {
            def shim := createMethodShim(m, compiler.inheritedType(m), shims)
            result := shim.name
        }
        else {
            result := getName(m)
        }
        return result
    }

    method getClassConstant(cl:ClassDecl):ClassConstant {
        var result := classConstants[cl.name]
        if result = null {
            writeImport(cl)
            compiler.resolve(cl)
            def type:String
            if isExternal(cl) {
                result := ClassConstant("\{escapeName(cl.type().name)}$class",
                        "%panda$core$Class")
                classConstants[cl.name] := result
                return classConstants[cl.name]
            }
            compiler.currentClass.push(cl)
            def vtable := compiler.getVTable(cl)
            result := ClassConstant("\{escapeName(cl.type().name)}$class", "<error>")
            classConstants[cl.name] := result
            def superPtr:String
            if cl.rawSuper != null {
                def superCC := getClassConstant(compiler.getClass(cl.rawSuper))
                superPtr := "(panda$core$Class*) &\{superCC.name}"
            }
            else {
                superPtr := "NULL"
            }
            def clConstant := getClassConstant(compiler.getClass(Type.Class()))
            def code := MutableString("\{result.name}_type \{result.name} = { " +
                    "(panda$core$Class*) &\{clConstant.name}, 1, \{superPtr}, \{getITable(cl)}, { ")
            var separator := ""
            for m in vtable {
                code.append(separator)
                if m.annotations.isAbstract() {
                    code.append("NULL")
                }
                else {
                    code.append(getMethodTableEntry(m))
                }
                separator := ", "
            }
            code.append("} };\n")
            types.printLine(code)
            compiler.currentClass.pop()
        }
        return result
    }

    method getWrapperClassConstant(cl:ClassDecl):ClassConstant {
        def name := "\{escapeName(cl.name)}$wrapperclass"
        var result := classConstants[name]
        if result = null {
            if isExternal(cl) {
                type(Type.Class())
                def type := "%panda$core$Class"
                types.printLine("\{name} = external global \{type}")
                result := ClassConstant(name, type)
            }
            else {
                def value := compiler.getClass(Type.Value())
                def valueVTable := compiler.getVTable(value)
                result := ClassConstant("\{escapeName(cl.name)}$wrapperclass", "<error>")
                def vtable := compiler.getVTable(cl)
                def superCC := getClassConstant(compiler.getClass(cl.rawSuper))
                def superCast := "(panda$core$Class*) &\{superCC.name}"
                def itable := getWrapperITable(cl)
                def clConstant := getClassConstant(compiler.getClass(Type.Class()))
                def code := MutableString("\{result.name}_type \{result.name} = { " +
                        "(panda$core$Class*) &\{clConstant.name}, 1, \{superCast}, \{itable}, { ")
                var separator := ""
                for i in 0 .. valueVTable.get_count() {
                    def m := vtable[i]
                    def methodName:String
                    if m.owner == cl {
                        methodName := createWrapperShim(m, wrapperShims)
                    }
                    else {
                        methodName := getName(m)
                        if isExternal(m.owner) {
                            writeDeclaration(m)
                        }
                    }
                    code.append("\{separator}\{methodName}")
                    separator := ", "
                }
                code.append("} };")
                types.print(code)
            }
            classConstants[name] := result
        }
        return result
    }

    function getName(v:Variable):String {
        if v.storage = Variable.Storage.PARAMETER {
            return "p_\{v.name}"
        }
        var result := variableNames[v]
        if result = null {
            varCount += 1
            result := "\{v.name}\{varCount}"
            variableNames[v] := result
        }
        return result
    }

    function getName(f:FieldDecl):String {
        assert f.annotations.isClass()
        return "\{escapeName(f.owner.name)}$\{f.name}"
    }

    class OpClass {
        constant SIGNED   := 10121
        constant UNSIGNED := 10122
        constant FLOAT    := 10123
    }

    function opClass(t:Type):Int {
        match t.typeKind {
            when Type.Kind.BUILTIN_INT:
                return OpClass.SIGNED
            when Type.Kind.BUILTIN_UINT, Type.Kind.BUILTIN_BIT:
                return OpClass.UNSIGNED
            when Type.Kind.BUILTIN_FLOAT:
                return OpClass.FLOAT
            otherwise:
                assert false
        }
    }

    method getAndReference(left:IRNode, right:IRNode, out:IndentedOutputStream):String {
        def result := nextVar()
        var leftRef := getReference(left, out)
        if left.type = Type.Bit() {
            leftRef := leftRef + ".value"
        }
        out.printLine("bool \{result} = \{leftRef};")
        def falseLabel := nextLabel()
        out.printLine("if (!\{result}) goto \{falseLabel};")
        var rightRef := getReference(right, out)
        if right.type = Type.Bit() {
            rightRef := rightRef + ".value"
        }
        out.printLine("\{result} = \{rightRef};")
        createBlock(falseLabel, out)
        return result
    }

    method getOrReference(left:IRNode, right:IRNode, out:IndentedOutputStream):String {
        def result := nextVar()
        var leftRef := getReference(left, out)
        if left.type = Type.Bit() {
            leftRef := leftRef + ".value"
        }
        out.printLine("bool \{result} = \{leftRef};")
        def trueLabel := nextLabel()
        out.printLine("if (\{result}) goto \{trueLabel};")
        var rightRef := getReference(right, out)
        if right.type = Type.Bit() {
            rightRef := rightRef + ".value"
        }
        out.printLine("\{result} = \{rightRef};")
        createBlock(trueLabel, out)
        return result
    }

    method getBinaryReference(cl:Int, t:Type, leftRef:String, op:Int, rightRef:String,
            out:IndentedOutputStream):String {
        def cOp:String
        var logical := false
        match op {
            when Token.Kind.ADD:
                cOp := "+"
            when Token.Kind.SUB:
                cOp := "-"
            when Token.Kind.MUL:
                cOp := "*"
            when Token.Kind.INTDIV:
                cOp := "/"
            when Token.Kind.DIV:
                cOp := "/"
            when Token.Kind.REM:
                cOp := "%"
            when Token.Kind.SHIFTLEFT:
                cOp := "<<"
            when Token.Kind.SHIFTRIGHT:
                cOp := ">>"
            when Token.Kind.BITWISEAND:
                cOp := "&"
            when Token.Kind.BITWISEOR:
                cOp := "|"
            when Token.Kind.XOR, Token.Kind.BITWISEXOR: 
                cOp := "^"
            when Token.Kind.EQ:
                cOp := "=="
                logical := true
            when Token.Kind.NEQ:
                cOp := "!="
                logical := true
            when Token.Kind.GT:
                cOp := ">"
                logical := true
            when Token.Kind.LT:
                cOp := "<"
                logical := true
            when Token.Kind.GTEQ:
                cOp := ">="
                logical := true
            when Token.Kind.LTEQ:
                logical := true
                cOp := "<="
            otherwise:
                assert false
        }
        def result := nextVar()
        if logical {
            out.print("bool ")
        }
        else {
            out.print("\{type(t)} ")
        }
        out.printLine("\{result} = \{leftRef} \{cOp} \{rightRef};")
        return result
    }

    method getIdentityReference(left:IRNode, right:IRNode, out:IndentedOutputStream):String {
        def leftRef := getReference(left, out)
        def rightRef := getReference(right, out)
        return "((panda$core$Bit) { \{leftRef} == \{rightRef} })"
    }

    method getNIdentityReference(left:IRNode, right:IRNode, out:IndentedOutputStream):String {
        def leftRef := getReference(left, out)
        def rightRef := getReference(right, out)
        return "((panda$core$Bit) { \{leftRef} != \{rightRef} })"
    }

    method getBinaryReference(left:IRNode, op:Int, right:IRNode, out:IndentedOutputStream):String {
        assert left.type = right.type
        match op {
            when Token.Kind.AND:       return getAndReference(left, right, out)
            when Token.Kind.OR:        return getOrReference(left, right, out)
            when Token.Kind.IDENTITY:  return getIdentityReference(left, right, out)
            when Token.Kind.NIDENTITY: return getNIdentityReference(left, right, out)
            otherwise:
                def leftRef := getReference(left, out)
                def rightRef := getReference(right, out)
                return getBinaryReference(opClass(left.type), left.type, leftRef, op, rightRef, out)
        }
    }

    method getBinaryReference(b:IRNode, out:IndentedOutputStream):String {
        assert b.kind = IRNode.Kind.BINARY
        assert b.children.get_count() = 2
        return getBinaryReference(b.children[0], b.payload->Int, b.children[1], out)
    }

    method getVirtualMethodReference(target:String, m:MethodDecl, out:IndentedOutputStream):String {
        def cc := getClassConstant(m.owner)
        var index := -1
        def vtable := compiler.getVTable(m.owner)
        for i in 0 .. vtable.get_count() {
            if vtable[i]->MethodDecl == m { -- FIXME unnecessary cast
                index := i
                break
            }
        }
        assert index != -1
        return "((\{type(compiler.inheritedTypeWithSelf(m))}) \{target}->$class->vtable[\{index}])"
    }

    method getInterfaceMethodReference(target:String, m:MethodDecl,
            out:IndentedOutputStream):String {
        def cc := getClassConstant(m.owner)
        def itable := nextVar()
        out.printLine("ITable* \{itable} = \{target}->$class->itable;")
        out.printLine("while (\{itable}->$class != (panda$core$Class*) &\{cc.name}) {")
        out.level += 1
        out.printLine("\{itable} = \{itable}->next;")
        out.level -= 1
        out.printLine("}")
        var index := -1
        def vtable := compiler.getVTable(m.owner)
        for i in 0 .. vtable.get_count() {
            if vtable[i]->MethodDecl == m { -- FIXME unnecessary cast
                index := i
                break
            }
        }
        index -= compiler.getVTable(compiler.getClass(Type.Object())).get_count()
        assert index != -1
        def result := nextVar()
        def methodType := type(compiler.inheritedTypeWithSelf(m))
        out.printLine("\{methodType} \{result} = \{itable}->methods[\{index}];")
        return result
    }

    method getMethodReference(target:String?, m:MethodDecl, isSuper:Bit,
            out:IndentedOutputStream):String {
        if !isSuper & m.isVirtual() {
            assert target != null, "calling instance \{m.signature()} without a target"
            if m.owner.classKind = ClassDecl.Kind.INTERFACE {
                return getInterfaceMethodReference(target, m, out)
            }
            else {
                return getVirtualMethodReference(target, m, out)
            }
        }
        else {
            if isExternal(m.owner) {
                writeDeclaration(m)
            }
            return getName(m)
        }
    }

    method getPointerCallReference(call:IRNode, out:IndentedOutputStream):String {
        def m := call.payload->MethodRef
        match m.value.name {
            when "alloc":
                assert call.children.get_count() = 1
                def count := getReference(call.children[0], out)
                assert m.returnType().subtypes.get_count() = 2
                def elementSize := sizeOf(m.returnType().subtypes[1])
                return "((\{type(call.type)}) malloc(\{count}.value * \{elementSize}))"
            when "get":
                assert call.children.get_count() = 1
                def ptr := getReference(call.children[0], out)
                return "(*\{ptr})"
            when "[]":
                assert call.children.get_count() = 2
                def ptr := getReference(call.children[0], out)
                def index := getReference(call.children[1], out)
                return "\{ptr}[\{index}.value]"
            when "realloc":
                assert call.children.get_count() = 2
                def ptr := getReference(call.children[0], out)
                def count := getReference(call.children[1], out)
                assert m.returnType().subtypes.get_count() = 2
                def elementSize := sizeOf(m.returnType().subtypes[1])
                return "((\{type(call.type)}) realloc(\{ptr}, \{count}.value * \{elementSize}))"
            when "offset":
                assert call.children.get_count() = 2
                def ptr := getReference(call.children[0], out)
                def offset := getReference(call.children[1], out)
                return "(\{ptr} + \{offset}.value)"
            otherwise:
                assert false
        }
    }

    method getCallReference(call:IRNode, out:IndentedOutputStream):String {
        assert call.kind = IRNode.Kind.CALL
        def m := (call.payload->MethodRef).value
        if m.owner.name = "panda.unsafe.Pointer" {
            return getPointerCallReference(call, out)
        }
        if isExternal(m.owner) {
            writeDeclaration(m)
        }
        if m.owner.name = "panda.core.Bit" {
            if m.name = "&" {
                assert call.children.get_count() = 2
                def bit := getAndReference(call.children[0], call.children[1], out)
                def result := nextVar()
                out.printLine("panda$core$Bit \{result} = { \{bit} };")
                return result
            }
            if m.name = "|" {
                assert call.children.get_count() = 2
                def bit := getOrReference(call.children[0], call.children[1], out)
                def result := nextVar()
                out.printLine("panda$core$Bit \{result} = { \{bit} };")
                return result
            }
        }
        def args := Array<String>(call.children.get_count())
        def actualMethodType:Type
        def actualResultType:String
        def isSuper := call.children.get_count() >= 1 & call.children[0].kind = IRNode.Kind.SUPER
        if !isSuper & m.isVirtual() {
            actualMethodType := compiler.inheritedType(m)
            actualResultType := type(actualMethodType.subtypes[actualMethodType.subtypes.get_count() - 1])
        }
        else {
            actualMethodType := compiler.declaredType(m)
            actualResultType := type(call.type)
        }
        def offset := call.children.get_count() - actualMethodType.subtypes.get_count() + 1
        for i in 0 .. call.children.get_count() {
            def arg := getReference(call.children[i], out)
            if i >= offset & actualMethodType.subtypes[i - offset] != call.children[i].type {
                arg := getCastReference(arg, call.children[i].type,
                        actualMethodType.subtypes[i - offset], out)
            }
            args.add(arg)
        }
        def target:String?
        if args.get_count() > 0 {
            -- this isn't actually correct - args[0] could be the target of an instance method, or
            -- just the first parameter to a class method. But getMethodReference ignores target for
            -- class methods, so this works and is easier than doing it the right way.
            target := args[0]
        }
        else {
            target := null
        }
        def methodRef := getMethodReference(target, m, isSuper, out)
        def indirect := needsStructIndirection(m)
        def result := nextVar()
        var separator := ""
        def indirectVar:String
        if indirect {
            methodHeader.printLine("\{actualResultType} \{result};")
            out.print("\{methodRef}(&\{result}")
            separator := ", "
        }
        else {
            out.print("\{actualResultType} \{result} = \{methodRef}(")
        }
        for arg in args {
            out.print("\{separator}\{arg}")
            separator := ", "
        }
        out.printLine(");")
        if type(call.type) != actualResultType {
            return getCastReference(result, 
                        actualMethodType.subtypes[actualMethodType.subtypes.get_count() - 1],
                        call.type,
                        out)
        }
        return result
    }

    method wrapValue(value:String, srcType:Type, dstType:Type, out:IndentedOutputStream):String {
        if srcType.typeKind = Type.Kind.NULLABLE {
            -- casting nullable value to nullable wrapper, need to special-case null
            def unwrapped := toNonNullableValue(value, srcType, srcType.subtypes[0], out)
            def nonNullValue := wrapValue(unwrapped, srcType.subtypes[0], dstType, out)
            return "(\{value}.nonnull ? \{nonNullValue} : NULL)"
        }
        def wrapped := "((\{type(dstType)}) wrap_\{escapeName(compiler.getClass(srcType).name)}" +
                "(\{value}))"
        if srcType.typeKind = Type.Kind.NULLABLE {
            return "(\{value}.nonnull ? \{wrapped} : NULL)"
        }
        return wrapped
    }

    method getFieldReference(fieldRef:IRNode, out:IndentedOutputStream):String {
        assert fieldRef.kind = IRNode.Kind.FIELD_REFERENCE
        assert fieldRef.children.get_count() = 1
        def field := fieldRef.payload->FieldDecl
        if field.annotations.isClass() {
            assert field.value != null
            return getReference(field.value, out)
        }
        def cl := compiler.getClass(fieldRef.children[0].type)
        writeImport(cl)
        def base := getReference(fieldRef.children[0], out)
        assert cl != null
        if compiler.isValue(cl) {
            return "\{base}.\{escapeName(field.name)}"
        }
        return "\{base}->\{escapeName(field.name)}"
    }

    method unwrapValue(value:String, srcType:Type, dstType:Type, out:IndentedOutputStream):String {
        def result := "((\{wrapperType(dstType)}) \{value})->value"
        if dstType.typeKind = Type.Kind.NULLABLE {
            -- casting nullable wrapper to nullable value, need to special-case null
            def wrapped := unwrapValue(value, srcType, dstType.subtypes[0], out)
            def nonNullValue := toNullableValue(wrapped, dstType.subtypes[0], dstType, out)
            return "(\{value} != NULL ? \{nonNullValue} : (\{type(dstType)}) { .nonnull = 0 })"
        }
        return result
    }

    method toNullableValue(value:String, srcType:Type, dstType:Type,
            out:IndentedOutputStream):String {
        return "((\{nullableType(dstType)}) { \{value}, true })"
    }

    method toNonNullableValue(value:String, srcType:Type, dstType:Type,
            out:IndentedOutputStream):String {
        return "((\{type(dstType)}) \{value}.value)"
    }

    method getCastReference(value:String, src:Type, target:Type, out:IndentedOutputStream):String {
        def op:String
        if target.isBuiltinNumber() {
            assert src.isBuiltinNumber()
            return "((\{type(target)}) \{value})"
        }
        else {
            def srcClass := compiler.getClass(src)
            assert srcClass != null
            def targetClass := compiler.getClass(target)
            assert targetClass != null
            if compiler.isValue(srcClass) & !compiler.isValue(targetClass) {
                return wrapValue(value, src, target, out)
            }
            else if !compiler.isValue(srcClass) & compiler.isValue(targetClass) {
                return unwrapValue(value, src, target, out)
            }
            else if compiler.isValue(srcClass) & target.typeKind = Type.Kind.NULLABLE &
                    target.subtypes[0] = src {
                return toNullableValue(value, src, target, out)
            }
            else if compiler.isValue(targetClass) & src.typeKind = Type.Kind.NULLABLE &
                    src.subtypes[0] = target {
                return toNonNullableValue(value, src, target, out)
            }
            op := "bitcast2"
        }
        def srcType := type(src)
        def dstType := type(target)
        if srcType = dstType {
            return value
        }
        return "((\{dstType}) \{value})"
    }

    method getCastReference(cast:IRNode, out:IndentedOutputStream):String {
        assert cast.kind = IRNode.Kind.CAST
        assert cast.children.get_count() = 1
        def base := getReference(cast.children[0], out)
        return getCastReference(base, cast.children[0].type, cast.type, out)
    }

    method getConstructReference(construct:IRNode, out:IndentedOutputStream):String {
        assert construct.kind = IRNode.Kind.CONSTRUCT
        assert construct.children.get_count() >= 1
        def cl := compiler.getClass(construct.type)
        assert cl != null
        def t := type(construct.type)
        if construct.type.isNumber() | construct.type = Type.Bit() {
            assert construct.children.get_count() = 1
            assert construct.children[0].children.get_count() = 1
            def value := getTypedReference(construct.children[0].children[0], out)
            return "((\{type(construct.type)}) { " + value + " })"
        }
        if compiler.isValue(cl) {
            varCount += 1
            def tmp := "$tmp\{varCount}"
            methodHeader.printLine("\{t} \{tmp};")
            writeCall(construct.children[0], "&\{tmp}", out)
            return tmp
        }
        def result := nextVar()
        out.printLine("\{type(construct.type)} \{result} = (\{type(construct.type)}) " +
                    "malloc(\{sizeOf(construct.type)});")
        def classPtr := nextVar()
        def className:String
        if construct.type.typeKind = Type.Kind.GENERIC {
            className := typeName(construct.type.subtypes[0])
        }
        else {
            className := typeName(construct.type)
        }
        out.printLine("\{result}->$class = (panda$core$Class*) &\{escapeName(cl.name)}$class;")
        out.printLine("\{result}->refCount.value = 1;")
        writeCall(construct.children[0], "\{result}", out)
        return result
    }

    method getIntReference(int:IRNode, out:IndentedOutputStream):String {
        return (int.payload->Int).convert() -- FIXME parens
    }

    method getNegatedIntReference(int:IRNode, out:IndentedOutputStream):String {
        return "-" + (int.payload->Int).convert() -- FIXME parens
    }

    method getBitReference(bit:IRNode, out:IndentedOutputStream):String {
        if bit.payload->Bit {
            return "true"
        }
        return "false"
    }

    method getVariableReference(v:Variable, out:IndentedOutputStream):String {
        return getName(v)
    }

    method getStringReference(s:String, out:IndentedOutputStream):String {
        varCount += 1
        def result := "$s\{varCount}"
        type(Type.StringType())
        strings.print("static panda$core$String \{result} = { " +
                "(panda$core$Class*) &panda$core$String$class, 2, (panda$core$Char8*) \"")
        for raw in s.utf8() {
            def c := raw.convert()->UInt8
            strings.print("\\x")
            strings.print("0123456789ABCDEF".utf8()[(c // 16).convert()])
            strings.print("0123456789ABCDEF".utf8()[(c % 16).convert()])
        }
        strings.printLine("\", \{s.utf8().get_count()}, 1 };")
        return "&\{result}"
    }

    method getSelfReference(s:IRNode, out:IndentedOutputStream):String {
        return "self"
    }

    method getSuperReference(s:IRNode, out:IndentedOutputStream):String {
        return "((\{type(s.type)}) self)"
    }

    method getIsNullReference(test:IRNode, out:IndentedOutputStream):String {
        assert test.kind = IRNode.Kind.IS_NULL
        assert test.children.get_count() = 1
        def value := getTypedReference(test.children[0], out)
        def cl := compiler.getClass(test.children[0].type)
        def bit:String
        if compiler.isValue(cl) {
            if test.children[0].type.typeKind != Type.Kind.NULLABLE {
                bit := "false"
            }
            else {
                bit := "!\{value}.nonnull"
            }
        }
        else {
            bit := "\{value} == NULL"
        }
        return "((panda$core$Bit) { \{bit} })"
    }

    method getIsNonNullReference(test:IRNode, out:IndentedOutputStream):String {
        assert test.kind = IRNode.Kind.IS_NONNULL
        assert test.children.get_count() = 1
        def value := getTypedReference(test.children[0], out)
        def cl := compiler.getClass(test.children[0].type)
        def bit:String
        if compiler.isValue(cl) {
            if test.children[0].type.typeKind != Type.Kind.NULLABLE {
                bit := "true"
            }
            else {
                bit := "\{value}.nonnull"
            }
        }
        else {
            bit := "\{value} != NULL"
        }
        return "((panda$core$Bit) { \{bit} })"
    }

    method getNullReference(expr:IRNode, out:IndentedOutputStream):String {
        assert expr.type.typeKind = Type.Kind.NULLABLE
        def cl := compiler.getClass(expr.type.subtypes[0])
        assert cl != null
        if compiler.isValue(cl) {
            return "((\{nullableType(expr.type)}) { .nonnull = false })"
        }
        else {
            return "NULL"
        }
    }

    method getPrefixReference(expr:IRNode, out:IndentedOutputStream):String {
        assert expr.kind = IRNode.Kind.PREFIX
        assert expr.children.get_count() = 1
        def base := getReference(expr.children[0], out)
        def result := nextVar()
        match (expr.payload->UInt64).convert()->Int64 {
            when Token.Kind.SUB:
                return "-\{base}"
            when Token.Kind.NOT:
                return "!\{base}"
            when Token.Kind.BITWISENOT:
                return "~\{base}"
            otherwise:
                assert false, expr.convert()
        }
    }

    method getReference(expr:IRNode, out:IndentedOutputStream):String {
        match expr.kind {
            when IRNode.Kind.BINARY:
                return getBinaryReference(expr, out)
            when IRNode.Kind.CALL:
                return getCallReference(expr, out)
            when IRNode.Kind.CAST:
                return getCastReference(expr, out)
            when IRNode.Kind.INT:
                return getIntReference(expr, out)
            when IRNode.Kind.NEGATED_INT:
                return getNegatedIntReference(expr, out)
            when IRNode.Kind.BIT:
                return getBitReference(expr, out)
            when IRNode.Kind.CONSTRUCT:
                return getConstructReference(expr, out)
            when IRNode.Kind.VARIABLE_REFERENCE:
                return getVariableReference(expr.payload->Variable, out)
            when IRNode.Kind.FIELD_REFERENCE:
                return getFieldReference(expr, out)
            when IRNode.Kind.STRING:
                return getStringReference(expr.payload->String, out)
            when IRNode.Kind.SELF:
                return getSelfReference(expr, out)
            when IRNode.Kind.SUPER:
                return getSuperReference(expr, out)
            when IRNode.Kind.REUSED_VALUE_DEFINITION:
                def value := getReference(expr.children[0], out)
                reusedValues[expr.payload->UInt64] := value
                return value
            when IRNode.Kind.REUSED_VALUE:
                def result := reusedValues[expr.payload->UInt64]
                assert result != null
                return result
            when IRNode.Kind.NULL:
                return getNullReference(expr, out)
            when IRNode.Kind.IS_NULL:
                return getIsNullReference(expr, out)
            when IRNode.Kind.IS_NONNULL:
                return getIsNonNullReference(expr, out)
            when IRNode.Kind.PREFIX:
                return getPrefixReference(expr, out)
            otherwise:
                assert false, "unsupported expression \{expr}:\{compiler.position(expr.offset)}"
        }
    }

    method getTypedReference(expr:IRNode, out:IndentedOutputStream):String {
        return getReference(expr, out)
    }

    method writeBlock(block:IRNode, out:IndentedOutputStream) {
        assert block.kind = IRNode.Kind.BLOCK
        out.printLine("{")
        out.level += 1
        for s in block.children {
            writeStatement(s, out)
        }
        out.level -= 1
        out.printLine("}")
    }

    method writePointerCall(stmt:IRNode, out:IndentedOutputStream) {
        def m := stmt.payload->MethodRef
        match m.value.name {
            when "set":
                assert stmt.children.get_count() = 2
                def ptr := getTypedReference(stmt.children[0], out)
                def arg := getTypedReference(compiler.unwrapCast(stmt.children[1]), out)
                out.printLine("store2 \{arg}, \{ptr}")
            when "[]:=":
                assert stmt.children.get_count() = 3
                assert compiler.unwrapCast(stmt.children[0]).type.subtypes.get_count() = 2
                def base := getReference(stmt.children[0], out)
                def index := getReference(stmt.children[1], out)
                def value := getReference(compiler.unwrapCast(stmt.children[2]), out)
                out.printLine("\{base}[\{index}.value] = \{value};")
            when "destroy":
                assert stmt.children.get_count() = 1
                out.printLine("free(\{getReference(stmt.children[0], out)});")
            otherwise:
                assert false
        }
    }

    -- if 'target' is non-null, it is inserted as a hidden first parameter to the call. This is used
    -- for init() calls, which require a self parameter but do not have a target in the IR.
    method writeCall(call:IRNode, target:String?, out:IndentedOutputStream) {
        assert call.kind = IRNode.Kind.CALL
        def m := (call.payload->MethodRef).value
        if m.owner.name = "panda.unsafe.Pointer" {
            writePointerCall(call, out)
            return
        }
        if isExternal(m.owner) {
            writeDeclaration(m)
        }
        def actualMethodType:Type
        def actualResultType:String
        def isSuper := call.children.get_count() >= 1 & call.children[0].kind = IRNode.Kind.SUPER
        if !isSuper & m.isVirtual() {
            actualMethodType := compiler.inheritedType(m)
            actualResultType := type(actualMethodType.subtypes[actualMethodType.subtypes.get_count() - 1])
        }
        else {
            actualMethodType := compiler.declaredType(m)
            actualResultType := type(call.type)
        }
        def args := Array<String>()
        if target != null {
            args.add(target)
        }
        def offset := call.children.get_count() - actualMethodType.subtypes.get_count() + 1
        for i in 0 .. call.children.get_count() {
            var arg := getReference(call.children[i], out)
            if i >= offset & actualMethodType.subtypes[i - offset] != call.children[i].type {
                arg := getCastReference(arg, call.children[i].type,
                            actualMethodType.subtypes[i - offset], out)
            }
            args.add(arg)
        }
        def refTarget:String?
        if args.get_count() > 0 {
            -- this isn't actually correct - args[0] could be the target of an instance method, or
            -- just the first parameter to a class method. But getMethodReference ignores target for
            -- non-virtual methods, so this works and is easier than doing it the right way.
            refTarget := args[0]
        }
        else {
            refTarget := null
        }
        def methodRef := getMethodReference(refTarget, m, isSuper, out)
        var separator := ""
        if needsStructIndirection(m) {
            varCount += 1
            def indirectVar := "$tmp" + varCount
            def resultType := type(call.type)
            methodHeader.printLine("\{resultType} \{indirectVar};")
            out.print("\{methodRef}(\{resultType}* \{indirectVar}")
            separator := ", "
        }
        else {
            out.print("\{methodRef}(")
        }
        for a in args {
            out.print(separator)
            out.print(a)
            separator := ", "
        }
        out.printLine(");")
    }

    method writeIf(s:IRNode, out:IndentedOutputStream) {
        assert s.kind = IRNode.Kind.IF
        assert s.children.get_count() = 2 | s.children.get_count() = 3
        assert s.children[0].type = Type.Bit()
        def test := getReference(s.children[0], out)
        out.printLine("if (\{test}.value) {")
        writeStatement(s.children[1], out)
        out.printLine("}")
        if s.children.get_count() = 3 {
            out.printLine("else {")
            writeStatement(s.children[2], out)
            out.printLine("}")
        }
    }

    method writeRangeFor(f:IRNode, out:IndentedOutputStream) {
        -- See LLVMCodeGenerator.writeRangeFor for an overview of why this code is so terrible.
        -- Here, we double down on the awful by keeping the LLVM structure completely intact and
        -- using gotos instead of anything resembling idiomatic C code, mostly to help ensure the
        -- behavior is identical.
        assert f.kind = IRNode.Kind.RANGE_FOR
        assert f.children.get_count() = 3
        def target := f.children[0]
        assert f.children[1].type.typeKind = Type.Kind.GENERIC
        assert f.children[1].type.subtypes.get_count() = 2
        assert f.children[1].type.subtypes[0].name = Compiler.RANGE_NAME
        def range := getTypedReference(f.children[1], out)
        def block := f.children[2]
        def t := f.children[1].type.subtypes[1]
        def llt := type(t)
        def indexType:String
        if t.typeKind = Type.Kind.NULLABLE {
            assert t.subtypes.get_count() = 1
            indexType := type(t.subtypes[0])
        }
        else {
            indexType := llt
        }
        def cl := compiler.getClass(t)
        assert cl != null
        assert compiler.instanceFields(cl).get_count() = 1
        def field := compiler.instanceFields(cl)[0]
        compiler.resolve(field)
        def numberType := type(field.type)
        assert target.kind = IRNode.Kind.VARIABLE_REFERENCE
        def index := getName(target.payload->Variable)

        -- extract start value from range
        def start := nextVar()
        out.printLine("\{numberType} \{start} = \{range}.start.value;")

        -- store start value
        def indexValuePtr := nextVar()
        out.printLine("\{type(cl.type())} \{index} = { \{start} };")

        -- extract end value from range
        def end := nextVar()
        out.printLine("\{numberType} \{end} = \{range}.end.value;")

        -- extract step value from range
        def step := nextVar()
        out.printLine("\{numberType} \{step} = \{range}.step.value;")

        -- extract inclusive / exclusive from range
        def inclusive := nextVar()
        out.printLine("bool \{inclusive} = \{range}.inclusive.value;")

        -- start block
        def loopStart := nextLabel()
        def loopBody := nextLabel()
        def loopEnd := nextLabel()
        def loopTest := nextLabel()
        loopDescriptors.push(LoopDescriptor(f.payload->String?, loopEnd, loopTest)) -- FIXME Auto
        def forwardEntry := nextLabel()
        def backwardEntry := nextLabel()
        def signPrefix:String
        if t.name.startsWith("panda.core.Int") {
            signPrefix := "s"
        }
        else {
            assert t.name.startsWith("panda.core.UInt") | t.name.startsWith("panda.core.Char")
            signPrefix := "u"
        }
        def direction:String
        if signPrefix = "s" {
            direction := nextVar()
            out.printLine("bool \{direction} = \{step} > 0;")
        }
        else {
            direction := "true"
        }
        out.printLine("if (\{direction}) goto \{forwardEntry}; else goto \{backwardEntry};")
        createBlock(forwardEntry, out)
        def forwardEntryInclusive := nextLabel()
        def forwardEntryExclusive := nextLabel()
        out.printLine("if (\{inclusive}) goto \{forwardEntryInclusive}; else goto " +
                "\{forwardEntryExclusive};")
        createBlock(forwardEntryInclusive, out)
        out.printLine("if (\{start} <= \{end}) goto \{loopStart}; else goto \{loopEnd};")
        createBlock(forwardEntryExclusive, out)
        out.printLine("if (\{start} < \{end}) goto \{loopStart}; else goto \{loopEnd};")
        createBlock(backwardEntry, out)
        def backwardEntryInclusive := nextLabel()
        def backwardEntryExclusive := nextLabel()
        out.printLine("if (\{inclusive}) goto \{backwardEntryInclusive}; else goto " +
                "\{backwardEntryExclusive};")
        createBlock(backwardEntryInclusive, out)
        out.printLine("if (\{start} >= \{end}) goto \{loopStart}; else goto \{loopEnd};")
        createBlock(backwardEntryExclusive, out)
        def backwardEntryExclusiveTest := nextVar()
        out.printLine("if (\{start} > \{end}) goto \{loopStart}; else goto \{loopEnd};")
        createBlock(loopStart, out)
        writeStatement(block, out)
        createBlock(loopTest, out)
        def loopInc := nextLabel()
        -- beginning of loop test, determine direction
        def forwardLabel := nextLabel()
        def backwardLabel := nextLabel()
        out.printLine("if (\{direction}) goto \{forwardLabel}; else goto \{backwardLabel};")

        -- forward loop; perform the test by subtracting index from end and then comparing to step,
        -- to avoid overflows near the maximum value
        createBlock(forwardLabel, out)
        def forwardDelta := nextVar()
        out.printLine("\{numberType} \{forwardDelta} = \{end} - \{index}.value;")

        -- forward loop; determine inclusive / exclusive
        def forwardInclusiveLabel := nextLabel()
        def forwardExclusiveLabel := nextLabel()
        out.printLine("if (\{inclusive}) goto \{forwardInclusiveLabel}; else goto " +
                "\{forwardExclusiveLabel};")

        -- forward inclusive test
        createBlock(forwardInclusiveLabel, out)
        -- always use unsigned comparison to avoid overflow; we know both the delta and the step are
        -- the same sign
        out.printLine("if (\{forwardDelta} >= \{step}) goto \{loopInc}; else goto \{loopEnd};")

        -- forward exclusive test
        createBlock(forwardExclusiveLabel, out)
        def forwardExclusiveTest := nextVar()
        out.printLine("if (\{forwardDelta} > \{step}) goto \{loopInc}; else goto \{loopEnd};")

        -- backward loop; perform the test by subtracting end from index and then comparing to
        -- -step, to avoid overflows near the minimum value
        createBlock(backwardLabel, out)
        def backwardDelta := nextVar()
        out.printLine("\{numberType} \{backwardDelta} = \{index}.value - \{end};")

        -- backward loop; determine inclusive / exclusive
        def backwardInclusiveLabel := nextLabel()
        def backwardExclusiveLabel := nextLabel()
        out.printLine("if (\{inclusive}) goto \{backwardInclusiveLabel}; else goto " +
                "\{backwardExclusiveLabel};")

        -- backward inclusive test
        createBlock(backwardInclusiveLabel, out)
        out.printLine("if (\{backwardDelta} >= -\{step}) goto \{loopInc}; else goto \{loopEnd};")

        -- backward exclusive test
        createBlock(backwardExclusiveLabel, out)
        out.printLine("if (\{backwardDelta} > -\{step}) goto \{loopInc}; else goto \{loopEnd};")

        createBlock(loopInc, out)
        def inc := nextVar()
        out.printLine("\{index}.value += \{step};")
        out.printLine("goto \{loopStart};")
        createBlock(loopEnd, out)
        loopDescriptors.pop()
    }

    method writeWhile(w:IRNode, out:IndentedOutputStream) {
        assert w.kind = IRNode.Kind.WHILE
        assert w.children.get_count() = 2
        assert w.children[0].type = Type.Bit()
        def loopStart := nextLabel()
        def loopEnd := nextLabel()
        loopDescriptors.push(LoopDescriptor(w.payload->String?, loopEnd, loopStart)) -- FIXME Auto
        createBlock(loopStart, out)
        out.printLine("if (!\{getReference(w.children[0], out)}.value) goto \{loopEnd};")
        writeStatement(w.children[1], out)
        out.printLine("goto \{loopStart};")
        createBlock(loopEnd, out)
        loopDescriptors.pop()

    }

    method writeDo(d:IRNode, out:IndentedOutputStream) {
        assert d.kind = IRNode.Kind.DO
        assert d.children.get_count() = 2
        assert d.children[1].type = Type.Bit()
        def loopStart := nextLabel()
        def loopEnd := nextLabel()
        loopDescriptors.push(LoopDescriptor(d.payload->String?, loopEnd, loopStart)) -- FIXME Auto
        createBlock(loopStart, out)
        writeStatement(d.children[0], out)
        out.printLine("if (\{getReference(d.children[1], out)}.value) goto \{loopStart};")
        createBlock(loopEnd, out)
        loopDescriptors.pop()
    }

    method writeLoop(l:IRNode, out:IndentedOutputStream) {
        assert l.kind = IRNode.Kind.LOOP
        assert l.children.get_count() = 1
        def loopStart := nextLabel()
        def loopEnd := nextLabel()
        loopDescriptors.push(LoopDescriptor(l.payload->String?, loopEnd, loopStart))
        createBlock(loopStart, out)
        out.printLine("while (true) {")
        writeStatement(l.children[0], out)
        out.printLine("}")
        createBlock(loopEnd, out)
        loopDescriptors.pop()
    }

    method writeVarTarget(target:IRNode, value:IRNode?, out:IndentedOutputStream) {
        match target.kind {
            when IRNode.Kind.VARIABLE_REFERENCE:
                def v := target.payload->Variable
                methodHeader.printLine("\{type(v.type)} \{getName(v)};")
                if value != null {
                    out.printLine("\{getName(v)} = \{getReference(value, out)};")
                }
            when IRNode.Kind.TUPLE_TARGET:
                assert false
            otherwise:
                assert false
        }
    }

    method writeVar(v:IRNode, out:IndentedOutputStream) {
        assert v.kind = IRNode.Kind.VAR |
                v.kind = IRNode.Kind.DEF |
                v.kind = IRNode.Kind.PROPERTY |
                v.kind = IRNode.Kind.CONSTANT
        for decl in v.children {
            assert decl.kind = IRNode.Kind.DECLARATION
            if decl.children.get_count() > 1 {
                writeVarTarget(decl.children[0], decl.children[1], out)
            }
            else {
                writeVarTarget(decl.children[0], null, out)
            }
        }
    }

    method getLValue(lvalue:IRNode, out:IndentedOutputStream):String {
        match lvalue.kind {
            when IRNode.Kind.CAST:
                return getLValue(compiler.unwrapCast(lvalue), out)
            when IRNode.Kind.VARIABLE_REFERENCE:
                return getName(lvalue.payload->Variable)
            when IRNode.Kind.FIELD_REFERENCE:
                def base := getReference(lvalue.children[0], out)
                return "\{base}->\{(lvalue.payload->FieldDecl).name}" -- FIXME parens
            when IRNode.Kind.REUSED_VALUE_DEFINITION:
                def result := getLValue(lvalue.children[0], out)
                reusedValues[lvalue.payload->UInt64] := result
                return result
            otherwise:
                assert false, "unsupported lvalue: \{lvalue}"
        }
    }

    method writeAssignment(a:IRNode, out:IndentedOutputStream) {
        assert a.kind = IRNode.Kind.BINARY
        assert a.children.get_count() = 2
        def lvalue := getLValue(a.children[0], out)
        def value:String
        def t := type(a.children[0].type)
        def op := a.payload->Int
        if op = Token.Kind.ASSIGNMENT {
            def right := getReference(a.children[1], out)
            value := right
        }
        else {
-*            Operator binOp;
            switch (op) {
                case Operator.ADDEQ:        binOp = Operator.ADD;                         break;
                case Operator.SUBEQ:        binOp = Operator.SUB;                         break;
                case Operator.MULEQ:        binOp = Operator.MUL;                         break;
                case Operator.DIVEQ:        binOp = Operator.DIV;                         break;
                case Operator.INTDIVEQ:     binOp = Operator.INTDIV;                      break;
                case Operator.REMEQ:        binOp = Operator.REM;                         break;
                case Operator.POWEQ:        binOp = Operator.POW;                         break;
                case Operator.XOREQ:        binOp = Operator.XOR;                         break;
                case Operator.BITWISEOREQ:  binOp = Operator.BITWISEOR;                   break;
                case Operator.BITWISEANDEQ: binOp = Operator.BITWISEAND;                  break;
                case Operator.BITWISEXOREQ: binOp = Operator.BITWISEXOR;                  break;
                case Operator.SHIFTLEFTEQ:  binOp = Operator.SHIFTLEFT;                   break;
                case Operator.SHIFTRIGHTEQ: binOp = Operator.SHIFTRIGHT;                  break;
                case Operator.ANDEQ:        this->writeAndEq(lvalue, a.fChildren[1], out); return;
                case Operator.OREQ:         this->writeOrEq(lvalue, a.fChildren[1], out);  return;
                default: abort();
            }
            def left := nextVar()
            out << "    " << left << " = load12 " << this->llvmType(a.fChildren[0].fType) << ", " <<
                    lvalue << "\n";
            String right = this->getReference(a.fChildren[1], out);
            value = type + " " +
                    this->getBinaryReference(op_class(a.fChildren[0].fType), type + " " + left, binOp,
                            right, out);
            *-
            assert false
        }
        out.printLine("\{lvalue} = \{value};")
    }

    method writeReturn(r:IRNode, out:IndentedOutputStream) {
        if r.children.get_count() = 1 {
            out.printLine("return \{getReference(r.children[0], out)};")
        }
        else {
            assert r.children.get_count() = 0
            out.printLine("return;")
        }
    }

    function findLoop(name:String?):LoopDescriptor {
        assert loopDescriptors.get_count() > 0
        if name = null {
            return loopDescriptors.peek()
        }
        for i in 0 .. loopDescriptors.get_count() {
            if loopDescriptors.peek(i).loopLabel != null & loopDescriptors.peek(i).loopLabel = name { -- FIXME shouldn't need null check
                return loopDescriptors.peek(i)
            }
        }
        assert false
    }

    method writeBreak(b:IRNode, out:IndentedOutputStream) {
        def desc := findLoop(b.payload->String?)
        out.printLine("goto \{desc.breakLabel};")
    }

    method writeContinue(c:IRNode, out:IndentedOutputStream) {
        def desc := findLoop(c.payload->String?)
        out.printLine("goto \{desc.continueLabel};")
    }

    method writeAssert(a:IRNode, out:IndentedOutputStream) {
        assert a.kind = IRNode.Kind.ASSERT
        assert a.children.get_count() = 1 | a.children.get_count() = 2
        out.printLine("PANDA_ASSERT(\{getReference(a.children[0], out)});")
    }

    method writeMatch(m:IRNode, out:IndentedOutputStream) {
        out.printLine("switch (\{getReference(m.children[0], out)}.value) {")
        out.level += 1
        for i in 1 .. m.children.get_count() {
            def w := m.children[i]
            if w.kind = IRNode.Kind.WHEN {
                for j in 0 .. w.children.get_count() - 1 {
                    out.printLine("case \{compiler.getConstantInt(w.children[j])}:")
                }
                writeBlock(w.children[w.children.get_count() - 1], out)
                out.printLine("break;")
            }
            else {
                assert w.kind = IRNode.Kind.OTHERWISE
                assert w.children.get_count() = 1
                out.printLine("default:")
                writeBlock(w.children[0], out)
            }
        }
        out.level -= 1
        out.printLine("}")
    }

    method writeStatement(stmt:IRNode, out:IndentedOutputStream) {
        match stmt.kind {
            when IRNode.Kind.BINARY:
                writeAssignment(stmt, out)
            when IRNode.Kind.BLOCK:
                writeBlock(stmt, out)
            when IRNode.Kind.CALL:
                writeCall(stmt, null, out)
            when IRNode.Kind.IF:
                writeIf(stmt, out)
            when IRNode.Kind.RANGE_FOR:
                writeRangeFor(stmt, out)
            when IRNode.Kind.WHILE:
                writeWhile(stmt, out)
            when IRNode.Kind.DO:
                writeDo(stmt, out)
            when IRNode.Kind.LOOP:
                writeLoop(stmt, out)
            when IRNode.Kind.VAR, IRNode.Kind.DEF, IRNode.Kind.CONSTANT, IRNode.Kind.PROPERTY:
                writeVar(stmt, out)
            when IRNode.Kind.RETURN:
                writeReturn(stmt, out)
            when IRNode.Kind.BREAK:
                writeBreak(stmt, out)
            when IRNode.Kind.CONTINUE:
                writeContinue(stmt, out)
            when IRNode.Kind.ASSERT:
                writeAssert(stmt, out)
            when IRNode.Kind.MATCH:
                writeMatch(stmt, out)
            otherwise:
                assert false, "unsupported statement \{stmt.kind}"
        }
    }

    method selfType(m:MethodDecl):String {
        def result := type(m.owner.type())
        if m.methodKind = MethodDecl.Kind.INIT & !result.endsWith("*") {
            return result + "*"
        }
        return result
    }

    @override
    method writeDeclaration(m:MethodDecl) {
        writeImport(m.owner)
    }

    @override
    method write(m:MethodDecl, body:IRNode) {
        assert compiler.currentClass.peek() == m.owner
        currentMethod := m
        currentBlock := "0"
        methodHeaderBuffer.clear()
        methods.print("\{type(m.returnType)} \{getName(m)}(")
        var separator := ""
        if !m.annotations.isClass() {
            methods.print("\{selfType(m)} self")
            separator := ", "
        }
        for p in m.parameters {
            methods.print("\{separator}\{type(p.type)} p_\{escapeName(p.name)}")
            separator := ", "
        }
        methods.printLine(") {")
        methods.level += 1
        assert body.kind = IRNode.Kind.BLOCK
        def bodyBuffer := MemoryOutputStream()
        def indentedBody := IndentedOutputStream(bodyBuffer)
        for s in body.children {
            writeStatement(s, indentedBody)
        }
        methods.print(methodHeaderBuffer.convert())
        methods.print(bodyBuffer.convert())
        methods.level -= 1
        methods.printLine("}")
        currentMethod := null
    }

    @override
    method start(cl:ClassDecl) {
        assert currentClass = null
        currentClass := cl
        imports.clear()
        strings.clear()
        declarations.clear()
        types.clear()
        methodsBuffer.clear()
        wrapperShimsBuffer.clear()
        shimsBuffer.clear()
        declared.clear()
        writtenTypes.clear()
        writtenWrappers.clear()
        classConstants.clear()
        variableNames.clear()
        varCount := 0
        reusedValues.clear()
        methodShims.clear()
        def path := hCodeGen.getPath(cl, ".c")
        path.parent().createDirectories()
        out := IndentedOutputStream(path.openOutputStream())
        getClassConstant(cl)
        if compiler.isValue(cl) {
            getWrapperClassConstant(cl)
            out.printLine("\{escapeName(cl.name)}$wrapper* wrap_\{escapeName(cl.name)}(" +
                    "\{escapeName(cl.name)} self) {")
            out.printLine("    \{escapeName(cl.name)}$wrapper* result = " +
                    "(\{escapeName(cl.name)}$wrapper*) malloc(\{sizeOfWrapper(cl.type())});")
            out.printLine("    result->cl = (panda$core$Class*) " +
                    "&\{escapeName(cl.name)}$wrapperclass;")
            out.printLine("    result->value = self;")
            out.printLine("    return result;")
            out.printLine("}")
        }
    }

    @override
    method end(cl:ClassDecl) {
        finish()
        currentClass := null
    }

    @override
    method finish() {
        out.printLine(shimsBuffer)
        out.printLine(wrapperShimsBuffer)
        out.printLine(types)
        out.printLine(strings)
        out.printLine(methodsBuffer)
        out.out.cleanup() -- FIXME shouldn't be necessary
    }
}