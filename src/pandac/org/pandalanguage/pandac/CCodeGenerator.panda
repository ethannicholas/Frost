package org.pandalanguage.pandac

uses org.pandalanguage.pandac.parser.Token

-- Note that the C code produced by this CodeGenerator is not quite compatible with the output of
-- the LLVM code generator due to slight ABI differences in how structures are passed and the use
-- of fastcc on the LLVM side of things. As this CodeGenerator is only intended to produce the
-- bootstrap compiler and does not interoperate in any way with LLVM code, this should not present
-- any problems, but is still something to be aware of.
@final
class CCodeGenerator : CodeGenerator {
    choice EnclosingContext {
        LOOP(String? -* label *-, String -* break target *-, String -* continue target *-)
        FINALLY(String -* label *-,
                Map<String, Pair<Int, String>> -* map from source label to (block id, return label) *-,
                String -* variable holding numeric id of block which jumped to finally block *-)
    }

    class AutoContext {
        def cg:CCodeGenerator

        def context:EnclosingContext

        init(cg:CCodeGenerator, context:EnclosingContext) {
            self.cg := cg
            self.context := context
            cg.enclosingContexts.push(context)
        }

        @override
        method cleanup() {
            cg.enclosingContexts.pop(context)
        }
    }

    constant NO_REFCNT := -999

    @weak
    var compiler:Compiler?

    def outDir:File

    def out:IndentedOutputStream

    def strings := MemoryOutputStream()

    def imports := HashSet<String>()

    @weak
    def hCodeGen:HCodeGenerator

    def hCodeGenRetain:HCodeGenerator?

    var currentClass:ClassDecl? := null

    init(outDir:File) {
        hCodeGenRetain := HCodeGenerator(outDir, self)
        init(outDir, hCodeGenRetain)
    }

    init(outDir:File, hCodeGen:HCodeGenerator) {
        self.outDir := outDir
        self.out := IndentedOutputStream(MemoryOutputStream())
        self.hCodeGen := hCodeGen
    }

    function escapeName(s:String):String {
        return hCodeGen.escapeName(s)
    }

    function getName(m:MethodDecl):String {
        return hCodeGen.getName(m)
    }

    function sizeOf(t:Type):Int {
        return hCodeGen.sizeOf(t)
    }

    function isExternal(cl:ClassDecl):Bit {
        return cl !== currentClass
    }

    method writeImport(cl:ClassDecl) {
        if cl.name = "panda.unsafe.Pointer" {
            return
        }
        def includePath := hCodeGen.getRelativePath(cl, ".h")
        if !imports.contains(includePath) {
            out.printLine("#include \"\{includePath}\"")
            imports.add(includePath)
        }
    }

    method type(t:Type):String {
        if t.isClass() {
            def cl := compiler.getClass(t)
            assert cl != null
            writeImport(cl)
        }
        if t.typeKind = Type.Kind.METHOD | t.typeKind = Type.Kind.FUNCTION {
            return type(Type.MutableMethod())
        }
        if t.typeKind = Type.Kind.IMMUTABLE_METHOD | t.typeKind = Type.Kind.IMMUTABLE_FUNCTION {
            return type(Type.Method())
        }
        return hCodeGen.type(t)
    }

    @pre(t.typeKind = Type.Kind.FUNCTION | t.typeKind = Type.Kind.METHOD |
            t.typeKind = Type.Kind.IMMUTABLE_FUNCTION | t.typeKind = Type.Kind.IMMUTABLE_METHOD)
    method methodType(t:Type, selfType:Type?):String {
        varCount += 1
        def result := "$fn\{varCount}"
        def code := MutableString("typedef ")
        code.append(type(t.subtypes[t.subtypes.count - 1]))
        code.append(" (*")
        code.append(result)
        code.append(")(")
        var separator := ""
        if selfType != null {
            code.append(type(selfType))
            separator := ", "
        }
        for i in 0 .. t.subtypes.count - 1 {
            code.append(separator)
            code.append(type(t.subtypes[i]))
            separator := ", "
        }
        code.append(");")
        types.printLine(code.finish())
        return result
    }

    @override
    method setCompiler(compiler:Compiler) {
        self.compiler := compiler
        hCodeGen.setCompiler(compiler)
    }

    class ClassConstant : Immutable {
        def name:String
        def type:String

        init(name:String, type:String) {
            self.name := name
            self.type := type
        }
    }

    class MethodShim {
        def name:String
        def type:String

        init(name:String, type:String) {
            self.name := name
            self.type := type
        }
    }

    constant POINTER_SIZE        := 8
    constant OBJECT_FIELD_COUNT  := 2
    constant CLASS_POINTER_INDEX := 0
    constant ITABLE_INDEX        := 2
    constant VTABLE_INDEX        := 3

    constant INT_TYPE  := "i64"
    constant SIZE_TYPE := "i64"

    def declarations := MemoryOutputStream()

    def types := MemoryOutputStream()

    def methodsBuffer := MemoryOutputStream()

    def methods := IndentedOutputStream(methodsBuffer)

    def methodHeaderBuffer := MemoryOutputStream()

    def methodHeader := IndentedOutputStream(methodHeaderBuffer)

    def shimsBuffer := MemoryOutputStream()

    def shims := IndentedOutputStream(shimsBuffer)

    def declared := HashSet<String>()

    def writtenTypes := HashSet<String>()

    def writtenWrappers := HashSet<String>()

    def classConstants := HashMap<String, ClassConstant>()

    def variableNames := IdentityMap<Variable, String>()

    var currentBlock:String

    var currentMethod:MethodDecl?

    var returnValueVar:String?

    def enclosingContexts := Stack<EnclosingContext>()

    var varCount := 0

    def reusedValues := HashMap<Int, String>()

    def methodShims := IdentityMap<MethodDecl, MethodShim>()

    method nextVar():String {
        varCount += 1
        return "$tmp\{varCount}"
    }

    method nextLabel():String {
        varCount += 1
        return "$l\{varCount}"
    }

    method createBlock(label:String, out:IndentedOutputStream) {
        out.printLine("\{label}:;")
        currentBlock := label
    }

    function fieldSize(t:Type):Int {
        assert t.resolved
        if t.isBuiltinNumber() {
            if t.name.endsWith("8") {
                return 1
            }
            if t.name.endsWith("16") {
                return 2
            }
            if t.name.endsWith("32") {
                return 4
            }
            assert t.name.endsWith("64")
            return 8
        }
        if t = Type.BuiltinBit() {
            return 1
        }
        def cl := compiler.getClass(t)
        assert cl != null
        if !compiler.isValue(cl) | cl.name = "panda.unsafe.Pointer" {
            return POINTER_SIZE
        }
        var result := 0
        for f in compiler.instanceFields(cl) {
            if f.annotations.isClass() {
                continue
            }
            compiler.resolve(f)
            if f.type = Type.ChoiceData() {
                -- FIXME need to respect alignment!
                result += hCodeGen.llvmCodeGen.getChoiceDataSize(cl)
            }
            else {
                def size := fieldSize(f.type)
                def align := result % size
                if align != 0 {
                    result += size - align
                }
                assert result % size = 0
                result += size
            }
        }
        if t.typeKind = Type.Kind.NULLABLE {
            result += 1
        }
        return result
    }

    function alignment(t:Type):Int {
        return fieldSize(t).min(8)
    }

    function sizeOfWrapper(t:Type):Int {
        def cl := compiler.getClass(t)
        assert cl != null & compiler.isValue(cl)
        var result := sizeOf(Type.Object())
        for f in compiler.instanceFields(cl) {
            compiler.resolve(f)
            if f.type = Type.ChoiceData() {
                -- FIXME need to respect alignment!
                result += hCodeGen.llvmCodeGen.getChoiceDataSize(cl)
            }
            else {
                def size := fieldSize(f.type)
                def align := result % size
                if align != 0 {
                    result += size - align
                }
                assert result % size = 0
                result += size
            }
        }
        if t.typeKind = Type.Kind.NULLABLE {
            result += 1
        }
        return result
    }

    method writeType(t:Type) {
        if writtenTypes.contains(t.name) {
            return
        }
    }

    function typeName(t:Type):String {
        return escapeName(t.name)
    }

    method wrapperTypeName(t:Type):String {
        if t.typeKind = Type.Kind.NULLABLE {
            return wrapperTypeName(t.subtypes[0])
        }
        return "\{escapeName(t.name)}$wrapper"
    }

    method wrapperType(t:Type):String {
        return wrapperTypeName(t) + "*"
    }

    method wrapperType(m:MethodDecl):String {
        def inheritedType := compiler.inheritedType(m)
        def result := MutableString()
        result.append(type(inheritedType.returnType()))
        result.append("(")
        assert m.isInstance()
        result.append("\{escapeName(m.owner.name)}")
        if compiler.isValue(m.owner) {
            result.append("$wrapper")
        }
        result.append("*")
        for i in 0 .. inheritedType.subtypes.count - 1 { 
            result.append(", ")
            result.append(type(inheritedType.subtypes[i]))
        }
        result.append(")*")
        return result.finish()
    }

    method nullableType(t:Type):String {
        assert t.typeKind = Type.Kind.NULLABLE, "\{t} is not nullable"
        return "\{type(t.subtypes[0])}$nullable"
    }

    method getITable(cl:ClassDecl):String {
        def interfaces := compiler.allInterfaces(cl.type)
        var previous := "NULL"
        for intfType in interfaces {
            def intf := compiler.getClass(intfType)
            def intfCC := getClassConstant(intf)
            def methods := compiler.interfaceMethods(cl, intfType)
            def name := "\{escapeName(cl.name)}$_\{escapeName(intf.name)}"
            def result := MutableString("struct { \{type(Type.Class())} cl; ITable* next; " +
                    "void* methods[\{methods.count}]; } \{name} = { " +
                    "(panda$core$Class*) &\{intfCC.name}, \{previous}, { ")
            var separator := ""
            for m in methods {
                result.append(separator)
                separator := ", "
                if m.annotations.isAbstract() {
                    result.append("NULL")
                }
                else {
                    result.append(getMethodTableEntry(m))
                }
            }
            result.append("} };\n")
            types.printLine(result.finish())
            previous := "(ITable*) &\{name}"
        }
        return previous
    }

    method createMethodShim(raw:MethodDecl, effective:Type, rawOut:OutputStream):MethodShim {
        def outBuffer := MemoryOutputStream()
        def out := IndentedOutputStream(outBuffer)
        def found := methodShims[raw]
        if found != null {
            return found
        }
        assert effective.isMethod()
        assert effective.subtypes.count = raw.parameters.count + 2 -- self and return
        assert raw.isInstance()
        def effectiveReturnType := effective.returnType()
        def resultName := getName(raw) + "$shim"
        def resultType := MutableString(type(effectiveReturnType))
        out.print("__attribute__((weak)) \{resultType} \{resultName}(")
        resultType.append("(")
        var separator := ""
        for i in 0 .. effective.subtypes.count - 1 {
            def pType := type(effective.subtypes[i])
            resultType.append(", ")
            resultType.append(pType)
            out.print("\{separator}\{pType} p\{i}")
            separator := ", "
        }
        out.printLine(") {")
        out.level +=1
        resultType.append(")*")
        def unrefs := MemoryOutputStream()
        def casts := Array<String>()
        for i in 0 .. effective.subtypes.count - 1 {
            def p := "p\{i}"
            def rawType:Type
            if i = 0 {
                rawType := raw.owner.type
            }
            else {
                rawType := raw.parameters[i - 1].type
            }
            if rawType != effective.subtypes[i] {
                def cast := getCastReference(p, effective.subtypes[i], rawType, out)
                casts.add(cast)
                if compiler.isValue(effective.subtypes[i]) & !compiler.isValue(rawType) {
                    unrefs.printLine("panda$core$Panda$unref$panda$core$Object(" +
                            "(panda$core$Object*) \{cast});")
                }
            }
            else {
                casts.add(p)
            }
        }
        if raw.returnType != Type.Void() {
            out.print("\{type(raw.returnType)} result = ")
        }
        out.print("\{getName(raw)}(")
        separator := ""
        for i in 0 .. effective.subtypes.count - 1 {
            out.print("\{separator}\{casts[i]}")
            separator := ", "
        }
        out.printLine(");")
        out.printLine(unrefs)
        if raw.returnType != Type.Void() {
            out.printLine("return " + getCastReference("result", raw.returnType,
                    effectiveReturnType, out) + ";")
        }
        out.level -= 1
        out.printLine("}")
        def result := MethodShim(resultName, resultType.finish())
        methodShims[raw] := result
        rawOut.print(outBuffer.finish())
        return result
    }

    method getWrapperITable(cl:ClassDecl):String {
        def interfaces := compiler.allInterfaces(cl.type)
        var previous := "NULL"
        for intfType in interfaces {
            def intf := compiler.getClass(intfType)
            def intfCC := getClassConstant(intf)
            def methods := compiler.interfaceMethods(cl, intfType)
            def name := "\{escapeName(cl.name)}$wrapper_\{escapeName(intf.name)}"
            def result := MutableString("struct { \{type(Type.Class())} cl; ITable* itable; " +
                    "void* methods[\{methods.count}]; } \{name} = { " +
                    "(\{type(Type.Class())}) &\{intfCC.name}, \{previous}, { ")
            var separator := ""
            for m in methods {
                result.append(separator)
                separator := ", "
                if m.annotations.isAbstract() {
                    result.append("NULL")
                }
                else {
                    result.append(getMethodTableEntry(m))
                }
            }
            result.append("} };\n")
            types.printLine(result.finish())
            previous := "(ITable*) &\{name}"
        }
        return previous
    }

    function needsStructIndirection(m:MethodDecl):Bit {
        return hCodeGen.needsStructIndirection(m)
    }

    method getMethodTableEntry(m:MethodDecl):String {
        compiler.resolve(m)
        if isExternal(m.owner) {
            writeDeclaration(m)
        }
        def result:String
        def declared := compiler.declaredTypeWithSelf(m, m.owner.type)
        def effectiveSelf:Type
        if compiler.isValue(m.owner) {
            effectiveSelf := Type.Object()
        }
        else {
            effectiveSelf := m.owner.type
        }
        def inherited := compiler.inheritedTypeWithSelf(m, effectiveSelf)
        if declared != inherited {
            def shim := createMethodShim(m, inherited, shims)
            result := shim.name
        }
        else {
            result := getName(m)
        }
        return result
    }

    method getClassConstant(cl:ClassDecl):ClassConstant {
        var result := classConstants[cl.name]
        if result = null {
            writeImport(cl)
            compiler.resolve(cl)
            def type:String
            if isExternal(cl) {
                result := ClassConstant("\{escapeName(cl.type.name)}$class",
                        "%panda$core$Class")
                classConstants[cl.name] := result
                return classConstants[cl.name]
            }
            compiler.currentClass.push(cl)
            def vtable := compiler.getVTable(cl)
            result := ClassConstant("\{escapeName(cl.type.name)}$class", "<error>")
            classConstants[cl.name] := result
            def superPtr:String
            if cl.rawSuper != null {
                def superCC := getClassConstant(compiler.getClass(cl.rawSuper))
                superPtr := "(panda$core$Class*) &\{superCC.name}"
            }
            else {
                superPtr := "NULL"
            }
            def clConstant := getClassConstant(compiler.getClass(Type.Class()))
            def name := getStringReference(cl.name)
            assert name.startsWith("&")
            def code := MutableString("static panda$core$String \{name[1..]};\n" +
                    "\{result.name}_type \{result.name} = { " +
                    "(panda$core$Class*) &\{clConstant.name}, \{NO_REFCNT}, " +
                    "\{name}, \{superPtr}, \{getITable(cl)}, { ")
            var separator := ""
            for m in vtable {
                code.append(separator)
                if m.annotations.isAbstract() {
                    code.append("NULL")
                }
                else {
                    code.append(getMethodTableEntry(m))
                }
                separator := ", "
            }
            code.append("} };\n")
            types.printLine(code.finish())
            compiler.currentClass.pop(cl)
        }
        return result
    }

    method getWrapperClassConstant(cl:ClassDecl):ClassConstant {
        def name := "\{escapeName(cl.name)}$wrapperclass"
        var result := classConstants[name]
        if result = null {
            if isExternal(cl) {
                type(Type.Class())
                def type := "%panda$core$Class"
                types.printLine("\{name} = external global \{type}")
                result := ClassConstant(name, type)
            }
            else {
                def value := compiler.getClass(Type.Value())
                def valueVTable := compiler.getVTable(value)
                result := ClassConstant("\{escapeName(cl.name)}$wrapperclass", "<error>")
                def vtable := compiler.getVTable(cl)
                def superCC := getClassConstant(compiler.getClass(cl.rawSuper))
                def superCast := "(panda$core$Class*) &\{superCC.name}"
                def itable := getWrapperITable(cl)
                def clConstant := getClassConstant(compiler.getClass(Type.Class()))
                def name := getStringReference(cl.name)
                assert name.startsWith("&")
                def code := MutableString("static panda$core$String \{name[1..]};\n" +
                        "\{result.name}_type \{result.name} = { " +
                        "(panda$core$Class*) &\{clConstant.name}, \{NO_REFCNT}, " +
                        "\{name}, \{superCast}, \{itable}, { ")
                var separator := ""
                for i in 0 .. valueVTable.count {
                    code.append("\{separator}\{getMethodTableEntry(vtable[i])}")
                    separator := ", "
                }
                code.append("} };")
                types.print(code.finish())
            }
            classConstants[name] := result
        }
        return result
    }

    function getName(v:Variable):String {
        if v.storage = Variable.Storage.PARAMETER {
            return "p_\{v.name}"
        }
        var result := variableNames[v]
        if result = null {
            varCount += 1
            result := "\{v.name}\{varCount}"
            variableNames[v] := result
        }
        return result
    }

    function getName(f:FieldDecl):String {
        assert f.annotations.isClass()
        return "\{escapeName(f.owner.name)}$\{f.name}"
    }

    choice OpClass {
        SIGNED
        UNSIGNED
        FLOAT
    }

    function opClass(t:Type):OpClass {
        match t.typeKind {
            when Type.Kind.BUILTIN_INT:
                return OpClass.SIGNED
            when Type.Kind.BUILTIN_UINT, Type.Kind.BUILTIN_BIT:
                return OpClass.UNSIGNED
            when Type.Kind.BUILTIN_FLOAT:
                return OpClass.FLOAT
            otherwise:
                assert false
        }
    }


    method getBinaryReference(t:Type, leftRef:String, op:Token.Kind, rightRef:String,
            out:IndentedOutputStream):String {
        def cOp:String
        var logical := false
        match op {
            when Token.Kind.ADD:
                cOp := "+"
            when Token.Kind.SUB:
                cOp := "-"
            when Token.Kind.MUL:
                cOp := "*"
            when Token.Kind.INTDIV:
                cOp := "/"
            when Token.Kind.DIV:
                cOp := "/"
            when Token.Kind.REM:
                cOp := "%"
            when Token.Kind.SHIFTLEFT:
                cOp := "<<"
            when Token.Kind.SHIFTRIGHT:
                cOp := ">>"
            when Token.Kind.BITWISEAND:
                cOp := "&"
            when Token.Kind.BITWISEOR:
                cOp := "|"
            when Token.Kind.XOR, Token.Kind.BITWISEXOR: 
                cOp := "^"
            when Token.Kind.EQ:
                cOp := "=="
                logical := true
            when Token.Kind.NEQ:
                cOp := "!="
                logical := true
            when Token.Kind.GT:
                cOp := ">"
                logical := true
            when Token.Kind.LT:
                cOp := "<"
                logical := true
            when Token.Kind.GTEQ:
                cOp := ">="
                logical := true
            when Token.Kind.LTEQ:
                logical := true
                cOp := "<="
            otherwise:
                assert false
        }
        def result := nextVar()
        if logical {
            out.print("bool ")
        }
        else {
            out.print("\{type(t)} ")
        }
        out.printLine("\{result} = \{leftRef} \{cOp} \{rightRef};")
        return result
    }

    method getVirtualMethodReference(target:String, m:MethodDecl, out:IndentedOutputStream):String {
        def cc := getClassConstant(m.owner)
        var index := -1
        def vtable := compiler.getVTable(m.owner)
        for i in 0 .. vtable.count {
            if vtable[i]->MethodDecl == m {
                index := i
                break
            }
        }
        assert index != -1
        return "((\{methodType(compiler.inheritedTypeWithSelf(m), null)}) " +
                "\{target}->$class->vtable[\{index}])"
    }

    method getInterfaceMethodReference(target:String, m:MethodDecl,
            out:IndentedOutputStream):String {
        def cc := getClassConstant(m.owner)
        def itable := nextVar()
        out.printLine("ITable* \{itable} = \{target}->$class->itable;")
        out.printLine("while (\{itable}->$class != (panda$core$Class*) &\{cc.name}) {")
        out.level += 1
        out.printLine("\{itable} = \{itable}->next;")
        out.level -= 1
        out.printLine("}")
        var index := -1
        def vtable := compiler.getVTable(m.owner)
        for i in 0 .. vtable.count {
            if vtable[i]->MethodDecl == m {
                index := i
                break
            }
        }
        index -= compiler.getVTable(compiler.getClass(Type.Object())).count
        assert index != -1
        def result := nextVar()
        def methodType := methodType(compiler.inheritedTypeWithSelf(m), null)
        out.printLine("\{methodType} \{result} = \{itable}->methods[\{index}];")
        return result
    }

    method getMethodReference(target:String?, m:MethodDecl, isSuper:Bit,
            out:IndentedOutputStream):String {
        if !isSuper & m.isVirtual() {
            assert target != null, "calling instance \{m.signature()} without a target"
            if m.owner.classKind = ClassDecl.Kind.INTERFACE {
                return getInterfaceMethodReference(target, m, out)
            }
            else {
                return getVirtualMethodReference(target, m, out)
            }
        }
        else {
            if isExternal(m.owner) {
                writeDeclaration(m)
            }
            return getName(m)
        }
    }

    method wrapValue(value:String, srcType:Type, dstType:Type, out:IndentedOutputStream):String {
        if srcType.typeKind = Type.Kind.NULLABLE {
            -- casting nullable value to nullable wrapper, need to special-case null
            def result := nextVar()
            out.printLine("\{type(dstType)} \{result};")
            out.printLine("if (\{value}.nonnull) {")
            out.level += 1
            def unwrapped := toNonNullableValue(value, srcType, srcType.subtypes[0], out)
            def nonNullValue := wrapValue(unwrapped, srcType.subtypes[0], dstType, out)
            out.printLine("\{result} = \{nonNullValue};")
            out.level -= 1
            out.printLine("}")
            out.printLine("else {")
            out.level += 1
            out.printLine("\{result} = NULL;")
            out.level -= 1
            out.printLine("}")
            return result
        }
        def wrapped := nextVar()
        out.printLine("\{wrapperType(srcType)} \{wrapped};")
        if srcType.typeKind = Type.Kind.NULLABLE {
            out.printLine("if (\{value}.nonnull) {")
            out.level += 1
        }
        out.printLine("\{wrapped} = (\{wrapperType(srcType)}) " +
                "pandaObjectAlloc(\{sizeOfWrapper(srcType)}, (panda$core$Class*) " +
                "&\{escapeName(srcType.name)}$wrapperclass);")
        out.printLine("\{wrapped}->value = \{value};")
        if srcType.typeKind = Type.Kind.NULLABLE {
            out.level -= 1
            out.printLine("}")
            out.printLine("else {")
            out.level += 1
            out.printLine("\{wrapped} = NULL;")
            out.level -= 1
            out.printLine("}")
        }
        return "((\{type(dstType)}) \{wrapped})"
    }

    method unwrapValue(value:String, srcType:Type, dstType:Type, out:IndentedOutputStream):String {
        def result := "((\{wrapperType(dstType)}) \{value})->value"
        if dstType.typeKind = Type.Kind.NULLABLE {
            -- casting nullable wrapper to nullable value, need to special-case null
            def wrapped := unwrapValue(value, srcType, dstType.subtypes[0], out)
            def nonNullValue := toNullableValue(wrapped, dstType.subtypes[0], dstType, out)
            return "(\{value} != NULL ? \{nonNullValue} : (\{type(dstType)}) { .nonnull = 0 })"
        }
        return result
    }

    method toNullableValue(value:String, srcType:Type, dstType:Type,
            out:IndentedOutputStream):String {
        return "((\{nullableType(dstType)}) { \{value}, true })"
    }

    method toNonNullableValue(value:String, srcType:Type, dstType:Type,
            out:IndentedOutputStream):String {
        return "((\{type(dstType)}) \{value}.value)"
    }

    method getCastReference(value:String, src:Type, target:Type, out:IndentedOutputStream):String {
        if target.isBuiltinNumber() {
            assert src.isBuiltinNumber()
            return "((\{type(target)}) \{value})"
        }
        else {
            def srcClass := compiler.getClass(src)
            assert srcClass != null
            def targetClass := compiler.getClass(target)
            assert targetClass != null
            if compiler.isValue(srcClass) & !compiler.isValue(targetClass) {
                return wrapValue(value, src, target, out)
            }
            else if !compiler.isValue(srcClass) & compiler.isValue(targetClass) {
                return unwrapValue(value, src, target, out)
            }
            else if compiler.isValue(srcClass) & target.typeKind = Type.Kind.NULLABLE &
                    target.subtypes[0] = src {
                return toNullableValue(value, src, target, out)
            }
            else if compiler.isValue(targetClass) & src.typeKind = Type.Kind.NULLABLE &
                    src.subtypes[0] = target {
                return toNonNullableValue(value, src, target, out)
            }
        }
        def srcType := type(src)
        def dstType := type(target)
        if srcType = dstType {
            return value
        }
        return "((\{dstType}) \{value})"
    }

    method getIntReference(int:UInt64, out:IndentedOutputStream):String {
        if int > Int64.MAX.convert() {
            return int + "u"
        }
        return int.convert()
    }

    method getNegatedIntReference(int:UInt64, out:IndentedOutputStream):String {
        return "-" + int
    }

    method getRealReference(real:Real64, out:OutputStream):String {
        def result := real.convert()->String
        if result.contains(".") {
            return result
        }
        return result + ".0"
    }

    method getBitReference(bit:Bit, out:IndentedOutputStream):String {
        if bit {
            return "true"
        }
        return "false"
    }

    method getVariableReference(v:Variable, out:IndentedOutputStream):String {
        return getName(v)
    }

    method getStringReference(s:String):String {
        varCount += 1
        def result := "$s\{varCount}"
        type(Type.StringType())
        strings.print("static panda$core$String \{result} = { " +
                "(panda$core$Class*) &panda$core$String$class, \{NO_REFCNT}, " +
                "(panda$core$Char8*) \"")
        for c in s.utf8() {
            strings.print("\\x\{c.convert()->UInt8,0>2:x}")
        }
        strings.printLine("\", \{s.utf8().count}, \{s.hash()}, NULL };")
        return "&\{result}"
    }

    method getSelfReference(out:IndentedOutputStream):String {
        return "self"
    }

    method getSuperReference(t:Type, out:IndentedOutputStream):String {
        return "((\{type(t)}) self)"
    }

    method getNullReference(t:Type, out:IndentedOutputStream):String {
        assert t.typeKind = Type.Kind.NULLABLE
        def cl := compiler.getClass(t.subtypes[0])
        assert cl != null
        if compiler.isValue(cl) {
            return "((\{nullableType(t)}) { .nonnull = false })"
        }
        else {
            return "NULL"
        }
    }

    method selfType(m:MethodDecl):String {
        def result := type(m.owner.type)
        if m.methodKind = MethodDecl.Kind.INIT & !result.endsWith("*") {
            return result + "*"
        }
        return result
    }

    @override
    method writeDeclaration(m:MethodDecl) {
        writeImport(m.owner)
    }

    @override
    method write(m:MethodDecl, ir:IR) {
        assert false
    }

    @override
    method start(cl:ClassDecl) {
        assert currentClass = null
        currentClass := cl
        imports.clear()
        strings.clear()
        declarations.clear()
        types.clear()
        methodsBuffer.clear()
        shimsBuffer.clear()
        declared.clear()
        writtenTypes.clear()
        writtenWrappers.clear()
        classConstants.clear()
        variableNames.clear()
        varCount := 0
        reusedValues.clear()
        methodShims.clear()
        def path := hCodeGen.getPath(cl, ".c")
        path.parent().createDirectories()
        out := IndentedOutputStream(path.openOutputStream())
        getClassConstant(cl)
        if compiler.isValue(cl) {
            getWrapperClassConstant(cl)
        }
    }

    @override
    method end(cl:ClassDecl) {
        finish()
        currentClass := null
    }

    @override
    method finish() {
        out.printLine(shimsBuffer.finish())
        shimsBuffer.clear()
        out.printLine(types.finish())
        types.clear()
        out.printLine(strings.finish())
        strings.clear()
        out.printLine(methodsBuffer.finish())
        methodsBuffer.clear()
    }
}