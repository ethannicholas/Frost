package org.pandalanguage.pandac

uses org.pandalanguage.pandac.parser.Token

-- Note that the C code produced by this CodeGenerator is not quite compatible with the output of
-- the LLVM code generator due to slight ABI differences in how structures are passed and the use
-- of fastcc on the LLVM side of things. As this CodeGenerator is only intended to produce the
-- bootstrap compiler and does not interoperate in any way with LLVM code, this should not present
-- any problems, but is still something to be aware of.
@final
class CCodeGenerator : CodeGenerator {
    choice EnclosingContext {
        LOOP(String? -* label *-, String -* break target *-, String -* continue target *-)
        FINALLY(String -* label *-,
                Map<String, Pair<Int, String>> -* map from source label to (block id, return label) *-,
                String -* variable holding numeric id of block which jumped to finally block *-)
    }

    constant NO_REFCNT := -999

    @weak
    var compiler:Compiler?

    def outDir:File

    def out:IndentedOutputStream

    def strings := MemoryOutputStream()

    def imports := Set<String>()

    def hCodeGen:HCodeGenerator

    var currentClass:ClassDecl? := null

    init(outDir:File) {
        self.outDir := outDir
        self.out := IndentedOutputStream(MemoryOutputStream())
        self.hCodeGen := HCodeGenerator(outDir)
    }

    function escapeName(s:String):String {
        return hCodeGen.escapeName(s)
    }

    function getName(m:MethodDecl):String {
        return hCodeGen.getName(m)
    }

    function sizeOf(t:Type):Int {
        return hCodeGen.sizeOf(t)
    }

    function isExternal(cl:ClassDecl):Bit {
        return cl !== currentClass
    }

    method writeImport(cl:ClassDecl) {
        if cl.name = "panda.unsafe.Pointer" {
            return
        }
        def includePath := hCodeGen.getRelativePath(cl, ".h")
        if !imports.contains(includePath) {
            out.printLine("#include \"\{includePath}\"")
            imports.add(includePath)
        }
    }

    method type(t:Type):String {
        if t.isClass() {
            def cl := compiler.getClass(t)
            assert cl != null
            writeImport(cl)
        }
        if t.typeKind = Type.Kind.METHOD | t.typeKind = Type.Kind.FUNCTION {
            varCount += 1
            def result := "$fn\{varCount}"
            def code := MutableString("typedef ")
            code.append(type(t.subtypes[t.subtypes.get_count() - 1]))
            code.append(" (*")
            code.append(result)
            code.append(")(")
            var separator := ""
            for i in 0 .. t.subtypes.get_count() - 1 {
                code.append(separator)
                code.append(type(t.subtypes[i]))
                separator := ", "
            }
            code.append(");")
            types.printLine(code.finish())
            return result
        }
        return hCodeGen.type(t)
    }

    @override
    method setCompiler(compiler:Compiler) {
        self.compiler := compiler
        hCodeGen.setCompiler(compiler)
    }

    class ClassConstant : Immutable {
        def name:String
        def type:String

        init(name:String, type:String) {
            self.name := name
            self.type := type
        }
    }

    class MethodShim {
        def name:String
        def type:String

        init(name:String, type:String) {
            self.name := name
            self.type := type
        }
    }

    constant POINTER_SIZE        := 8
    constant OBJECT_FIELD_COUNT  := 2
    constant CLASS_POINTER_INDEX := 0
    constant ITABLE_INDEX        := 2
    constant VTABLE_INDEX        := 3

    constant INT_TYPE  := "i64"
    constant SIZE_TYPE := "i64"

    def declarations := MemoryOutputStream()

    def types := MemoryOutputStream()

    def methodsBuffer := MemoryOutputStream()

    def methods := IndentedOutputStream(methodsBuffer)

    def methodHeaderBuffer := MemoryOutputStream()

    def methodHeader := IndentedOutputStream(methodHeaderBuffer)

    def wrapperShimsBuffer := MemoryOutputStream()

    def wrapperShims := IndentedOutputStream(wrapperShimsBuffer)

    def shimsBuffer := MemoryOutputStream()

    def shims := IndentedOutputStream(shimsBuffer)

    def declared := Set<String>()

    def writtenTypes := Set<String>()

    def writtenWrappers := Set<String>()

    def classConstants := HashMap<String, ClassConstant>()

    def variableNames := IdentityMap<Variable, String>()

    var currentBlock:String

    var currentMethod:MethodDecl?

    def enclosingContexts := Stack<EnclosingContext>()

    def extraEffects := Stack<Array<IRNode>>()

    var varCount := 0

    def reusedValues := HashMap<Int, String>()

    def methodShims := IdentityMap<MethodDecl, MethodShim>()

    method nextVar():String {
        varCount += 1
        return "$tmp\{varCount}"
    }

    method nextLabel():String {
        varCount += 1
        return "$l\{varCount}"
    }

    method createBlock(label:String, out:IndentedOutputStream) {
        out.printLine("\{label}:;")
        currentBlock := label
    }

    function fieldSize(t:Type):Int {
        assert t.resolved
        if t.isBuiltinNumber() {
            if t.name.endsWith("8") {
                return 1
            }
            if t.name.endsWith("16") {
                return 2
            }
            if t.name.endsWith("32") {
                return 4
            }
            assert t.name.endsWith("64")
            return 8
        }
        if t = Type.BuiltinBit() {
            return 1
        }
        def cl := compiler.getClass(t)
        assert cl != null
        if !compiler.isValue(cl) | cl.name = "panda.unsafe.Pointer" {
            return POINTER_SIZE
        }
        var result := 0
        for f in compiler.instanceFields(cl) {
            if f.annotations.isClass() {
                continue
            }
            compiler.resolve(f)
            if f.type = Type.ChoiceData() {
                -- FIXME need to respect alignment!
                result += hCodeGen.llvmCodeGen.getChoiceDataSize(cl)
            }
            else {
                def size := fieldSize(f.type)
                def align := result % size
                if align != 0 {
                    result += size - align
                }
                assert result % size = 0
                result += size
            }
        }
        if t.typeKind = Type.Kind.NULLABLE {
            result += 1
        }
        return result
    }

    function alignment(t:Type):Int {
        return fieldSize(t).min(8)
    }

    function sizeOfWrapper(t:Type):Int {
        def cl := compiler.getClass(t)
        assert cl != null & compiler.isValue(cl)
        var result := sizeOf(Type.Object())
        for f in compiler.instanceFields(cl) {
            compiler.resolve(f)
            if f.type = Type.ChoiceData() {
                -- FIXME need to respect alignment!
                result += hCodeGen.llvmCodeGen.getChoiceDataSize(cl)
            }
            else {
                def size := fieldSize(f.type)
                def align := result % size
                if align != 0 {
                    result += size - align
                }
                assert result % size = 0
                result += size
            }
        }
        if t.typeKind = Type.Kind.NULLABLE {
            result += 1
        }
        return result
    }

    method writeType(t:Type) {
        if writtenTypes.contains(t.name) {
            return
        }
    }

    function typeName(t:Type):String {
        return escapeName(t.name)
    }

    method wrapperTypeName(t:Type):String {
        if t.typeKind = Type.Kind.NULLABLE {
            return wrapperTypeName(t.subtypes[0])
        }
        return "\{escapeName(t.name)}$wrapper"
    }

    method wrapperType(t:Type):String {
        return wrapperTypeName(t) + "*"
    }

    method wrapperType(m:MethodDecl):String {
        def inheritedType := compiler.inheritedType(m)
        def result := MutableString()
        result.append(type(inheritedType.subtypes[inheritedType.subtypes.get_count() - 1]))
        result.append("(")
        assert m.isInstance()
        result.append("\{escapeName(m.owner.name)}")
        if compiler.isValue(m.owner) {
            result.append("$wrapper")
        }
        result.append("*")
        for i in 0 .. inheritedType.subtypes.get_count() - 1 { 
            result.append(", ")
            result.append(type(inheritedType.subtypes[i]))
        }
        result.append(")*")
        return result.finish()
    }

    method nullableType(t:Type):String {
        assert t.typeKind = Type.Kind.NULLABLE, "\{t} is not nullable"
        return "\{type(t.subtypes[0])}$nullable"
    }

    method getITable(cl:ClassDecl):String {
        def interfaces := compiler.allInterfaces(cl.type())
        var previous := "NULL"
        for intfType in interfaces {
            def intf := compiler.getClass(intfType)
            def intfCC := getClassConstant(intf)
            def methods := compiler.interfaceMethods(cl, intfType)
            def name := "\{escapeName(cl.name)}$_\{escapeName(intf.name)}"
            def result := MutableString("struct { \{type(Type.Class())} cl; ITable* next; " +
                    "void* methods[\{methods.get_count()}]; } \{name} = { " +
                    "(panda$core$Class*) &\{intfCC.name}, \{previous}, { ")
            var separator := ""
            for m in methods {
                result.append(separator)
                separator := ", "
                if m.annotations.isAbstract() {
                    result.append("NULL")
                }
                else {
                    result.append(getMethodTableEntry(m))
                }
            }
            result.append("} };\n")
            types.printLine(result.finish())
            previous := "(ITable*) &\{name}"
        }
        return previous
    }

    method createMethodShim(raw:MethodDecl, effective:Type, rawOut:OutputStream):MethodShim {
        def outBuffer := MemoryOutputStream()
        def out := IndentedOutputStream(outBuffer)
        def found := methodShims[raw]
        if found != null {
            return found
        }
        assert effective.isMethod()
        assert effective.subtypes.get_count() = raw.parameters.get_count() + 1
        assert raw.isInstance()
        def effectiveReturnType := effective.subtypes[effective.subtypes.get_count() - 1]
        def resultName := getName(raw) + "$shim"
        def resultType := MutableString(type(effectiveReturnType))
        out.print("\{resultType} \{resultName}(")
        def self_t := selfType(raw)
        out.print("\{self_t} self")
        resultType.append("(")
        resultType.append(self_t)
        for i in 0 .. raw.parameters.get_count() {
            def pType := type(effective.subtypes[i])
            resultType.append(", ")
            resultType.append(pType)
            out.print(", \{pType} p\{i}")
        }
        out.printLine(") {")
        out.level +=1
        resultType.append(")*")
        def casts := Array<String>()
        for i in 0 .. raw.parameters.get_count() {
            def p := "p\{i}"
            if raw.parameters[i].type != effective.subtypes[i] {
                casts.add(getCastReference(p, effective.subtypes[i],
                        raw.parameters[i].type, out))
            }
            else {
                casts.add(p)
            }
        }
        if raw.returnType != Type.Void() {
            out.print("\{type(raw.returnType)} result = ")
        }
        out.print("\{getName(raw)}(self")
        for i in 0 .. raw.parameters.get_count() {
            out.print(", \{casts[i]}")
        }
        out.printLine(");")
        if raw.returnType != Type.Void() {
            out.printLine("return " + getCastReference("result", raw.returnType,
                    effectiveReturnType, out) + ";")
        }
        out.level -= 1
        out.printLine("}")
        def result := MethodShim(resultName, resultType.finish())
        methodShims[raw] := result
        rawOut.print(outBuffer.finish())
        return result
    }

    method createWrapperShim(m:MethodDecl, out:IndentedOutputStream):String {
        assert m.isInstance()
        def oldMethod := currentMethod
        currentMethod := m
        def result := "\{getName(m)}$wrappershim"
        def selfType := "\{escapeName(m.owner.name)}$wrapper*"
        out.print("\{type(m.returnType)} \{result}(\{selfType} self")
        def actualMethodType := compiler.declaredType(m)
        def inheritedMethodType := compiler.inheritedType(m)
        for i in 0 .. m.parameters.get_count() {
            out.print(", \{type(inheritedMethodType.subtypes[i])} \{m.parameters[i].name}")
        }
        out.printLine(") {")
        out.level += 1
        def parameters := Array<String>()
        for i in 0 .. m.parameters.get_count() {
            parameters.add(getCastReference(m.parameters[i].name, inheritedMethodType.subtypes[i],
                    actualMethodType.subtypes[i], out))
        }
        def children := Array<IRNode>()
        children.add(IRNode.SELF(Position(), Type.Object()))
        if m.returnType != Type.Void() {
            out.print("return ")
        }
        out.print("\{getName(m)}(self->value")
        for i in 0 .. m.parameters.get_count() {
            out.print(", \{parameters[i]}")
        }
        out.printLine(");")
        out.level -= 1
        out.printLine("}")
        currentMethod := oldMethod
        return result
    }

    method getWrapperITable(cl:ClassDecl):String {
        def interfaces := compiler.allInterfaces(cl.type())
        var previous := "NULL"
        for intfType in interfaces {
            def intf := compiler.getClass(intfType)
            def intfCC := getClassConstant(intf)
            def methods := compiler.interfaceMethods(cl, intfType)
            def name := "\{escapeName(cl.name)}$wrapper_\{escapeName(intf.name)}"
            def result := MutableString("struct { \{type(Type.Class())} cl; ITable* itable; " +
                    "void* methods[\{methods.get_count()}]; } \{name} = { " +
                    "(\{type(Type.Class())}) &\{intfCC.name}, \{previous}, { ")
            var separator := ""
            for m in methods {
                result.append(separator)
                separator := ", "
                if m.annotations.isAbstract() {
                    result.append("NULL")
                }
                else {
                    result.append(createWrapperShim(m, wrapperShims))
                }
            }
            result.append("} };\n")
            types.printLine(result.finish())
            previous := "(ITable*) &\{name}"
        }
        return previous
    }

    function needsStructIndirection(m:MethodDecl):Bit {
        return hCodeGen.needsStructIndirection(m)
    }

    method getMethodTableEntry(m:MethodDecl):String {
        compiler.resolve(m)
        if isExternal(m.owner) {
            writeDeclaration(m)
        }
        def result:String
        def declared := compiler.declaredTypeWithSelf(m, m.owner.type())
        def inherited := compiler.inheritedTypeWithSelf(m)
        if declared != inherited {
            def shim := createMethodShim(m, compiler.inheritedType(m), shims)
            result := shim.name
        }
        else {
            result := getName(m)
        }
        return result
    }

    method getClassConstant(cl:ClassDecl):ClassConstant {
        var result := classConstants[cl.name]
        if result = null {
            writeImport(cl)
            compiler.resolve(cl)
            def type:String
            if isExternal(cl) {
                result := ClassConstant("\{escapeName(cl.type().name)}$class",
                        "%panda$core$Class")
                classConstants[cl.name] := result
                return classConstants[cl.name]
            }
            compiler.currentClass.push(cl)
            def vtable := compiler.getVTable(cl)
            result := ClassConstant("\{escapeName(cl.type().name)}$class", "<error>")
            classConstants[cl.name] := result
            def superPtr:String
            if cl.rawSuper != null {
                def superCC := getClassConstant(compiler.getClass(cl.rawSuper))
                superPtr := "(panda$core$Class*) &\{superCC.name}"
            }
            else {
                superPtr := "NULL"
            }
            def clConstant := getClassConstant(compiler.getClass(Type.Class()))
            def name := getStringReference(cl.name)
            assert name.startsWith("&")
            def code := MutableString("static panda$core$String \{name[1..]};\n" +
                    "\{result.name}_type \{result.name} = { " +
                    "(panda$core$Class*) &\{clConstant.name}, \{NO_REFCNT}, " +
                    "\{name}, \{superPtr}, \{getITable(cl)}, { ")
            var separator := ""
            for m in vtable {
                code.append(separator)
                if m.annotations.isAbstract() {
                    code.append("NULL")
                }
                else {
                    code.append(getMethodTableEntry(m))
                }
                separator := ", "
            }
            code.append("} };\n")
            types.printLine(code.finish())
            compiler.currentClass.pop()
        }
        return result
    }

    method getWrapperClassConstant(cl:ClassDecl):ClassConstant {
        def name := "\{escapeName(cl.name)}$wrapperclass"
        var result := classConstants[name]
        if result = null {
            if isExternal(cl) {
                type(Type.Class())
                def type := "%panda$core$Class"
                types.printLine("\{name} = external global \{type}")
                result := ClassConstant(name, type)
            }
            else {
                def value := compiler.getClass(Type.Value())
                def valueVTable := compiler.getVTable(value)
                result := ClassConstant("\{escapeName(cl.name)}$wrapperclass", "<error>")
                def vtable := compiler.getVTable(cl)
                def superCC := getClassConstant(compiler.getClass(cl.rawSuper))
                def superCast := "(panda$core$Class*) &\{superCC.name}"
                def itable := getWrapperITable(cl)
                def clConstant := getClassConstant(compiler.getClass(Type.Class()))
                def name := getStringReference(cl.name)
                assert name.startsWith("&")
                def code := MutableString("static panda$core$String \{name[1..]};\n" +
                        "\{result.name}_type \{result.name} = { " +
                        "(panda$core$Class*) &\{clConstant.name}, \{NO_REFCNT}, " +
                        "\{name}, \{superCast}, \{itable}, { ")
                var separator := ""
                for i in 0 .. valueVTable.get_count() {
                    def m := vtable[i]
                    def methodName:String
                    if m.owner == cl {
                        methodName := createWrapperShim(m, wrapperShims)
                    }
                    else {
                        methodName := getName(m)
                        if isExternal(m.owner) {
                            writeDeclaration(m)
                        }
                    }
                    code.append("\{separator}\{methodName}")
                    separator := ", "
                }
                code.append("} };")
                types.print(code.finish())
            }
            classConstants[name] := result
        }
        return result
    }

    function getName(v:Variable):String {
        if v.storage = Variable.Storage.PARAMETER {
            return "p_\{v.name}"
        }
        var result := variableNames[v]
        if result = null {
            varCount += 1
            result := "\{v.name}\{varCount}"
            variableNames[v] := result
        }
        return result
    }

    function getName(f:FieldDecl):String {
        assert f.annotations.isClass()
        return "\{escapeName(f.owner.name)}$\{f.name}"
    }

    choice OpClass {
        SIGNED
        UNSIGNED
        FLOAT
    }

    function opClass(t:Type):OpClass {
        match t.typeKind {
            when Type.Kind.BUILTIN_INT:
                return OpClass.SIGNED
            when Type.Kind.BUILTIN_UINT, Type.Kind.BUILTIN_BIT:
                return OpClass.UNSIGNED
            when Type.Kind.BUILTIN_FLOAT:
                return OpClass.FLOAT
            otherwise:
                assert false
        }
    }

    method getAndReference(left:IRNode, right:IRNode, out:IndentedOutputStream):String {
        extraEffects.push(Array<IRNode>())
        def result := nextVar()
        var leftRef := getReference(left, out)
        if left.type() = Type.Bit() {
            leftRef := leftRef + ".value"
        }
        out.printLine("bool \{result} = \{leftRef};")
        writeExtraEffects(out)
        def falseLabel := nextLabel()
        out.printLine("if (!\{result}) goto \{falseLabel};")
        extraEffects.push(Array<IRNode>())
        var rightRef := getReference(right, out)
        if right.type() = Type.Bit() {
            rightRef := rightRef + ".value"
        }
        out.printLine("\{result} = \{rightRef};")
        writeExtraEffects(out)
        createBlock(falseLabel, out)
        return result
    }

    method getOrReference(left:IRNode, right:IRNode, out:IndentedOutputStream):String {
        extraEffects.push(Array<IRNode>())
        def result := nextVar()
        var leftRef := getReference(left, out)
        if left.type() = Type.Bit() {
            leftRef := leftRef + ".value"
        }
        out.printLine("bool \{result} = \{leftRef};")
        writeExtraEffects(out)
        def trueLabel := nextLabel()
        out.printLine("if (\{result}) goto \{trueLabel};")
        extraEffects.push(Array<IRNode>())
        var rightRef := getReference(right, out)
        if right.type() = Type.Bit() {
            rightRef := rightRef + ".value"
        }
        out.printLine("\{result} = \{rightRef};")
        writeExtraEffects(out)
        createBlock(trueLabel, out)
        return result
    }

    method getBinaryReference(t:Type, leftRef:String, op:Token.Kind, rightRef:String,
            out:IndentedOutputStream):String {
        def cOp:String
        var logical := false
        match op {
            when Token.Kind.ADD:
                cOp := "+"
            when Token.Kind.SUB:
                cOp := "-"
            when Token.Kind.MUL:
                cOp := "*"
            when Token.Kind.INTDIV:
                cOp := "/"
            when Token.Kind.DIV:
                cOp := "/"
            when Token.Kind.REM:
                cOp := "%"
            when Token.Kind.SHIFTLEFT:
                cOp := "<<"
            when Token.Kind.SHIFTRIGHT:
                cOp := ">>"
            when Token.Kind.BITWISEAND:
                cOp := "&"
            when Token.Kind.BITWISEOR:
                cOp := "|"
            when Token.Kind.XOR, Token.Kind.BITWISEXOR: 
                cOp := "^"
            when Token.Kind.EQ:
                cOp := "=="
                logical := true
            when Token.Kind.NEQ:
                cOp := "!="
                logical := true
            when Token.Kind.GT:
                cOp := ">"
                logical := true
            when Token.Kind.LT:
                cOp := "<"
                logical := true
            when Token.Kind.GTEQ:
                cOp := ">="
                logical := true
            when Token.Kind.LTEQ:
                logical := true
                cOp := "<="
            otherwise:
                assert false
        }
        def result := nextVar()
        if logical {
            out.print("bool ")
        }
        else {
            out.print("\{type(t)} ")
        }
        out.printLine("\{result} = \{leftRef} \{cOp} \{rightRef};")
        return result
    }

    method getIdentityReference(left:IRNode, right:IRNode, out:IndentedOutputStream):String {
        def leftRef := getReference(left, out)
        def rightRef := getReference(right, out)
        return "((panda$core$Bit) { \{leftRef} == \{rightRef} })"
    }

    method getNIdentityReference(left:IRNode, right:IRNode, out:IndentedOutputStream):String {
        def leftRef := getReference(left, out)
        def rightRef := getReference(right, out)
        return "((panda$core$Bit) { \{leftRef} != \{rightRef} })"
    }

    method getBinaryReference(left:IRNode, op:Token.Kind, right:IRNode,
            out:IndentedOutputStream):String {
        assert left.type() = right.type()
        match op {
            when Token.Kind.AND:       return getAndReference(left, right, out)
            when Token.Kind.OR:        return getOrReference(left, right, out)
            when Token.Kind.IDENTITY:  return getIdentityReference(left, right, out)
            when Token.Kind.NIDENTITY: return getNIdentityReference(left, right, out)
            otherwise:
                def leftRef := getReference(left, out)
                def rightRef := getReference(right, out)
                return getBinaryReference(left.type(), leftRef, op, rightRef, out)
        }
    }

    method getVirtualMethodReference(target:String, m:MethodDecl, out:IndentedOutputStream):String {
        def cc := getClassConstant(m.owner)
        var index := -1
        def vtable := compiler.getVTable(m.owner)
        for i in 0 .. vtable.get_count() {
            if vtable[i]->MethodDecl == m {
                index := i
                break
            }
        }
        assert index != -1
        return "((\{type(compiler.inheritedTypeWithSelf(m))}) \{target}->$class->vtable[\{index}])"
    }

    method getInterfaceMethodReference(target:String, m:MethodDecl,
            out:IndentedOutputStream):String {
        def cc := getClassConstant(m.owner)
        def itable := nextVar()
        out.printLine("ITable* \{itable} = \{target}->$class->itable;")
        out.printLine("while (\{itable}->$class != (panda$core$Class*) &\{cc.name}) {")
        out.level += 1
        out.printLine("\{itable} = \{itable}->next;")
        out.level -= 1
        out.printLine("}")
        var index := -1
        def vtable := compiler.getVTable(m.owner)
        for i in 0 .. vtable.get_count() {
            if vtable[i]->MethodDecl == m {
                index := i
                break
            }
        }
        index -= compiler.getVTable(compiler.getClass(Type.Object())).get_count()
        assert index != -1
        def result := nextVar()
        def methodType := type(compiler.inheritedTypeWithSelf(m))
        out.printLine("\{methodType} \{result} = \{itable}->methods[\{index}];")
        return result
    }

    method getMethodReference(target:String?, m:MethodDecl, isSuper:Bit,
            out:IndentedOutputStream):String {
        if !isSuper & m.isVirtual() {
            assert target != null, "calling instance \{m.signature()} without a target"
            if m.owner.classKind = ClassDecl.Kind.INTERFACE {
                return getInterfaceMethodReference(target, m, out)
            }
            else {
                return getVirtualMethodReference(target, m, out)
            }
        }
        else {
            if isExternal(m.owner) {
                writeDeclaration(m)
            }
            return getName(m)
        }
    }

    method getPointerCallReference(t:Type, m:MethodRef, args:ImmutableArray<IRNode>,
            out:IndentedOutputStream):String {
        match m.value.name {
            when "alloc":
                assert args.get_count() = 1
                def count := getReference(args[0], out)
                assert m.returnType().subtypes.get_count() = 2
                def elementSize := fieldSize(m.returnType().subtypes[1])
                return "((\{type(t)}) pandaZAlloc(\{count}.value * \{elementSize}))"
            when "get":
                assert args.get_count() = 1
                def ptr := getReference(args[0], out)
                return "(*\{ptr})"
            when "[]":
                assert args.get_count() = 2
                def ptr := getReference(args[0], out)
                def index := getReference(args[1], out)
                return "\{ptr}[\{index}.value]"
            when "realloc":
                assert args.get_count() = 3
                def ptr := getReference(args[0], out)
                def oldCount := getReference(args[1], out)
                def newCount := getReference(args[2], out)
                assert m.returnType().subtypes.get_count() = 2
                def elementSize := fieldSize(m.returnType().subtypes[1])
                return "((\{type(t)}) pandaRealloc(\{ptr}, \{oldCount}.value * \{elementSize}, " +
                        "\{newCount}.value * \{elementSize}))"
            when "offset":
                assert args.get_count() = 2
                def ptr := getReference(args[0], out)
                def offset := getReference(args[1], out)
                return "(\{ptr} + \{offset}.value)"
            otherwise:
                assert false
        }
    }

    method getCallReference(t:Type, mref:MethodRef, args:ImmutableArray<IRNode>,
            out:IndentedOutputStream):String {
        def m := mref.value
        if m.owner.name = "panda.unsafe.Pointer" {
            return getPointerCallReference(t, mref, args, out)
        }
        if isExternal(m.owner) {
            writeDeclaration(m)
        }
        if m.owner.name = "panda.core.Bit" {
            if m.name = "&" {
                assert args.get_count() = 2
                def bit := getAndReference(args[0], args[1], out)
                def result := nextVar()
                out.printLine("panda$core$Bit \{result} = { \{bit} };")
                return result
            }
            if m.name = "|" {
                assert args.get_count() = 2
                def bit := getOrReference(args[0], args[1], out)
                def result := nextVar()
                out.printLine("panda$core$Bit \{result} = { \{bit} };")
                return result
            }
        }
        def argRefs := Array<String>(args.get_count())
        def actualMethodType:Type
        def actualResultType:String
        def isSuper := args.get_count() >= 1 & args[0] = IRNode.SUPER
        if !isSuper & m.isVirtual() {
            actualMethodType := compiler.inheritedType(m)
            actualResultType := type(actualMethodType.subtypes[actualMethodType.subtypes.get_count() - 1])
        }
        else {
            actualMethodType := compiler.declaredType(m)
            actualResultType := type(t)
        }
        def offset := args.get_count() - actualMethodType.subtypes.get_count() + 1
        for i in 0 .. args.get_count() {
            def arg := getReference(args[i], out)
            if i >= offset & actualMethodType.subtypes[i - offset] != args[i].type() {
                arg := getCastReference(arg, args[i].type(),
                        actualMethodType.subtypes[i - offset], out)
            }
            argRefs.add(arg)
        }
        def target:String?
        if argRefs.get_count() > 0 {
            -- this isn't actually correct - args[0] could be the target of an instance method, or
            -- just the first parameter to a class method. But getMethodReference ignores target for
            -- class methods, so this works and is easier than doing it the right way.
            target := argRefs[0]
        }
        else {
            target := null
        }
        def methodRef := getMethodReference(target, m, isSuper, out)
        def indirect := needsStructIndirection(m)
        def result := nextVar()
        var separator := ""
        def indirectVar:String
        if indirect {
            methodHeader.printLine("\{actualResultType} \{result};")
            out.print("\{methodRef}(&\{result}")
            separator := ", "
        }
        else {
            out.print("\{actualResultType} \{result} = \{methodRef}(")
        }
        for arg in argRefs {
            out.print("\{separator}\{arg}")
            separator := ", "
        }
        out.printLine(");")
        if type(t) != actualResultType {
            return getCastReference(result, 
                        actualMethodType.subtypes[actualMethodType.subtypes.get_count() - 1],
                        t,
                        out)
        }
        return result
    }

    method wrapValue(value:String, srcType:Type, dstType:Type, out:IndentedOutputStream):String {
        if srcType.typeKind = Type.Kind.NULLABLE {
            -- casting nullable value to nullable wrapper, need to special-case null
            def unwrapped := toNonNullableValue(value, srcType, srcType.subtypes[0], out)
            def nonNullValue := wrapValue(unwrapped, srcType.subtypes[0], dstType, out)
            return "(\{value}.nonnull ? \{nonNullValue} : NULL)"
        }
        def wrapped := nextVar()
        out.printLine("\{wrapperType(srcType)} \{wrapped};")
        if srcType.typeKind = Type.Kind.NULLABLE {
            out.printLine("if (\{value}.nonnull) {")
            out.level += 1
        }
        out.printLine("\{wrapped} = (\{wrapperType(srcType)}) " +
                "pandaObjectAlloc(\{sizeOfWrapper(srcType)}, (panda$core$Class*) " +
                "&\{escapeName(srcType.name)}$wrapperclass);")
        out.printLine("\{wrapped}->value = \{value};")
        if srcType.typeKind = Type.Kind.NULLABLE {
            out.level -= 1
            out.printLine("}")
            out.printLine("else {")
            out.level += 1
            out.printLine("\{wrapped} = NULL;")
            out.level -= 1
            out.printLine("}")
        }
        return "((\{type(dstType)}) \{wrapped})"
    }

    method getFieldReference(base:IRNode, field:FieldDecl, out:IndentedOutputStream):String {
        if field.annotations.isClass() {
            assert field.value != null
            return getReference(field.value, out)
        }
        def cl := compiler.getClass(base.type())
        writeImport(cl)
        def baseRef := getReference(base, out)
        assert cl != null
        if compiler.isValue(cl) {
            return "\{baseRef}.\{escapeName(field.name)}"
        }
        return "\{baseRef}->\{escapeName(field.name)}"
    }

    method unwrapValue(value:String, srcType:Type, dstType:Type, out:IndentedOutputStream):String {
        def result := "((\{wrapperType(dstType)}) \{value})->value"
        if dstType.typeKind = Type.Kind.NULLABLE {
            -- casting nullable wrapper to nullable value, need to special-case null
            def wrapped := unwrapValue(value, srcType, dstType.subtypes[0], out)
            def nonNullValue := toNullableValue(wrapped, dstType.subtypes[0], dstType, out)
            return "(\{value} != NULL ? \{nonNullValue} : (\{type(dstType)}) { .nonnull = 0 })"
        }
        return result
    }

    method toNullableValue(value:String, srcType:Type, dstType:Type,
            out:IndentedOutputStream):String {
        return "((\{nullableType(dstType)}) { \{value}, true })"
    }

    method toNonNullableValue(value:String, srcType:Type, dstType:Type,
            out:IndentedOutputStream):String {
        return "((\{type(dstType)}) \{value}.value)"
    }

    method getCastReference(value:String, src:Type, target:Type, out:IndentedOutputStream):String {
        def op:String
        if target.isBuiltinNumber() {
            assert src.isBuiltinNumber()
            return "((\{type(target)}) \{value})"
        }
        else {
            def srcClass := compiler.getClass(src)
            assert srcClass != null
            def targetClass := compiler.getClass(target)
            assert targetClass != null
            if compiler.isValue(srcClass) & !compiler.isValue(targetClass) {
                return wrapValue(value, src, target, out)
            }
            else if !compiler.isValue(srcClass) & compiler.isValue(targetClass) {
                return unwrapValue(value, src, target, out)
            }
            else if compiler.isValue(srcClass) & target.typeKind = Type.Kind.NULLABLE &
                    target.subtypes[0] = src {
                return toNullableValue(value, src, target, out)
            }
            else if compiler.isValue(targetClass) & src.typeKind = Type.Kind.NULLABLE &
                    src.subtypes[0] = target {
                return toNonNullableValue(value, src, target, out)
            }
            op := "bitcast2"
        }
        def srcType := type(src)
        def dstType := type(target)
        if srcType = dstType {
            return value
        }
        return "((\{dstType}) \{value})"
    }

    method getCastReference(base:IRNode, t:Type, out:IndentedOutputStream):String {
        def baseRef := getReference(base, out)
        return getCastReference(baseRef, base.type(), t, out)
    }

    method getConstructReference(target:Type, initCall:IRNode, out:IndentedOutputStream):String {
        match initCall {
            when IRNode.CALL(_, initType, initMref, initArgs):
                def cl := compiler.getClass(target)
                assert cl != null
                def t := type(target)
                if target.isNumber() | target = Type.Bit() {
                    match initCall {
                        when IRNode.CALL(_, _, _, args):
                            assert args.get_count() = 1
                            def value := getTypedReference(args[0], out)
                            return "((\{t}) { " + value + " })"
                    }
                }
                if compiler.isValue(cl) {
                    varCount += 1
                    def tmp := "$tmp\{varCount}"
                    methodHeader.printLine("\{t} \{tmp};")
                    writeCall(initType, initMref, initArgs, "&\{tmp}", out)
                    return tmp
                }
                def result := nextVar()
                out.printLine("\{t} \{result} = (\{t}) pandaObjectAlloc(\{sizeOf(target)}, " +
                        "(panda$core$Class*) &\{escapeName(cl.name)}$class);")
                writeCall(initType, initMref, initArgs, "\{result}", out)
                return result
            otherwise:
                assert false
        }
    }

    method getIntReference(int:UInt64, out:IndentedOutputStream):String {
        return int.convert()
    }

    method getNegatedIntReference(int:UInt64, out:IndentedOutputStream):String {
        return "-" + int
    }

    method getRealReference(real:Real64, out:OutputStream):String {
        def result := real.convert()->String
        if result.contains(".") {
            return result
        }
        return result + ".0"
    }

    method getBitReference(bit:Bit, out:IndentedOutputStream):String {
        if bit {
            return "true"
        }
        return "false"
    }

    method getVariableReference(v:Variable, out:IndentedOutputStream):String {
        return getName(v)
    }

    method getStringReference(s:String):String {
        varCount += 1
        def result := "$s\{varCount}"
        type(Type.StringType())
        strings.print("static panda$core$String \{result} = { " +
                "(panda$core$Class*) &panda$core$String$class, \{NO_REFCNT}, " +
                "(panda$core$Char8*) \"")
        for c in s.utf8() {
            strings.print("\\x\{c.convert()->UInt8,0>2:x}")
        }
        strings.printLine("\", \{s.utf8().get_count()}, \{s.hash()}, NULL };")
        return "&\{result}"
    }

    method getSelfReference(out:IndentedOutputStream):String {
        return "self"
    }

    method getSuperReference(t:Type, out:IndentedOutputStream):String {
        return "((\{type(t)}) self)"
    }

    method getIsNullReference(value:IRNode, out:IndentedOutputStream):String {
        def ref := getTypedReference(value, out)
        def cl := compiler.getClass(value.type())
        def bit:String
        if compiler.isValue(cl) {
            if value.type().typeKind != Type.Kind.NULLABLE {
                bit := "false"
            }
            else {
                bit := "!\{ref}.nonnull"
            }
        }
        else {
            bit := "\{ref} == NULL"
        }
        return "((panda$core$Bit) { \{bit} })"
    }

    method getIsNonNullReference(value:IRNode, out:IndentedOutputStream):String {
        def ref := getTypedReference(value, out)
        def cl := compiler.getClass(value.type())
        def bit:String
        if compiler.isValue(cl) {
            if value.type().typeKind != Type.Kind.NULLABLE {
                bit := "true"
            }
            else {
                bit := "\{ref}.nonnull"
            }
        }
        else {
            bit := "\{ref} != NULL"
        }
        return "((panda$core$Bit) { \{bit} })"
    }

    method getNullReference(t:Type, out:IndentedOutputStream):String {
        assert t.typeKind = Type.Kind.NULLABLE
        def cl := compiler.getClass(t.subtypes[0])
        assert cl != null
        if compiler.isValue(cl) {
            return "((\{nullableType(t)}) { .nonnull = false })"
        }
        else {
            return "NULL"
        }
    }

    method getPrefixReference(op:Token.Kind, base:IRNode, out:IndentedOutputStream):String {
        def baseRef := getReference(base, out)
        def result := nextVar()
        match op {
            when Token.Kind.SUB:
                return "-\{baseRef}"
            when Token.Kind.NOT:
                return "!\{baseRef}"
            when Token.Kind.BITWISENOT:
                return "~\{baseRef}"
            otherwise:
                assert false
        }
    }

    method getTernaryReference(test:IRNode, ifTrue:IRNode, ifFalse:IRNode,
            out:IndentedOutputStream):String {
        extraEffects.push(Array<IRNode>())
        assert ifTrue.type() = ifFalse.type()
        def testRef := getTypedReference(test, out)
        writeExtraEffects(out)
        var trueLabel := nextLabel()
        var falseLabel := nextLabel()
        def merge := nextLabel()
        def result := nextVar()
        out.printLine("\{type(ifTrue.type())} \{result};")
        out.printLine("if (\{testRef}.value) goto \{trueLabel}; else goto \{falseLabel};")
        createBlock(trueLabel, out)
        extraEffects.push(Array<IRNode>())
        out.printLine("\{result} = \{getReference(ifTrue, out)};")
        writeExtraEffects(out)
        out.printLine("goto \{merge};")
        createBlock(falseLabel, out)
        extraEffects.push(Array<IRNode>())
        out.printLine("\{result} = \{getReference(ifFalse, out)};")
        writeExtraEffects(out)
        out.printLine("goto \{merge};")
        createBlock(merge, out)
        return result
    }

    method getChoiceFieldReference(expr:IRNode, out:IndentedOutputStream):String {
        return getLValue(expr, out)
    }

    method getExpressionWithExtraEffectsReference(expr:IRNode, stmt:IRNode,
            out:IndentedOutputStream):String {
        def result := getReference(expr, out)
        extraEffects.peek().add(stmt)
        return result
    }

    method getReference(expr:IRNode, out:IndentedOutputStream):String {
        match expr {
            when IRNode.BINARY(_, _, left, op, right):
                return getBinaryReference(left, op, right, out)
            when IRNode.CALL(_, type, target, args):
                return getCallReference(type, target, args, out)
            when IRNode.CAST(_, base, type, explicit):
                return getCastReference(base, type, out)
            when IRNode.INT(_, _, value):
                return getIntReference(value, out)
            when IRNode.NEGATED_INT(_, _, value):
                return getNegatedIntReference(value, out)
            when IRNode.REAL(_, _, value):
                return getRealReference(value, out)
            when IRNode.BIT(_, _, value):
                return getBitReference(value, out)
            when IRNode.CONSTRUCT(_, type, initCall):
                return getConstructReference(type, initCall, out)
            when IRNode.VARIABLE_REFERENCE(_, variable):
                return getVariableReference(variable, out)
            when IRNode.FIELD_REFERENCE(_, _, base, field):
                return getFieldReference(base, field, out)
            when IRNode.STRING(_, str):
                return getStringReference(str)
            when IRNode.SELF:
                return getSelfReference(out)
            when IRNode.SUPER(_, t):
                return getSuperReference(t, out)
            when IRNode.REUSED_VALUE_DEFINITION(base, id):
                def result := nextVar()
                methodHeader.printLine("\{type(base.type())} \{result};")
                out.printLine("\{result} = \{getReference(base, out)};")
                reusedValues[id] := result
                return result
            when IRNode.REUSED_VALUE(_, _, id):
                def result := reusedValues[id]
                assert result != null
                return result
            when IRNode.NULL(pos, type):
                return getNullReference(type, out)
            when IRNode.IS_NULL(_, value):
                return getIsNullReference(value, out)
            when IRNode.IS_NONNULL(_, value):
                return getIsNonNullReference(value, out)
            when IRNode.PREFIX(_, op, base):
                return getPrefixReference(op, base, out)
            when IRNode.TERNARY(_, test, ifTrue, ifFalse):
                return getTernaryReference(test, ifTrue, ifFalse, out)
            when IRNode.CHOICE_FIELD_REFERENCE:
                return getChoiceFieldReference(expr, out)
            when IRNode.EXPRESSION_WITH_EXTRA_EFFECTS(base, stmt):
                return getExpressionWithExtraEffectsReference(base, stmt, out)
            otherwise:
                assert false, "unsupported expression \{expr}"
        }
    }

    method getTypedReference(expr:IRNode, out:IndentedOutputStream):String {
        return getReference(expr, out)
    }

    method writeBlock(statements:ImmutableArray<IRNode>, out:IndentedOutputStream) {
        out.printLine("{")
        out.level += 1
        for s in statements {
            writeStatement(s, out)
        }
        out.level -= 1
        out.printLine("}")
    }

    method writeBlockWithFinally(statements:ImmutableArray<IRNode>,
                                 finally:ImmutableArray<IRNode>,
                                 out:IndentedOutputStream) {
        -- The idea is similar to LLVMCodeGenerator.writeBlockWithFinally, but we don't have phi
        -- nodes, so we just use a temporary variable to store the target
        def finallyLabel := nextLabel()
        def returnLabelMap := HashMap<String, Pair<Int, String>>()
        varCount += 1
        def source := nextVar()
        out.printLine("int \{source};")
        enclosingContexts.push(EnclosingContext.FINALLY(finallyLabel, returnLabelMap, source))
        writeBlock(statements, out)
        def fallthrough := nextLabel()
        if !compiler.endsWithBranch(statements) {
            out.printLine("\{source} = -1;")
            out.printLine("goto \{finallyLabel};")
            returnLabelMap[currentBlock] := Pair<Int, String>(-1, fallthrough)
        }
        createBlock(finallyLabel, out)
        for s in finally {
            writeStatement(s, out)
        }
        out.printLine("switch (\{source}) {")
        out.level += 1
        for value in returnLabelMap.values() {
            out.printLine("case \{value.first}: goto \{value.second};")
        }
        out.level -= 1
        out.printLine("}")
        createBlock(fallthrough, out)
        enclosingContexts.pop()
    }

    method writePointerCall(m:MethodRef, args:ImmutableArray<IRNode>, out:IndentedOutputStream) {
        match m.value.name {
            when "set":
                assert args.get_count() = 2
                def ptr := getTypedReference(args[0], out)
                def arg := getTypedReference(compiler.unwrapCast(args[1]), out)
                out.printLine("store2 \{arg}, \{ptr}")
            when "[]:=":
                assert args.get_count() = 3
                assert compiler.unwrapCast(args[0]).type().subtypes.get_count() = 2
                def base := getReference(args[0], out)
                def index := getReference(args[1], out)
                def value := getReference(compiler.unwrapCast(args[2]), out)
                out.printLine("\{base}[\{index}.value] = \{value};")
            when "destroy":
                assert args.get_count() = 1
                out.printLine("pandaFree(\{getReference(args[0], out)});")
            otherwise:
                assert false
        }
    }

    -- if 'target' is non-null, it is inserted as a hidden first parameter to the call. This is used
    -- for init() calls, which require a self parameter but do not have a target in the IR.
    method writeCall(t:Type, mref:MethodRef, args:ImmutableArray<IRNode>, target:String?,
            out:IndentedOutputStream) {
        def m := mref.value
        if m.owner.name = "panda.unsafe.Pointer" {
            writePointerCall(mref, args, out)
            return
        }
        if isExternal(m.owner) {
            writeDeclaration(m)
        }
        def actualMethodType:Type
        def actualResultType:String
        def isSuper := args.get_count() >= 1 & args[0] = IRNode.SUPER
        if !isSuper & m.isVirtual() {
            actualMethodType := compiler.inheritedType(m)
            actualResultType := type(actualMethodType.subtypes[actualMethodType.subtypes.get_count() - 1])
        }
        else {
            actualMethodType := compiler.declaredType(m)
            actualResultType := type(t)
        }
        def argRefs := Array<String>()
        if target != null {
            argRefs.add(target)
        }
        def offset := args.get_count() - actualMethodType.subtypes.get_count() + 1
        for i in 0 .. args.get_count() {
            var arg := getReference(args[i], out)
            if i >= offset & actualMethodType.subtypes[i - offset] != args[i].type() {
                arg := getCastReference(arg, args[i].type(),
                            actualMethodType.subtypes[i - offset], out)
            }
            argRefs.add(arg)
        }
        def targetRef:String?
        if argRefs.get_count() > 0 {
            -- this isn't actually correct - argRefs[0] could be the target of an instance method,
            -- or just the first parameter to a class method. But getMethodReference ignores target
            -- for non-virtual methods, so this works and is easier than doing it the right way.
            targetRef := argRefs[0]
        }
        else {
            targetRef := null
        }
        def methodRef := getMethodReference(targetRef, m, isSuper, out)
        var separator := ""
        if needsStructIndirection(m) {
            varCount += 1
            def indirectVar := "$tmp" + varCount
            def resultType := type(t)
            methodHeader.printLine("\{resultType} \{indirectVar};")
            out.print("\{methodRef}(\{resultType}* \{indirectVar}")
            separator := ", "
        }
        else {
            out.print("\{methodRef}(")
        }
        for a in argRefs {
            out.print(separator)
            out.print(a)
            separator := ", "
        }
        out.printLine(");")
    }

    method writeIf(test:IRNode, ifTrue:ImmutableArray<IRNode>, ifFalse:IRNode?,
            out:IndentedOutputStream) {
        extraEffects.push(Array<IRNode>())
        def testRef := getReference(test, out)
        writeExtraEffects(out)
        out.printLine("if (\{testRef}.value) {")
        writeBlock(ifTrue, out)
        out.printLine("}")
        if ifFalse != null {
            out.printLine("else {")
            writeStatement(ifFalse, out)
            out.printLine("}")
        }
    }

    method writeSimpleRangeFor(label:String?, target:IRNode, list:IRNode,
            statements:ImmutableArray<IRNode>, out:IndentedOutputStream) {
        -- See LLVMCodeGenerator.writeRangeFor for an overview of why this code is so terrible.
        -- Here, we double down on the awful by keeping the LLVM structure completely intact and
        -- using gotos instead of anything resembling idiomatic C code, mostly to help ensure the
        -- behavior is identical.
        assert list.type().typeKind = Type.Kind.GENERIC
        assert list.type().subtypes.get_count() = 2
        assert list.type().subtypes[0].name = Compiler.RANGE_NAME
        def range := getTypedReference(list, out)
        def t := list.type().subtypes[1]
        def llt := type(t)
        def indexType:String
        if t.typeKind = Type.Kind.NULLABLE {
            assert t.subtypes.get_count() = 1
            indexType := type(t.subtypes[0])
        }
        else {
            indexType := llt
        }
        def cl := compiler.getClass(t)
        assert cl != null
        assert compiler.instanceFields(cl).get_count() = 1
        def field := compiler.instanceFields(cl)[0]
        compiler.resolve(field)
        def numberType := type(field.type)
        def index:String
        match target {
            when IRNode.VARIABLE_REFERENCE(_, variable):
                index := getName(variable)
            otherwise:
                assert false
        }

        -- extract start value from range
        def start := nextVar()
        out.printLine("\{numberType} \{start} = \{range}.min.value;")

        -- store start value
        def indexValuePtr := nextVar()
        out.printLine("\{type(cl.type())} \{index} = { \{start} };")

        -- extract end value from range
        def end := nextVar()
        out.printLine("\{numberType} \{end} = \{range}.max.value;")

        -- extract inclusive / exclusive from range
        def inclusive := nextVar()
        out.printLine("bool \{inclusive} = \{range}.inclusive.value;")

        -- start block
        def loopStart := nextLabel()
        def loopBody := nextLabel()
        def loopEnd := nextLabel()
        def loopTest := nextLabel()
        enclosingContexts.push(EnclosingContext.LOOP(label, loopEnd, loopTest)) -- FIXME Auto
        def forwardEntry := nextLabel()
        def backwardEntry := nextLabel()
        def signPrefix:String
        def unsigned:String
        if t.name.startsWith("panda.core.Int") {
            signPrefix := "s"
            unsigned := "u" + numberType
        }
        else {
            assert t.name.startsWith("panda.core.UInt") | t.name.startsWith("panda.core.Char")
            signPrefix := "u"
            unsigned := numberType
        }
        def forwardEntryInclusive := nextLabel()
        def forwardEntryExclusive := nextLabel()
        out.printLine("if (\{inclusive}) goto \{forwardEntryInclusive}; else goto " +
                "\{forwardEntryExclusive};")
        createBlock(forwardEntryInclusive, out)
        out.printLine("if (\{start} <= \{end}) goto \{loopStart}; else goto \{loopEnd};")
        createBlock(forwardEntryExclusive, out)
        out.printLine("if (\{start} < \{end}) goto \{loopStart}; else goto \{loopEnd};")
        createBlock(loopStart, out)
        writeBlock(statements, out)
        createBlock(loopTest, out)
        def loopInc := nextLabel()
        def forwardDelta := nextVar()
        out.printLine("\{numberType} \{forwardDelta} = \{end} - \{index}.value;")

        -- forward loop; determine inclusive / exclusive
        def forwardInclusiveLabel := nextLabel()
        def forwardExclusiveLabel := nextLabel()
        out.printLine("if (\{inclusive}) goto \{forwardInclusiveLabel}; else goto " +
                "\{forwardExclusiveLabel};")

        -- forward inclusive test
        createBlock(forwardInclusiveLabel, out)
        -- always use unsigned comparison to avoid overflow; we know both the delta and the step are
        -- the same sign
        out.printLine("if ((\{unsigned}) \{forwardDelta} >= 1) goto \{loopInc}; else goto " +
                "\{loopEnd};")

        -- forward exclusive test
        createBlock(forwardExclusiveLabel, out)
        def forwardExclusiveTest := nextVar()
        out.printLine("if ((\{unsigned}) \{forwardDelta} > 1) goto \{loopInc}; else goto " +
                "\{loopEnd};")

        createBlock(loopInc, out)
        def inc := nextVar()
        out.printLine("\{index}.value += 1;")
        out.printLine("goto \{loopStart};")
        createBlock(loopEnd, out)
        enclosingContexts.pop()
    }

    method writeSteppedRangeFor(label:String?, target:IRNode, list:IRNode,
            statements:ImmutableArray<IRNode>, out:IndentedOutputStream) {
        -- See LLVMCodeGenerator.writeRangeFor for an overview of why this code is so terrible.
        -- Here, we double down on the awful by keeping the LLVM structure completely intact and
        -- using gotos instead of anything resembling idiomatic C code, mostly to help ensure the
        -- behavior is identical.
        assert list.type().typeKind = Type.Kind.GENERIC
        assert list.type().subtypes.get_count() = 3
        assert list.type().subtypes[0].name = Compiler.STEPPED_RANGE_NAME
        def range := getTypedReference(list, out)
        def t := list.type().subtypes[1]
        def stepType := list.type().subtypes[2]
        def llt := type(t)
        def indexType:String
        if t.typeKind = Type.Kind.NULLABLE {
            assert t.subtypes.get_count() = 1
            indexType := type(t.subtypes[0])
        }
        else {
            indexType := llt
        }
        def cl := compiler.getClass(t)
        assert cl != null
        assert compiler.instanceFields(cl).get_count() = 1
        def field := compiler.instanceFields(cl)[0]
        compiler.resolve(field)
        def numberType := type(field.type)
        def index:String
        match target {
            when IRNode.VARIABLE_REFERENCE(_, variable):
                index := getName(variable)
            otherwise:
                assert false
        }

        -- extract start value from range
        def start := nextVar()
        out.printLine("\{numberType} \{start} = \{range}.start.value;")

        -- store start value
        def indexValuePtr := nextVar()
        out.printLine("\{type(cl.type())} \{index} = { \{start} };")

        -- extract end value from range
        def end := nextVar()
        out.printLine("\{numberType} \{end} = \{range}.end.value;")

        -- extract step value from range
        def step := nextVar()
        def stepCl := compiler.getClass(stepType)
        assert stepCl != null
        assert compiler.instanceFields(stepCl).get_count() = 1
        def stepField := compiler.instanceFields(stepCl)[0]
        compiler.resolve(stepField)
        out.printLine("\{type(stepField.type)} \{step} = \{range}.step.value;")

        -- extract inclusive / exclusive from range
        def inclusive := nextVar()
        out.printLine("bool \{inclusive} = \{range}.inclusive.value;")

        -- start block
        def loopStart := nextLabel()
        def loopBody := nextLabel()
        def loopEnd := nextLabel()
        def loopTest := nextLabel()
        enclosingContexts.push(EnclosingContext.LOOP(label, loopEnd, loopTest)) -- FIXME Auto
        def forwardEntry := nextLabel()
        def backwardEntry := nextLabel()
        def unsigned:String
        def signPrefix:String
        if stepType.name.startsWith("panda.core.Int") {
            signPrefix := "s"
        }
        else {
            assert stepType.name.startsWith("panda.core.UInt") |
                    stepType.name.startsWith("panda.core.Char")
            signPrefix := "u"
        }
        if numberType.startsWith("u") {
            unsigned := numberType
        }
        else {
            unsigned := "u" + numberType
        }
        def direction:String
        if signPrefix = "s" {
            direction := nextVar()
            out.printLine("bool \{direction} = \{step} > 0;")
        }
        else {
            direction := "true"
        }
        out.printLine("if (\{direction}) goto \{forwardEntry}; else goto \{backwardEntry};")
        createBlock(forwardEntry, out)
        def forwardEntryInclusive := nextLabel()
        def forwardEntryExclusive := nextLabel()
        out.printLine("if (\{inclusive}) goto \{forwardEntryInclusive}; else goto " +
                "\{forwardEntryExclusive};")
        createBlock(forwardEntryInclusive, out)
        out.printLine("if (\{start} <= \{end}) goto \{loopStart}; else goto \{loopEnd};")
        createBlock(forwardEntryExclusive, out)
        out.printLine("if (\{start} < \{end}) goto \{loopStart}; else goto \{loopEnd};")
        createBlock(backwardEntry, out)
        def backwardEntryInclusive := nextLabel()
        def backwardEntryExclusive := nextLabel()
        out.printLine("if (\{inclusive}) goto \{backwardEntryInclusive}; else goto " +
                "\{backwardEntryExclusive};")
        createBlock(backwardEntryInclusive, out)
        out.printLine("if (\{start} >= \{end}) goto \{loopStart}; else goto \{loopEnd};")
        createBlock(backwardEntryExclusive, out)
        def backwardEntryExclusiveTest := nextVar()
        out.printLine("if (\{start} > \{end}) goto \{loopStart}; else goto \{loopEnd};")
        createBlock(loopStart, out)
        writeBlock(statements, out)
        createBlock(loopTest, out)
        def loopInc := nextLabel()
        -- beginning of loop test, determine direction
        def forwardLabel := nextLabel()
        def backwardLabel := nextLabel()
        out.printLine("if (\{direction}) goto \{forwardLabel}; else goto \{backwardLabel};")

        -- forward loop; perform the test by subtracting index from end and then comparing to step,
        -- to avoid overflows near the maximum value
        createBlock(forwardLabel, out)
        def forwardDelta := nextVar()
        out.printLine("\{numberType} \{forwardDelta} = \{end} - \{index}.value;")

        -- forward loop; determine inclusive / exclusive
        def forwardInclusiveLabel := nextLabel()
        def forwardExclusiveLabel := nextLabel()
        out.printLine("if (\{inclusive}) goto \{forwardInclusiveLabel}; else goto " +
                "\{forwardExclusiveLabel};")

        -- forward inclusive test
        createBlock(forwardInclusiveLabel, out)
        -- always use unsigned comparison to avoid overflow; we know both the delta and the step are
        -- the same sign
        out.printLine("if ((\{unsigned}) \{forwardDelta} >= \{step}) goto \{loopInc}; else goto " +
                "\{loopEnd};")

        -- forward exclusive test
        createBlock(forwardExclusiveLabel, out)
        def forwardExclusiveTest := nextVar()
        out.printLine("if ((\{unsigned}) \{forwardDelta} > \{step}) goto \{loopInc}; else goto " +
                "\{loopEnd};")

        -- backward loop; perform the test by subtracting end from index and then comparing to
        -- -step, to avoid overflows near the minimum value
        createBlock(backwardLabel, out)
        def backwardDelta := nextVar()
        out.printLine("\{numberType} \{backwardDelta} = \{index}.value - \{end};")

        -- backward loop; determine inclusive / exclusive
        def backwardInclusiveLabel := nextLabel()
        def backwardExclusiveLabel := nextLabel()
        out.printLine("if (\{inclusive}) goto \{backwardInclusiveLabel}; else goto " +
                "\{backwardExclusiveLabel};")

        -- backward inclusive test
        createBlock(backwardInclusiveLabel, out)
        out.printLine("if ((\{unsigned}) \{backwardDelta} >= -\{step}) goto \{loopInc}; else " +
                "goto \{loopEnd};")

        -- backward exclusive test
        createBlock(backwardExclusiveLabel, out)
        out.printLine("if ((\{unsigned}) \{backwardDelta} > -\{step}) goto \{loopInc}; else " +
                "goto \{loopEnd};")

        createBlock(loopInc, out)
        def inc := nextVar()
        out.printLine("\{index}.value += \{step};")
        out.printLine("goto \{loopStart};")
        createBlock(loopEnd, out)
        enclosingContexts.pop()
    }

    method writeRangeFor(label:String?, target:IRNode, list:IRNode,
            statements:ImmutableArray<IRNode>, out:IndentedOutputStream) {
        if list.type().isRange() {
            writeSimpleRangeFor(label, target, list, statements, out)
        }
        else if list.type().isSteppedRange() {
            writeSteppedRangeFor(label, target, list, statements, out)
        }
        else {
            assert false
        }
    }

    method writeWhile(label:String?, test:IRNode, statements:ImmutableArray<IRNode>,
            out:IndentedOutputStream) {
        assert test.type() = Type.Bit()
        def loopStart := nextLabel()
        def loopEnd := nextLabel()
        enclosingContexts.push(EnclosingContext.LOOP(label, loopEnd, loopStart)) -- FIXME Auto
        createBlock(loopStart, out)
        extraEffects.push(Array<IRNode>())
        def testVar := nextVar()
        out.printLine("bool \{testVar} = \{getReference(test, out)}.value;")
        writeExtraEffects(out)
        out.printLine("if (!\{testVar}) goto \{loopEnd};")
        writeBlock(statements, out)
        out.printLine("goto \{loopStart};")
        createBlock(loopEnd, out)
        enclosingContexts.pop()
    }

    method writeDo(label:String?, statements:ImmutableArray<IRNode>, test:IRNode,
            out:IndentedOutputStream) {
        assert test.type() = Type.Bit()
        def loopStart := nextLabel()
        def loopEnd := nextLabel()
        enclosingContexts.push(EnclosingContext.LOOP(label, loopEnd, loopStart)) -- FIXME Auto
        createBlock(loopStart, out)
        writeBlock(statements, out)
        extraEffects.push(Array<IRNode>())
        def testVar := nextVar()
        out.printLine("bool \{testVar} = \{getReference(test, out)}.value;")
        writeExtraEffects(out)
        out.printLine("if (\{testVar}) goto \{loopStart};")
        createBlock(loopEnd, out)
        enclosingContexts.pop()
    }

    method writeLoop(label:String?, statements:ImmutableArray<IRNode>, out:IndentedOutputStream) {
        def loopStart := nextLabel()
        def loopEnd := nextLabel()
        enclosingContexts.push(EnclosingContext.LOOP(label, loopEnd, loopStart)) -- FIXME Auto
        createBlock(loopStart, out)
        out.printLine("while (true) {")
        writeBlock(statements, out)
        out.printLine("}")
        createBlock(loopEnd, out)
        enclosingContexts.pop()
    }

    method writeVarTarget(target:IRNode, value:IRNode?, out:IndentedOutputStream) {
        match target {
            when IRNode.VARIABLE_REFERENCE(_, v):
                methodHeader.print("\{type(v.type)} \{getName(v)}")
                if compiler.isRefCounted(v.type) {
                    methodHeader.print(" = NULL")
                }
                methodHeader.printLine(";")
                if value != null {
                    out.printLine("\{getName(v)} = \{getReference(value, out)};")
                }
                else {
                    out.printLine("memset(&\{getName(v)}, 0, sizeof(\{getName(v)}));")
                }
            otherwise:
                assert false
        }
    }

    method writeVar(kind:Variable.Kind, decls:ImmutableArray<IRNode>, out:IndentedOutputStream) {
        for decl in decls {
            match decl {
                when IRNode.DECLARATION(target, value):
                    writeVarTarget(target, value, out)
                otherwise:
                    assert false
            }
        }
    }

    method getLValue(lvalue:IRNode, out:IndentedOutputStream):String {
        match lvalue {
            when IRNode.CAST:
                return getLValue(compiler.unwrapCast(lvalue), out)
            when IRNode.VARIABLE_REFERENCE(_, v):
                return getName(v)
            when IRNode.FIELD_REFERENCE(_, _, base, field):
                def baseRef := getReference(base, out)
                return "\{baseRef}->\{field.name}"
            when IRNode.REUSED_VALUE_DEFINITION(value, id):
                def result := getLValue(value, out)
                reusedValues[id] := result
                return result
            when IRNode.CHOICE_FIELD_REFERENCE(_, value, ce, field):
                def data := ce.owner.fields[1]
                assert data.name = ClassDecl.CHOICE_DATA_NAME
                def fieldRef := IRNode.FIELD_REFERENCE(lvalue.position(),
                        data.type, value, data)
                def base := getLValue(fieldRef, out)
                def size := hCodeGen.llvmCodeGen.getChoiceDataSize(ce.owner)
                def offset := hCodeGen.llvmCodeGen.getChoiceFieldOffset(ce, field)
                def result := nextVar()
                out.printLine("\{type(lvalue.type())}* \{result} = ((\{type(lvalue.type())}*) " +
                        "((char*) \{base} + \{offset}));")
                return "*\{result}"
            otherwise:
                assert false, "unsupported lvalue: \{lvalue}"
        }
    }

    method writeAssignment(left:IRNode, right:IRNode, out:IndentedOutputStream) {
        out.printLine("\{getLValue(left, out)} = \{getReference(right, out)};")
    }

    method writeReturn(value:IRNode?, out:IndentedOutputStream) {
        if value != null {
            def tmp := "$finallyReturn\{varCount}"
            varCount += 1
            def valueType := type(value.type())
            methodHeader.printLine("\{valueType} \{tmp};")
            extraEffects.push(Array<IRNode>())
            def result := getReference(value, out)
            out.printLine("\{tmp} = \{result};")
            writeExtraEffects(out)
            writeFinallies(null, out)
            def load := nextVar()
            out.printLine("return \{tmp};")
        }
        else {
            writeFinallies(null, out)
            out.printLine("return;")
        }
    }

    -- invokes all currently-pending finally blocks and resumes the same code flow
    method writeFinallies(boundary:EnclosingContext?, out:IndentedOutputStream) {
        for c in enclosingContexts {
            match c {
                when EnclosingContext.FINALLY(label, returnMap, sourceBlock):
                    def returnLabel := nextLabel()
                    out.printLine("\{sourceBlock} = \{returnMap.get_count()};")
                    out.printLine("goto \{label};")
                    returnMap[currentBlock] := Pair<Int, String>(returnMap.get_count(), returnLabel)
                    createBlock(returnLabel, out)
            }
            if boundary != null & boundary == c {
                break
            }
        }
    }

    function findLoop(name:String?):EnclosingContext {
        for i in 0 .. enclosingContexts.get_count() {
            def context := enclosingContexts.peek(i)
            match context {
                when EnclosingContext.LOOP(loopLabel, _, _):
                    if name = null | (loopLabel != null & loopLabel = name) {
                        return context
                    }
            }
        }
        assert false
    }

    method writeBreak(label:String?, out:IndentedOutputStream) {
        def desc := findLoop(label)
        writeFinallies(desc, out)
        match desc {
            when EnclosingContext.LOOP(_, breakLabel, _):
                out.printLine("goto \{breakLabel};")
            otherwise:
                assert false
        }
    }

    method writeContinue(label:String?, out:IndentedOutputStream) {
        def desc := findLoop(label)
        writeFinallies(desc, out)
        match desc {
            when EnclosingContext.LOOP(_, _, continueLabel):
                out.printLine("goto \{continueLabel};")
            otherwise:
                assert false
        }
    }

    method writeAssert(test:IRNode, message:IRNode?, out:IndentedOutputStream) {
        extraEffects.push(Array<IRNode>())
        out.printLine("PANDA_ASSERT(\{getReference(test, out)});")
        writeExtraEffects(out)
    }

    method writeMatch(value:IRNode, whens:ImmutableArray<IRNode>, other:ImmutableArray<IRNode>?,
            out:IndentedOutputStream) {
        out.printLine("switch (\{getReference(value, out)}.value) {")
        out.level += 1
        for w in whens {
            match w {
                when IRNode.WHEN(_, tests, statements):
                    for test in tests {
                        out.printLine("case \{compiler.getConstantInt(test)}:")
                    }
                    writeBlock(statements, out)
                    out.printLine("break;")
                otherwise:
                    assert false
            }
        }
        if other != null {
            out.printLine("default:")
            writeBlock(other, out)
        }
        out.level -= 1
        out.printLine("}")
    }

    method writeExtraEffects(out:IndentedOutputStream) {
        def finalEffects := extraEffects.pop()
        for i in finalEffects.get_count() - 1 ... 0 by -1 {
            writeStatement(finalEffects[i], out)
        }
    }

    method writeStatement(stmt:IRNode, out:IndentedOutputStream) {
        extraEffects.push(Array<IRNode>())
        match stmt {
            when IRNode.BINARY(_, _, left, op, right):
                writeAssignment(left, right, out)
            when IRNode.BLOCK(_, statements):
                writeBlock(statements, out)
            when IRNode.BLOCK_WITH_FINALLY(_, statements, finally):
                writeBlockWithFinally(statements, finally, out)
            when IRNode.CALL(_, target, mref, args):
                writeCall(target, mref, args, null, out)
            when IRNode.EXPRESSION_WITH_EXTRA_EFFECTS(base, stmt):
                getExpressionWithExtraEffectsReference(base, stmt, out)
            when IRNode.IF(_, test, ifTrue, ifFalse):
                writeIf(test, ifTrue, ifFalse, out)
            when IRNode.RANGE_FOR(_, label, target, list, statements):
                writeRangeFor(label, target, list, statements, out)
            when IRNode.WHILE(_, label, test, statements):
                writeWhile(label, test, statements, out)
            when IRNode.DO(_, label, statements, test):
                writeDo(label, statements, test, out)
            when IRNode.LOOP(_, label, statements):
                writeLoop(label, statements, out)
            when IRNode.VAR(_, kind, decls):
                writeVar(kind, decls, out)
            when IRNode.RETURN(_, value):
                writeReturn(value, out)
            when IRNode.BREAK(_, label):
                writeBreak(label, out)
            when IRNode.CONTINUE(_, label):
                writeContinue(label, out)
            when IRNode.ASSERT(_, test, msg):
                writeAssert(test, msg, out)
            when IRNode.MATCH(_, value, whens, other):
                writeMatch(value, whens, other, out)
            when IRNode.REUSED_VALUE_DEFINITION(base, id):
                def result := nextVar()
                methodHeader.printLine("\{type(base.type())} \{result};")
                out.printLine("\{result} = \{getReference(base, out)};")
                reusedValues[id] := result
            otherwise:
                assert false, "unsupported statement \{stmt}"
        }
        writeExtraEffects(out)
    }

    method selfType(m:MethodDecl):String {
        def result := type(m.owner.type())
        if m.methodKind = MethodDecl.Kind.INIT & !result.endsWith("*") {
            return result + "*"
        }
        return result
    }

    @override
    method writeDeclaration(m:MethodDecl) {
        writeImport(m.owner)
    }

    @override
    method write(m:MethodDecl, body:ImmutableArray<IRNode>) {
        assert compiler.currentClass.peek() == m.owner
        currentMethod := m
        currentBlock := "0"
        methodHeaderBuffer.clear()
        methods.print("\{type(m.returnType)} \{getName(m)}(")
        var separator := ""
        if !m.annotations.isClass() {
            methods.print("\{selfType(m)} self")
            separator := ", "
        }
        for p in m.parameters {
            methods.print("\{separator}\{type(p.type)} p_\{escapeName(p.name)}")
            separator := ", "
        }
        methods.printLine(") {")
        methods.level += 1
        def bodyBuffer := MemoryOutputStream()
        def indentedBody := IndentedOutputStream(bodyBuffer)
        if m.methodKind = MethodDecl.Kind.INIT {
            for f in compiler.instanceFields(m.owner) {
                compiler.resolve(f)
                if compiler.isRefCounted(f.type) & f.name != "$class" {
                    writeAssignment(IRNode.FIELD_REFERENCE(m.position, f.type,
                            IRNode.SELF(m.position, m.owner.type()), f),
                            IRNode.NULL(m.position, f.type.nullable()), indentedBody)
                }
            }
        }
        for s in body {
            writeStatement(s, indentedBody)
        }
        methods.print(methodHeaderBuffer.finish())
        methods.print(bodyBuffer.finish())
        methods.level -= 1
        methods.printLine("}")
        currentMethod := null
    }

    @override
    method start(cl:ClassDecl) {
        assert currentClass = null
        currentClass := cl
        imports.clear()
        strings.clear()
        declarations.clear()
        types.clear()
        methodsBuffer.clear()
        wrapperShimsBuffer.clear()
        shimsBuffer.clear()
        declared.clear()
        writtenTypes.clear()
        writtenWrappers.clear()
        classConstants.clear()
        variableNames.clear()
        varCount := 0
        reusedValues.clear()
        methodShims.clear()
        def path := hCodeGen.getPath(cl, ".c")
        path.parent().createDirectories()
        out := IndentedOutputStream(path.openOutputStream())
        getClassConstant(cl)
        if compiler.isValue(cl) {
            getWrapperClassConstant(cl)
        }
    }

    @override
    method end(cl:ClassDecl) {
        finish()
        currentClass := null
    }

    @override
    method finish() {
        out.printLine(shimsBuffer.finish())
        shimsBuffer.clear()
        out.printLine(wrapperShimsBuffer.finish())
        wrapperShimsBuffer.clear()
        out.printLine(types.finish())
        types.clear()
        out.printLine(strings.finish())
        strings.clear()
        out.printLine(methodsBuffer.finish())
        methodsBuffer.clear()
--        out.out.cleanup() -- FIXME shouldn't be necessary
    }
}