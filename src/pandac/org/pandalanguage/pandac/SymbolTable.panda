package org.pandalanguage.pandac

@final
class SymbolTable {
    @private
    def compiler:Compiler

    @private
    def symbols := HashMap<String, Symbol>()

    @private
    def merged := HashMap<String, Symbol>()

    @private
    def parents := Array<SymbolTable>()

    init(compiler:Compiler) {
        self.compiler := compiler
    }

    init(parent:SymbolTable) {
        self.compiler := parent.compiler
        self.parents.add(parent)
    }

    method add(s:Symbol) {
        add(s, s.name)
    }

    method add(s:Symbol, name:String) {
        merged.remove(name)
        def old := symbols[name]
        if old = null {
            symbols[name] := s
            return
        }
        if s.kind = Symbol.Kind.METHOD {
            match old.kind {
                when Symbol.Kind.METHOD:
                    def methods := Array<MethodDecl>()
                    methods.add(s->MethodDecl)
                    methods.add(old->MethodDecl)
                    symbols[name] := Methods(methods)
                    return
                when Symbol.Kind.METHODS:
                    def methods := Array<MethodDecl>()
                    methods.add(s->MethodDecl)
                    methods.addAll((old->Methods).methods) -- FIXME extra parentheses
                    symbols[name] := Methods(methods)
                    return
            }
        }
        compiler.error(s.position, "duplicate symbol '\{name}' (previous declaration was at " +
                old.position)
    }

    @private
    method addIfNotOverridden(m:MethodDecl, methods:List<MethodDecl>) {
        if !m.get_heritable() {
            return
        }
        for test in methods {
            if compiler.getOverriddenMethod(test) == m {
                return
            }
        }
        methods.add(m)
    }

    @private
    function merge(symbol:Symbol?, inherited:Symbol?):Symbol? {
        if inherited = null {
            return symbol
        }
        if symbol = null {
            return inherited
        }
        if symbol == inherited {
            return symbol
        }
        if !inherited.get_heritable() {
            return symbol
        }
        match symbol.kind {
            when Symbol.Kind.METHOD:
                match inherited.kind {
                    when Symbol.Kind.METHODS:
                        def methods := Array<MethodDecl>() -- FIXME literal
                        methods.add(symbol->MethodDecl)
                        for m in (inherited->Methods).methods {
                            addIfNotOverridden(m, methods)
                        }
                        return Methods(methods)
                    when Symbol.Kind.METHOD:
                        if compiler.getOverriddenMethod(symbol->MethodDecl) ==
                                inherited->MethodDecl {
                            return symbol
                        }
                        def methods := Array<MethodDecl>() -- FIXME literal
                        methods.add(symbol->MethodDecl)
                        methods.add(inherited->MethodDecl)
                        return Methods(methods)
                    otherwise:
                        return symbol
                }
            when Symbol.Kind.METHODS:
                match inherited.kind {
                    when Symbol.Kind.METHODS:
                        def methods := Array<MethodDecl>((symbol->Methods).methods) -- FIXME parens
                        for m in (inherited->Methods).methods {
                            addIfNotOverridden(m, methods)
                        }
                        return Methods(methods)
                    when Symbol.Kind.METHOD:
                        def methods := Array<MethodDecl>((symbol->Methods).methods) -- FIXME parens
                        addIfNotOverridden(inherited->MethodDecl, methods)
                        return Methods(methods)
                    otherwise:
                        return symbol
                }
            otherwise:
                return symbol
        }
    }

    function [](name:String):Symbol? {
        var result := merged[name]
        if result = null {
            result := symbols[name]
            for p in parents {
                result := merge(result, p[name])
            }
            merged[name] := result
        }
        return result
    }

    @override
    function convert():String {
        return "SymbolTable<parents(\{parents.get_count()}), symbols=\{symbols}>"
    }
}