package org.pandalanguage.pandac.pandadoc

uses org.pandalanguage.pandac.ClassDecl
uses org.pandalanguage.pandac.CodeGenerator
uses org.pandalanguage.pandac.Compiler
uses org.pandalanguage.pandac.Compiler.Error
uses org.pandalanguage.pandac.Compiler.Settings
uses org.pandalanguage.pandac.Config
uses org.pandalanguage.pandac.IRNode
uses org.pandalanguage.pandac.MethodDecl

@private
class DummyCodeGenerator : CodeGenerator {
    @override
    method setCompiler(compiler:Compiler) {
    }

    @override
    method start(cl:ClassDecl) {
    }

    @override
    method writeDeclaration(m:MethodDecl) {
    }

    @override
    method write(m:MethodDecl, body:ImmutableArray<IRNode>) {
    }

    @override
    method end(cl:ClassDecl) {
    }

    @override
    method finish() {
    }
}

method process(input:File, pandadoc:PandaDoc) {
    if input.isDirectory() {
        for file in input.list() {
            process(file, pandadoc)
        }
    }
    else if input.path.endsWith(".panda") {
        for cl in pandadoc.compiler.scan(input) {
            pandadoc.add(cl)
        }
    }
}

method recursiveDelete(root:File, currentPath:File) {
    for f in currentPath.list() {
        recursiveDelete(root, f)
    }
    -- deleting a directory tree on an end user's machine is scary, so let's be extra careful...
    if !currentPath.absolute().path.startsWith(root.absolute().path) {
        Console.errorStream().printLine("Panicking! Recursive delete stepped outside of the " +
                "expected path tree! (was deleting \{root}, ended up looking at \{currentPath})")
        System.exit(1)
    }
    currentPath.delete()
}

method xsltproc(input:File, xsl:File, output:File) {
    if input.isDirectory() {
        for file in input.list() {
            xsltproc(file, xsl, output.resolve(file.name()))
        }
    }
    else if input.path.endsWith(".xml") {
        def args := Array<String>() -- FIXME literal
        args.add(xsl.path)
        args.add(input.path)
        def p := System.exec(File("xsltproc"), args)
        output.parent().createDirectories()
        p.output.sendTo(output.changeExtension(".html").openOutputStream())
        p.error.sendTo(Console.errorStream())
        assert p.waitFor() = 0
    }
}

method addTableOfContentsToTree(toc:String, path:File, level:Int) {
    if path.isDirectory() {
        for file in path.list() {
            addTableOfContentsToTree(toc, file, level + 1)
        }
    }
    else if path.name().endsWith(".html") {
        def root := level * "../"
        def finalToc := toc.replace("href=\"", "href=\"\{root}")
                .replace("src=\"", "src=\"\{root}")
                .replace("prepareToC(\"", "prepareToC(\"\{root}")
        path.write(path.readFully().replace(/<!--TOCBEGIN-->.*<!--TOCEND-->/,
                "<!--TOCBEGIN-->\{finalToc}<!--TOCEND-->"))
    }
}

method addTableOfContents(tocFile:File, tree:File, apiRelativePath:String) {
    def args := Array<String>() -- FIXME literal
    args.add(File(Config.pandaSourceDir()).resolve("tools/tableOfContents.xsl").path)
    args.add(tocFile.path)
    def p := System.exec(File("xsltproc"), args)
    addTableOfContentsToTree(p.output.readFully(), tree, -1)
}

method main(args:ListView<String>) {
    if args.get_count() != 4 {
        Console.errorStream().printLine("usage: pandadoc <source dir> <api dir> <root dir>")
        System.exit(1)
    }
    def input := File(args[1])
    def root := File(args[2])
    def apiRelativePath := args[3] + "/"
    def tmpOutput := System.tempDir().resolve("pandadoc-tmp")
    def tocFile := System.tempDir().resolve("pandadoc-toc.xml")
    def imports := Array<File>() -- FIXME literal
    imports.add(File(Config.pandaSourceDir()))
    imports.add(input)
    def settings := Settings(File(Config.pandaSourceDir()), imports, 0, 0)
    def compiler := Compiler(MessageQueue<Error>(), DummyCodeGenerator(), settings)
    def pandadoc := PandaDoc(compiler, tmpOutput, tocFile, apiRelativePath)
    process(input, pandadoc)
    pandadoc.finish()
    def mainXSL := File(Config.pandaSourceDir()).resolve("tools/pandadoc.xsl")
    xsltproc(tmpOutput, mainXSL, root.resolve(apiRelativePath))
    for file in File(Config.pandaSourceDir()).resolve("../docs/html").list() {
        file.openInputStream().sendTo(root.resolve(file.name()).openOutputStream())
    }
    recursiveDelete(tmpOutput.absolute(), tmpOutput.absolute())
    addTableOfContents(tocFile, root, apiRelativePath)
--    tocFile.delete()
    Console.printLine(tocFile)
}
