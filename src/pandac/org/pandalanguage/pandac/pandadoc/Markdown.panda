package org.pandalanguage.pandac.pandadoc

uses org.pandalanguage.pandac.Compiler
uses org.pandalanguage.pandac.parser.Parser
uses org.pandalanguage.pandac.parser.SyntaxHighlighter
uses org.pandalanguage.pandac.parser.Token

-- Port of markdownj (https://github.com/myabc/markdownj) with some fixes and enhancements. As this
-- is a port of Java code which is in turn a port of Perl code, this isn't especially idiomatic
-- Panda code.

-- Original markdownj license and copyright:
-*

Copyright (c) 2005 Pete Bevin
Copyright (c) 2005 - 2007 John Mutchek, Marty Lamb / Martian Software, Inc.
Copyright (c) 2008 - 2013 Alex Coles

All rights reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are met:

    * Redistributions of source code must retain the above copyright
      notice, this list of conditions and the following disclaimer.
    * Redistributions in binary form must reproduce the above copyright
      notice, this list of conditions and the following disclaimer in the
      documentation and/or other materials provided with the distribution.
    * Neither the name of the <organization> nor the
      names of its contributors may be used to endorse or promote products
      derived from this software without specific prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
DISCLAIMED. IN NO EVENT SHALL <COPYRIGHT HOLDER> BE LIABLE FOR ANY
DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

*-

@private
class Protector {
    -- for the record, I hate the way Markdown implementations use long pseudorandom strings to
    -- "escape" things rather than using actual escape sequences, but I have about six million more
    -- important things on my plate and don't have the energy to fight it right now.
    @private
    def encodeMap := HashMap<String, String>()

    def decodeMap := HashMap<String, String>()

    def random := Random.default()

    method encode(s:String):String {
        var result := encodeMap[s]
        if result = null {
            result := randomToken()
            encodeMap[s] := result
            decodeMap[result] := s
        }
        return result
    }

    function decode(s:String):String? {
        return decodeMap[s]
    }

    method randomToken():String {
        constant LENGTH := 20
        constant SAFE_CHARS := "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-/,."
        def result := MutableString()
        for i in 0 .. LENGTH {
            result.append(SAFE_CHARS[random.int(SAFE_CHARS.byteLength())])
        }
        return result.finish()
    }
}

class Markdown {
    class LinkDefinition {
        def url:String
        def title:String

        init(url:String, title:String)  {
            self.url := url
            self.title := title
        }
    }

    constant TAB_WIDTH := 4

    def source:File

    def errorQueue := MessageQueue<Compiler.Error>()

    def parser := Parser(errorQueue)

    @private
    def linkResolver:(String)=>(String)?

    def linkDefinitions := HashMap<String, LinkDefinition>()

    @private
    def charProtector := Protector()

    @private
    def htmlProtector := Protector()

    @private
    def random := Random.default()

    @private
    var listLevel := 0

    init() {
        init(null)
    }

    init(linkResolver:(String)=>(String)?) {
        self.source := File("/tmp/dummy")
        self.linkResolver := linkResolver
        parser.syntaxHighlighter := SyntaxHighlighter()
    }

    method process(raw:String):String {
        def text := MutableString(raw)
        text.replace(/\r\n/, "\n") -- DOS to Unix
        text.replace(/\r/, "\n")    -- Mac to Unix
        text.replace(/(?m)^[ \t]+$/, "")

        -- Make sure text ends with a couple of newlines:
        text.append("\n\n")

        detabify(text)
        text.replace(/^[ ]+$/, "")
        hashHTMLBlocks(text)
        stripLinkDefinitions(text)
        runBlockGamut(text)
        unescapeSpecialChars(text)

        text.append("\n")
        return text.convert()
    }

    method encodeBackslashEscapes(text:MutableString) {
        def normalChars := "`_>!".utf8()
        def escapedChars := "*{}[]()#+-.".utf8()

        -- Two backslashes in a row
        text.replace("\\\\\\\\", charProtector.encode("\\"))

        -- Normal characters don't require a backslash in the regular expression
        encodeEscapes(text, normalChars, "\\\\")
        encodeEscapes(text, escapedChars, "\\\\\\")
    }

    method encodeEscapes(text:MutableString, chars:ListView<Char8>, slashes:String) {
        for ch in chars {
            def regex := RegularExpression("(?m)" + slashes + ch)
            text.replace(regex, charProtector.encode(ch.convert()), false)
        }
    }

    method stripLinkDefinitions(text:MutableString) {
        def p := RegularExpression("^[ ]{0,3}\\[(.+)\\]:" + -- ID = $1
                "[ \\t]*\\n?[ \\t]*" + -- Space
                "<?(\\S+?)>?" + -- URL = $2
                "[ \\t]*\\n?[ \\t]*" + -- Space
                "(?:[\"(](.+?)[\")][ \\t]*)?" + -- Optional title = $3
                "(?:\\n+|\\Z)",
                RegularExpression.MULTILINE)

        text.replace(p, function(groups:ListView<String?>):String {
            def id := groups[1] -- FIXME .toLowerCase()
            def url := MutableString(groups[2])
            encodeAmpsAndAngles(url)
            var title:String?
            if groups.get_count() > 3 {
                title := groups[3]
                if title = null {
                    title := ""
                }
                title := title.replace("\"", "&quot;")
            }
            else {
                title := ""
            }

            linkDefinitions[id] := LinkDefinition(url.finish(), title)
            return ""
        })
    }

    method runBlockGamut(text:MutableString) {
        doHeaders(text)
        doHorizontalRules(text)
        doLists(text)
        doCodeBlocks(text)
        doBlockQuotes(text)
        hashHTMLBlocks(text)
        formParagraphs(text)
    }

    method doHorizontalRules(text:MutableString) {
        def hrDelimiters := Array<String>() -- FIXME literal
        hrDelimiters.add("\\*")
        hrDelimiters.add("-")
        hrDelimiters.add("_")
        for hrDelimiter in hrDelimiters {
            text.replace(RegularExpression("(?m)^[ ]{0,2}([ ]?\{hrDelimiter}[ ]?){3,}[ ]*$"),
                    "<hr />")
        }
    }

    method hashHTMLBlocks(text:MutableString) {
        -- Hashify HTML blocks:
        -- We only want to do this for block-level HTML tags, such as headers,
        -- lists, and tables. That's because we still want to wrap <p>s around
        -- "paragraphs" that are wrapped in non-block-level tags, such as anchors,
        -- phrase emphasis, and spans. The list of tags we're looking for is
        -- hard-coded:

        def tagsA := Array<String>() -- FIXME literal
        tagsA.add("p")
        tagsA.add("div")
        tagsA.add("h1")
        tagsA.add("h2")
        tagsA.add("h3")
        tagsA.add("h4")
        tagsA.add("h5")
        tagsA.add("h6")
        tagsA.add("blockquote")
        tagsA.add("pre")
        tagsA.add("table")
        tagsA.add("dl")
        tagsA.add("ol")
        tagsA.add("ul")
        tagsA.add("script")
        tagsA.add("noscript")
        tagsA.add("form")
        tagsA.add("fieldset")
        tagsA.add("iframe")
        tagsA.add("math")
        def tagsB := Array<String>() -- FIXME literal
        tagsB.add("ins")
        tagsB.add("del")

        def alternationA := tagsA.join("|")
        def alternationB := "\{alternationA}|\{tagsB.join("|")}"

        def lessThanTab := TAB_WIDTH - 1

        -- First, look for nested blocks, e.g.:
        --   <div>
        --       <div>
        --       tags for inner block must be indented.
        --       </div>
        --   </div>
        --
        -- The outermost tags must start at the left margin for this to match, and
        -- the inner nested divs must be indented.
        -- We need to do this before the next, more liberal match, because the next
        -- match will start at the first `<div>` and stop at the first `</div>`.
        def p1 := RegularExpression("(" +
                "^<(" + alternationA + ")" +
                "\\b" +
                "(.*\\n)*?" +
                "</\\2>" +
                "[ ]*" +
                "(?=\\n+|\\Z))",
                RegularExpression.MULTILINE || RegularExpression.CASE_INSENSITIVE)

        function protectHTML(groups:ListView<String?>):String {
            def literal := groups[0]
            return "\n\n\{htmlProtector.encode(literal)}\n\n"
        }
        text.replace(p1, protectHTML)

        -- Now match more liberally, simply from `\n<tag>` to `</tag>\n`
        def p2 := RegularExpression("(" +
                "^" +
                "<(" + alternationB + ")" +
                "\\b" +
                "(.*\\n)*?" +
                ".*</\\2>" +
                "[ ]*" +
                "(?=\\n+|\\Z))",
                RegularExpression.MULTILINE || RegularExpression.CASE_INSENSITIVE)
        text.replace(p2, protectHTML)

        -- Special case for <hr>
        def p3 := RegularExpression("(?:" +
                "(?<=\\n\\n)" +
                "|" +
                "\\A\\n?" +
                ")" +
                "(" +
                "[ ]{0," + lessThanTab + "}" +
                "<(hr)" +
                "\\b" +
                "([^<>])*?" +
                "/?>" +
                "[ ]*" +
                "(?=\\n{2,}|\\Z))",
                RegularExpression.CASE_INSENSITIVE)
        text.replace(p3, protectHTML)

        -- Special case for standalone HTML comments:
        def p4 := RegularExpression("(?:" +
                "(?<=\\n\\n)" +
                "|" +
                "\\A\\n?" +
                ")" +
                "(" +
                "[ ]{0," + lessThanTab + "}" +
                "(?s:" +
                "<!" +
                "(--.*?--\\s*)+" +
                ">" +
                ")" +
                "[ ]*" +
                "(?=\\n{2,}|\\Z)" +
                ")")
        text.replace(p4, protectHTML)
    }

    method formParagraphs(markup:MutableString) {
        markup.replace(/\A\n+/, "")
        markup.replace(/\n+\z/, "")

        def paragraphs:Array<String>
        if markup.byteLength() = 0 {
            paragraphs := Array<String>()
        } else {
            paragraphs := Array<String>(markup.convert().split(/\n{2,}/))
        }
        for i in 0 .. paragraphs.get_count() {
            def paragraph := paragraphs[i]
            def decoded := htmlProtector.decode(paragraph)
            if decoded != null {
                paragraphs[i] := decoded
            }
            else {
                def mutable := MutableString(paragraph)
                runSpanGamut(mutable)
                paragraphs[i] := "<p>\{mutable}</p>"
            }
        }
        markup[..] := paragraphs.join("\n\n")
    }

    method doAutoLinks(markup:MutableString) {
        markup.replace(/<((https?|ftp):[^'\">\s]+)>/, "<a href=\"$1\">$1</a>")
        def email := /<([-.\w]+\@[-a-z0-9]+(\.[-a-z0-9]+)*\.[a-z]+)>/
        markup.replace(email, function(groups:ListView<String?>):String {
            def address := groups[1]
            def ed := MutableString(address)
            unescapeSpecialChars(ed)
            def addr := encodeEmail(ed.convert())
            def url := encodeEmail("mailto:\{ed}")
            return "<a href=\"\{url}\">\{addr}</a>"
        })
    }

    method unescapeSpecialChars(ed:MutableString) {
        for hash in charProtector.decodeMap.keys() {
            def plaintext := charProtector.decode(hash)
            ed.replace(hash, plaintext)
        }
    }

    function encodeEmail(s:String):String {
        def result := MutableString()
        for ch in s {
            -- WTF...? I have to wonder who looked at this and thought "Yeah, this is a great plan!"
            def r := random.real64()
            if r < 0.45 { -- Decimal
                result.append("&#")
                result.append(ch.convert()->Int32)
                result.append(";")
            }
            else if r < 0.9 { -- Hex
                result.append("&#x")
                result.append(ch.convert()->Int32.format("x"))
                result.append(";")
            }
            else {
                result.append(ch)
            }
        }
        return result.convert()
    }

    method doBlockQuotes(markup:MutableString) {
        def p := RegularExpression("(" +
                "(" +
                "^[ \t]*>[ \t]?" + -- > at the start of a line
                ".+\\n" + -- rest of the first line
                "(.+\\n)*" + -- subsequent consecutive lines
                "\\n*" + -- blanks
                ")+" +
                ")",
                RegularExpression.MULTILINE)
        markup.replace(p, function(groups:ListView<String?>):Object {
            def blockQuote := MutableString(groups[1])
            blockQuote.replace(/(?m)^[ \t]*>[ \t]?/, "")
            blockQuote.replace(/(?m)^[ \t]+$/, "")
            runBlockGamut(blockQuote)
            blockQuote.replace("^", "  ")

            def p1 := RegularExpression("(\\s*<pre>.*?</pre>)", RegularExpression.DOTALL)
            blockQuote.replace(p1, groups => groups[1].replace("^  ", ""))
            return "<blockquote>\n\{blockQuote}\n</blockquote>\n\n"
        })
    }

    method detabify(text:MutableString) {
        text.replace(/(.*?)\t/, function(groups:ListView<String?>):String {
            def lineSoFar := groups[1]
            def width := lineSoFar.length()
            def replacement := MutableString(lineSoFar)
            do {
                replacement.append(" ")
                width += 1
            }
            while width % TAB_WIDTH != 0
            return replacement.convert()
        })
    }

    @class
    method outdent(s:MutableString) {
        s.replace(/(?m)^(\t|[ ]{1,4})/, "")
    }

    class CodeReplacer {
        constant LANG_IDENTIFIER := "lang:"

        def markdown:Markdown

        init(markdown:Markdown) {
            self.markdown := markdown
        }

        function replacement(groups:ListView<String?>):String {
            def codeBlock := groups[1]
            def ed := MutableString(codeBlock)
            Markdown.outdent(ed)
            markdown.encodeCode(ed)
            markdown.detabify(ed)
            ed.replace(/\A\n+/, "")
            ed.replace(/\s+\z/, "")
            def text := ed.convert()
            def out:String
            def firstLine := firstLine(text)
            if isLanguageIdentifier(firstLine) {
              out := languageBlock(firstLine, text)
            }
            else {
              out := genericCodeBlock(text)
            }
            return out
        }

        function firstLine(text:String):String {
            return text.split("\n")[0]
        }

        function isLanguageIdentifier(line:String):Bit {
            var lang := ""
            if line.startsWith(LANG_IDENTIFIER) {
                lang := line.replace(LANG_IDENTIFIER, "").trim() -- FIXME supposed to be replaceFirst
            }
            return lang != ""
        }

        function languageBlock(firstLine:String, text:String):String {
            def lang := firstLine.replace(LANG_IDENTIFIER, "").trim() -- FIXME supposed to be replaceFirst
            def block := text.replace(firstLine + "\n", "") -- FIXME supposed to be replaceFirst
            return "\n\n<pre class=\"\{lang}\">\n\{block}\n</pre>\n\n"
        }

        function genericCodeBlock(text:String):String {
            return "\n\n<pre><code>\{text}\n</code></pre>\n\n"
        }
    }

    method doCodeBlocks(markup:MutableString) {
        def p := RegularExpression(
                "(?:\\n\\n|\\A)" +
                "((?:" +
                "(?:[ ]{4})" +
                ".*\\n+" +
                ")+" +
                ")" +
                "((?=^[ ]{0,4}\\S)|\\Z)", RegularExpression.MULTILINE)
        markup.replace(p, CodeReplacer(self).replacement)
    }

    method prettyPrint(parser:Parser):String {
        def result := MutableString("<span class=\"pandacode\">")
        var current := SyntaxHighlighter.Kind.DEFAULT
        for t in parser.syntaxHighlighter.tokens {
            if t.second != current & current != SyntaxHighlighter.Kind.DEFAULT {
                result.append("</span>")
            }
            if t.second != current {
                current := t.second
                match current {
                    when SyntaxHighlighter.Kind.DEFAULT: {}
                    when SyntaxHighlighter.Kind.COMMENT, SyntaxHighlighter.Kind.DOC_COMMENT:
                        result.append("<span class=\"comment\">")
                    when SyntaxHighlighter.Kind.ANNOTATION:
                        result.append("<span class=\"annotation\">")
                    when SyntaxHighlighter.Kind.METHOD_NAME:
                        result.append("<span class=\"methodName\">")
                    when SyntaxHighlighter.Kind.METHOD_PARAMETER:
                        result.append("<span class=\"parameterName\">")
                    when SyntaxHighlighter.Kind.TYPE:
                        result.append("<span class=\"type\">")
                    when SyntaxHighlighter.Kind.KEYWORD:
                        result.append("<span class=\"keyword\">")
                    when SyntaxHighlighter.Kind.CONTROL_KEYWORD:
                        result.append("<span class=\"control\">")
                    when SyntaxHighlighter.Kind.LITERAL:
                        result.append("<span class=\"literal\">")
                    when SyntaxHighlighter.Kind.STRING:
                        result.append("<span class=\"string\">")
                    when SyntaxHighlighter.Kind.OPERATOR:
                        result.append("<span class=\"operator\">")
                    when SyntaxHighlighter.Kind.LABEL:
                        result.append("<span class=\"label\">")
                    otherwise:
                        assert false
                }
            }
            def s := MutableString(parser.text(t.first))
            s.replace("&", "&amp;")
            s.replace("<", "&lt;")
            s.replace(">", "&gt;")
            s.replace("\\*", charProtector.encode("*"))
            s.replace("_", charProtector.encode("_"))
            s.replace("\\[", charProtector.encode("["))
            s.replace("\\]", charProtector.encode("]"))
            s.replace("\\\\", charProtector.encode("\\"))
            if current != SyntaxHighlighter.Kind.COMMENT &
                    current != SyntaxHighlighter.Kind.DOC_COMMENT {
                result.append("<span class=\"\{t.first.kind}\">")
            }
            result.append(s)
            if current != SyntaxHighlighter.Kind.COMMENT &
                    current != SyntaxHighlighter.Kind.DOC_COMMENT {
                result.append("</span>")
            }
        }
        if current != SyntaxHighlighter.Kind.DEFAULT {
            result.append("</span>")
        }
        result.append("</span>")
        return result.finish()
    }

    method syntaxHighlight(ed:MutableString) {
        errorQueue.clear()
        def text := ed.convert().trim()
        parser.start(source, text)
        def file := parser.file()
        if file != null & errorQueue.pendingMessages() = 0 {
            ed[..] := prettyPrint(parser)
            return
        }

        errorQueue.clear()
        parser.start(source, text)
        while parser.peek().kind != Token.Kind.EOF & errorQueue.pendingMessages() = 0 {
            parser.statement()
        }
        if errorQueue.pendingMessages() = 0 {
            ed[..] := prettyPrint(parser)
            return
        }

        errorQueue.clear()
        parser.start(source, text)
        while parser.peek().kind != Token.Kind.EOF & errorQueue.pendingMessages() = 0 {
            parser.expression()
        }
        if errorQueue.pendingMessages() = 0 {
            ed[..] := prettyPrint(parser)
            return
        }

        errorQueue.clear()
        parser.start(source, text)
        loop {
            def next := parser.next()
            if next.kind = Token.Kind.EOF {
                break
            }
        }
        ed[..] := prettyPrint(parser)
    }

    method encodeCode(ed:MutableString) {
        -- we want to allow "..." on a line by itself, so turn it into an escaped comment to make it
        -- through the parser
        ed.replace(/(?m)$(\s*)\.\.\.(\s*)^/, "$1-*#...#*-$2")
        syntaxHighlight(ed)
        ed.replace("-*#...#*-", "<span class=\"ellipsis\">...</span>")
    }

    method doLists(text:MutableString) {
        def lessThanTab := TAB_WIDTH - 1

        def wholeList :=
                "(" +
                "(" +
                "[ ]{0,\{lessThanTab}}" +
                "((?:[-+*]|\\d+[.]))" + -- $3 is first list item marker
                "[ ]+" +
                ")" +
                "(?s:.+?)" +
                "(" +
                "\\z" + -- End of input is OK
                "|" +
                "\\n{2,}" +
                "(?=\\S)" + -- If not end of input, then a new para
                "(?![ ]*" +
                "(?:[-+*]|\\d+[.])" +
                "[ ]+" +
                ")" + -- negative lookahead for another list marker
                ")" +
                ")"

        if listLevel > 0 {
            def matchStartOfLine := RegularExpression("(?m)^\{wholeList}")
            text.replace(matchStartOfLine, function(groups:ListView<String?>):Object {
                var list := groups[1]
                def listStart := groups[3]
                def listType:String
                if listStart.matches(/[*+-]/) {
                    listType := "ul"
                }
                else {
                    listType := "ol"
                }

                -- Turn double returns into triple returns, so that we can make a
                -- paragraph for the last item in a list, if necessary:
                list := list.replace(/\\n{2,}/, "\n\n\n")

                var result := processListItems(list)

                -- Trim any trailing whitespace, to put the closing `</ol>` or `</ul>` up on the
                -- preceding line, to get it past the current stupid HTML block parser. This is a
                -- hack to work around the terrible hack that is the HTML block parser.
                result := result.replace(/\\s+$/, "")

                return "<\{listType}>\{result}</\{listType}>\n"
            })
        }
        else {
            def matchStartOfLine := RegularExpression("(?m)(?:(?<=\\n\\n)|\\A\\n?)" + wholeList)
            text.replace(matchStartOfLine, function(groups:ListView<String?>):Object {
                var list := groups[1]
                def listStart := groups[3]
                def listType:String
                if listStart.matches(/[*+-]/) {
                    listType := "ul"
                }
                else {
                    listType := "ol"
                }

                -- Turn double returns into triple returns, so that we can make a paragraph for the
                -- last item in a list, if necessary:
                list := list.replace(/\n{2,}/, "\n\n\n")

                def result := processListItems(list)
                return "<\{listType}>\n\{result}</\{listType}>\n"
            })
        }
    }

    method processListItems(rawList:String):String {
        -- The listLevel variable keeps track of when we're inside a list. Each time we enter a
        -- list, we increment it; when we leave a list, we decrement. If it's zero, we're not in a
        -- list anymore.
        --
        -- We do this because when we're not inside a list, we want to treat something like this:
        --
        --       I recommend upgrading to version
        --       8. Oops, now this line is treated
        --       as a sub-list.
        --
        -- As a single paragraph, despite the fact that the second line starts with a
        -- digit-period-space sequence.
        --
        -- Whereas when we're inside a list (or sub-list), that line will be treated as the start of
        -- a sub-list. What a kludge, huh? This is an aspect of Markdown's syntax that's hard to
        -- parse perfectly without resorting to mind-reading. Perhaps the solution is to change the
        -- syntax rules such that sub-lists must start with a starting cardinal number; e.g. "1." or
        -- "a.".

        listLevel += 1

        -- Trim trailing blank lines:
        def list := rawList.replace(/\n{2,}\z/, "\n")

        def p := RegularExpression("(\\n)?" +
                "^([ \\t]*)([-+*]|\\d+[.])[ ]+" +
                "((?s:.+?)(\\n{1,2}))" +
                "(?=\\n*(\\z|\\2([-+\\*]|\\d+[.])[ \\t]+))",
                RegularExpression.MULTILINE)
        list := list.replace(p, function(groups:ListView<String?>):String {
            def text := groups[4]
            def item := MutableString(text)
            def leadingLine := groups[1]
            if !isEmptyString(leadingLine) | hasParagraphBreak(item) {
                outdent(item)
                runBlockGamut(item)
            }
            else {
                -- Recurse sub-lists
                outdent(item)
                doLists(item)
                runSpanGamut(item)
            }
            item.trim()
            return "<li>\{item}</li>\n"
        })
        listLevel -= 1
        return list
    }

    @class
    function hasParagraphBreak(item:MutableString):Bit {
        return item.contains("\n\n")
    }

    @class
    function isEmptyString(leadingLine:String?):Bit {
        return leadingLine = null | leadingLine = ""
    }

    method doHeaders(markup:MutableString) {
        -- setext-style headers
        markup.replace(/(?m)^(.*)\n====+$/, function(groups:ListView<String?>):String {
            def result := MutableString(groups[1])
            runSpanGamut(result)
            return "<h1>\{result}</h1>"
        })
        markup.replace(/(?m)^(.*)\n----+$/, function(groups:ListView<String?>):String {
            def result := MutableString(groups[1])
            runSpanGamut(result)
            return "<h2>\{result}</h2>"
        })

        -- atx-style headers - e.g., "#### heading 4 ####"
        def p := RegularExpression("^(#{1,6})\\s*(.*?)\\s*\\1?$", RegularExpression.MULTILINE)
        markup.replace(p, function(groups:ListView<String?>):Object {
            def marker := groups[1]
            def heading := MutableString(groups[2])
            runSpanGamut(heading)
            def level := marker.length()
            def tag := "h" + level
            return "<\{tag}>\{heading}</\{tag}>\n"
        })
    }

    method runSpanGamut(text:MutableString) {
        escapeSpecialCharsWithinTagAttributes(text)
        doCodeSpans(text)
        encodeBackslashEscapes(text)

        doImages(text)
        doAnchors(text)
        doAutoLinks(text)

        -- Fix for BUG #1357582
        -- We must call escapeSpecialCharsWithinTagAttributes() a second time to
        -- escape the contents of any attributes generated by the prior methods.
        -- - Nathan Winant, nw@exegetic.net, 8/29/2006
        escapeSpecialCharsWithinTagAttributes(text)

        encodeAmpsAndAngles(text)
        doItalicsAndBold(text)

        text.replace(/ {2,}\n/, " <br />\n")
    }

    choice HTMLToken {
        TAG(String)
        TEXT(String)
    }

    @class
    function nestedTagsRegex(depth:Int):String {
        if depth = 0 {
            return ""
        }
        else {
            return "(?:<[a-z/!$](?:[^<>]|\{nestedTagsRegex(depth - 1)})*>)"
        }
    }

    method tokenizeHTML(text:String):ListView<HTMLToken> {
        def tokens := Array<HTMLToken>()
        def nestedTags := nestedTagsRegex(6)

        def p := RegularExpression(
                "(?s:<!(--.*?--\\s*)+>)" +
                "|" +
                "(?s:<\\?.*?\\?>)" +
                "|" +
                nestedTags,
                RegularExpression.CASE_INSENSITIVE)

        def m := p.matcher(text)
        var lastPos := text.start()
        while m.find() {
            if lastPos < m.get_start() {
                tokens.add(HTMLToken.TEXT(text.substring(lastPos .. m.get_start())))
            }
            tokens.add(HTMLToken.TAG(text.substring(m.get_start() .. m.get_end())))
            lastPos := m.get_end()
        }
        if lastPos < text.end() {
            tokens.add(HTMLToken.TEXT(text.substring(lastPos .. text.end())))
        }

        return tokens
    }

    -*
     * escape special characters
     *
     * Within tags -- meaning between < and > -- encode [\ ` * _] so they
     * don't conflict with their use in Markdown for code, italics and strong.
     * We're replacing each such character with its corresponding random string
     * value; this is likely overkill, but it should prevent us from colliding
     * with the escape values by accident.
     *-
    method escapeSpecialCharsWithinTagAttributes(text:MutableString) {
        def tokens := tokenizeHTML(text.convert())
        text.clear()

        for token in tokens {
            var value:String
            match token {
                when HTMLToken.TAG(text):
                    value := text
                    value := value.replace("\\\\", charProtector.encode("\\"))
                    value := value.replace("`", charProtector.encode("`"))
                    value := value.replace("\\*", charProtector.encode("*"))
                    value := value.replace("_", charProtector.encode("_"))
                when HTMLToken.TEXT(text):
                    value := text
            }
            text.append(value)
        }
    }

    method doImages(text:MutableString) {
        -- Inline image syntax
        text.replace(/!\\[(.*)\\]\\((.*) \"(.*)\"\\)/, "<img src=\"$2\" alt=\"$1\" title=\"$3\" />")
        text.replace(/!\\[(.*)\\]\\((.*)\\)/, "<img src=\"$2\" alt=\"$1\" />")

        -- Reference-style image syntax
        def imageLink := RegularExpression("(" +
                "[!]\\[(.*?)\\]" + -- alt text = $2
                "[ ]?(?:\\n[ ]*)?" +
                "\\[(.*?)\\]" + -- ID = $3
                ")")
        text.replace(imageLink, function(groups:ListView<String?>):String {
            def replacementText:String
            def wholeMatch := groups[1]
            def altText := groups[2]
            def id := groups[3] -- FIXME .toLowerCase()
            if id = "" {
                id := altText -- FIXME .toLowerCase()
            }

            -- imageDefinition is the same as linkDefinition
            def defn := linkDefinitions[id]
            if defn != null {
                var url := defn.url
                url := url.replace(/\\*/, charProtector.encode("*"))
                url := url.replace(/_/, charProtector.encode("_"))
                def title := defn.title
                var titleTag := ""
                if title != null & title != "" {
                    title := title.replace(/\\*/, charProtector.encode("*"))
                    title := title.replace(/_/, charProtector.encode("_"))
                    titleTag := " alt=\"\{altText}\" title=\"\{title}\""
                }
                replacementText := "<img src=\"\{url}\"\{titleTag}/>"
            }
            else {
                replacementText := wholeMatch
            }
            return replacementText
        })
    }

    method doAnchors(markup:MutableString) {
        -- Internal references: [link text] [id]
        def internalLink := RegularExpression("(" +
                "\\[(.*?)\\]" + -- Link text = $2
                "[ ]?(?:\\n[ ]*)?" +
                "\\[(.*?)\\]" + -- ID = $3
                ")")
        markup.replace(internalLink, function(groups:ListView<String?>):Object {
            def replacementText:String
            def wholeMatch := groups[1]
            def linkText := groups[2]
            var id := groups[3] -- FIXME .toLowerCase();
            if id = "" { -- for shortcut links like [this][]
                id := linkText -- .toLowerCase()
            }

            def defn := linkDefinitions[id]
            if defn != null {
                var url := defn.url
                -- protect emphasis (* and _) within urls
                url := url.replace("\\*", charProtector.encode("*"))
                url := url.replace("_", charProtector.encode("_"))
                def title := defn.title
                var titleTag := ""
                if title != null & title != "" {
                    -- protect emphasis (* and _) within urls
                    title := title.replace("\\*", charProtector.encode("*"))
                    title := title.replace("_", charProtector.encode("_"))
                    titleTag := " title=\"\{title}\""
                }
                replacementText := "<a href=\"\{url}\"\{titleTag}>\{linkText}</a>"
            }
            else {
                replacementText := wholeMatch
            }
            return replacementText
        })

        -- Inline-style links: [link text](url "optional title")
        def inlineLink := RegularExpression("(" + -- Whole match = $1
                "\\[(.*?)\\]" + -- Link text = $2
                "\\(" +
                "[ \\t]*" +
                "<?(.*?)>?" + -- href = $3
                "[ \\t]*" +
                "(" +
                "(['\"])" + -- Quote character = $5
                "(.*?)" + -- Title = $6
                "\\5" +
                ")?" +
                "\\)" +
                ")",
                RegularExpression.DOTALL)
        markup.replace(inlineLink, function(groups:ListView<String?>):String {
            def linkText := groups[2]
            var url := groups[3]
            def title := groups[6]
            -- protect emphasis (* and _) within urls
            url := url.replace(/\*/, charProtector.encode("*"))
            url := url.replace(/_/, charProtector.encode("_"))
            def result := MutableString()
            result.append("<a href=\"\{url}\"")
            if title != null {
                -- protect emphasis (* and _) within urls
                title := title.replace("\\*", charProtector.encode("*"))
                title := title.replace("_", charProtector.encode("_"))
                title := title.replace("\"", "&quot;")
                result.append(" title=\"")
                result.append(title)
                result.append("\"")
            }
            result.append(">\{linkText}")
            result.append("</a>")
            return result.convert()
        })

        -- Last, handle reference-style shortcuts: [link text]
        -- These must come last in case you've also got [link test][1]
        -- or [link test](/foo)
        def referenceShortcut := RegularExpression("(" + -- wrap whole match in $1
                                                   "\\[" +
                                                   "([^\\[\\]]+)" + -- link text = $2; can't contain '[' or ']'
                                                   "\\]" +
                                                   ")",
                                                   RegularExpression.DOTALL)
        markup.replace(referenceShortcut, function(groups:ListView<String?>):Object {
            def replacementText:String
            def wholeMatch := groups[1]
            def linkText := groups[2]
            var id := linkText -- FIXME .toLowerCase()
            id := id.replace(/[ ]?\\n/, " ") -- change embedded newlines into spaces
            def defn := linkDefinitions[id]
            if defn != null {
                var url := defn.url
                -- protect emphasis (* and _) within urls
                url := url.replace("\\*", charProtector.encode("*"))
                url := url.replace("_", charProtector.encode("_"))
                var title := defn.title
                var titleTag := ""
                if title != null & title != "" {
                    -- protect emphasis (* and _) within urls
                    title := title.replace("\\*", charProtector.encode("*"))
                    title := title.replace("_", charProtector.encode("_"))
                    titleTag := " title=\"\{title}\""
                }
                replacementText := "<a href=\"\{url}\"\{titleTag}>\{linkText}</a>"
            }
            else {
                replacementText := wholeMatch
            }
            return replacementText
        })
    }

     method doItalicsAndBold(markup:MutableString) {
        markup.replace(/(\*\\*|__)(?=\S)(.+?[*_]*)(?<=\S)\1/, "<strong>$2</strong>")
        markup.replace(/(\*|_)(?=\S)(.+?)(?<=\S)\1/, "<em>$2</em>")
    }

    method encodeAmpsAndAngles(markup:MutableString) {
        -- Ampersand-encoding based entirely on Nat Irons's Amputator MT plugin:
        -- http://bumppo.net/projects/amputator/
        markup.replace(/&(?!#?[xX]?(?:[0-9a-fA-F]+|\w+);)/, "&amp;")
        markup.replace(/<(?![a-zA-Z/?\$!])/, "&lt;")
    }

    method doCodeSpans(markup:MutableString) {
        markup.replace(/(?<!\\)(`+)(.+?)(?<!`)\1(?!`)/,
            function(groups:ListView<String?>):String {
                def code := groups[2]
                def sub := MutableString(code)
                sub.replace(/^[ \t]+/, "")
                sub.replace(/[ \t]+$/, "")
                encodeCode(sub)
                return "<code>\{sub}</code>"
            }
        )
    }
}