package org.pandalanguage.pandac.pandadoc

uses org.pandalanguage.pandac.Annotations
uses org.pandalanguage.pandac.ClassDecl
uses org.pandalanguage.pandac.CodeGenerator
uses org.pandalanguage.pandac.Compiler
uses org.pandalanguage.pandac.FieldDecl
uses org.pandalanguage.pandac.IRNode
uses org.pandalanguage.pandac.MethodDecl
uses org.pandalanguage.pandac.Pair
uses org.pandalanguage.pandac.Type

class PandaDoc : CodeGenerator {
    class XMLWriter {
        def out:IndentedOutputStream

        def stack := Stack<String>()

        init(out:OutputStream) {
            self.out := IndentedOutputStream(out)
        }

        method open(tag:String) {
            out.printLine("<\{tag}>")
            out.level += 1
            stack.push(tag)
        }

        method close(tag:String) {
            out.level -= 1
            out.printLine("</\{tag}>")
            stack.pop(tag)
        }

        method write(tag:String, text:String) {
            assert !text.contains("&&gt")
            out.printLine("<\{tag}>\{text}</\{tag}>")
        }
    }

    def outDir:File

    @weak
    var compiler:Compiler?

    var out:XMLWriter

    var returns:String?

    var params := HashMap<String, String>()

    init(outDir:File) {
        self.outDir := outDir
    }

    @override
    method setCompiler(compiler:Compiler) {
        self.compiler := compiler
    }

    function getRelativePath(cl:ClassDecl, extension:String):String {
        return cl.name.replace(".", "/").replace("<", ".LT").replace(">", ".GT")
                .replace("?", ".Q").replace(",", ".C").replace(" ", "") + extension
    }

    function getPath(cl:ClassDecl, extension:String):File {
        return outDir.resolve(getRelativePath(cl, extension))
    }

    function simpleName(t:Type):String {
        match t.typeKind {
            when Type.Kind.CLASS:
                def index := t.name.lastIndexOf(".")
                if index = null {
                    return t.name
                }
                return t.name[t.name.next(index)..]
            when Type.Kind.NULLABLE:
                return simpleName(t.subtypes[0]) + "?"
            when Type.Kind.GENERIC:
                def simpleNames := Array<String>() -- FIXME use map
                for s in t.subtypes {
                    simpleNames.add(simpleName(s))
                }
                return simpleNames[0] + "<" + simpleNames[1..].join() + ">"
            otherwise:
                return t.name
        }
    }

    function escape(s:String):String {
        return s.replace("&", "&amp;").replace("<", "&lt;").replace(">", "&gt;")
    }

    method write(t:Type) {
        out.open("type")
        out.write("name", escape(t.name))
        out.write("simpleName", escape(simpleName(t)))
        out.close("type")
    }

    method write(a:Annotations) {
        out.open("annotations")
        if a.isPrivate() {
            out.write("annotation", "@private")
        }
        if a.isProtected() {
            out.write("annotation", "@protected")
        }
        if a.isPackage() {
            out.write("annotation", "@package")
        }
        if a.isClass() {
            out.write("annotation", "@class")
        }
        if a.isOverride() {
            out.write("annotation", "@override")
        }
        if a.isFinal() {
            out.write("annotation", "@final")
        }
        if a.isWeak() {
            out.write("annotation", "@weak")
        }
        out.close("annotations")
    }

    ================================================================================================
    Given a documentation comment string, splits it into the main text and tags. For instance, given
    `"This is a doccomment @param foo a Foo @returns a Bar", returns `[("", "This is a doccomment"),
    ("param", "foo a Foo"), ("returns", "a Bar")]`.
    ================================================================================================
    function splitDoc(text:String):ListView<Pair<String, String>> {
        -- figure out how many spaces are at the start of each line and remove them
        def lines := Array<String>(text.split(/\r?\n/))
        if lines[0] = "" {
            lines.removeIndex(0)
        }
        var spaces := Int.MAX
        for line in lines {
            if line.trim() != "" {
                spaces := spaces.min(line.parse(/( *).*/)[0].byteLength())
            }
        }
        for i in 0 .. lines.get_count() { -- FIXME use map
            if lines[i].trim() != "" {
                lines[i] := lines[i][spaces..]
            }
        }

        def result := Array<Pair<String, String>>()
        def split := lines.join("\n").split(/(?m)^(?=[ \t]*@\w+)/)
        for raw in split {
            def s := raw.trim()
            if !s.startsWith("@") {
                result.add(Pair<String, String>("", s))
            }
            else {
                def parsed := s.parse(/(?d)@(\w*)\s*(.*)/)
                if parsed != null {
                result.add(Pair<String, String>(parsed[0], parsed[1])) }
            }
        }
        return result
    }

    method writeDoc(doccomment:String) {
        def summary:String
        def index := doccomment.indexOf(".")
        if index != null {
            summary := doccomment.substring(...index)
        }
        else {
            summary := doccomment
        }
        def md := Markdown()
        out.open("doc")
        def oldLevel := out.out.level
        -- the indentation from the IndentedOutputStream will screw up any <pre> blocks in the
        -- doccomment, so we need to temporarily zero it out
        out.out.level := 0
        var processedSummary := md.process(summary)
        if processedSummary.startsWith("<p>") {
            processedSummary := processedSummary.parse(/(?s)<p>(.*)<\/p>\s*/)[0]
        }
        out.write("summary", processedSummary)
        out.write("description", md.process(doccomment))
        out.out.level := oldLevel
        out.close("doc")
    }

    function visible(f:FieldDecl):Bit {
        return !f.annotations.isPrivate()
    }

    function visible(m:MethodDecl):Bit {
        return !m.annotations.isPrivate() & !m.annotations.isSynthetic()
    }

    method writeDoc(f:FieldDecl) {
        if f.doccomment != null {
            def split := splitDoc(f.doccomment)
            writeDoc(split[0].second)
            for tag in split[1..] {
                match tag.first {
                    when "see":
                    otherwise:
                        compiler.error(f.position, "tag '@\{tag.first}' is not supported on fields")
                }
            }
        }
    }

    method write(f:FieldDecl) {
        if !visible(f) {
            return
        }
        out.open("field")
        out.write("name", f.name)
        def kind:String
        match f.fieldKind {
            when FieldDecl.Kind.VAR:
                kind := "var"
            when FieldDecl.Kind.DEF:
                kind := "def"
            when FieldDecl.Kind.CONSTANT:
                kind := "constant"
            when FieldDecl.Kind.PROPERTY:
                kind := "property"
        }
        out.write("kind", kind)
        write(f.annotations)
        write(f.type)
        writeDoc(f)
        out.close("field")
    }

    method getDocComment(m:MethodDecl):String? {
        if m.doccomment != null & m.doccomment.trim() = "@inherit" {
            def overridden := compiler.getOverriddenMethod(m)
            if overridden = null {
                compiler.error(m.position, "method specifies '@inherit', but no matching method " +
                        "found among its ancestors")
                return null
            }
            def result := getDocComment(overridden)
            if result = null {
                compiler.error(m.position, "method specifies '@inherit', but " +
                        "\{overridden.declaration()} does not have any documentation")
                return null
            }
            return result
        }
        return m.doccomment
    }

    function stripParagraph(s:String):String {
        def parsed := s.parse(/<p>(.*)<\/p>\s*/)
        if parsed != null {
            return parsed[0]
        }
        return s
    }

    method writeDoc(m:MethodDecl) {
        def c := getDocComment(m)
        if c = null {
            return
        }
        def split := splitDoc(c)
        writeDoc(split[0].second)
        for tag in split[1..] {
            match tag.first {
                when "param":
                    def split := tag.second.parse(/(?d)(\S+)\s+(.+)/)
                    if split = null {
                        compiler.error(m.position, "invalid '@param' contents '\{tag.second}'")
                        continue
                    }
                    params[split[0]] := stripParagraph(Markdown().process(split[1]))
                when "returns":
                    returns := stripParagraph(Markdown().process(tag.second))
                when "see":
                otherwise:
                    compiler.error(m.position, "tag '@\{tag.first}' is not supported on methods")
            }
        }
    }

    method write(m:MethodDecl) {
        if !visible(m) {
            return
        }
        def tag:String
        match m.methodKind {
            when MethodDecl.Kind.METHOD:
                tag := "method"
            when MethodDecl.Kind.FUNCTION:
                tag := "function"
            when MethodDecl.Kind.INIT:
                tag := "init"
        }
        out.open(tag)
        out.write("name", escape(m.name))
        writeDoc(m)
        write(m.annotations)
        out.open("params")
        for p in m.parameters {
            out.open("param")
            out.write("name", p.name)
            write(p.type)
            def desc := params[p.name]
            if desc != null {
                out.write("description", desc)
            }
            out.close("param")
        }
        out.close("params")
        if m.returnType != Type.Void() {
            out.open("return")
            write(m.returnType)
            if returns != null {
                out.write("description", returns)
            }
            out.close("return")
        }
        out.close(tag)
    }

    method writeAncestors(cl:ClassDecl) {
        out.open("ancestors")
        var ancestor := cl.rawSuper
        while ancestor != null {
            write(ancestor)
            def ancestorClass := compiler.getClass(ancestor)
            if ancestorClass = null {
                return
            }
            ancestor := ancestorClass.rawSuper
        }
        out.close("ancestors")
    }

    function linkTo(cl:ClassDecl):String {
        return "broken link.html"
    }

    method writeInheritedFields(cl:ClassDecl) {
        def fields := Array<FieldDecl>()
        var ancestor := cl.rawSuper
        while ancestor != null {
            def ancestorClass := compiler.getClass(ancestor)
            if ancestorClass = null {
                return
            }
            for f in ancestorClass.fields {
                if visible(f) {
                    compiler.resolve(f)
                    fields.add(f)
                }
            }
            ancestor := ancestorClass.rawSuper
        }
        fields[..] := fields[.. by -1]

        if fields.get_count() > 0 {
            out.open("inheritedFields")
            for f in fields {
                out.open("field")
                out.write("name", f.name)
                out.write("link", "\{linkTo(f.owner)}#\{f.name}")
                out.close("field")
            }
            out.close("inheritedFields")
        }
    }

    method writeInheritedMethods(cl:ClassDecl) {
        def methods := Array<MethodDecl>()
        def overridden := HashSet<String>()
        for m in cl.methods {
            def o := compiler.getOverriddenMethod(m)
            if o != null {
                overridden.add(o.signature())
            }
        }
        var ancestor := cl.rawSuper
        while ancestor != null {
            def ancestorClass := compiler.getClass(ancestor)
            if ancestorClass = null {
                return
            }
            for m in ancestorClass.methods {
                if m.methodKind != MethodDecl.Kind.INIT & visible(m) &
                        !overridden.contains(m.signature()) {
                    compiler.resolve(m)
                    methods.add(m)
                    def o := compiler.getOverriddenMethod(m)
                    if o != null {
                        overridden.add(o.signature())
                    }
                }
            }
            ancestor := ancestorClass.rawSuper
        }
        methods[..] := methods[.. by -1]

        if methods.get_count() > 0 {
            out.open("inheritedMethods")
            for m in methods {
                out.open("method")
                out.write("name", m.name)
                out.write("link", "\{linkTo(m.owner)}#\{m.name}")
                out.close("method")
            }
            out.close("inheritedMethods")
        }
    }

    method writeDoc(cl:ClassDecl) {
        if cl.doccomment != null {
            def split := splitDoc(cl.doccomment)
            writeDoc(split[0].second)
        }
    }

    @override
    method start(cl:ClassDecl) {
        returns := null
        params.clear()
        def dest := getPath(cl, ".xml")
        dest.parent().createDirectories()
        out := XMLWriter(dest.openOutputStream())
        out.open("class")
        out.write("name", cl.name)
        out.write("simpleName", simpleName(cl.type()))
        writeDoc(cl)
        writeAncestors(cl)
        if cl.rawInterfaces.get_count() > 0 {
            out.open("interfaces")
            cl.rawInterfaces.apply(self.write) -- FIXME shouldn't need 'self.'
            out.close("interfaces")
        }
        writeInheritedFields(cl)
        writeInheritedMethods(cl)
        cl.fields.apply(self.write) -- FIXME shouldn't need 'self.'
        cl.methods.apply(self.write) -- FIXME shouldn't need 'self.'
        out.close("class")
    }

    @override
    method writeDeclaration(m:MethodDecl) {
    }

    @override
    method write(m:MethodDecl, body:ImmutableArray<IRNode>) {
    }

    @override
    method end(cl:ClassDecl) {
    }

    @override
    method finish() {
    }
}