package org.pandalanguage.pandac.pandadoc

class TableOfContentsNode {
    def name:String

    def url:String

    def children := HashMap<String, TableOfContentsNode>()

    init(name:String, url:String) {
        self.name := name
        self.url := url
    }

    @private
    @class
    method swap(a:List<TableOfContentsNode>, i1:Int, i2:Int) {
        def tmp := a[i1]
        a[i1] := a[i2]
        a[i2] := tmp
    }

    @private
    @class
    function lessThan(a:String, b:String):Bit {
        for i in 0 .. a.length.min(b.length) {
            if a[i] < b[i] {
                return true
            }
            if a[i] > b[i] {
                return false
            }
        }
        return a.length < b.length
    }

    @private
    @class
    method sort(a:List<TableOfContentsNode>, left:Int, right:Int) {
        if left >= right {
            return
        }
        def pivotIndex := left + (right - left) // 2
        def pivot := a[pivotIndex]
        swap(a, right, pivotIndex)
        var storeIndex := left
        for i in left ... right - 1 {
            if lessThan(a[i].name, pivot.name) {
                swap(a, i, storeIndex)
                storeIndex += 1
            }
        }
        swap(a, storeIndex, right)
        sort(a, left, storeIndex - 1)
        sort(a, storeIndex + 1, right)
    }

    ================================================================================================
    Quick and dirty naive quicksort, until generics are done and ListView can be 
    sorted natively. FIXME kill this.
    ================================================================================================
    @class
    method sort(a:List<TableOfContentsNode>) {
        sort(a, 0, a.count - 1)
    }

    method write(apiRelativePath:String, out:XMLWriter) {
        out.open("entry")
        if name !== null {
            var index := name.lastIndexOf(".")
            if index !== null {
                index := name.next(index)
            }
            else {
                index := name.start
            }
            out.write("name", name)
            out.write("simpleName", name[index..])
            out.write("url", apiRelativePath + url)
        }
        if children.count != 0 {
            out.open("contents")
            def list := children.values.all()
            sort(list)
            for child in list {
                child.write(apiRelativePath, out)
            }
            out.close("contents")
        }
        out.close("entry")
    }
}
