package org.pandalanguage.pandac

uses org.pandalanguage.pandac.parser.Token

@final
class ASTNode : Immutable {
    class Kind {
        constant PACKAGE                := 100
        constant USES                   := 101
        constant INT                    := 102
        constant BINARY                 := 103
        constant RANGE_INCLUSIVE        := 104
        constant RANGE_EXCLUSIVE        := 105
        constant IDENTIFIER             := 106
        constant CALL                   := 107
        constant DOT                    := 108
        constant TYPE                   := 109
        constant NULLABLE_TYPE          := 110
        constant CAST                   := 111
        constant PREFIX                 := 112
        constant STRING                 := 113
        constant SELF                   := 114
        constant SUPER                  := 115
        constant BIT                    := 116
        constant NULL                   := 117
        constant IF                     := 118
        constant FOR                    := 119
        constant DO                     := 120
        constant WHILE                  := 121
        constant LOOP                   := 122
        constant ASSERT                 := 123
        constant WHEN                   := 124
        constant MATCH                  := 125
        constant BLOCK                  := 126
        constant OTHERWISE              := 127
        constant EXPRESSIONS            := 128
        constant DECLARATION            := 129
        constant VAR                    := 130
        constant DEF                    := 131
        constant CONSTANT               := 132
        constant PROPERTY               := 133
        constant BREAK                  := 134
        constant CONTINUE               := 135
        constant RETURN                 := 136
        constant GENERICS               := 137
        constant VOID                   := 138
        constant TYPES                  := 139
        constant CLASS_MEMBERS          := 140
        constant DOC_COMMENT            := 141
        constant CLASS                  := 142
        constant ANNOTATION             := 143
        constant ANNOTATIONS            := 144
        constant METHOD                 := 145
        constant FUNCTION               := 146
        constant INIT                   := 147
        constant FIELD                  := 148
        constant PARAMETER              := 149
        constant PARAMETERS             := 150
        constant INTERFACE              := 151
        constant FILE                   := 152
        constant TUPLE_TARGET           := 153
        constant GENERIC_TYPE           := 154
        constant CHOICE                 := 155
        constant CHOICE_ENTRY           := 156
        constant REAL                   := 157
        constant CHOICE_FIELD_REFERENCE := 158
        constant CHOICE_FIELDS          := 159
    }

    @class
    function operatorName(op:Int):String {
        match op {
            when Token.Kind.ADD:        return "+"
            when Token.Kind.AND:        return "&"
            when Token.Kind.DIV:        return "/"
            when Token.Kind.INTDIV:     return "//"
            when Token.Kind.MUL:        return "*"
            when Token.Kind.SUB:        return "-"
            when Token.Kind.ADDEQ:      return "+="
            when Token.Kind.ANDEQ:      return "&="
            when Token.Kind.DIVEQ:      return "/="
            when Token.Kind.INTDIVEQ:   return "//="
            when Token.Kind.MULEQ:      return "*="
            when Token.Kind.SUBEQ:      return "-="
            when Token.Kind.OR:         return "|"
            when Token.Kind.ASSIGNMENT: return ":="
            when Token.Kind.EQ:         return "="
            when Token.Kind.NEQ:        return "!="
            when Token.Kind.GT:         return ">"
            when Token.Kind.GTEQ:       return ">="
            when Token.Kind.LT:         return "<"
            when Token.Kind.LTEQ:       return "<="
            otherwise:                  return "<operator:\{op}>"
        }
    }

    def kind:Int

    def position:Position

    def payload:Object?

    def children:ImmutableArray<ASTNode>?

    init(kind:Int, position:Position) {
        init(kind, position, null, null)
    }

    init(kind:Int, position:Position, payload:UInt64) {
        init(kind, position, payload, null)
    }

    init(kind:Int, position:Position, payload:panda.core.Real64) {
        init(kind, position, payload, null)
    }

    init(kind:Int, position:Position, payload:String) {
        init(kind, position, payload, null)
    }

    init(kind:Int, position:Position, payload:Bit) {
        init(kind, position, payload, null)
    }

    init(kind:Int, position:Position, payload:Pair<ChoiceEntry, Int>) {
        init(kind, position, payload, null)
    }

    init(kind:Int, position:Position, children:ListView<ASTNode>) {
        init(kind, position, null, children)
    }

    init(kind:Int, position:Position, payload:Object?, children:ListView<ASTNode>?) {
        self.kind := kind
        self.position := position
        self.payload := payload
        if children != null {
            self.children := ImmutableArray<ASTNode>(children)
        }
        else {
            self.children := null
        }
    }

    @override
    function convert():String {
        match kind {
            when Kind.PREFIX:
                assert children.get_count() = 1
                return "\{operatorName(payload->Int)}\{children[0]}"
            when Kind.BINARY:
                assert children.get_count() = 2
                if payload->Int = Token.Kind.LBRACKET {
                    return "\{children[0]}[\{children[1]}]"
                }
                return "(\{children[0]} \{operatorName(payload->Int)} \{children[1]})"
            when Kind.INT:
                return payload.convert()
            when Kind.BIT:
                return payload.convert()
            when Kind.STRING:
                return "'\{payload.convert()}'"
            when Kind.PACKAGE:
                return "package \{payload}"
            when Kind.USES:
                return "uses \{payload}"
            when Kind.RANGE_INCLUSIVE:
                assert children.get_count() = 3
                def result := MutableString()
                if children[0] != null {
                    result.append(children[0])
                }
                result.append("...")
                if children[1] != null {
                    result.append(children[1])
                }
                if children[2] != null {
                    result.append(" by ")
                    result.append(children[2])
                }
                return result.finish()
            when Kind.RANGE_EXCLUSIVE:
                assert children.get_count() = 3
                def result := MutableString()
                if children[0].kind != ASTNode.Kind.VOID {
                    result.append(children[0])
                }
                result.append("..")
                if children[1].kind != ASTNode.Kind.VOID {
                    result.append(children[1])
                }
                if children[2].kind != ASTNode.Kind.VOID {
                    result.append(" by ")
                    result.append(children[2])
                }
                return result.finish()
            when Kind.CALL:
                assert children.get_count() >= 1
                def result := MutableString(children[0].convert())
                result.append("(")
                var separator := ""
                for i in 1 .. children.get_count() {
                    result.append(separator)
                    result.append(children[i])
                    separator := ", "
                }
                result.append(")")
                return result.finish()
            when Kind.IDENTIFIER:
                if children != null {
                    assert children.get_count() = 1
                    return payload + ":" + children[0]
                }
                return payload.convert()
            when Kind.DOT:
                assert children.get_count() = 1
                return "\{children[0]}.\{payload}"
            when Kind.IF:
                assert children.get_count() = 2 | children.get_count() = 3
                def result := "if \{children[0]} \{children[1]}"
                if children.get_count() = 3 {
                    return result + " else \{children[2]}"
                }
                return result
            when Kind.FOR:
                assert children.get_count() = 3
                return "for \{children[0]} in \{children[1]} \{children[2]}"
            when Kind.WHILE:
                assert children.get_count() = 2
                return "while \{children[0]} \{children[1]}"
            when Kind.DO:
                assert children.get_count() = 2
                return "do \{children[0]} while \{children[1]}"
            when Kind.LOOP:
                assert children.get_count() = 1
                return "loop \{children[0]}"
            when Kind.BREAK:
                if payload != null {
                    return "break \{payload}"
                }
                return "break"
            when Kind.CONTINUE:
                if payload != null {
                    return "continue \{payload}"
                }
                return "continue"
            when Kind.RETURN:
                if children != null {
                    assert children.get_count() = 1
                    return "return \{children[0]}"
                }
                return "return"
            when Kind.BLOCK:
                def result := MutableString("{\n")
                for child in children {
                    def c := child.convert()
                    if c.startsWith("(") & c.endsWith(")") {
                        result.append(c[c.next(c.start()) .. c.previous(c.end())])
                    }
                    else {
                        result.append(child)
                    }
                    result.append("\n")
                }
                result.append("}")
                return result.finish()
            when Kind.TYPE:
                return payload.convert()
            when Kind.NULLABLE_TYPE:
                return children[0] + "?"
            when Kind.GENERIC_TYPE:
                def result := MutableString(children[0].convert())
                result.append("<")
                var separator := ""
                for c in children[1..] {
                    result.append(separator)
                    result.append(c)
                    separator := ", "
                }
                result.append(">")
                return result.finish()
            when Kind.TYPES:
                def result := MutableString()
                var separator := ""
                for c in children {
                    result.append(separator)
                    result.append(c)
                    separator := ", "
                }
                return result.finish()
            when Kind.ANNOTATION:
                return payload.convert()
            when Kind.ANNOTATIONS:
                def result := MutableString()
                for c in children {
                    result.append(c)
                    result.append("\n")
                }
                return result.finish()
            when Kind.DECLARATION:
                if children.get_count() = 1 {
                    return children[0].convert()
                }
                return "\{children[0]} := \{children[1]}"
            when Kind.VAR:
                def result := MutableString("var ")
                var separator := ""
                for c in children {
                    result.append(separator)
                    result.append(c)
                    separator := ", "
                }
                return result.finish()
            when Kind.DEF:
                def result := MutableString("def ")
                var separator := ""
                for c in children {
                    result.append(separator)
                    result.append(c)
                    separator := ", "
                }
                return result.finish()
            when Kind.PROPERTY:
                def result := MutableString("property ")
                var separator := ""
                for c in children {
                    result.append(separator)
                    result.append(c)
                    separator := ", "
                }
                return result.finish()
            when Kind.CONSTANT:
                def result := MutableString("constant ")
                var separator := ""
                for c in children {
                    result.append(separator)
                    result.append(c)
                    separator := ", "
                }
                return result.finish()
            when Kind.FIELD:
                assert children.get_count() = 3
                return "\{children[0]}\{children[1]}\{children[2]}"
            when Kind.PARAMETER:
                assert children.get_count() = 1
                return "\{payload}:\{children[0]}"
            when Kind.PARAMETERS:
                def result := MutableString("(")
                var separator := ""
                for c in children {
                    result.append(separator)
                    result.append(c)
                    separator := ", "
                }
                result.append(")")
                return result.finish()
            when Kind.INIT:
                assert children.get_count() = 5
                return "\{children[0]}\{children[1]}init\{children[2]} \{children[3]}\{children[4]}"
            when Kind.METHOD:
                assert children.get_count() = 6
                return "\{children[0]}\{children[1]}method \{payload}\{children[2]}:" +
                        "\{children[3]} \{children[4]}\{children[5]}"
            when Kind.FUNCTION:
                assert children.get_count() = 6
                for c in children {
                    Console.printLine(c)
                }
                return "\{children[0]}\{children[1]}function \{payload}\{children[2]}:" +
                        "\{children[3]} \{children[4]}\{children[5]}"
            when Kind.CLASS_MEMBERS:
                def result := MutableString("{\n")
                for c in children {
                    result.append(c)
                    result.append("\n")
                }
                result.append("}")
                return result.finish()
            when Kind.CLASS:
                assert children.get_count() = 6
                def result := MutableString()
                result.append(children[0])
                result.append(children[1])
                result.append("class \{payload}")
                result.append(children[2])
                if children[3].kind != ASTNode.Kind.VOID {
                    result.append(" : ")
                    result.append(children[3])
                }
                if children[4].kind != ASTNode.Kind.VOID {
                    result.append(" (")
                    result.append(children[4])
                    result.append(")")
                }
                result.append(" ")
                result.append(children[5])
                return result.finish()
            when Kind.INTERFACE:
                assert children.get_count() = 5
                def result := MutableString()
                result.append(children[0])
                result.append(children[1])
                result.append("class \{payload}")
                result.append(children[2])
                result.append(" ")
                result.append(children[3])
                result.append(children[4])
                return result.finish()
            when Kind.FILE:
                def result := MutableString()
                for c in children {
                    result.append(c)
                    result.append("\n")
                }
                return result.finish()
            when Kind.SELF:
                return "self"
            when Kind.SUPER:
                return "super"
            when Kind.VOID:
                return ""
            when Kind.NULL:
                return "null"
            when Kind.CAST:
                return "\{children[0]}->\{children[1]}"
            when Kind.ASSERT:
                if children.get_count() = 1 {
                    return "assert \{children[0]}"
                }
                assert children.get_count() = 2
                return "assert \{children[0]}, \{children[1]}"
            otherwise:
                return "<ASTNode:\{kind}>"
        }
    }
}