package org.pandalanguage.pandac

====================================================================================================
A reference to a method in a particular context type. For instance, the method `String.!=` and the
method `File.!=` are actually the same method (inherited from `Equatable`), but have different types
because one of them comes from `Equatable<String>` and the other `Equatable<File>`.
====================================================================================================
@final
class MethodRef {
    def value:MethodDecl

    def target:IRNode

    def owner:Type

    def effectiveType:Type

    ================================================================================================
    Creates a reference to a method within a particular "target", where the target is the
    object from which the method was taken. In `"Hello".length()`, the target is the string
    `"Hello"`. For class methods, the target is a `TYPE_REFERENCE` the class itself. Instance
    methods may also have a `TYPE_REFERENCE` target, in which case the method takes an extra
    explicit parameter representing its `self`.
    ================================================================================================
    init(compiler:Compiler, target:IRNode?, value:MethodDecl) {
        assert target != null -- FIXME use non-nullable parameter
        assert value.resolved != Compiler.Resolution.UNRESOLVED
        self.value := value
        self.target := target
        def targetType:Type
        match target {
            when IRNode.TYPE_REFERENCE(_, type):
                targetType := type
            otherwise:
                targetType := target.type()
        }
        if !value.annotations.isClass() {
            owner := findType(compiler, targetType, value.owner)
            assert owner != null, "did not find \{value.owner.name} in \{targetType}"
            effectiveType := compiler.remapType(owner, value.type())
            if !compiler.isImmutable(target.type()) {
                def kind:Type.Kind
                if effectiveType.typeKind = Type.Kind.IMMUTABLE_FUNCTION {
                    kind := Type.Kind.FUNCTION
                }
                else {
                    kind := Type.Kind.METHOD
                }
                effectiveType := Type.methodType(value.position, kind,
                        effectiveType.subtypes[..effectiveType.subtypes.get_count() - 1],
                        effectiveType.subtypes[effectiveType.subtypes.get_count() - 1])
            }
            match target {
                when IRNode.TYPE_REFERENCE(_, type):
                    def params := Array<Type>()
                    params.add(owner)
                    params.addAll(effectiveType.subtypes[..effectiveType.subtypes.get_count() - 1])
                    effectiveType := Type.methodType(effectiveType.position, effectiveType.typeKind,
                            params, effectiveType.subtypes[effectiveType.subtypes.get_count() - 1])
            }
        }
        else {
            match target {
                when IRNode.TYPE_REFERENCE(_, type):
                    owner := type
                    effectiveType := compiler.remapType(owner, value.type())
                otherwise:
                    assert false, "\{value.declaration()} has invalid target \{target}" +
                            "(\{target.position})"
            }
        }
    }

    ================================================================================================
    Returns the type under which a particular class was inherited. For instance,
    `HashMap<String, File>` inherits `MapView` under the type `MapView<String, File>`.
    ================================================================================================
    @class
    function findType(compiler:Compiler, start:Type, target:ClassDecl):Type? {
        if start.typeKind = Type.Kind.GENERIC_PARAMETER {
            return findType(compiler, start.parameter.bound, target)
        }
        def startClass := compiler.getClass(start)
        if startClass = null {
            return null
        }
        if startClass == target {
            return start.nonnullable()
        }
        if startClass.rawSuper != null {
            def result := findType(compiler, compiler.remapType(start, startClass.rawSuper),
                    target)
            if result != null {
                return result
            }
        }
        for intf in startClass.rawInterfaces {
            def result := findType(compiler, compiler.remapType(start, intf), target)
            if result != null {
                return result
            }
        }
        return null
    }

    function parameterCount():Int {
        return value.parameters.get_count()
    }

    function parameter(index:Int):Type {
        return effectiveType.subtypes[index]
    }

    function returnType():Type {
        return effectiveType.subtypes[effectiveType.subtypes.get_count() - 1]
    }

    @override
    function convert():String {
        return "MethodRef(\{value.declaration()}, \{effectiveType})"
    }
}