package org.pandalanguage.pandac.parser

uses org.pandalanguage.pandac.ASTNode
uses org.pandalanguage.pandac.ClassDecl -- FIXME should be able to import ClassDecl.Kind directly
uses org.pandalanguage.pandac.Compiler
uses org.pandalanguage.pandac.ErrorReporter
uses org.pandalanguage.pandac.MethodDecl -- FIXME should be able to import MethodDecl.Kind directly
uses org.pandalanguage.pandac.Position
uses org.pandalanguage.pandac.Variable -- FIXME should be able to import Variable.Kind directly

@final
class Parser {
    def lexer := Lexer()

    def errors:MessageQueue<Compiler.Error>

    var path:File

    var source:String

    def pushbackBuffer := SpecializedArray<Token>()

    def commaSeparatedExpressionContext := Stack<Bit>()

    var inSpeculative := false

    def speculativeBuffer := SpecializedArray<Token>()

    init(errors:MessageQueue<Compiler.Error>) {
        self.errors := errors
        commaSeparatedExpressionContext.push(false)
    }

    method start(path:File, source:String) {
        lexer.start(source)
        self.path := path
        self.source := source
        pushbackBuffer.clear()
    }

    method rawNext():Token {
        if pushbackBuffer.get_count() != 0 {
            def idx := pushbackBuffer.get_count() - 1
            def result := pushbackBuffer[idx]
            pushbackBuffer.removeIndex(idx)
            return result
        }
        def result := lexer.next()
        if inSpeculative {
            speculativeBuffer.add(result)
        }
        return result
    }

    method next():Token {
        outer: loop {
            def result := rawNext()
            match result.kind {
                when Token.Kind.WHITESPACE:
                    continue
                when Token.Kind.LINE_COMMENT:
                    loop {
                        def next := rawNext()
                        match next.kind {
                            when Token.Kind.WHITESPACE:
                                if text(next).contains("\n") {
                                    continue outer
                                }
                            when Token.Kind.EOF:
                                return next
                        }
                    }
                when Token.Kind.BLOCK_COMMENT_START:
                    loop {
                        def next := next()
                        match next.kind {
                            when Token.Kind.BLOCK_COMMENT_END:
                                continue outer
                            when Token.Kind.EOF:
                                error(result, "unterminated comment")
                                return next
                        }
                    }
                otherwise:
                    return result
            }
        }
    }

    method pushback(token:Token) {
        pushbackBuffer.add(token)
    }

    method peek():Token {
        if pushbackBuffer.get_count() = 0 {
            pushback(next())
        }
        return pushbackBuffer[pushbackBuffer.get_count() - 1]
    }

    method checkNext(kind:Token.Kind):Token? {
        def result := next()
        if result.kind = kind {
            return result
        }
        pushback(result)
        return null
    }

    method expect(kind:Token.Kind, expected:String):Token? {
        def result := next()
        if result.kind = kind {
            return result
        }
        error(result, "expected \{expected}, but found '\{text(result)}'")
        return null
    }

    method error(token:Token, msg:String) {
        if !inSpeculative {
            errors.post(Compiler.Error(path, token.position, msg))
        }
    }

    method startSpeculative() {
        assert !inSpeculative
        inSpeculative := true
        speculativeBuffer.clear()
        speculativeBuffer.addAll(pushbackBuffer)
    }

    method accept() {
        inSpeculative := false
    }

    method rewind() {
        inSpeculative := false
        for i in speculativeBuffer.get_count() - 1 ... 0 by -1 {
            pushbackBuffer.add(speculativeBuffer[i])
        }
    }

    function text(token:Token):String {
        return source.substring(token.start .. token.end)
    }

    function addStringChunk(string:ASTNode?, chunk:ASTNode):ASTNode {
        if string = null {
            return chunk
        }
        return ASTNode.BINARY(string.position(), string, Token.Kind.ADD, chunk)
    }

    method formatString(start:Token):String? {
        def result := MutableString()
        loop {
            def token := rawNext()
            match token.kind {
                when Token.Kind.WHITESPACE:
                    def str := text(token)
                    if str.contains("\n") {
                        error(token, "unterminated string literal")
                        return null
                    }
                    result.append(str)
                when Token.Kind.EOF:
                    error(token, "unterminated string literal")
                    return null
                when Token.Kind.BACKSLASH:
                    def escape := rawNext()
                    if escape.kind = Token.Kind.EOF {
                        error(token, "unterminated string literal")
                        return null
                    }
                    def escapeText := text(escape)
                    def c := escapeText.utf8()[0]
                    match c {
                        when "n":  result.append("\n")
                        when "r":  result.append("\r")
                        when "t":  result.append("\t")
                        when "'":  result.append("'")
                        when "\"": result.append("\"")
                        when "\\": result.append("\\")
                        when "}":  result.append("}")
                        otherwise:
                            error(token, "invalid format string escape sequence")
                            return null
                    }
                    result.append(escapeText[escapeText.next(escapeText.start())..])
                when Token.Kind.RBRACE:
                    pushback(token)
                    return result.finish()
                otherwise:
                    result.append(text(token))
            }
        }
    }

    method alignmentString(start:Token):String? {
        def result := MutableString()
        loop {
            def token := rawNext()
            match token.kind {
                when Token.Kind.WHITESPACE:
                    def str := text(token)
                    if str.contains("\n") {
                        error(token, "unterminated string literal")
                        return null
                    }
                    result.append(str)
                when Token.Kind.EOF:
                    error(token, "unterminated string literal")
                    return null
                when Token.Kind.BACKSLASH:
                    def escape := rawNext()
                    if escape.kind = Token.Kind.EOF {
                        error(token, "unterminated string literal")
                        return null
                    }
                    def escapeText := text(escape)
                    def c := escapeText.utf8()[0]
                    match c {
                        when "n":  result.append("\n")
                        when "r":  result.append("\r")
                        when "t":  result.append("\t")
                        when "'":  result.append("'")
                        when "\"": result.append("\"")
                        when "\\": result.append("\\")
                        when ":":  result.append(":")
                        when "}":  result.append("}")
                        otherwise:
                            error(token, "invalid format string escape sequence")
                            return null
                    }
                    result.append(escapeText[escapeText.next(escapeText.start())..])
                when Token.Kind.COLON:
                    pushback(token)
                    return result.finish()
                when Token.Kind.RBRACE:
                    pushback(token)
                    return result.finish()
                otherwise:
                    result.append(text(token))
            }
        }
    }

    @private
    function convertToString(expr:ASTNode):ASTNode {
        def dot := ASTNode.DOT(expr.position(), expr, "convert")
        def call := ASTNode.CALL(expr.position(), dot, ImmutableArray<ASTNode>())
        def stringType := ASTNode.TYPE(expr.position(), "panda.core.String")
        return ASTNode.BINARY(expr.position(), call, Token.Kind.CAST, stringType)
    }

    method string():ASTNode? {
        def start := next()
        if start.kind != Token.Kind.DOUBLE_QUOTE & start.kind != Token.Kind.SINGLE_QUOTE {
            error(start, "expected a string, but found '\{text(start)}'")
            return null
        }
        var result:ASTNode? := null
        def chunk := MutableString()
        loop {
            def token := rawNext()
            if token.kind = start.kind {
                break
            }
            match token.kind {
                when Token.Kind.WHITESPACE:
                    def str := text(token)
                    if str.contains("\n") {
                        error(start, "unterminated string literal")
                        return null
                    }
                    chunk.append(str)
                when Token.Kind.EOF:
                    error(start, "unterminated string literal")
                    return null
                when Token.Kind.BACKSLASH:
                    def escape := rawNext()
                    if escape.kind = Token.Kind.EOF {
                        error(start, "unterminated string literal")
                        return null
                    }
                    def escapeText := text(escape)
                    def c := escapeText.utf8()[0]
                    match c {
                        when "n":  chunk.append("\n")
                        when "r":  chunk.append("\r")
                        when "t":  chunk.append("\t")
                        when "'":  chunk.append("'")
                        when "\"": chunk.append("\"")
                        when "\\": chunk.append("\\")
                        when "{": {
                            -- handle string interpolation
                            var expr := expression()
                            if expr = null {
                                return null
                            }
                            def align:String? := null
                            def format:String? := null
                            if checkNext(Token.Kind.COMMA) != null {
                                align := alignmentString(start)
                            }
                            if checkNext(Token.Kind.COLON) != null {
                                format := formatString(start)
                                if format = null {
                                    return null
                                }
                                def formattable := ASTNode.TYPE(expr.position(),
                                        "panda.core.Formattable")
                                def cast := ASTNode.BINARY(expr.position(), expr, Token.Kind.CAST,
                                        formattable)
                                def dot := ASTNode.DOT(expr.position(), cast, "format")
                                def callArgs := Array<ASTNode>() -- FIXME literal
                                callArgs.add(ASTNode.STRING(start.position, format))
                                expr := ASTNode.CALL(expr.position(), dot, callArgs.finish())
                            }
                            if expect(Token.Kind.RBRACE, "'}'") = null {
                                return null
                            }
                            if align != null {
                                if format = null {
                                    expr := convertToString(expr)
                                }
                                def pandaType := ASTNode.TYPE(expr.position(), "panda.core.Panda")
                                def callTarget := ASTNode.DOT(expr.position(), pandaType, "align")
                                def callArgs := Array<ASTNode>()
                                callArgs.add(expr)
                                callArgs.add(ASTNode.STRING(start.position, align))
                                expr := ASTNode.CALL(expr.position(), callTarget, callArgs.finish())
                            }
                            def text := chunk.finish()
                            chunk := MutableString()
                            if text != "" | result != null {
                                result := addStringChunk(result, ASTNode.STRING(start.position,
                                        text))
                                result := addStringChunk(result, expr)
                            }
                            else {
                                result := convertToString(expr)
                            }
                        }
                        otherwise:
                            error(token, "invalid string escape sequence")
                            return null
                    }
                    chunk.append(escapeText[escapeText.next(escapeText.start())..])
                otherwise:
                    chunk.append(text(token))
            }
        }
        return addStringChunk(result, ASTNode.STRING(start.position, chunk.finish()))
    }

    ================================================================================================
    term = IDENTIFIER | DECIMAL | BINARY | HEX | REAL | SELF | SUPER | NULL | TRUE | FALSE |
            string | LPAREN expression RPAREN | ANNOTATION(@pre) LPAREN expression RPAREN |
            anonymousMethod | ANNOTATION(@return) |
    ================================================================================================
    method term():ASTNode? {
        def t := next()
        match t.kind {
            when Token.Kind.IDENTIFIER:
                return ASTNode.IDENTIFIER(t.position, text(t))
            when Token.Kind.DECIMAL:
                return ASTNode.INT(t.position, text(t).convert())
            when Token.Kind.BINARY:
                return ASTNode.INT(t.position, UInt64.parse(text(t)[2..], 2))
            when Token.Kind.HEX:
                return ASTNode.INT(t.position, UInt64.parse(text(t)[2..], 16))
            when Token.Kind.REAL:
                return ASTNode.REAL(t.position, Real64.parse(text(t)))
            when Token.Kind.SELF:
                return ASTNode.SELF(t.position)
            when Token.Kind.SUPER:
                return ASTNode.SUPER(t.position)
            when Token.Kind.NULL:
                return ASTNode.NULL(t.position)
            when Token.Kind.TRUE:
                return ASTNode.BIT(t.position, true)
            when Token.Kind.FALSE:
                return ASTNode.BIT(t.position, false)
            when Token.Kind.DOUBLE_QUOTE, Token.Kind.SINGLE_QUOTE:
                pushback(t)
                return string()
            when Token.Kind.LPAREN:
                def result := expression()
                if result = null {
                    return null
                }
                if expect(Token.Kind.RPAREN, "')'") = null {
                    return null
                }
                return result
            when Token.Kind.ANNOTATION:
                def name := text(t)
                if name = "@pre" {
                    expect(Token.Kind.LPAREN, "'('")
                    def expr := expression()
                    expect(Token.Kind.RPAREN, "')'")
                    return ASTNode.AT_PRE(t.position, expr)
                }
                else if name = "@return" {
                    return ASTNode.AT_RETURN(t.position)
                }
                error(t, "expected an expression, but found '\{name}'")
                return null
            when Token.Kind.FUNCTION, Token.Kind.METHOD:
                pushback(t)
                return anonymousMethod()
            otherwise:
                error(t, "expected an expression, but found '\{text(t)}'")
                return null
        }
    }

    @class
    function getClassName(expr:ASTNode):String? {
        match expr {
            when ASTNode.IDENTIFIER(_, text): return text
            when ASTNode.DOT(_, base, field):
                var result := getClassName(base)
                if result != null {
                    result += "." + field
                }
                return result
            otherwise:
                return null
        }
    }

    ================================================================================================
    methodName = IDENTIFIER | ADD | SUB | MUL | DIV | INTDIV | POW | EQ | GT | LT | GTEQ | LTEQ |
            REM | AND | BITWISEAND | OR | BITWISEOR | XOR | BITWISEXOR | NOT | BITWISENOT |
            SHIFTLEFT | SHIFTRIGHT | (LBRACKET RBRACKET ASSIGNMENT?)
    ================================================================================================
    method methodName():String? {
        def name := next()
        match name.kind {
            when Token.Kind.IDENTIFIER, Token.Kind.ADD, Token.Kind.SUB, Token.Kind.MUL,
                    Token.Kind.DIV, Token.Kind.INTDIV, Token.Kind.POW, Token.Kind.EQ,
                    Token.Kind.NEQ, Token.Kind.LT, Token.Kind.GTEQ, Token.Kind.LTEQ,
                    Token.Kind.REM, Token.Kind.AND, Token.Kind.BITWISEAND, Token.Kind.OR,
                    Token.Kind.BITWISEOR, Token.Kind.XOR, Token.Kind.BITWISEXOR, Token.Kind.NOT,
                    Token.Kind.BITWISENOT, Token.Kind.SHIFTLEFT:
                return text(name)
            when Token.Kind.GT:
                def token := rawNext()
                if token.kind = Token.Kind.GT { -- two GT's in a row = SHIFTRIGHT
                    return ">>"
                }
                else {
                    pushback(token)
                    return ">"
                }
            when Token.Kind.LBRACKET:
                if expect(Token.Kind.RBRACKET, "']'") = null {
                    return null
                }
                if checkNext(Token.Kind.ASSIGNMENT) != null {
                    return "[]:="
                }
                return "[]"
            otherwise:
                error(name,
                        "expected an identifier or operator, but found '\{text(name)}'")
                return null
        }
    }

    method type():ASTNode? {
        return type(true)
    }

    ================================================================================================
    functionOrTupleType = LPAREN (type (COMMA type)*)? RPAREN ((YIELDS | YIELDS_METHOD |
            YIELDS_IMMUTABLE | YIELDS_METHOD_IMMUTABLE) LPAREN (type (COMMA type)*)? RPAREN)?
    ================================================================================================
    method functionOrTupleType():ASTNode? {
        def start := expect(Token.Kind.LPAREN, "'('")
        if start = null {
            return null
        }
        def subtypes := Array<ASTNode>()
        if checkNext(Token.Kind.RPAREN) = null {
            var t := type()
            if t = null {
                return null
            }
            subtypes.add(t)
            while checkNext(Token.Kind.COMMA) != null {
                t := type()
                if t = null {
                    return null
                }
                subtypes.add(t)
            }
            expect(Token.Kind.RPAREN, "')'")
        }
        def yields := peek()
        match yields.kind {
            when Token.Kind.YIELDS, Token.Kind.YIELDS_METHOD, Token.Kind.YIELDS_IMMUTABLE,
                    Token.Kind.YIELDS_METHOD_IMMUTABLE:
                next()
                if expect(Token.Kind.LPAREN, "'('") = null {
                    return null
                }
                def returnTypes := Array<ASTNode>()
                if checkNext(Token.Kind.RPAREN) = null {
                    var t := type()
                    if t = null {
                        return null
                    }
                    returnTypes.add(t)
                    while checkNext(Token.Kind.COMMA) != null {
                        t := type()
                        if t = null {
                            return null
                        }
                        returnTypes.add(t)
                    }
                    expect(Token.Kind.RPAREN, "')'")
                }
                def returnType:ASTNode?
                if returnTypes.get_count() = 0 {
                    returnType := null
                }
                else if returnTypes.get_count() = 1 {
                    returnType := returnTypes[0]
                }
                else {
                    returnType := ASTNode.TUPLE_TYPE(start.position, returnTypes.finish())
                }
                return ASTNode.METHOD_TYPE(start.position, yields.kind, subtypes.finish(),
                        returnType)
            otherwise:
                return ASTNode.TUPLE_TYPE(start.position, subtypes.finish())
        }
    }

    ================================================================================================
    type = IDENTIFIER (DOT IDENTIFIER)* (LT type (COMMA type)*) GT)? QUESTION? | functionOrTupleType
    ================================================================================================
    method type(needSpeculativeParse:Bit):ASTNode? {
        if peek().kind = Token.Kind.LPAREN {
            return functionOrTupleType()
        }
        def start := expect(Token.Kind.IDENTIFIER, "an identifier")
        if start = null {
            return null
        }
        def name := MutableString(text(start))
        while checkNext(Token.Kind.DOT) != null {
            def id := expect(Token.Kind.IDENTIFIER, "an identifier")
            if id = null {
                return null
            }
            name.append(".")
            name.append(text(id))
        }
        def finalName := name.finish()
        var result := ASTNode.TYPE(start.position, finalName)
        if peek().kind = Token.Kind.LT {
            -- may need to speculatively parse, because foo->Int8<bar looks like the start of a cast
            -- to "Int8<bar...", but is actually a cast to Int8 followed by less-than bar
            if needSpeculativeParse {
                startSpeculative()
            }
            next()
            def children := Array<ASTNode>()
            var t := type(false)
            if t = null {
                if needSpeculativeParse {
                    rewind()
                    return result
                }
                return null
            }
            children.add(t)
            while checkNext(Token.Kind.COMMA) != null {
                t := type(false)
                if t = null {
                    if needSpeculativeParse {
                        rewind()
                        return result
                    }
                    return null
                }
                children.add(t)
            }
            if expect(Token.Kind.GT, "'>'") = null {
                if needSpeculativeParse {
                    rewind()
                    return result
                }
                return null
            }
            result := ASTNode.GENERIC_TYPE(start.position, finalName, children.finish())
            accept()
        }
        if checkNext(Token.Kind.QUESTION) != null {
            result := ASTNode.NULLABLE_TYPE(start.position, result)
        }
        return result
    }

    ================================================================================================
    callExpression = term ((LPAREN (expression (COMMA expression)*)? RPAREN |
            DOT (methodName | INIT) | LBRACKET expression RBRACKET)* |
            (CAST | INSTANCEOF | NINSTANCEOF) type)* |
            (<if result so far is a valid class name> LT type (COMMA type)* GT)?
    Note there is a great deal of special handling to deal with class names, due to ambiguities
    between generic parameters and comparison expressions, e.g. foo(X < Y, Z > ... could be either a
    generic type X<Y, Z> or two comparison expressions X < Y and Z > <whatever the next token is>.
    We can't disambiguate this until we see the next token.
    ================================================================================================
    method callExpression():ASTNode? {
        var result := term()
        if result = null {
            return null
        }
        loop {
            def token := next()
            match token.kind {
                when Token.Kind.LPAREN:
                    commaSeparatedExpressionContext.push(true) -- FIXME use init / cleanup to automate this
                    def args := Array<ASTNode>()
                    if checkNext(Token.Kind.RPAREN) = null {
                        var expr := expression()
                        if expr = null {
                            commaSeparatedExpressionContext.pop()
                            return null
                        }
                        args.add(expr)
                        while checkNext(Token.Kind.COMMA) != null {
                            expr := expression()
                            if expr = null {
                                commaSeparatedExpressionContext.pop()
                                return null
                            }
                            args.add(expr)
                        }
                        if expect(Token.Kind.RPAREN, "')'") = null {
                            commaSeparatedExpressionContext.pop()
                            return null
                        }
                    }
                    commaSeparatedExpressionContext.pop()
                    result := ASTNode.CALL(token.position, result, args.finish())
                when Token.Kind.LBRACKET:
                    def arg := expression()
                    if arg = null {
                        return null
                    }
                    if expect(Token.Kind.RBRACKET, "']'") = null {
                        return null
                    }
                    result := ASTNode.BINARY(token.position, result, Token.Kind.LBRACKET, arg)
                when Token.Kind.DOT:
                    def name:String?
                    if checkNext(Token.Kind.INIT) != null {
                        name := "init"
                    }
                    else {
                        name := methodName()
                        if name = null {
                            return null
                        }
                    }
                    result := ASTNode.DOT(token.position, result, name)
                when Token.Kind.CAST:
                    def target := type()
                    if target = null {
                        return null
                    }
                    result := ASTNode.BINARY(token.position, result, Token.Kind.CAST, target)
                when Token.Kind.LT:
                    -- this is where we need to be careful. First, we make sure it makes sense to
                    -- interpret this as the start of a generic parameter list...
                    pushback(token)
                    def name := getClassName(result)
                    if name != null {
                        startSpeculative()
                        next()
                        -- no matter what, we might have to backtrack, because we might not find a
                        -- '>', e.g. foo(X < Y)
                        def types := Array<ASTNode>()
                        var t := type(false)
                        if t = null {
                            rewind()
                            return result
                        }
                        types.add(t)
                        while checkNext(Token.Kind.COMMA) != null {
                            t := type(false)
                            if t = null {
                                rewind()
                                return result
                            }
                            types.add(t)
                        }
                        if expect(Token.Kind.GT, "'>'") = null {
                            rewind()
                            return result
                        }
                        -- ok, we've successfully parsed a type... but we still might be wrong. If
                        -- we have, say, X<Y, Z>, it's possible that was supposed to be two
                        -- comparison expressions (which would include whatever the next token is).
                        -- Consider the following cases:
                        --
                        -- var x := X<Y, Z>
                        -- foo() -- type name followed by a method call
                        --
                        -- bar(X<Y, Z>foo) -- two expressions, X<Y and Z>foo
                        --
                        -- note that, ignoring whitespace, the sequence X<Y,Z>foo is identical in
                        -- both cases. We can resolve the ambiguity by noting that the other
                        -- interpretation is incorrect in both cases; there is no way for
                        -- var x := (two expressions) to make sense, and there is no way for
                        -- (<type name> <identifier>) to make sense in function call parameters.
                        -- So, we keep track of whether we are in a context that expects a comma-
                        -- separated list of expressions. If so, we need to look at the next token
                        -- after the type, as only a very few tokens can legally follow a type name
                        -- in an expression list. If not, we know it's a type regardless of what
                        -- follows it, because there is no way it can resolve to multiple
                        -- expressions.
                        def shouldAccept:Bit
                        if commaSeparatedExpressionContext[0] {
                            match peek().kind {
                                when Token.Kind.DOT, Token.Kind.LPAREN, Token.Kind.COMMA,
                                        Token.Kind.CAST:
                                    shouldAccept := true
                                otherwise:
                                    shouldAccept := false
                            }
                        }
                        else {
                            shouldAccept := true
                        }
                        if shouldAccept {
                            accept()
                            result := ASTNode.GENERIC_TYPE(result.position(), name, types.finish())
                            continue
                        }
                        else {
                            rewind()
                            return result
                        }
                    }
                    return result
                otherwise:
                    pushback(token)
                    return result
            }
        }
    }

    ================================================================================================
    exponentExression = callExpression (POW callExpression)*
    ================================================================================================
    method exponentExpression():ASTNode? {
        var result := callExpression()
        if result = null {
            return null
        }
        loop {
            def op := checkNext(Token.Kind.POW)
            if op = null {
                break
            }
            def next := callExpression()
            if next = null {
                return null
            }
            result := ASTNode.BINARY(op.position, result, op.kind, next)
        }
        return result
    }

    ================================================================================================
    prefixExpression = (SUB | NOT | BITWISENOT)? exponentExpression
    ================================================================================================
    method prefixExpression():ASTNode? {
        def op := next()
        match op.kind {
            when Token.Kind.SUB, Token.Kind.NOT, Token.Kind.BITWISENOT:
                def base := exponentExpression()
                if base = null {
                    return null
                }
                return ASTNode.PREFIX(op.position, op.kind, base)
            otherwise:
                pushback(op)
                return exponentExpression()
        }
    }

    ================================================================================================
    multiplicativeExpression = prefixExpression ((MUL | DIV | INTDIV | REM | SHIFTLEFT |
            SHIFTRIGHT | BITWISEAND | BITWISEXOR) prefixExpression)*
    Note that SHIFTRIGHT is handled specially, as the lexer only produces GT and we synthesize the
    SHIFTRIGHT token here.
    ================================================================================================
    method multiplicativeExpression():ASTNode? {
        var result := prefixExpression()
        if result = null {
            return null
        }
        loop {
            def op := next()
            match op.kind {
                when Token.Kind.MUL, Token.Kind.DIV, Token.Kind.INTDIV, Token.Kind.REM,
                        Token.Kind.SHIFTLEFT, Token.Kind.BITWISEAND, Token.Kind.BITWISEOR:
                    def next := prefixExpression()
                    if next = null {
                        return null
                    }
                    result := ASTNode.BINARY(op.position, result, op.kind, next)
                when Token.Kind.GT:
                    def nextToken := rawNext()
                    if nextToken.kind = Token.Kind.GT {
                        -- two GTs in a row = SHIFTRIGHT
                        def next := prefixExpression()
                        if next = null {
                            return null
                        }
                        result := ASTNode.BINARY(op.position, result, Token.Kind.SHIFTRIGHT, next)
                    }
                    else {
                        pushback(nextToken)
                        pushback(op)
                        return result
                    }
                otherwise:
                    pushback(op)
                    return result
            }
        }
    }

    ================================================================================================
    additiveExpression = multiplicativeExpression
            ((ADD | SUB | BITWISEOR) multiplicativeExpression)*
    ================================================================================================
    method additiveExpression():ASTNode? {
        var result := multiplicativeExpression()
        if result = null {
            return null
        }
        loop {
            def op := next()
            match op.kind {
                when Token.Kind.ADD, Token.Kind.SUB, Token.Kind.BITWISEXOR:
                    def next := multiplicativeExpression()
                    if next = null {
                        return null
                    }
                    result := ASTNode.BINARY(op.position, result, op.kind, next)
                otherwise:
                    pushback(op)
                    return result
            }
        }
    }

    ================================================================================================
    rangeExpression = additiveExpression | (additiveExpression? (DOTDOT | ELLIPSIS)
           additiveExpression? (BY additiveExpression)?)
    ================================================================================================
    method rangeExpression():ASTNode? {
        var result:ASTNode?
        match peek().kind {
            when Token.Kind.DOTDOT, Token.Kind.ELLIPSIS:
                result := null
            otherwise:
                result := additiveExpression()
                if result = null {
                    return null
                }
        }
        def op := next()
        match op.kind {
            when Token.Kind.DOTDOT, Token.Kind.ELLIPSIS:
                def next := peek()
                def right:ASTNode?
                if next.kind != Token.Kind.RBRACKET & next.kind != Token.Kind.RPAREN &
                        next.kind != Token.Kind.BY {
                    right := additiveExpression()
                    if right = null {
                        return null
                    }
                }
                else {
                    right := null
                }
                def step:ASTNode?
                if checkNext(Token.Kind.BY) != null {
                    step := additiveExpression()
                    if step = null {
                        return null
                    }
                }
                else {
                    step := null
                }
                return ASTNode.RANGE(op.position, result, right, op.kind = Token.Kind.ELLIPSIS,
                        step)
            otherwise:
                pushback(op)
                return result
        }
    }

    ================================================================================================
    comparisonExpression = rangeExpression ((EQ | IDENTITY | NEQ |
             NIDENTITY | LT | GT | LTEQ | GTEQ | IN) rangeExpression)*
    ================================================================================================
    method comparisonExpression():ASTNode? {
        var result := rangeExpression()
        if result = null {
            return null
        }
        loop {
            def op := next()
            match op.kind {
                when Token.Kind.EQ,
                        Token.Kind.NEQ,
                        Token.Kind.IDENTITY,
                        Token.Kind.NIDENTITY,
                        Token.Kind.LT,
                        Token.Kind.GT,
                        Token.Kind.LTEQ,
                        Token.Kind.GTEQ:
                    def next := rangeExpression()
                    if next = null {
                        return null
                    }
                    result := ASTNode.BINARY(op.position, result, op.kind, next)
                otherwise:
                    pushback(op)
                    return result
            }
        }
    }

    ================================================================================================
    andExpression = comparisonExpression ((AND | XOR) comparisonExpression)*
    ================================================================================================
    method andExpression():ASTNode? {
        var result := comparisonExpression()
        if result = null {
            return null
        }
        loop {
            def op := next()
            match op.kind {
                when Token.Kind.AND, Token.Kind.XOR:
                    def next := comparisonExpression()
                    if next = null {
                        return null
                    }
                    result := ASTNode.BINARY(op.position, result, op.kind, next)
                otherwise:
                    pushback(op)
                    return result
            }
        }
    }

    ================================================================================================
    expression = andExpression (OR andExpression)*
    ================================================================================================
    method expression():ASTNode? {
        var result := andExpression()
        if result = null {
            return null
        }
        loop {
            def op := checkNext(Token.Kind.OR)
            if op = null {
                break
            }
            def next := andExpression()
            if next = null {
                return null
            }
            result := ASTNode.BINARY(op.position, result, op.kind, next)
        }
        return result
    }

    ================================================================================================
    ifStatement = IF expression block (else (ifStatement | block))?
    ================================================================================================
    method ifStatement():ASTNode? {
        def start := expect(Token.Kind.IF, "'if'")
        if start = null {
            return null
        }
        def test := expression()
        if test = null {
            return null
        }
        def ifTrue := blockStatements()
        if ifTrue = null {
            return null
        }
        var ifFalse:ASTNode?
        if checkNext(Token.Kind.ELSE) != null {
            if peek().kind = Token.Kind.IF {
                ifFalse := ifStatement()
                if ifFalse = null {
                    return null
                }
            }
            else {
                ifFalse := block()
                if ifFalse = null {
                    return null
                }
            }
        }
        else {
            ifFalse := null
        }
        return ASTNode.IF(start.position, test, ifTrue, ifFalse)
    }

    ================================================================================================
    typeDeclaration = COLON type
    ================================================================================================
    method typeDeclaration():ASTNode? {
        if expect(Token.Kind.COLON, "':'") = null {
            return null
        }
        return type(false)
    }

    ================================================================================================
    target = IDENTIFIER (typeDeclaration?)
    ================================================================================================
    method target():ASTNode? {
        def id := expect(Token.Kind.IDENTIFIER, "an identifier")
        if id = null {
            return null
        }
        if peek().kind = Token.Kind.COLON {
            def type := typeDeclaration()
            if type = null {
                return null
            }
            return ASTNode.TYPED_IDENTIFIER(id.position, text(id), type)
        }
        return ASTNode.IDENTIFIER(id.position, text(id))
    }

    ================================================================================================
    forLoop = FOR target IN expression block
    ================================================================================================
    method forLoop(label:String?):ASTNode? {
        def start := expect(Token.Kind.FOR, "'for'")
        if start = null {
            return null
        }
        def t := target()
        if t = null {
            return null
        }
        if expect(Token.Kind.IN, "'in'") = null {
            return null
        }
        def list := expression()
        if list = null {
            return null
        }
        def block := blockStatements()
        if block = null {
            return null
        }
        return ASTNode.FOR(start.position, label, t, list, block)
    }

    ================================================================================================
    whileLoop = WHILE expression block
    ================================================================================================
    method whileLoop(label:String?):ASTNode? {
        def start := expect(Token.Kind.WHILE, "'while'")
        if start = null {
            return null
        }
        def test := expression()
        if test = null {
            return null
        }
        def body := blockStatements()
        if body = null {
            return null
        }
        return ASTNode.WHILE(start.position, label, test, body)
    }

    ================================================================================================
    doLoop = DO block WHILE expression
    ================================================================================================
    method doLoop(label:String?):ASTNode? {
        def start := expect(Token.Kind.DO, "'do'")
        if start = null {
            return null
        }
        def body := blockStatements()
        if body = null {
            return null
        }
        if expect(Token.Kind.WHILE, "'while'") = null {
            return null
        }
        def test := expression()
        if test = null {
            return null
        }
        return ASTNode.DO(start.position, label, body, test)
    }

    ================================================================================================
    loopLoop = LOOP block
    ================================================================================================
    method loopLoop(label:String?):ASTNode? {
        def start := expect(Token.Kind.LOOP, "'loop'")
        if start = null {
            return null
        }
        def body := blockStatements()
        if body = null {
            return null
        }
        return ASTNode.LOOP(start.position, label, body)
    }

    ================================================================================================
    assertStatement = ASSERT expression (COMMA expression)?
    ================================================================================================
    method assertStatement():ASTNode? {
        def start := expect(Token.Kind.ASSERT, "'assert'")
        if start = null {
            return null
        }
        def expr := expression()
        if expr = null {
            return null
        }
        def message:ASTNode?
        if checkNext(Token.Kind.COMMA) != null{
            message := expression()
            if message = null {
                return null
            }
        }
        else {
            message := null
        }
        return ASTNode.ASSERT(start.position, expr, message)
    }

    ================================================================================================
    whenClause = WHEN expression (COMMA expression)* COLON statement* terminalStatement?
    ================================================================================================
    method whenClause():ASTNode? {
        def start := expect(Token.Kind.WHEN, "'when'")
        if start = null {
            return null
        }
        def expressions := Array<ASTNode>()
        var expr := expression()
        if expr = null {
            return null
        }
        expressions.add(expr)
        while checkNext(Token.Kind.COMMA) != null {
            expr := expression()
            if expr = null {
                return null
            }
            expressions.add(expr)
        }
        if expect(Token.Kind.COLON, "':'") = null {
            return null
        }
        def statements := Array<ASTNode>()
        loop {
            match peek().kind {
                when Token.Kind.WHEN, Token.Kind.OTHERWISE, Token.Kind.RBRACE:
                    break
                when Token.Kind.BREAK, Token.Kind.CONTINUE, Token.Kind.RETURN:
                    def stmt := terminalStatement()
                    if stmt = null {
                        return null
                    }
                    statements.add(stmt)
                    break
                otherwise: {
                    def stmt := statement()
                    if stmt = null {
                        return null
                    }
                    statements.add(stmt)
                }
            }
        }
        return ASTNode.WHEN(start.position, expressions.finish(), statements.finish())
    }

    ================================================================================================
    match = MATCH expression LBRACE when* (DEFAULT COLON statement*)? RBRACE
    ================================================================================================
    method matchStatement():ASTNode? {
        def start := expect(Token.Kind.MATCH, "'match'")
        if start = null {
            return null
        }
        def expr := expression()
        if expr = null {
            return null
        }
        if expect(Token.Kind.LBRACE, "'{'") = null {
            return null
        }
        def whens := Array<ASTNode>()
        var other:Array<ASTNode>? := null
        loop {
            def token := peek()
            match token.kind {
                when Token.Kind.RBRACE:
                    break
                when Token.Kind.WHEN:
                    def w := whenClause()
                    if w = null {
                        return null
                    }
                    whens.add(w)
                when Token.Kind.OTHERWISE:
                    def o := next()
                    if expect(Token.Kind.COLON, "':'") = null {
                        return null
                    }
                    other := Array<ASTNode>()
                    loop {
                        match peek().kind {
                            when Token.Kind.RBRACE:
                                break
                            when Token.Kind.BREAK, Token.Kind.CONTINUE, Token.Kind.RETURN:
                                def stmt := terminalStatement()
                                if stmt = null {
                                    return null
                                }
                                other.add(stmt)
                                break
                            otherwise:
                                def stmt := statement()
                                if stmt = null {
                                    return null
                                }
                                other.add(stmt)
                        }
                    }
                    break
                otherwise:
                    next()
                    error(token, "expected 'when', 'otherwise', or '}', but " +
                            "found '\{text(token)}'")
            }
        }
        if expect(Token.Kind.RBRACE, "'}'") = null {
            return null
        }
        if other != null {
            return ASTNode.MATCH(start.position, expr, whens.finish(), other.finish())
        }
        return ASTNode.MATCH(start.position, expr, whens.finish(), null)
    }

    ================================================================================================
    blockStatements = LBRACE statement* terminalStatement? RBRACE
    ================================================================================================
    method blockStatements():ImmutableArray<ASTNode>? {
        def start := expect(Token.Kind.LBRACE, "'{'")
        if start = null {
            return null
        }
        def result := Array<ASTNode>()
        loop {
            match peek().kind {
                when Token.Kind.RBRACE:
                    next()
                    break
                when Token.Kind.BREAK, Token.Kind.CONTINUE, Token.Kind.RETURN:
                    def stmt := terminalStatement()
                    if stmt = null {
                        return null
                    }
                    if expect(Token.Kind.RBRACE, "'}'") = null {
                        return null
                    }
                    result.add(stmt)
                    break
                otherwise:
                    def stmt := statement()
                    if stmt = null {
                        return null
                    }
                    result.add(stmt)
            }
        }
        return result.finish()
    }

    ================================================================================================
    block = blockStatements
    ================================================================================================
    method block():ASTNode? {
        def statements := blockStatements()
        if statements = null {
            return null
        }
        return ASTNode.BLOCK(Position(), statements)
    }

    ================================================================================================
    expressionOrAssignment = expression assignmentOperator expression)?
    ================================================================================================
    method expressionOrAssignment():ASTNode? {
        def start := expression()
        if start = null {
            return null
        }
        match peek().kind {
            when Token.Kind.ASSIGNMENT, Token.Kind.ADDEQ, Token.Kind.SUBEQ, Token.Kind.MULEQ,
                    Token.Kind.DIVEQ, Token.Kind.REMEQ, Token.Kind.INTDIVEQ, Token.Kind.POWEQ,
                    Token.Kind.OREQ, Token.Kind.BITWISEOREQ, Token.Kind.ANDEQ,
                    Token.Kind.BITWISEANDEQ, Token.Kind.XOREQ, Token.Kind.BITWISEXOREQ,
                    Token.Kind.SHIFTLEFTEQ, Token.Kind.SHIFTRIGHTEQ:
                def op := next()
                def rvalue := expression()
                if rvalue = null {
                    return null
                }
                return ASTNode.BINARY(start.position(), start, op.kind, rvalue)
            when Token.Kind.EQ:
                error(peek(), "unexpected '=', perhaps you meant ':='?")
                def op := next()
                def rvalue := expression()
                if rvalue = null {
                    return null
                }
                return ASTNode.BINARY(start.position(), start, op.kind, rvalue)
            otherwise:
                return start
        }
    }

    ================================================================================================
    singleVar = target (ASSIGNMENT expression)?
    ================================================================================================
    method singleVar():ASTNode? {
        def t := target()
        if t = null {
            return null
        }
        def value:ASTNode?
        if checkNext(Token.Kind.ASSIGNMENT) != null {
            value := expression()
            if value = null {
                return null
            }
        }
        else if peek().kind = Token.Kind.EQ {
            error(next(), "unexpected '=', perhaps you meant ':='?")
            value := expression()
            if value = null {
                return null
            }
        }
        else {
            value := null
        }
        return ASTNode.DECLARATION(t.position(), t, value)
    }

    ================================================================================================
    varDeclaration = (VAR | DEF | PROPERTY | CONSTANT) singleVar (COMMA singleVar*)
    ================================================================================================
    method varDeclaration():ASTNode? {
        def start := next()
        def kind:Variable.Kind
        match start.kind {
            when Token.Kind.VAR:
                kind := Variable.Kind.VAR
            when Token.Kind.DEF:
                kind := Variable.Kind.DEF
            when Token.Kind.PROPERTY:
                kind := Variable.Kind.PROPERTY
            when Token.Kind.CONSTANT:
                kind := Variable.Kind.CONSTANT
            otherwise:
                error(start, "expected 'var', 'def', 'property', or 'constant'")
        }
        def declarations := Array<ASTNode>()
        var decl := singleVar()
        if decl = null {
            return null
        }
        declarations.add(decl)
        while checkNext(Token.Kind.COMMA) != null {
            var decl := singleVar()
            if decl = null {
                return null
            }
            declarations.add(decl)
        }
        return ASTNode.VAR(start.position, kind, declarations.finish())
    }

    ================================================================================================
    initCall = INIT LPAREN (expression (COMMA expression)*)? RPAREN
    ================================================================================================
    method initCall():ASTNode? {
        def start := expect(Token.Kind.INIT, "'init'")
        if start = null {
            return null
        }
        if expect(Token.Kind.LPAREN, "'('") = null {
            return null
        }
        commaSeparatedExpressionContext.push(true) -- FIXME use init / cleanup to automate this
        def target := ASTNode.IDENTIFIER(start.position, text(start))
        def args := Array<ASTNode>()
        if checkNext(Token.Kind.RPAREN) = null {
            var expr := expression()
            if expr = null {
                commaSeparatedExpressionContext.pop()
                return null
            }
            args.add(expr)
            while checkNext(Token.Kind.COMMA) != null {
                expr := expression()
                if expr = null {
                    commaSeparatedExpressionContext.pop()
                    return null
                }
                args.add(expr)
            }
            if expect(Token.Kind.RPAREN, "')'") = null {
                commaSeparatedExpressionContext.pop()
                return null
            }
        }
        commaSeparatedExpressionContext.pop()
        return ASTNode.CALL(start.position, target, args.finish())
    }

    ================================================================================================
    breakStatement = BREAK IDENTIFIER?
    ================================================================================================
    method breakStatement():ASTNode? {
        def start := expect(Token.Kind.BREAK, "'break'")
        if start = null {
            return null
        }
        def label := checkNext(Token.Kind.IDENTIFIER)
        if label != null {
            return ASTNode.BREAK(start.position, text(label))
        }
        return ASTNode.BREAK(start.position, null)
    }

    ================================================================================================
    continueStatement = CONTINUE IDENTIFIER?
    ================================================================================================
    method continueStatement():ASTNode? {
        def start := expect(Token.Kind.CONTINUE, "'continue'")
        if start = null {
            return null
        }
        def label := checkNext(Token.Kind.IDENTIFIER)
        if label != null {
            return ASTNode.CONTINUE(start.position, text(label))
        }
        return ASTNode.CONTINUE(start.position, null)
    }

    ================================================================================================
    returnStatement = RETURN expression?
    ================================================================================================
    method returnStatement():ASTNode? {
        def start := expect(Token.Kind.RETURN, "'return'")
        if start = null {
            return null
        }
        match peek().kind {
            when Token.Kind.RBRACE, Token.Kind.WHEN, Token.Kind.OTHERWISE:
                return ASTNode.RETURN(start.position, null)
            otherwise:
                def children := Array<ASTNode>()
                def expr := expression()
                if expr = null {
                    return null
                }
                children.add(expr)
                return ASTNode.RETURN(start.position, expr)
        }
    }

    ================================================================================================
    terminalStatement = breakStatement | continueStatement | returnStatement
    ================================================================================================
    method terminalStatement():ASTNode? {
        match peek().kind {
            when Token.Kind.BREAK:    return breakStatement()
            when Token.Kind.CONTINUE: return continueStatement()
            when Token.Kind.RETURN:   return returnStatement()
            otherwise: assert false
        }
    }

    method anyLoop(label:String?):ASTNode? {
        match peek().kind {
            when Token.Kind.DO:    return doLoop(label)
            when Token.Kind.FOR:   return forLoop(label)
            when Token.Kind.LOOP:  return loopLoop(label)
            when Token.Kind.WHILE: return whileLoop(label)
            otherwise:
                -- trigger error
                expect(Token.Kind.DO, "'do', 'for', 'loop', or 'while' following label")
                return null
        }
    }

    ================================================================================================
    statement = ifStatement | anyLoop | expressionOrAssignment | assertStatement | matchStatement |
            block | varDeclaration | initCall
    ================================================================================================
    method statement():ASTNode? {
        match peek().kind {
            when Token.Kind.IF:     return ifStatement()
            when Token.Kind.FOR:    return forLoop(null)
            when Token.Kind.WHILE:  return whileLoop(null)
            when Token.Kind.DO:     return doLoop(null)
            when Token.Kind.LOOP:   return loopLoop(null)
            when Token.Kind.ASSERT: return assertStatement()
            when Token.Kind.MATCH:  return matchStatement()
            when Token.Kind.LBRACE: return block()
            when Token.Kind.IDENTIFIER:
                def id := next()
                if checkNext(Token.Kind.COLON) != null {
                    return anyLoop(text(id))
                }
                pushback(id)
                return expressionOrAssignment()
            when Token.Kind.SELF, Token.Kind.SUPER:
                return expressionOrAssignment()
            when Token.Kind.VAR, Token.Kind.DEF, Token.Kind.PROPERTY, Token.Kind.CONSTANT:
                return varDeclaration()
            when Token.Kind.INIT:
                return initCall()
            otherwise:
                -- trigger error
                expect(Token.Kind.IF, "a statement")
                return null
        }
    }

    ================================================================================================
    packageDeclaration = PACKAGE IDENTIFIER (DOT IDENTIFIER)*
    ================================================================================================
    method packageDeclaration():ASTNode? {
        def start := expect(Token.Kind.PACKAGE, "'package'")
        if start = null {
            return null
        }
        var next := expect(Token.Kind.IDENTIFIER, "an identifier")
        if next = null {
            return null
        }
        def name := MutableString(text(next))
        loop {
            next := checkNext(Token.Kind.DOT)
            if next = null {
                break
            }
            name.append(".")
            next := expect(Token.Kind.IDENTIFIER, "an identifier")
            if next = null {
                return null
            }
            name.append(text(next))
        }
        return ASTNode.PACKAGE(start.position, name.finish())
    }

    ================================================================================================
    usesDeclaration = USES IDENTIFIER (DOT IDENTIFIER)*
    ================================================================================================
    method usesDeclaration():ASTNode? {
        def start := expect(Token.Kind.USES, "'uses'")
        if start = null {
            return null
        }
        def next := expect(Token.Kind.IDENTIFIER, "an identifier")
        if next = null {
            return null
        }
        def name := MutableString(text(next))
        loop {
            next := checkNext(Token.Kind.DOT)
            if next = null {
                break
            }
            name.append(".")
            next := expect(Token.Kind.IDENTIFIER, "an identifier")
            if next = null {
                return null
            }
            name.append(text(next))
        }
        return ASTNode.USES(start.position, name.finish())
    }

    ================================================================================================
    genericsDeclaration = LT IDENTIFIER typeDeclaration? (COMMA IDENTIFIER typeDeclaration?)* GT
    ================================================================================================
    method genericsDeclaration():ImmutableArray<ASTNode>? {
        def start := expect(Token.Kind.LT, "'<'")
        if start = null {
            return null
        }
        var id := expect(Token.Kind.IDENTIFIER, "an identifier")
        if id = null {
            return null
        }
        def parameters := Array<ASTNode>()
        if checkNext(Token.Kind.COLON) != null {
            def t := type()
            if t = null {
                return null
            }
            parameters.add(ASTNode.TYPED_IDENTIFIER(id.position, text(id), t))
        }
        else {
            parameters.add(ASTNode.IDENTIFIER(id.position, text(id)))
        }
        while checkNext(Token.Kind.COMMA) != null {
            id := expect(Token.Kind.IDENTIFIER, "an identifier")
            if id = null {
                return null
            }
            if checkNext(Token.Kind.COLON) != null {
                def t := type()
                if t = null {
                    return null
                }
                parameters.add(ASTNode.TYPED_IDENTIFIER(id.position, text(id), t))
            }
            else {
                parameters.add(ASTNode.IDENTIFIER(id.position, text(id)))
            }
        }
        if expect(Token.Kind.GT, "'>'") = null {
            return null
        }
        return parameters.finish()
    }

    ================================================================================================
    supertypes = COLON type (COMMA type)*
    ================================================================================================
    method supertypes():ImmutableArray<ASTNode>? {
        def start := expect(Token.Kind.COLON, "':'")
        if start = null {
            return null
        }
        def result := Array<ASTNode>()
        var t := type()
        if t = null {
            return null
        }
        result.add(t)
        while checkNext(Token.Kind.COMMA) != null {
            t := type()
            if t = null {
                return null
            }
            result.add(t)
        }
        return result.finish()
    }

    ================================================================================================
    annotation = ANNOTATION (LPAREN expression RPAREN)?
    ================================================================================================
    method annotation():ASTNode? {
        def a := expect(Token.Kind.ANNOTATION, "an annotation")
        def expr:ASTNode?
        if checkNext(Token.Kind.LPAREN) != null {
            expr := expression()
            if expr = null {
                return null
            }
            expect(Token.Kind.RPAREN, "')'")
        }
        return ASTNode.ANNOTATION(a.position, text(a), expr)
    }

    ================================================================================================
    annotations = annotation*
    ================================================================================================
    method annotations():ImmutableArray<ASTNode> {
        def result := Array<ASTNode>()
        while peek().kind = Token.Kind.ANNOTATION {
            def a := annotation()
            if a = null {
                break
            }
            result.add(a)
        }
        return result.finish()
    }

    method doccomment():ASTNode? {
        def start := expect(Token.Kind.DOC_COMMENT, "a documentation comment")
        if start = null {
            return null
        }
        def result := MutableString()
        loop {
            def next := rawNext()
            if next.kind = Token.Kind.DOC_COMMENT {
                break
            }
            if next.kind = Token.Kind.EOF {
                error(start, "unterminated documentation comment")
                return null
            }
            result.append(text(next))
        }
        return ASTNode.STRING(start.position, result.finish())
    }

    ================================================================================================
    parameter = IDENTIFIER typeDeclaration
    ================================================================================================
    method parameter():ASTNode? {
        def id := expect(Token.Kind.IDENTIFIER, "an identifier")
        if id = null {
            return null
        }
        def t := typeDeclaration()
        if t = null {
            return null
        }
        return ASTNode.PARAMETER(id.position, text(id), t)
    }

    ================================================================================================
    parameters = LPAREN (parameter (COMMA parameter)*)? RPAREN
    ================================================================================================
    method parameters():ImmutableArray<ASTNode>? {
        def start := expect(Token.Kind.LPAREN, "'('")
        if start = null {
            return null
        }
        def result := Array<ASTNode>()
        if checkNext(Token.Kind.RPAREN) = null {
            def param := parameter()
            if param = null {
                return null
            }
            result.add(param)
            while checkNext(Token.Kind.COMMA) != null {
                param := parameter()
                if param = null {
                    return null
                }
                result.add(param)
            }
            if expect(Token.Kind.RPAREN, "')'") = null {
                return null
            }
        }
        return result.finish()
    }

    ================================================================================================
    methodDeclaration = (METHOD | FUNCTION) methodName parameters typeDeclaration? block?
    ================================================================================================
    method methodDeclaration(doccomment:ASTNode?, annotations:ImmutableArray<ASTNode>):ASTNode? {
        def kind:MethodDecl.Kind
        def start := checkNext(Token.Kind.FUNCTION)
        if start = null {
            start := expect(Token.Kind.METHOD, "'method' or 'function'")
            if start = null {
                return null
            }
            kind := MethodDecl.Kind.METHOD
        }
        else {
            kind := MethodDecl.Kind.FUNCTION
        }
        def name := methodName()
        if name = null {
            return null
        }
        def params := parameters()
        if params = null {
            return null
        }
        def returnType:ASTNode?
        if peek().kind = Token.Kind.COLON {
            returnType := typeDeclaration()
            if returnType = null {
                return null
            }
        }
        else {
            returnType := null
        }
        def body:ImmutableArray<ASTNode>?
        if peek().kind = Token.Kind.LBRACE {
            body := blockStatements()
            if body = null {
                return null
            }
        }
        else {
            body := null
        }
        return ASTNode.METHOD(start.position, doccomment, annotations, kind, name, params,
                returnType, body)
    }

    ================================================================================================
    anonymousMethod = (METHOD | FUNCTION) parameters typeDeclaration? block
    ================================================================================================
    method anonymousMethod():ASTNode? {
        def kind:MethodDecl.Kind
        def start := checkNext(Token.Kind.FUNCTION)
        if start = null {
            start := expect(Token.Kind.METHOD, "'method' or 'function'")
            if start = null {
                return null
            }
            kind := MethodDecl.Kind.METHOD
        }
        else {
            kind := MethodDecl.Kind.FUNCTION
        }
        def params := parameters()
        if params = null {
            return null
        }
        def returnType:ASTNode?
        if peek().kind = Token.Kind.COLON {
            returnType := typeDeclaration()
            if returnType = null {
                return null
            }
        }
        else {
            returnType := null
        }
        def body := blockStatements()
        if body = null {
            return null
        }
        return ASTNode.METHOD(start.position, null, ImmutableArray<ASTNode>(), kind, "<anonymous>", -- FIXME literal
                params, returnType, body)
    }

    ================================================================================================
    initDeclaration = INIT parameters block
    ================================================================================================
    method initDeclaration(doccomment:ASTNode?, annotations:ImmutableArray<ASTNode>):ASTNode? {
        def start := expect(Token.Kind.INIT, "'init'")
        if start = null {
            return null
        }
        def params := parameters()
        if params = null {
            return null
        }
        def b := blockStatements()
        if b = null {
            return null
        }
        return ASTNode.METHOD(start.position, doccomment, annotations, MethodDecl.Kind.INIT, "init",
                params, null, b)
    }

    ================================================================================================
    fieldDeclaration = varDeclaration
    ================================================================================================
    method fieldDeclaration(doccomment:ASTNode?, annotations:ImmutableArray<ASTNode>):ASTNode? {
        def decl := varDeclaration()
        if decl = null {
            return null
        }
        return ASTNode.FIELD(decl.position(), doccomment, annotations, decl)
    }

    ================================================================================================
    choiceEntry = IDENTIFIER (LPAREN (type (COMMA type)*)? RPAREN)?
    ================================================================================================
    method choiceEntry(doccomment:ASTNode?):ASTNode? {
        def name := expect(Token.Kind.IDENTIFIER, "an identifier")
        if name = null {
            return null
        }
        def fields := Array<ASTNode>()
        if checkNext(Token.Kind.LPAREN) != null {
            if peek().kind != Token.Kind.RPAREN {
                var field := type()
                if field = null {
                    return null
                }
                fields.add(field)
                while checkNext(Token.Kind.COMMA) != null {
                    field := type()
                    if field = null {
                        return null
                    }
                    fields.add(field)
                }
            }
            if expect(Token.Kind.RPAREN, "')'") = null {
                return null
            }
        }
        return ASTNode.CHOICE_ENTRY(name.position, doccomment, text(name), fields.finish())
    }

    ================================================================================================
    choiceDeclaration = CHOICE IDENTIFIER LBRACE choiceEntry* declaration* RBRACE
    ================================================================================================
    method choiceDeclaration(choiceDoccomment:ASTNode?,
            choiceAnnotations:ImmutableArray<ASTNode>):ASTNode? {
        def start := expect(Token.Kind.CHOICE, "'choice'")
        if start = null {
            return null
        }
        def name := expect(Token.Kind.IDENTIFIER, "an identifier")
        if name = null {
            return null
        }
        if expect(Token.Kind.LBRACE, "'{'") = null {
            return null
        }
        def members := Array<ASTNode>()
        var dc:ASTNode? := null
        loop {
            def next := peek()
            match next.kind {
                when Token.Kind.CLASS, Token.Kind.INTERFACE, Token.Kind.CHOICE, Token.Kind.METHOD,
                        Token.Kind.FUNCTION, Token.Kind.ANNOTATION, Token.Kind.VAR, Token.Kind.DEF,
                        Token.Kind.PROPERTY, Token.Kind.CONSTANT:
                    break
                when Token.Kind.DOC_COMMENT:
                    if dc != null {
                        error(next, "expected a declaration, but found '\{text(next)}'")
                    }
                    dc := doccomment()
                when Token.Kind.IDENTIFIER:
                    def c := choiceEntry(dc)
                    if c = null {
                        return null
                    }
                    members.add(c)
                    dc := null
                otherwise:
                    break
            }
        }
        var a := ImmutableArray<ASTNode>() -- FIXME literal
        loop {
            def next := peek()
            match next.kind {
                when Token.Kind.ANNOTATION:
                    if a.get_count() > 0 {
                        error(next, "expected a declaration, but found '\{text(next)}'")
                        return null
                    }
                    a := annotations()
                when Token.Kind.DOC_COMMENT:
                    if dc != null | a.get_count() > 0 {
                        error(next, "expected a declaration, but found '\{text(next)}'")
                        return null
                    }
                    dc := doccomment()
                when Token.Kind.CLASS:
                    def decl := classDeclaration(dc, a)
                    if decl = null {
                        return null
                    }
                    members.add(decl)
                    dc := null
                    a := ImmutableArray<ASTNode>()
                when Token.Kind.INTERFACE:
                    def decl := interfaceDeclaration(dc, a)
                    if decl = null {
                        return null
                    }
                    members.add(decl)
                    dc := null
                    a := ImmutableArray<ASTNode>()
                when Token.Kind.CHOICE:
                    def decl := choiceDeclaration(dc, a)
                    if decl = null {
                        return null
                    }
                    members.add(decl)
                    dc := null
                    a := ImmutableArray<ASTNode>()
                when Token.Kind.METHOD, Token.Kind.FUNCTION:
                    def decl := methodDeclaration(dc, a)
                    if decl = null {
                        return null
                    }
                    members.add(decl)
                    dc := null
                    a := ImmutableArray<ASTNode>()
                when Token.Kind.VAR, Token.Kind.DEF, Token.Kind.PROPERTY, Token.Kind.CONSTANT:
                    def decl := fieldDeclaration(dc, a)
                    if decl = null {
                        return null
                    }
                    members.add(decl)
                    dc := null
                    a := ImmutableArray<ASTNode>()
                when Token.Kind.RBRACE:
                    expect(Token.Kind.RBRACE, "'}'")
                    break
                otherwise:
                    error(next, "expected a declaration, but found '\{text(next)}'")
                    self.next()
                    return null
            }
        }
        return ASTNode.CLASS(start.position, choiceDoccomment, choiceAnnotations,
                ClassDecl.Kind.CHOICE, text(name), null, null, members.finish())
    }

    ================================================================================================
    declaration = invariant | (doccomment? annotations) (classDeclaration | interfaceDeclaration |
            choiceDeclaration | methodDeclaration | initDeclaration | fieldDeclaration)
    ================================================================================================
    method declaration():ASTNode? {
        def start := peek()
        def dc:ASTNode?
        if start.kind = Token.Kind.DOC_COMMENT {
            dc := doccomment()
            if dc = null {
                return null
            }
        }
        else {
            dc := null
        }
        def a := annotations()
        if a = null {
            return null
        }
        match peek().kind {
            when Token.Kind.CLASS:
                return classDeclaration(dc, a)
            when Token.Kind.INTERFACE:
                return interfaceDeclaration(dc, a)
            when Token.Kind.CHOICE:
                return choiceDeclaration(dc, a)
            when Token.Kind.METHOD, Token.Kind.FUNCTION:
                return methodDeclaration(dc, a)
            when Token.Kind.INIT:
                return initDeclaration(dc, a)
            when Token.Kind.VAR, Token.Kind.DEF, Token.Kind.PROPERTY, Token.Kind.CONSTANT:
                return fieldDeclaration(dc, a)
            otherwise:
                -- trigger error
                expect(Token.Kind.CLASS, "a declaration")
                return null
        }
    }

    ================================================================================================
    classDeclaration = CLASS IDENTIFIER genericsDeclaration? supertypes? LBRACE declaration* RBRACE
    ================================================================================================
    method classDeclaration(doccomment:ASTNode?, annotations:ImmutableArray<ASTNode>):ASTNode? {
        def start := expect(Token.Kind.CLASS, "'class'")
        if start = null {
            return null
        }
        def name := expect(Token.Kind.IDENTIFIER, "an identifier")
        if name = null {
            return null
        }
        def generics:ImmutableArray<ASTNode>?
        if peek().kind = Token.Kind.LT {
            generics := genericsDeclaration()
            if generics = null {
                return null
            }
        }
        else {
            generics := null
        }
        def stypes:ImmutableArray<ASTNode>?
        if peek().kind = Token.Kind.COLON {
            stypes := supertypes()
            if stypes = null {
                return null
            }
        }
        else {
            stypes := null
        }
        if expect(Token.Kind.LBRACE, "'{'") = null {
            return null
        }
        def members := Array<ASTNode>()
        while checkNext(Token.Kind.RBRACE) = null {
            def member := declaration()
            if member = null {
                return null
            }
            members.add(member)
        }
        return ASTNode.CLASS(start.position, doccomment, annotations, ClassDecl.Kind.CLASS,
                text(name), generics, stypes, members.finish())
    }

    ================================================================================================
    interfaceDeclaration = INTERFACE IDENTIFIER genericsDeclaration? (COLON type (COMMA type)*)?
            LBRACE declaration* RBRACE
    ================================================================================================
    method interfaceDeclaration(doccomment:ASTNode?, annotations:ImmutableArray<ASTNode>):ASTNode? {
        def start := expect(Token.Kind.INTERFACE, "'interface'")
        if start = null {
            return null
        }
        def name := expect(Token.Kind.IDENTIFIER, "an identifier")
        if name = null {
            return null
        }
        def generics:ImmutableArray<ASTNode>?
        if peek().kind = Token.Kind.LT {
            generics := genericsDeclaration()
            if generics = null {
                return null
            }
        }
        else {
            generics := ImmutableArray<ASTNode>()
        }
        def intfs := Array<ASTNode>()
        if checkNext(Token.Kind.COLON) != null {
            var t := type()
            if t = null {
                return null
            }
            intfs.add(t)
            while checkNext(Token.Kind.COMMA) != null {
                t := type()
                if t = null {
                    return null
                }
                intfs.add(t)
            }
        }
        if expect(Token.Kind.LBRACE, "'{'") = null {
            return null
        }
        def members := Array<ASTNode>()
        while checkNext(Token.Kind.RBRACE) = null {
            def member := declaration()
            if member = null {
                return null
            }
            members.add(member)
        }
        return ASTNode.CLASS(start.position, doccomment, annotations, ClassDecl.Kind.INTERFACE,
                text(name), generics, intfs.finish(), members.finish())
    }

    ================================================================================================
    bodyEntry = usesDeclaration | packageDeclaration | statement | declaration
    ================================================================================================
    method bodyEntry():ASTNode? {
        match peek().kind {
            when Token.Kind.USES:
                return usesDeclaration()
            when Token.Kind.PACKAGE:
                return packageDeclaration()
            when Token.Kind.CLASS, Token.Kind.INTERFACE, Token.Kind.CHOICE,
                    Token.Kind.METHOD, Token.Kind.FUNCTION, Token.Kind.ANNOTATION,
                    Token.Kind.DOC_COMMENT:
                return declaration()
            otherwise:
                return statement()
        }
    }

    ================================================================================================
    file = bodyEntry*
    ================================================================================================
    method file():ASTNode? {
        def entries := Array<ASTNode>()
        while peek().kind != Token.Kind.EOF {
            def entry := bodyEntry()
            if entry = null {
                return null
            }
            assert !inSpeculative
            entries.add(entry)
        }
        return ASTNode.FILE(entries.finish())
    }
}
