package org.pandalanguage.pandac

@final
class HCodeGenerator : CodeGenerator {
    @weak
    var compiler:Compiler?

    def typeImportStream := MemoryOutputStream()

    def typesBuffer := MemoryOutputStream()

    def types := IndentedOutputStream(typesBuffer)

    def bodyImportStream := MemoryOutputStream()

    def bodyBuffer := MemoryOutputStream()

    def body := IndentedOutputStream(bodyBuffer)

    def typeImports := HashSet<String>()

    def bodyImports := HashSet<String>()

    def imports := typeImports

    def importStream := typeImportStream

    def outDir:File

    var out:IndentedOutputStream

    var typesOut:IndentedOutputStream

    def llvmCodeGen := LLVMCodeGenerator("", MemoryOutputStream())

    @weak
    def cCodeGen:CCodeGenerator

    def cCodeGenRetain:CCodeGenerator?

    init(outDir:File) {
        cCodeGenRetain := CCodeGenerator(outDir, self)
        init(outDir, cCodeGenRetain)
    }

    init(outDir:File, cCodeGen:CCodeGenerator) {
        self.outDir := outDir
        self.out := IndentedOutputStream(MemoryOutputStream())
        self.typesOut := IndentedOutputStream(MemoryOutputStream())
        self.cCodeGen := cCodeGen
    }

    function escapeName(s:String):String {
        return llvmCodeGen.escapeName(s)
    }

    function getName(m:MethodDecl):String {
        def llvmName := llvmCodeGen.getName(m)
        assert llvmName.startsWith("@")
        return llvmName[1..]
    }

    function sizeOf(t:Type):Int {
        return llvmCodeGen.sizeOf(t)
    }

    function getRelativePath(cl:ClassDecl, extension:String):String {
        return cl.name.replace(".", "/").replace("<", ".LT").replace(">", ".GT")
                .replace("?", ".Q").replace(",", ".C").replace(" ", "") + extension
    }

    method type(t:Type):String {
        match t.typeKind {
            when Type.Kind.VOID:
                return "void"
            when Type.Kind.BUILTIN_INT:
                return "int\{sizeOf(t) * 8}_t"
            when Type.Kind.BUILTIN_UINT:
                return "uint\{sizeOf(t) * 8}_t"
            when Type.Kind.BUILTIN_BIT:
                return "bool"
            when Type.Kind.BUILTIN_FLOAT:
                match sizeOf(t) {
                    when 4: return "float"
                    when 8: return "double"
                    otherwise: assert false
                }
            when Type.Kind.CLASS:
                def name := "\{escapeName(t.name)}"
                def cl := compiler.getClass(t)
                assert cl != null
                if !compiler.isValue(cl) {
                    if !imports.contains(name) {
                        importStream.printLine("typedef struct \{name} \{name};")
                        imports.add(name)
                    }
                    return name + "*"
                }
                def includePath := getRelativePath(cl, "_types.h")
                if !imports.contains(includePath) {
                    importStream.printLine("#include \"\{includePath}\"")
                    imports.add(includePath)
                }
                return name
            when Type.Kind.NULLABLE:
                def cl := compiler.getClass(t)
                assert cl != null
                if compiler.isValue(cl) {
                    return type(t.subtypes[0]) + "$nullable"
                }
                return type(t.subtypes[0])
            when Type.Kind.GENERIC:
                if t.subtypes[0].name = "panda.unsafe.Pointer" {
                    return type(t.subtypes[1]) + "*"
                }
                def cl := compiler.getClass(t)
                if cl.isSpecialization() {
                    def name := "\{escapeName(t.name)}"
                    def cl := compiler.getClass(t)
                    assert cl != null
                    if !compiler.isValue(cl) {
                        if !imports.contains(name) {
                            importStream.printLine("typedef struct \{name} \{name};")
                            imports.add(name)
                        }
                        return name + "*"
                    }
                    def includePath := getRelativePath(cl, ".h")
                    if !imports.contains(includePath) {
                        importStream.printLine("#include \"\{includePath}\"")
                        imports.add(includePath)
                    }
                    return name
                }
                return type(t.subtypes[0])
            when Type.Kind.GENERIC_PARAMETER:
                return type(t.parameter.bound)
            when Type.Kind.FUNCTION, Type.Kind.METHOD:
                return type(Type.MutableMethod())
            when Type.Kind.IMMUTABLE_FUNCTION, Type.Kind.IMMUTABLE_METHOD:
                return type(Type.Method())
            otherwise:
                assert false, "unsupported type '\{t}'"
        }
    }

    method declaration(t:Type, name:String):String {
        return "\{type(t)} \{name}"
    }

    @override
    method setCompiler(compiler:Compiler) {
        self.compiler := compiler
        llvmCodeGen.setCompiler(compiler)
    }

    function getPath(cl:ClassDecl, extension:String):File {
        return outDir.resolve(getRelativePath(cl, extension))
    }

    @override
    method start(cl:ClassDecl) {
        typeImportStream.clear()
        typesBuffer.clear()
        bodyImportStream.clear()
        bodyBuffer.clear()
        typeImports.clear()
        bodyImports.clear()
        def path := getPath(cl, ".h")
        path.parent().createDirectories()
        self.out := IndentedOutputStream(path.openOutputStream())
        def typesPath := getPath(cl, "_types.h")
        self.typesOut := IndentedOutputStream(typesPath.openOutputStream())
        out.printLine("#pragma once")
        out.printLine("#include \"panda_c.h\"")
        out.printLine("#include \"\{typesPath.name()}\"")
        typesOut.printLine("#pragma once")
        typesOut.printLine("#include \"panda_c.h\"")
        importStream := typeImportStream
        imports := typeImports
        types.printLine("typedef struct \{escapeName(cl.name)} {")
        types.level += 1
        for f in compiler.instanceFields(cl) {
            compiler.resolve(f)
            if f.type = Type.ChoiceData() {
                types.printLine("int8_t \{f.name}[\{llvmCodeGen.getChoiceDataSize(cl)}];")
            }
            else {
                types.printLine("\{type(f.type)} \{f.name};")
            }
        }
        if cl.name = "panda.core.Class" {
            types.printLine("ITable* itable;")
            types.printLine("void* vtable[];")
        }
        types.level -= 1
        types.printLine("} \{escapeName(cl.name)};")
        types.printLine("#include \"panda/core/Class.h\"")
        types.printLine("typedef struct { panda$core$Class* cl; int32_t refCount; " +
                "\{type(Type.StringType())} name; \{type(Type.Class())} super; ITable* itable; " +
                "void* vtable[\{compiler.getVTable(cl).count}]; } " +
                "\{escapeName(cl.name)}$class_type;")
        types.printLine("extern \{escapeName(cl.name)}$class_type \{escapeName(cl.name)}$class;")
        if compiler.isValue(cl) {
            types.printLine("typedef struct \{escapeName(cl.name)}$wrapper {")
            types.level += 1
            types.printLine("panda$core$Class* cl;")
            types.printLine("int32_t refCount;")
            types.printLine("\{type(cl.type())} value;")
            types.level -= 1
            types.printLine("} \{escapeName(cl.name)}$wrapper;")
            types.printLine("typedef struct \{escapeName(cl.name)}$nullable {")
            types.level += 1
            types.printLine("\{escapeName(cl.name)} value;")
            types.printLine("bool nonnull;")
            types.level -= 1
            types.printLine("} \{escapeName(cl.name)}$nullable;")
            def value := compiler.getClass(Type.Value())
            def valueVTable := compiler.getVTable(value)
            types.printLine("typedef struct { panda$core$Class* cl; int32_t refCount; " +
                    "panda$core$String* name; panda$core$Class* super; ITable* itable; " +
                    "void* vtable[\{valueVTable.count}]; } " +
                    "\{escapeName(cl.name)}$wrapperclass_type;")
            types.printLine("extern \{escapeName(cl.name)}$wrapperclass_type " +
                    "\{escapeName(cl.name)}$wrapperclass;")
        }
    }

    method selfType(m:MethodDecl):String {
        def result := type(m.owner.type())
        if m.methodKind = MethodDecl.Kind.INIT & !result.endsWith("*") {
            return result + "*"
        }
        return result
    }

    ================================================================================================
    Returns true if this is an external method returning a struct.

    Returning structs from C functions into LLVM code is tricky. I tried it the naive and obvious
    way, and found it didn't work. Some cursory research indicated that C functions that return
    structs are at least sometimes compiled to accept a special pointer ("sret") as an extra
    parameter, and the caller is expected to know to alloca space for the return value and pass in a
    pointer to it.

    Since online sources were complaining about how poorly documented this is, there were
    indications that there may be multiple struct return strategies depending on the nature of
    the struct, people were suggesting looking at the assembly code generated by Clang to figure
    out how one was supposed to call a given function, and this all varies from platform to
    platform, we avoid the whole mess by making it explicit. External functions which wish to
    return structs explicitly receive a pointer to the result structure as their first parameter.
    ================================================================================================
    function needsStructIndirection(m:MethodDecl):Bit {
        if !m.returnType.isClass() {
            return false
        }
        def result := m.annotations.isExternal() & m.returnType.isClass() &
                compiler.isValue(compiler.getClass(m.returnType))
        -- if an external method requires struct indirection, it will have a different signature
        -- than a non-external method; this means this feature doesn't play nice with overriding. We
        -- can fix this down the road with shims, but for right now just assert that a method
        -- requiring struct indirection is not an override and cannot be overridden
        assert !result | (!m.annotations.isOverride() & (m.annotations.isFinal() |
                m.annotations.isClass())), "invalid struct indirection on \{m.signature()}"
        return result
    }

    @override
    method writeDeclaration(m:MethodDecl) {
        importStream := bodyImportStream
        imports := bodyImports
        var separator := ""
        if needsStructIndirection(m) {
            body.print("void \{getName(m)}(\{type(m.returnType)}* result")
            separator := ", "
        }
        else {
            body.print("\{type(m.returnType)} \{getName(m)}(")
        }
        if !m.annotations.isClass() {
            body.print("\{separator}\{selfType(m)} self")
            separator := ", "
        }
        for p in m.parameters {
            def name := "p_\{escapeName(p.name)}"
            body.print("\{separator}\{declaration(p.type, name)}")
            separator := ", "
        }
        body.printLine(");")
    }

    @override
    method write(m:MethodDecl, ir:IR) {
        writeDeclaration(m)
    }

    @override
    method end(cl:ClassDecl) {
        typesOut.printLine(typeImportStream.finish())
        typesOut.printLine(typesBuffer.finish())
        out.printLine(bodyImportStream.finish())
        out.printLine(bodyBuffer.finish())
    }

    @override
    method finish() {
    }
}