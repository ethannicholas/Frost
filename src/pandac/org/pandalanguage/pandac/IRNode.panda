package org.pandalanguage.pandac

uses org.pandalanguage.pandac.parser.Token

class IRNode : Immutable {
    class Kind {
        constant BLOCK                       := 1000
        constant TYPE_REFERENCE              := 1001
        constant METHOD_REFERENCE            := 1002
        constant UNRESOLVED_METHOD_REFERENCE := 1003
        constant INT                         := 1004
        constant CALL                        := 1005
        constant BREAK                       := 1006
        constant CONTINUE                    := 1007
        constant RETURN                      := 1008
        constant CAST                        := 1009
        constant CONSTRUCT                   := 1010
        constant BIT                         := 1011
        constant IF                          := 1012
        constant WHILE                       := 1013
        constant DO                          := 1014
        constant LOOP                        := 1015
        constant VARIABLE_REFERENCE          := 1016
        constant VAR                         := 1017
        constant DEF                         := 1018
        constant CONSTANT                    := 1019
        constant PROPERTY                    := 1020
        constant DECLARATION                 := 1021
        constant TUPLE_TARGET                := 1022
        constant BINARY                      := 1023
        constant SUPER                       := 1024
        constant SELF                        := 1025
        constant FIELD_REFERENCE             := 1026
        constant REUSED_VALUE_DEFINITION     := 1027
        constant REUSED_VALUE                := 1028
        constant RANGE_FOR                   := 1029
        constant NULL_LITERAL                := 1030
        constant UNRESOLVED_RANGE            := 1031
        constant NEGATED_INT                 := 1032
    }

    def kind:Int

    def offset:Int

    def payload:Object?

    def type:Type

    def children:ImmutableArray<IRNode>

    init(kind:Int, offset:Int) {
        init(kind, offset, Type.Void(), null, Array<IRNode>())
    }

    init(kind:Int, offset:Int, payload:UInt64) {
        init(kind, offset, Type.Void(), payload, Array<IRNode>())
    }

    init(kind:Int, offset:Int, payload:String) {
        init(kind, offset, Type.Void(), payload, Array<IRNode>())
    }

    init(kind:Int, offset:Int, payload:Bit) {
        init(kind, offset, Type.Void(), payload, Array<IRNode>())
    }

    init(kind:Int, offset:Int, children:ListView<IRNode>) {
        init(kind, offset, Type.Void(), null, children)
    }

    init(kind:Int, offset:Int, payload:Object?, children:ListView<IRNode>) {
        init(kind, offset, Type.Void(), payload, children)
    }

    init(kind:Int, offset:Int, type:Type) {
        init(kind, offset, type, null, Array<IRNode>())
    }

    init(kind:Int, offset:Int, type:Type, payload:UInt64) {
        init(kind, offset, type, payload, Array<IRNode>())
    }

    init(kind:Int, offset:Int, type:Type, payload:String) {
        init(kind, offset, type, payload, Array<IRNode>())
    }

    init(kind:Int, offset:Int, type:Type, payload:Bit) {
        init(kind, offset, type, payload, Array<IRNode>())
    }

    init(kind:Int, offset:Int, type:Type, payload:Type) {
        init(kind, offset, type, payload, Array<IRNode>())
    }

    init(kind:Int, offset:Int, type:Type, payload:Variable) {
        init(kind, offset, type, payload, Array<IRNode>())
    }

    init(kind:Int, offset:Int, type:Type, children:ListView<IRNode>) {
        init(kind, offset, type, null, children)
    }

    init(kind:Int, offset:Int, type:Type, payload:Object?, children:ListView<IRNode>) {
        self.kind := kind
        self.offset := offset
        self.type := type
        self.payload := payload
        self.children := ImmutableArray<IRNode>(children)
        assert kind != Kind.CAST | children[0].type != Type.IntLiteral()
    }

    @override
    function convert():String {
        match kind {
            when Kind.BLOCK:
                def result := MutableString("{\n")
                for child in children {
                    def c := child.convert()
                    if c.startsWith("(") & c.endsWith(")") {
                        result.append(c[c.next(c.start()) .. c.previous(c.end())])
                    }
                    else {
                        result.append(child)
                    }
                    result.append("\n")
                }
                result.append("}")
                return result.convert()
            when Kind.METHOD_REFERENCE:
                return "\{children[0]}.\{(payload->MethodRef).value.name}" -- FIXME parens
            when Kind.UNRESOLVED_METHOD_REFERENCE:
                return "\{children[0]}.\{(payload->ListView<MethodRef>)[0].value.name}" -- FIXME parens
            when Kind.TYPE_REFERENCE:
                return payload.convert()
            when Kind.INT:
                return payload.convert()
            when Kind.BIT:
                return payload.convert()
            when Kind.CONSTRUCT:
                return "\{type}(\{children[0].children.join(", ")})"
            when Kind.CAST:
                return "\{children[0]}->\{type}"
            when Kind.VARIABLE_REFERENCE:
                return "\{payload->Variable}"
            otherwise:
                return "<IRNode:\{kind}>"
        }
    }
}