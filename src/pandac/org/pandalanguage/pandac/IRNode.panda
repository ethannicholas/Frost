package org.pandalanguage.pandac

uses org.pandalanguage.pandac.parser.Token

@final
class IRNode {
    class Kind {
        constant BLOCK                       := 1000
        constant TYPE_REFERENCE              := 1001
        constant METHOD_REFERENCE            := 1002
        constant UNRESOLVED_METHOD_REFERENCE := 1003
        constant INT                         := 1004
        constant CALL                        := 1005
        constant BREAK                       := 1006
        constant CONTINUE                    := 1007
        constant RETURN                      := 1008
        constant CAST                        := 1009
        constant CONSTRUCT                   := 1010
        constant BIT                         := 1011
        constant IF                          := 1012
        constant WHILE                       := 1013
        constant DO                          := 1014
        constant LOOP                        := 1015
        constant VARIABLE_REFERENCE          := 1016
        constant VAR                         := 1017
        constant DEF                         := 1018
        constant CONSTANT                    := 1019
        constant PROPERTY                    := 1020
        constant DECLARATION                 := 1021
        constant TUPLE_TARGET                := 1022
        constant BINARY                      := 1023
        constant SUPER                       := 1024
        constant SELF                        := 1025
        constant FIELD_REFERENCE             := 1026
        constant REUSED_VALUE_DEFINITION     := 1027
        constant REUSED_VALUE                := 1028
        constant RANGE_FOR                   := 1029
        constant NULL                        := 1030
        constant UNRESOLVED_RANGE            := 1031
        constant NEGATED_INT                 := 1032
        constant STRING                      := 1033
        constant ASSERT                      := 1034
        constant IS_NULL                     := 1035
        constant IS_NONNULL                  := 1036
        constant UNRESOLVED_IDENTIFIER       := 1037
        -- target used for init calls during object construction, meaning "the object that was just
        -- constructed"
        constant CONSTRUCTED_OBJECT          := 1038
        constant UNRESOLVED_METHOD_CALL      := 1039
        -- index expressions (foo[bar]) always start out unresolved, because of indexed assignment.
        -- For instance, a given object might define a "[]:=" method but not a "[]" function, or the
        -- index types could be different between "[]" and "[]:=". Holding off on resolution allows
        -- us to handle cases like this.
        constant UNRESOLVED_INDEX            := 1040
        constant PREFIX                      := 1041
        -- [value, when0, when1...]
        constant MATCH                       := 1042
        -- [value0, value1, ..., block]
        constant WHEN                        := 1042
        constant OTHERWISE                   := 1043
    }

    def kind:Int

    def position:Position

    def payload:Object?

    def type:Type

    def children:Array<IRNode>

    init(kind:Int, position:Position) {
        init(kind, position, Type.Void(), null, Array<IRNode>())
    }

    init(kind:Int, position:Position, payload:UInt64) {
        init(kind, position, Type.Void(), payload, Array<IRNode>())
    }

    init(kind:Int, position:Position, payload:String) {
        init(kind, position, Type.Void(), payload, Array<IRNode>())
    }

    init(kind:Int, position:Position, payload:Bit) {
        init(kind, position, Type.Void(), payload, Array<IRNode>())
    }

    init(kind:Int, position:Position, children:ListView<IRNode>) {
        init(kind, position, Type.Void(), null, children)
    }

    init(kind:Int, position:Position, payload:Object?, children:ListView<IRNode>) {
        init(kind, position, Type.Void(), payload, children)
    }

    init(kind:Int, position:Position, type:Type) {
        init(kind, position, type, null, Array<IRNode>())
    }

    init(kind:Int, position:Position, type:Type, payload:UInt64) {
        init(kind, position, type, payload, Array<IRNode>())
    }

    init(kind:Int, position:Position, type:Type, payload:String) {
        init(kind, position, type, payload, Array<IRNode>())
    }

    init(kind:Int, position:Position, type:Type, payload:Bit) {
        init(kind, position, type, payload, Array<IRNode>())
    }

    init(kind:Int, position:Position, type:Type, payload:Type) {
        init(kind, position, type, payload, Array<IRNode>())
    }

    init(kind:Int, position:Position, type:Type, payload:Variable) {
        init(kind, position, type, payload, Array<IRNode>())
    }

    init(kind:Int, position:Position, type:Type, children:ListView<IRNode>) {
        init(kind, position, type, null, children)
    }

    init(kind:Int, position:Position, type:Type, payload:Object?, children:ListView<IRNode>) {
        self.kind := kind
        self.position := position
        self.type := type
        self.payload := payload
        self.children := Array<IRNode>(children)
        assert type.resolved
        assert kind != Kind.TYPE_REFERENCE | (payload != null & (payload->Type).resolved)
    }

    @override
    function convert():String {
        match kind {
            when Kind.BLOCK:
                def result := MutableString("{\n")
                for child in children {
                    def c := child.convert()
                    if c.startsWith("(") & c.endsWith(")") {
                        result.append(c[c.next(c.start()) .. c.previous(c.end())])
                    }
                    else {
                        result.append(child)
                    }
                    result.append("\n")
                }
                result.append("}")
                return result.finish()
            when Kind.METHOD_REFERENCE:
                if children.get_count() > 0 {
                    return "\{children[0]}.\{(payload->MethodRef).value.name}" -- FIXME parens
                }
                return (payload->MethodRef).value.name -- FIXME parens
            when Kind.UNRESOLVED_METHOD_REFERENCE:
                if children.get_count() = 1 {
                    return "\{children[0]}.\{(payload->ListView<MethodRef>)[0].value.name}" -- FIXME parens
                }
                assert children.get_count() = 0
                return (payload->ListView<MethodRef>)[0].value.name -- FIXME parens
            when Kind.TYPE_REFERENCE:
                return payload.convert()
            when Kind.INT:
                return payload.convert()
            when Kind.NEGATED_INT:
                return "-" + payload.convert()
            when Kind.BIT:
                return payload.convert()
            when Kind.CONSTRUCT:
                return "\{type}(\{children[0].children.join(", ")})"
            when Kind.CONSTRUCTED_OBJECT:
                return "-* constructed object: \{type} *-"
            when Kind.CALL:
                return "\{(payload->MethodRef).value.name}(\{children.join(", ")})" -- FIXME parens
            when Kind.CAST:
                return "(\{children[0]}->\{type})"
            when Kind.VARIABLE_REFERENCE:
                return "\{payload->Variable}"
            when Kind.BINARY:
                return "(\{children[0]} \{Compiler.operatorName(payload->Int)} \{children[1]})"
            when Kind.SELF:
                return "self"
            when Kind.REUSED_VALUE_DEFINITION:
                return "\{children[0]}-* ReusedValueDefinition: \{payload} *-"
            when Kind.REUSED_VALUE:
                return "-* ReusedValue: \{payload} *-"
            when Kind.FIELD_REFERENCE:
                return "\{children[0]}.\{(payload->FieldDecl).name}" -- FIXME parens
            when Kind.NULL:
                return "null"
            when Kind.DECLARATION:
                if children.get_count() = 1 {
                    return children[0].convert()
                }
                return "\{children[0]} := \{children[1]}"
            when Kind.DEF:
                return "def \{children.join(", ")}"
            when Kind.VAR:
                return "var \{children.join(", ")}"
            when Kind.RETURN:
                return "return \{children.join()}"
            when Kind.UNRESOLVED_RANGE:
                def result := MutableString("unresolved_range<")
                if children[0].kind != IRNode.Kind.NULL {
                    result.append(children[0])
                }
                if payload->Bit {
                    result.append("...")
                }
                else {
                    result.append("..")
                }
                if children[1].kind != IRNode.Kind.NULL {
                    result.append(children[1])
                }
                if children.get_count() > 2 {
                    result.append(" by ")
                    result.append(children[2])
                }
                result.append(">")
                return result.finish()
            when Kind.STRING:
                return "\"\{payload}\""
            otherwise:
                return "<IRNode:\{kind}>"
        }
    }
}