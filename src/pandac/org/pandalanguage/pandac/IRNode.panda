package org.pandalanguage.pandac

uses org.pandalanguage.pandac.parser.Token

choice IRNode {
    ASSERT(Position, IRNode, IRNode?)
    BINARY(Position, Type, IRNode, Token.Kind, IRNode)
    BIT(Position, Type, Bit)
    BLOCK(Position, ImmutableArray<IRNode>)
    BREAK(Position, String?)
    CALL(Position, Type, MethodRef, ImmutableArray<IRNode>)
    CAST(Position, IRNode, Type, Bit -* explicit *-)
    -- a choice entry, like IRNode.Kind.STRING
    CHOICE_ENTRY_REFERENCE(Position, ChoiceEntry)
    -- a field of a choice entry, like IRNode.Kind.STRING[0]
    CHOICE_FIELD_REFERENCE(Position, IRNode, ChoiceEntry, Int)
    CONSTRUCT(Position, Type, IRNode)
    -- target used for init calls during object construction, meaning "the object that was just
    -- constructed"
    CONSTRUCTED_OBJECT(Position, Type)
    CONTINUE(Position, String?)
    DECLARATION(IRNode -* target *-, IRNode? -* value *-)
    DO(Position, String?, ImmutableArray<IRNode>, IRNode)
    -- evaluates to the expression, but executes the extraEffectsStatement after the current
    -- statement
    EXPRESSION_WITH_EXTRA_EFFECTS(IRNode -* expression *-, IRNode -* extraEffectStatement *-)
    FIELD_REFERENCE(Position, Type, IRNode -* base *-, FieldDecl)
    IF(Position, IRNode, ImmutableArray<IRNode>, IRNode?)
    INT(Position, Type, UInt64)
    IS_NONNULL(Position, IRNode)
    IS_NULL(Position, IRNode)
    LOOP(Position, String?, ImmutableArray<IRNode>)
    MATCH(Position, IRNode -* value *-, ImmutableArray<IRNode> -* whens *-,
            ImmutableArray<IRNode>? -* otherwise statements *-)
    METHOD_REFERENCE(Position, IRNode? -* target *-, MethodRef)
    NEGATED_INT(Position, Type, UInt64)
    NULL(Position, Type)
    PREFIX(Position, Token.Kind, IRNode)
    RANGE_FOR(Position, String, IRNode -* target *-, IRNode -* list *-, ImmutableArray<IRNode>)
    REAL(Position, Type, Real64)
    RETURN(Position, IRNode?)
    REUSED_VALUE(Position, Type, Int -* id *-)
    REUSED_VALUE_DEFINITION(IRNode, Int -* id *-)
    SELF(Position, Type)
    STRING(Position, String)
    SUPER(Position, Type)
    -- C-style ternary expression. Not supported in Panda source code, but used internally.
    TERNARY(Position, IRNode, IRNode, IRNode)
    TYPE_REFERENCE(Position, Type)
    UNRESOLVED_IDENTIFIER(Position, String)
    -- index expressions (foo[bar]) always start out unresolved, because of indexed assignment. For
    -- instance, a given object might define a "[]:=" method but not a "[]" function, or the index
    -- types could be different between "[]" and "[]:=". Holding off on resolution allows us to
    -- handle cases like this.
    UNRESOLVED_INDEX(Position, Type, IRNode -* base *-, ImmutableArray<IRNode> -* args *-)
    UNRESOLVED_METHOD_CALL(Position, Type, IRNode -* target *-, ImmutableArray<MethodRef>,
            ImmutableArray<IRNode> -* args *-)
    UNRESOLVED_METHOD_REFERENCE(Position, IRNode -* target *-, ImmutableArray<MethodRef>)
    UNRESOLVED_RANGE(Position, IRNode -* start *-, IRNode -* end *-, Bit, IRNode -* step *-)
    VAR(Position, Variable.Kind, ImmutableArray<IRNode> -* DECLARATIONs *-)
    VARIABLE_REFERENCE(Position, Variable)
    WHEN(Position, ImmutableArray<IRNode> -* tests *-, ImmutableArray<IRNode> -* statements *-)
    WHILE(Position, String?, IRNode, ImmutableArray<IRNode>)

    function type():Type {
        match self {
            when BINARY(_, type, _, _, _):
                return type
            when BIT(_, type, _):
                return type
            when CALL(_, type, _, _):
                return type
            when CAST(_, _, type, _):
                return type
            when CHOICE_ENTRY_REFERENCE(_, ce):
                return Type.Invalid()
            when CHOICE_FIELD_REFERENCE(_, _, ce, field):
                return ce.fields[field]
            when CONSTRUCT(_, type, _):
                return type
            when CONSTRUCTED_OBJECT(_, type):
                return type
            when EXPRESSION_WITH_EXTRA_EFFECTS(expr, _):
                return expr.type()
            when FIELD_REFERENCE(_, type, _, _):
                return type
            when INT(_, type, _):
                return type
            when IS_NONNULL:
                return Type.Bit()
            when IS_NULL:
                return Type.Bit()
            when METHOD_REFERENCE(_, ref, _):
                return Type("<method>", Type.Kind.INVALID, Position(), true)
            when NEGATED_INT(_, type, _):
                return type
            when NULL(_, type):
                return type
            when PREFIX(_, _, base):
                return base.type()
            when REAL(_, type, _):
                return type
            when REUSED_VALUE(_, type, id):
                return type
            when REUSED_VALUE_DEFINITION(base, _):
                return base.type()
            when SELF(_, type):
                return type
            when STRING:
                return Type.StringType()
            when SUPER(_, type):
                return type
            when TERNARY(_, _, ifTrue, ifFalse):
                assert ifTrue.type() = ifFalse.type()
                return ifTrue.type()
            when TYPE_REFERENCE:
                return Type.Class()
            when UNRESOLVED_IDENTIFIER:
                return Type.Invalid()
            when UNRESOLVED_INDEX(_, type, _, _):
                return type
            when UNRESOLVED_METHOD_CALL(_, type, _, _, _):
                return type
            when UNRESOLVED_METHOD_REFERENCE:
                return Type.Invalid()
            when UNRESOLVED_RANGE:
                return Type.Invalid()
            when VARIABLE_REFERENCE(_, variable):
                return variable.type
            otherwise:
                assert false
        }
    }

    function position():Position {
        match self {
            when ASSERT(position, _, _):
                return position
            when BINARY(position, _, _, _, _):
                return position
            when BIT(position, _, _):
                return position
            when BLOCK(position, _):
                return position
            when BREAK(position, _):
                return position
            when CALL(position, _, _, _):
                return position
            when CAST(position, _, _, _):
                return position
            when CHOICE_ENTRY_REFERENCE(position, _):
                return position
            when CHOICE_FIELD_REFERENCE(position, _, _, _):
                return position
            when CONSTRUCT(position, _, _):
                return position
            when CONSTRUCTED_OBJECT(position, _):
                return position
            when CONTINUE(position, _):
                return position
            when DECLARATION(target, _):
                return target.position()
            when DO(position, _, _, _):
                return position
            when EXPRESSION_WITH_EXTRA_EFFECTS(expr, _):
                return expr.position()
            when FIELD_REFERENCE(position, _, _, _):
                return position
            when IF(position, _, _, _):
                return position
            when INT(position, _, _):
                return position
            when IS_NONNULL(position, _):
                return position
            when IS_NULL(position, _):
                return position
            when LOOP(position, _, _):
                return position
            when MATCH(position, _, _, _):
                return position
            when METHOD_REFERENCE(position, _, _):
                return position
            when NEGATED_INT(position, _, _):
                return position
            when NULL(position, _):
                return position
            when PREFIX(position, _, _):
                return position
            when RANGE_FOR(position, _, _, _, _):
                return position
            when REAL(position, _, _):
                return position
            when RETURN(position, _):
                return position
            when REUSED_VALUE(position, _, _):
                return position
            when REUSED_VALUE_DEFINITION(base, _):
                return base.position()
            when SELF(position, _):
                return position
            when STRING(position, _):
                return position
            when SUPER(position, _):
                return position
            when TERNARY(position, _, _, _):
                return position
            when TYPE_REFERENCE(position, _):
                return position
            when UNRESOLVED_IDENTIFIER(position, _):
                return position
            when UNRESOLVED_INDEX(position, _, _, _):
                return position
            when UNRESOLVED_METHOD_CALL(position, _, _, _, _):
                return position
            when UNRESOLVED_METHOD_REFERENCE(position, _, _):
                return position
            when UNRESOLVED_RANGE(position, _, _, _, _):
                return position
            when VAR(position, _, _):
                return position
            when VARIABLE_REFERENCE(position, _):
                return position
            when WHEN(position, _, _):
                return position
            when WHILE(position, _, _, _):
                return position
            otherwise:
                assert false
        }
    }

    function hasSideEffects():Bit {
        match self {
            when ASSERT(_, test, msg):
                return test.hasSideEffects() | msg.hasSideEffects()
            when BINARY(_, _, left, op, right):
                return Compiler.isAssignment(op) | left.hasSideEffects() | right.hasSideEffects()
            when BIT(_, _, bit):
                return false
            when BLOCK(_, statements):
                for s in statements {
                    if s.hasSideEffects() {
                        return true
                    }
                }
                return false
            when BREAK(_, label):
                return false
            when CALL(_, _, m, args):
                if m.value.methodKind = MethodDecl.Kind.METHOD {
                    return true
                }
                for arg in args {
                    if arg.hasSideEffects() {
                        return true
                    }
                }
                return false
            when CAST(_, value, type, _):
                return false
            when CHOICE_ENTRY_REFERENCE(_, ce):
                return false
            when CHOICE_FIELD_REFERENCE(_, base, ce, field):
                return false
            when CONSTRUCT(_, type, call):
                return call.hasSideEffects()
            when CONSTRUCTED_OBJECT(_, Type):
                return false
            when CONTINUE(_, label):
                return false
            when DECLARATION(target, value):
                return value != null & value.hasSideEffects()
            when DO(_, label, statements, test):
                if test.hasSideEffects() {
                    return true
                }
                for s in statements {
                    if s.hasSideEffects() {
                        return true
                    }
                }
                return false
            when EXPRESSION_WITH_EXTRA_EFFECTS:
                return true
            when FIELD_REFERENCE(_, _, base, field):
                return false
            when IF(_, test, ifTrue, ifFalse):
                if test.hasSideEffects() {
                    return true
                }
                for s in ifTrue {
                    if s.hasSideEffects() {
                        return true
                    }
                }
                return ifFalse.hasSideEffects()
            when INT(_, _, value):
                return false
            when IS_NONNULL(_, value):
                return value.hasSideEffects()
            when IS_NULL(_, value):
                return value.hasSideEffects()
            when LOOP(_, label, statements):
                for s in statements {
                    if s.hasSideEffects() {
                        return true
                    }
                }
                return false
            when MATCH(_, value, whens, other):
                if value.hasSideEffects() {
                    return true
                }
                for w in whens {
                    if w.hasSideEffects() {
                        return true
                    }
                }
                for s in other {
                    if s.hasSideEffects() {
                        return true
                    }
                }
                return false

            when METHOD_REFERENCE(_, target, m):
                return false
            when NEGATED_INT(_, _, value):
                return false
            when NULL:
                return false
            when PREFIX(_, op, base):
                return base.hasSideEffects()
            when RANGE_FOR(_, label, target, list, statements):
                if list.hasSideEffects() {
                    return true
                }
                for s in statements {
                    if s.hasSideEffects() {
                        return true
                    }
                }
                return false
            when REAL(_, _, value):
                return false
            when RETURN(_, value):
                return value.hasSideEffects()
            when REUSED_VALUE(_, _, id):
                return false
            when REUSED_VALUE_DEFINITION(base, id):
                return base.hasSideEffects()
            when SELF:
                return false
            when STRING(_, str):
                return false
            when SUPER:
                return false
            when TERNARY(_, test, ifTrue, ifFalse):
                return test.hasSideEffects() | ifTrue.hasSideEffects() | ifFalse.hasSideEffects()
            when TYPE_REFERENCE(_, type):
                return false
            when UNRESOLVED_IDENTIFIER(_, name):
                assert false
            when UNRESOLVED_INDEX(_, _, base, args):
                assert false
            when UNRESOLVED_METHOD_CALL(_, _, target, methods, args):
                assert false
            when UNRESOLVED_METHOD_REFERENCE(_, target, methods):
                assert false
            when UNRESOLVED_RANGE(_, start, end, inclusive, step):
                assert false
            when VAR(_, kind, decls):
                for d in decls {
                    if d.hasSideEffects() {
                        return true
                    }
                }
                return false
            when VARIABLE_REFERENCE(_, variable):
                return false
            when WHEN(_, tests, statements):
                for t in tests {
                    if t.hasSideEffects() {
                        return true
                    }
                }
                for s in statements {
                    if s.hasSideEffects() {
                        return true
                    }
                }
                return false
            when WHILE(_, label, test, statements):
                if test.hasSideEffects() {
                    return true
                }
                for s in statements {
                    if s.hasSideEffects() {
                        return true
                    }
                }
                return false
            otherwise:
                assert false
        }
    }

    @override
    function convert():String {
        match self {
            when ASSERT(_, test, msg):
                if msg != null {
                    return "assert \{test}, \{msg}"
                }
                return "assert \{test}"
            when BINARY(_, _, left, op, right):
                return "\{left} \{op} \{right}"
            when BIT(_, _, bit):
                return bit.convert()
            when BLOCK(_, statements):
                def result := MutableString("{\n")
                for s in statements {
                    result.append(s + "\n")
                }
                result.append("}")
                return result.finish()
            when BREAK(_, label):
                if label != null {
                    return "break \{label}"
                }
                return "break"
            when CALL(_, _, m, args):
                return "\{m.value.name}(\{args.join()})"
            when CAST(_, value, type, _):
                return "\{value}->\{type}"
            when CHOICE_ENTRY_REFERENCE(_, ce):
                return ce.convert()
            when CHOICE_FIELD_REFERENCE(_, base, ce, field):
                return "\{base}.\{ce}[\{field}]"
            when CONSTRUCT(_, type, call):
                match call {
                    when CALL(_, _, _, args):
                        return "\{type}(\{args.join()})"
                    otherwise:
                        assert false
                }
            when CONSTRUCTED_OBJECT(_, Type):
                return "-* constructed object *-"
            when CONTINUE(_, label):
                if label != null {
                    return "continue \{label}"
                }
                return "continue"
            when DECLARATION(target, value):
                if value != null {
                    return "\{target} := \{value}"
                }
                return target.convert()
            when DO(_, label, statements, test):
                def result := MutableString()
                if label != null {
                    result.append("\{label}: ")
                }
                result.append("do {\n")
                for s in statements {
                    result.append(s + "\n")
                }
                result.append("} while \{test}")
                return result.finish()
            when EXPRESSION_WITH_EXTRA_EFFECTS(expr, stmt):
                return "\{expr} -* and then: \{stmt} *-"
            when FIELD_REFERENCE(_, _, base, field):
                return "\{base}.\{field.name}"
            when IF(_, test, ifTrue, ifFalse):
                def result := MutableString("if \{test} {")
                for s in ifTrue {
                    result.append(s + "\n")
                }
                result.append("}")
                if ifFalse != null {
                    result.append("\nelse \{ifFalse}")
                }
                return result.finish()
            when INT(_, _, value):
                return value.convert()
            when IS_NONNULL(_, value):
                return "(\{value} != null)"
            when IS_NULL(_, value):
                return "(\{value} = null)"
            when LOOP(_, label, statements):
                def result := MutableString()
                if label != null {
                    result.append("\{label}: ")
                }
                result.append("loop {\n")
                for s in statements {
                    result.append(s + "\n")
                }
                result.append("}")
                return result.finish()
            when MATCH(_, value, whens, other):
                def result := MutableString("match \{value} {\n")
                for w in whens {
                    result.append(w + "\n")
                }
                if other != null {
                    result.append("otherwise:\n")
                    for s in other {
                        result.append(s + "\n")
                    }
                }
                result.append("}")
                return result.finish()
            when METHOD_REFERENCE(_, target, m):
                if target != null {
                    return "\{target}.\{m.value.name}"
                }
                return m.value.name
            when NEGATED_INT(_, _, value):
                return "-" + value
            when NULL:
                return "null"
            when PREFIX(_, op, base):
                return "\{op}\{base}"
            when RANGE_FOR(_, label, target, list, statements):
                def result := MutableString()
                if label != null {
                    result.append("\{label}: ")
                }
                result.append("for \{target} in \{list} {\n")
                for s in statements {
                    result.append(s + "\n")
                }
                result.append("}")
                return result.finish()
            when REAL(_, _, value):
                return value.convert()
            when RETURN(_, value):
                if value != null {
                    return "return \{value}"
                }
                return "return"
            when REUSED_VALUE(_, type, id):
                return "-* reused value: \{id}:\{type} *-"
            when REUSED_VALUE_DEFINITION(base, id):
                return "-* reused value definition: \{id} := \{base} *-"
            when SELF:
                return "self"
            when STRING(_, str):
                return str
            when SUPER:
                return "super"
            when TERNARY(_, test, ifTrue, ifFalse):
                return "(\{test} ? \{ifTrue} : \{ifFalse})"
            when TYPE_REFERENCE(_, type):
                return type.convert()
            when UNRESOLVED_IDENTIFIER(_, name):
                return name
            when UNRESOLVED_INDEX(_, _, base, args):
                return "\{base}[\{args.join()}]"
            when UNRESOLVED_METHOD_CALL(_, _, target, methods, args):
                return "\{target}.\{methods[0].value.name}(\{args.join()})"
            when UNRESOLVED_METHOD_REFERENCE(_, target, methods):
                return "\{target}.\{methods[0].value.name}"
            when UNRESOLVED_RANGE(_, start, end, inclusive, step):
                def result := MutableString()
                if start != null {
                    result.append(start)
                }
                if inclusive {
                    result.append("...")
                }
                else {
                    result.append("..")
                }
                if end != null {
                    result.append(end)
                }
                if step != null {
                    result.append(" by \{step}")
                }
                return result.finish()
            when VAR(_, kind, decls):
                def result := MutableString()
                match kind {
                    when Variable.Kind.VAR:      result.append("var ")
                    when Variable.Kind.DEF:      result.append("def ")
                    when Variable.Kind.CONSTANT: result.append("constant ")
                    when Variable.Kind.PROPERTY: result.append("property ")
                }
                result.append(decls.join())
                return result.finish()
            when VARIABLE_REFERENCE(_, variable):
                return variable.name
            when WHEN(_, tests, statements):
                return "when \{tests.join()}:\n\{statements.join("\n")}"
            when WHILE(_, label, test, statements):
                def result := MutableString()
                if label != null {
                    result.append("\{label}: ")
                }
                result.append("while \{test} {\n")
                for s in statements {
                    result.append(s + "\n")
                }
                result.append("}")
                return result.finish()
            otherwise:
                assert false
        }
    }
}