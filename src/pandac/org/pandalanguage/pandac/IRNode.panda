package org.pandalanguage.pandac

uses org.pandalanguage.pandac.parser.Token

choice IRNode {
    ASSERT(Position, IRNode, IRNode?)
    AT_RETURN(Position, Type)
    BINARY(Position, Type, IRNode, Token.Kind, IRNode)
    BIT(Position, Type, Bit)
    BLOCK(Position, ImmutableArray<IRNode>)
    -- represents a block which has additional code that must be run before exiting the block, no
    -- matter how the block ends up being exited.
    BLOCK_WITH_FINALLY(Position,
                       ImmutableArray<IRNode> -* statements *-,
                       ImmutableArray<IRNode> -* finally *-)
    BREAK(Position, String?)
    CALL(Position, Type, MethodRef, ImmutableArray<IRNode>)
    CAST(Position, IRNode, Type, Bit -* explicit *-)
    -- a choice entry, like IRNode.Kind.STRING
    CHOICE_CASE_REFERENCE(Position, ChoiceCase)
    -- a field of a choice entry, like IRNode.Kind.STRING[0]
    CHOICE_FIELD_REFERENCE(Position, IRNode, ChoiceCase, Int)
    CONSTRUCT(Position, Type, IRNode -* init call *-)
    -- target used for init calls during object construction, meaning "the object that was just
    -- constructed"
    CONSTRUCTED_OBJECT(Position, Type)
    CONTINUE(Position, String?)
    DECLARATION(IRNode -* target *-, IRNode? -* value *-)
    DO(Position, String?, ImmutableArray<IRNode>, IRNode)
    -- evaluates to the expression, but executes the extraEffectsStatement after the current
    -- statement
    DYNAMIC_CALL(IRNode -* panda.core.Method *-, ImmutableArray<IRNode>)
    EXPRESSION_WITH_EXTRA_EFFECTS(IRNode -* expression *-, IRNode -* extraEffectStatement *-)
    FIELD_REFERENCE(Position, Type, IRNode? -* base *-, FieldDecl)
    IF(Position, IRNode, ImmutableArray<IRNode>, IRNode?)
    INT(Position, Type, UInt64)
    IS_NONNULL(Position, IRNode)
    IS_NULL(Position, IRNode)
    LOOP(Position, String?, ImmutableArray<IRNode>)
    MATCH(Position, IRNode -* value *-, ImmutableArray<IRNode> -* whens *-,
            ImmutableArray<IRNode>? -* otherwise statements *-)
    METHOD_REFERENCE(Position, Type, IRNode? -* target *-, MethodRef)
    NEGATED_INT(Position, Type, UInt64)
    NULL(Position, Type)
    PREFIX(Position, Token.Kind, IRNode)
    RANGE_FOR(Position, String, IRNode -* target *-, IRNode -* list *-, ImmutableArray<IRNode>)
    REAL(Position, Type, Real64)
    RETURN(Position, IRNode?)
    REUSED_VALUE(Position, Type, Int -* id *-)
    REUSED_VALUE_DEFINITION(IRNode, Int -* id *-)
    SELF(Position, Type)
    SELF_CAPTURE(Position, Type)
    STRING(Position, String)
    SUPER(Position, Type)
    -- C-style ternary expression. Not supported in Panda source code, but used internally.
    TERNARY(Position, IRNode, IRNode, IRNode)
    TYPE_REFERENCE(Position, Type)
    UNRESOLVED_IDENTIFIER(Position, String)
    -- index expressions (foo[bar]) always start out unresolved, because of indexed assignment. For
    -- instance, a given object might define a "[]:=" method but not a "[]" function, or the index
    -- types could be different between "[]" and "[]:=". Holding off on resolution allows us to
    -- handle cases like this.
    UNRESOLVED_INDEX(Position, Type, IRNode -* base *-, ImmutableArray<IRNode> -* args *-)
    UNRESOLVED_LAMBDA(Position, ImmutableArray<String> -* parameters *-, ASTNode -* body *-)
    UNRESOLVED_METHOD_CALL(Position, Type, IRNode -* target *-, ImmutableArray<MethodRef>,
            ImmutableArray<IRNode> -* args *-)
    UNRESOLVED_METHOD_REFERENCE(Position, IRNode? -* target *-, ImmutableArray<MethodRef>)
    UNRESOLVED_RANGE(Position, IRNode -* start *-, IRNode -* end *-, Bit, IRNode -* step *-)
    VAR(Position, Variable.Kind, ImmutableArray<IRNode> -* DECLARATIONs *-)
    VARIABLE_CAPTURE(Position, String, Type)
    VARIABLE_REFERENCE(Position, Variable)
    WHEN(Position, ImmutableArray<IRNode> -* tests *-, ImmutableArray<IRNode> -* statements *-)
    WHILE(Position, String?, IRNode, ImmutableArray<IRNode>)

    function type():Type {
        match self {
            when AT_RETURN(_, type):
                return type
            when BINARY(_, type, _, _, _):
                return type
            when BIT(_, type, _):
                return type
            when CALL(_, type, _, _):
                return type
            when CAST(_, _, type, _):
                return type
            when CHOICE_CASE_REFERENCE(_, ce):
                return Type.Invalid()
            when CHOICE_FIELD_REFERENCE(_, _, ce, field):
                return ce.fields[field]
            when CONSTRUCT(_, type, _):
                return type
            when CONSTRUCTED_OBJECT(_, type):
                return type
            when DYNAMIC_CALL(m, _):
                return m.type().subtypes[m.type().subtypes.count - 1]
            when EXPRESSION_WITH_EXTRA_EFFECTS(expr, _):
                return expr.type()
            when FIELD_REFERENCE(_, type, _, _):
                return type
            when INT(_, type, _):
                return type
            when IS_NONNULL:
                return Type.Bit()
            when IS_NULL:
                return Type.Bit()
            when METHOD_REFERENCE(_, type, target, m):
                return type
            when NEGATED_INT(_, type, _):
                return type
            when NULL(_, type):
                return type
            when PREFIX(_, _, base):
                return base.type()
            when REAL(_, type, _):
                return type
            when REUSED_VALUE(_, type, id):
                return type
            when REUSED_VALUE_DEFINITION(base, _):
                return base.type()
            when SELF(_, type):
                return type
            when SELF_CAPTURE(_, type):
                return type
            when STRING:
                return Type.StringType()
            when SUPER(_, type):
                return type
            when TERNARY(_, _, ifTrue, ifFalse):
                assert ifTrue.type() = ifFalse.type()
                return ifTrue.type()
            when TYPE_REFERENCE:
                return Type.Class()
            when UNRESOLVED_IDENTIFIER:
                return Type.Invalid()
            when UNRESOLVED_INDEX(_, type, _, _):
                return type
            when UNRESOLVED_LAMBDA:
                return Type.Invalid()
            when UNRESOLVED_METHOD_CALL(_, type, _, _, _):
                return type
            when UNRESOLVED_METHOD_REFERENCE:
                return Type.Invalid()
            when UNRESOLVED_RANGE:
                return Type.Invalid()
            when VARIABLE_CAPTURE(_, _, type):
                return type
            when VARIABLE_REFERENCE(_, variable):
                return variable.type
            otherwise:
                assert false
        }
    }

    function position():Position {
        match self {
            when ASSERT(position, _, _):
                return position
            when AT_RETURN(position, _):
                return position
            when BINARY(position, _, _, _, _):
                return position
            when BIT(position, _, _):
                return position
            when BLOCK(position, _):
                return position
            when BREAK(position, _):
                return position
            when CALL(position, _, _, _):
                return position
            when CAST(position, _, _, _):
                return position
            when CHOICE_CASE_REFERENCE(position, _):
                return position
            when CHOICE_FIELD_REFERENCE(position, _, _, _):
                return position
            when CONSTRUCT(position, _, _):
                return position
            when CONSTRUCTED_OBJECT(position, _):
                return position
            when CONTINUE(position, _):
                return position
            when DECLARATION(target, _):
                return target.position()
            when DO(position, _, _, _):
                return position
            when DYNAMIC_CALL(m, _):
                return m.position()
            when EXPRESSION_WITH_EXTRA_EFFECTS(expr, _):
                return expr.position()
            when FIELD_REFERENCE(position, _, _, _):
                return position
            when IF(position, _, _, _):
                return position
            when INT(position, _, _):
                return position
            when IS_NONNULL(position, _):
                return position
            when IS_NULL(position, _):
                return position
            when LOOP(position, _, _):
                return position
            when MATCH(position, _, _, _):
                return position
            when METHOD_REFERENCE(position, _, _, _):
                return position
            when NEGATED_INT(position, _, _):
                return position
            when NULL(position, _):
                return position
            when PREFIX(position, _, _):
                return position
            when RANGE_FOR(position, _, _, _, _):
                return position
            when REAL(position, _, _):
                return position
            when RETURN(position, _):
                return position
            when REUSED_VALUE(position, _, _):
                return position
            when REUSED_VALUE_DEFINITION(base, _):
                return base.position()
            when SELF(position, _):
                return position
            when SELF_CAPTURE(position, _):
                return position
            when STRING(position, _):
                return position
            when SUPER(position, _):
                return position
            when TERNARY(position, _, _, _):
                return position
            when TYPE_REFERENCE(position, _):
                return position
            when UNRESOLVED_IDENTIFIER(position, _):
                return position
            when UNRESOLVED_INDEX(position, _, _, _):
                return position
            when UNRESOLVED_LAMBDA(position, _, _):
                return position
            when UNRESOLVED_METHOD_CALL(position, _, _, _, _):
                return position
            when UNRESOLVED_METHOD_REFERENCE(position, _, _):
                return position
            when UNRESOLVED_RANGE(position, _, _, _, _):
                return position
            when VAR(position, _, _):
                return position
            when VARIABLE_CAPTURE(position, _, _):
                return position
            when VARIABLE_REFERENCE(position, _):
                return position
            when WHEN(position, _, _):
                return position
            when WHILE(position, _, _, _):
                return position
            otherwise:
                assert false
        }
    }

    function hasSideEffects():Bit {
        match self {
            when ASSERT(_, test, msg):
                return test.hasSideEffects() | msg.hasSideEffects()
            when AT_RETURN:
                return false
            when BINARY(_, _, left, op, right):
                return Compiler.isAssignment(op) | left.hasSideEffects() | right.hasSideEffects()
            when BIT:
                return false
            when BLOCK(_, statements):
                for s in statements {
                    if s.hasSideEffects() {
                        return true
                    }
                }
                return false
            when BREAK:
                return false
            when CALL(_, _, m, args):
                if m.value.methodKind = MethodDecl.Kind.METHOD {
                    return true
                }
                for arg in args {
                    if arg.hasSideEffects() {
                        return true
                    }
                }
                return false
            when CAST:
                return false
            when CHOICE_CASE_REFERENCE:
                return false
            when CHOICE_FIELD_REFERENCE:
                return false
            when CONSTRUCT(_, type, call):
                return call.hasSideEffects()
            when CONSTRUCTED_OBJECT:
                return false
            when CONTINUE:
                return false
            when DECLARATION(target, value):
                return value != null & value.hasSideEffects()
            when DO(_, label, statements, test):
                if test.hasSideEffects() {
                    return true
                }
                for s in statements {
                    if s.hasSideEffects() {
                        return true
                    }
                }
                return false
            when EXPRESSION_WITH_EXTRA_EFFECTS:
                return true
            when FIELD_REFERENCE:
                return false
            when IF(_, test, ifTrue, ifFalse):
                if test.hasSideEffects() {
                    return true
                }
                for s in ifTrue {
                    if s.hasSideEffects() {
                        return true
                    }
                }
                return ifFalse.hasSideEffects()
            when INT:
                return false
            when IS_NONNULL(_, value):
                return value.hasSideEffects()
            when IS_NULL(_, value):
                return value.hasSideEffects()
            when LOOP(_, label, statements):
                for s in statements {
                    if s.hasSideEffects() {
                        return true
                    }
                }
                return false
            when MATCH(_, value, whens, other):
                if value.hasSideEffects() {
                    return true
                }
                for w in whens {
                    if w.hasSideEffects() {
                        return true
                    }
                }
                for s in other {
                    if s.hasSideEffects() {
                        return true
                    }
                }
                return false

            when METHOD_REFERENCE:
                return false
            when NEGATED_INT:
                return false
            when NULL:
                return false
            when PREFIX(_, _, base):
                return base.hasSideEffects()
            when RANGE_FOR(_, _, _, list, statements):
                if list.hasSideEffects() {
                    return true
                }
                for s in statements {
                    if s.hasSideEffects() {
                        return true
                    }
                }
                return false
            when REAL:
                return false
            when RETURN(_, value):
                return value.hasSideEffects()
            when REUSED_VALUE:
                return false
            when REUSED_VALUE_DEFINITION(base, _):
                return base.hasSideEffects()
            when SELF:
                return false
            when SELF_CAPTURE:
                return false
            when STRING:
                return false
            when SUPER:
                return false
            when TERNARY(_, test, ifTrue, ifFalse):
                return test.hasSideEffects() | ifTrue.hasSideEffects() | ifFalse.hasSideEffects()
            when TYPE_REFERENCE:
                return false
            when UNRESOLVED_IDENTIFIER:
                assert false
            when UNRESOLVED_INDEX:
                assert false
            when UNRESOLVED_LAMBDA:
                assert false
            when UNRESOLVED_METHOD_CALL:
                assert false
            when UNRESOLVED_METHOD_REFERENCE:
                assert false
            when UNRESOLVED_RANGE:
                assert false
            when VAR(_, _, decls):
                for d in decls {
                    if d.hasSideEffects() {
                        return true
                    }
                }
                return false
            when VARIABLE_CAPTURE:
                return false
            when VARIABLE_REFERENCE:
                return false
            when WHEN(_, tests, statements):
                for t in tests {
                    if t.hasSideEffects() {
                        return true
                    }
                }
                for s in statements {
                    if s.hasSideEffects() {
                        return true
                    }
                }
                return false
            when WHILE(_, _, test, statements):
                if test.hasSideEffects() {
                    return true
                }
                for s in statements {
                    if s.hasSideEffects() {
                        return true
                    }
                }
                return false
            otherwise:
                assert false
        }
    }

    @private
    @class
    method transform(nodes:ImmutableArray<IRNode>?,
            f:(IRNode)=&>(IRNode?)):ImmutableArray<IRNode>? {
        var newNodes:Array<IRNode>? := null
        if nodes != null {
            for i in 0 .. nodes.count {
                def newNode := nodes[i].doTransform(f)
                if newNode != null {
                    if newNodes = null {
                        newNodes := Array<IRNode>(nodes)
                    }
                    newNodes[i] := newNode
                }
            }
        }
        if newNodes != null {
            return newNodes.finish()
        }
        return null
    }

    @private
    @class
    method transform(node:IRNode?, f:(IRNode)=&>(IRNode?)):IRNode? {
        if node = null {
            return null
        }
        return node.transform(f)
    }

    function default(node:IRNode?, defaultValue:IRNode?):IRNode? {
        if node != null {
            return node
        }
        return defaultValue
    }

    function default(nodes:ImmutableArray<IRNode>?,
            defaultValue:ImmutableArray<IRNode>?):ImmutableArray<IRNode>? {
        if nodes != null {
            return nodes
        }
        return defaultValue
    }

    method transform(f:(IRNode)=&>(IRNode?)):IRNode {
        def result := doTransform(f)
        if result != null {
            return result
        }
        return self
    }

    @private
    method doTransform(f:(IRNode)=&>(IRNode?)):IRNode? {
        def transformed := f(self)
        if transformed != null {
            return transformed
        }
        match self {
            when AT_RETURN, BIT, BREAK, CHOICE_CASE_REFERENCE, CONSTRUCTED_OBJECT, CONTINUE, INT,
                    NEGATED_INT, NULL, REAL, SELF, SELF_CAPTURE, STRING, SUPER, REUSED_VALUE,
                    TYPE_REFERENCE, UNRESOLVED_IDENTIFIER, UNRESOLVED_METHOD_REFERENCE,
                    UNRESOLVED_INDEX, UNRESOLVED_LAMBDA, UNRESOLVED_METHOD_CALL, UNRESOLVED_RANGE,
                    VARIABLE_CAPTURE, VARIABLE_REFERENCE:
                -- do nothing
            when ASSERT(position, test, message):
                def newTest := test.doTransform(f)
                def newMessage := transform(message, f)
                if newTest != null | newMessage != null {
                    return IRNode.ASSERT(position, default(newTest, test),
                            default(newMessage, message))
                }
            when BINARY(position, type, left, op, right):
                def newLeft := left.doTransform(f)
                def newRight := right.doTransform(f)
                if newLeft != null | newRight != null {
                    return IRNode.BINARY(position, type, default(newLeft, left), op,
                                  default(newRight, right))
                }
            when BLOCK(position, statements):
                def newStatements := transform(statements, f)
                if newStatements != null {
                    return IRNode.BLOCK(position, newStatements)
                }
            when BLOCK_WITH_FINALLY(position, statements, finally):
                def newStatements := transform(statements, f)
                def newFinally := transform(finally, f)
                if newStatements != null {
                    return IRNode.BLOCK_WITH_FINALLY(position, default(newStatements, statements),
                            default(newFinally, finally))
                }
            when CALL(position, type, m, args):
                def newArgs := transform(args, f)
                if newArgs != null {
                    return IRNode.CALL(position, type, m, default(newArgs, args))
                }
            when CAST(position, value, type, explicit):
                def newValue := value.doTransform(f)
                if newValue != null {
                    return IRNode.CAST(position, newValue, type, explicit)
                }
            when CHOICE_FIELD_REFERENCE(position, base, ce, field):
                def newBase := base.doTransform(f)
                if newBase != null {
                    return IRNode.CHOICE_FIELD_REFERENCE(position, newBase, ce, field)
                }
            when CONSTRUCT(position, type, call):
                def newCall := call.doTransform(f)
                if newCall != null {
                    return IRNode.CONSTRUCT(position, type, newCall)
                }
            when DECLARATION(target, value):
                def newValue := transform(value, f)
                if newValue != null {
                    return IRNode.DECLARATION(target, newValue)
                }
            when DO(position, label, statements, test):
                def newStatements := transform(statements, f)
                def newTest := test.doTransform(f)
                if newStatements != null | newTest != null {
                    return IRNode.DO(position, label, default(newStatements, statements),
                            default(newTest, test))
                }
            when DYNAMIC_CALL(m, args):
                def newM := m.doTransform(f)
                def newArgs := transform(args, f)
                if newM != null | newArgs != null {
                    return IRNode.DYNAMIC_CALL(default(newM, m), default(newArgs, args))
                }
            when EXPRESSION_WITH_EXTRA_EFFECTS(expr, statements):
                def newExpr := expr.doTransform(f)
                def newStatements := statements.doTransform(f)
                if newExpr != null | newStatements != null {
                    return IRNode.EXPRESSION_WITH_EXTRA_EFFECTS(default(newExpr, expr),
                            default(newStatements, statements))
                }
            when FIELD_REFERENCE(position, type, base, field):
                def newBase := transform(base, f)
                if newBase != null {
                    return IRNode.FIELD_REFERENCE(position, type, newBase, field)
                }
            when IF(position, test, ifTrue, ifFalse):
                def newTest := test.doTransform(f)
                def newIfTrue := transform(ifTrue, f)
                def newIfFalse := transform(ifFalse, f)
                if newTest != null | newIfTrue != null | newIfFalse != null {
                    return IRNode.IF(position, default(newTest, test), default(newIfTrue, ifTrue),
                            default(newIfFalse, ifFalse))
                }
            when IS_NONNULL(position, value):
                def newValue := value.doTransform(f)
                if newValue != null {
                    return IRNode.IS_NONNULL(position, newValue)
                }
            when IS_NULL(position, value):
                def newValue := value.doTransform(f)
                if newValue != null {
                    return IRNode.IS_NULL(position, newValue)
                }
            when LOOP(position, label, statements):
                def newStatements := transform(statements, f)
                if newStatements != null {
                    return IRNode.LOOP(position, label, newStatements)
                }
            when MATCH(position, value, whens, other):
                def newValue := value.doTransform(f)
                def newWhens := transform(whens, f)
                def newOther := transform(other, f)
                if newValue != null | newWhens != null | newOther != null {
                    return IRNode.MATCH(position, default(newValue, value),
                            default(newWhens, whens), default(newOther, other))
                }
            when METHOD_REFERENCE(position, type, target, m):
                def newTarget := transform(target, f)
                if newTarget != null {
                    return IRNode.METHOD_REFERENCE(position, type, newTarget, m)
                }
            when PREFIX(position, op, base):
                def newBase := base.doTransform(f)
                if newBase != null {
                    return IRNode.PREFIX(position, op, newBase)
                }
            when RANGE_FOR(position, label, target, list, statements):
                def newList := list.doTransform(f)
                def newStatements := transform(statements, f)
                if newList != null | newStatements != null {
                    return IRNode.RANGE_FOR(position, label, target, default(newList, list),
                            default(newStatements, statements))
                }
            when RETURN(position, value):
                def newValue := transform(value, f)
                if newValue != null {
                    return RETURN(position, newValue)
                }
            when REUSED_VALUE_DEFINITION(base, id):
                def newBase := base.doTransform(f)
                if newBase != null {
                    return IRNode.REUSED_VALUE_DEFINITION(newBase, id)
                }
            when TERNARY(position, test, ifTrue, ifFalse):
                def newTest := test.doTransform(f)
                def newIfTrue := ifTrue.doTransform(f)
                def newIfFalse := ifFalse.doTransform(f)
                if newTest != null | newIfTrue != null | newIfFalse != null {
                    return IRNode.TERNARY(position, default(newTest, test),
                            default(newIfTrue, ifTrue), default(newIfFalse, ifFalse))
                }
            when VAR(position, kind, decls):
                def newDecls := transform(decls, f)
                if newDecls != null {
                    return VAR(position, kind, newDecls)
                }
            when WHEN(position, tests, statements):
                def newTests := transform(tests, f)
                def newStatements := transform(statements, f)
                if newTests != null | newStatements != null {
                    return IRNode.WHEN(position, default(newTests, tests),
                            default(newStatements, statements))
                }
            when WHILE(position, label, test, statements):
                def newTest := test.doTransform(f)
                def newStatements := transform(statements, f)
                if newTest != null | newStatements != null {
                    return IRNode.WHILE(position, label, default(newTest, test),
                            default(newStatements, statements))
                }
            otherwise:
                assert false
        }        
        return null
    }

    @override
    function convert():String {
        match self {
            when ASSERT(_, test, msg):
                if msg != null {
                    return "assert \{test}, \{msg}"
                }
                return "assert \{test}"
            when AT_RETURN:
                return "@return"
            when BINARY(_, _, left, op, right):
                return "\{left} \{op} \{right}"
            when BIT(_, _, bit):
                return bit.convert()
            when BLOCK(_, statements):
                def result := MutableString("{\n")
                for s in statements {
                    result.append(s + "\n")
                }
                result.append("}")
                return result.finish()
            when BLOCK_WITH_FINALLY(_, statements, finally):
                def result := MutableString("try {\n")
                for s in statements {
                    result.append(s + "\n")
                }
                result.append("}\nfinally {\n")
                for s in finally {
                    result.append(s + "\n")
                }
                result.append("}")
                return result.finish()
            when BREAK(_, label):
                if label != null {
                    return "break \{label}"
                }
                return "break"
            when CALL(_, _, m, args):
                return "\{m.value.name}(\{args.join()})"
            when CAST(_, value, type, _):
                return "\{value}->\{type}"
            when CHOICE_CASE_REFERENCE(_, ce):
                return ce.convert()
            when CHOICE_FIELD_REFERENCE(_, base, ce, field):
                return "\{base}.\{ce}[\{field}]"
            when CONSTRUCT(_, type, call):
                match call {
                    when CALL(_, _, _, args):
                        return "\{type}(\{args.join()})"
                    otherwise:
                        assert false
                }
            when CONSTRUCTED_OBJECT(_, Type):
                return "-* constructed object *-"
            when CONTINUE(_, label):
                if label != null {
                    return "continue \{label}"
                }
                return "continue"
            when DECLARATION(target, value):
                if value != null {
                    return "\{target}:\{target.type()} := \{value}"
                }
                return "\{target}:\{target.type()}"
            when DO(_, label, statements, test):
                def result := MutableString()
                if label != null {
                    result.append("\{label}: ")
                }
                result.append("do {\n")
                for s in statements {
                    result.append(s + "\n")
                }
                result.append("} while \{test}")
                return result.finish()
            when DYNAMIC_CALL(m, args):
                return "\{m}(\{args.join(" ")})"
            when EXPRESSION_WITH_EXTRA_EFFECTS(expr, stmt):
                return "\{expr} -* and then: \{stmt} *-"
            when FIELD_REFERENCE(_, _, base, field):
                if base != null {
                    return "\{base}.\{field.name}"
                }
                return field.name
            when IF(_, test, ifTrue, ifFalse):
                def result := MutableString("if \{test} {")
                for s in ifTrue {
                    result.append(s + "\n")
                }
                result.append("}")
                if ifFalse != null {
                    result.append("\nelse \{ifFalse}")
                }
                return result.finish()
            when INT(_, _, value):
                return value.convert()
            when IS_NONNULL(_, value):
                return "(\{value} != null)"
            when IS_NULL(_, value):
                return "(\{value} = null)"
            when LOOP(_, label, statements):
                def result := MutableString()
                if label != null {
                    result.append("\{label}: ")
                }
                result.append("loop {\n")
                for s in statements {
                    result.append(s + "\n")
                }
                result.append("}")
                return result.finish()
            when MATCH(_, value, whens, other):
                def result := MutableString("match \{value} {\n")
                for w in whens {
                    result.append(w + "\n")
                }
                if other != null {
                    result.append("otherwise:\n")
                    for s in other {
                        result.append(s + "\n")
                    }
                }
                result.append("}")
                return result.finish()
            when METHOD_REFERENCE(_, _, target, m):
                if target != null {
                    return "\{target}.\{m.value.name}"
                }
                return m.value.name
            when NEGATED_INT(_, _, value):
                return "-" + value
            when NULL:
                return "null"
            when PREFIX(_, op, base):
                return "\{op}\{base}"
            when RANGE_FOR(_, label, target, list, statements):
                def result := MutableString()
                if label != null {
                    result.append("\{label}: ")
                }
                result.append("for \{target} in \{list} {\n")
                for s in statements {
                    result.append(s + "\n")
                }
                result.append("}")
                return result.finish()
            when REAL(_, _, value):
                return value.convert()
            when RETURN(_, value):
                if value != null {
                    return "return \{value}"
                }
                return "return"
            when REUSED_VALUE(_, type, id):
                return "$reused(\{id})"
            when REUSED_VALUE_DEFINITION(base, id):
                return "$reused(\{id} := \{base})"
            when SELF:
                return "self"
            when SELF_CAPTURE:
                return "self-*capture*-"
            when STRING(_, str):
                return str.format("panda")
            when SUPER:
                return "super"
            when TERNARY(_, test, ifTrue, ifFalse):
                return "(\{test} ? \{ifTrue} : \{ifFalse})"
            when TYPE_REFERENCE(_, type):
                return type.convert()
            when UNRESOLVED_IDENTIFIER(_, name):
                return name
            when UNRESOLVED_INDEX(_, _, base, args):
                return "\{base}[\{args.join()}]"
            when UNRESOLVED_LAMBDA(_, params, body):
                return "(\{params.join()})=>\{body}"
            when UNRESOLVED_METHOD_CALL(_, _, target, methods, args):
                if target != null {
                    return "-*UNRESOLVED*-\{target}.\{methods[0].value.name}(\{args.join()})"
                }
                else {
                    return "-*UNRESOLVED*-\{methods[0].value.name}(\{args.join()})"
                }
            when UNRESOLVED_METHOD_REFERENCE(_, target, methods):
                if target != null {
                    return "\{target}.\{methods[0].value.name}"
                }
                else {
                    return "\{methods[0].value.name}"
                }
            when UNRESOLVED_RANGE(_, start, end, inclusive, step):
                def result := MutableString()
                if start != null {
                    result.append(start)
                }
                if inclusive {
                    result.append("...")
                }
                else {
                    result.append("..")
                }
                if end != null {
                    result.append(end)
                }
                if step != null {
                    result.append(" by \{step}")
                }
                return result.finish()
            when VAR(_, kind, decls):
                def result := MutableString()
                match kind {
                    when Variable.Kind.VAR:      result.append("var ")
                    when Variable.Kind.DEF:      result.append("def ")
                    when Variable.Kind.CONSTANT: result.append("constant ")
                    when Variable.Kind.PROPERTY: result.append("property ")
                }
                result.append(decls.join())
                return result.finish()
            when VARIABLE_CAPTURE(_, name, _):
                return name
            when VARIABLE_REFERENCE(_, variable):
                return variable.name + "-*capture*-"
            when WHEN(_, tests, statements):
                return "when \{tests.join()}:\n\{statements.join("\n")}"
            when WHILE(_, label, test, statements):
                def result := MutableString()
                if label != null {
                    result.append("\{label}: ")
                }
                result.append("while \{test} {\n")
                for s in statements {
                    result.append(s + "\n")
                }
                result.append("}")
                return result.finish()
            otherwise:
                assert false
        }
    }
}