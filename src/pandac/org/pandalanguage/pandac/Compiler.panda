package org.pandalanguage.pandac

uses org.pandalanguage.pandac.parser.Parser

class Compiler (ErrorReporter) {
    def importDirs:ListView<File>

    def parser:Parser

    def scanner:Scanner

    def root:SymbolTable

    @private
    def scans := HashMap<File, ListView<ClassDecl>>()

    @private
    def classes := HashMap<String, ClassDecl>()

    @private
    def currentClass := Stack<ClassDecl>()

    @private
    var symbolTable:SymbolTable

    @private
    def codeGenerator:CodeGenerator

    @private
    var errorCount := 0

    init(importDirs:ListView<File>) {
        self.importDirs := importDirs
        self.parser := Parser(self)
        self.scanner := Scanner(self)
        self.root := SymbolTable(self)
        self.symbolTable := root
        self.codeGenerator := LLVMCodeGenerator(self)
        codeGenerator.start(File("/tmp/output.ll").openOutputStream())
        root.add(Type("builtin_int8", Type.Kind.BUILTIN_INT, -1, true))
        root.add(Type("builtin_int16", Type.Kind.BUILTIN_INT, -1, true))
        root.add(Type("builtin_int32", Type.Kind.BUILTIN_INT, -1, true))
        root.add(Type("builtin_int64", Type.Kind.BUILTIN_INT, -1, true))
        root.add(Alias("Int", "panda.core.Int64", -1))
        addAlias("panda.core.Class")
        addAlias("panda.core.Int32")
        addAlias("panda.core.Int64")
        addAlias("panda.core.Immutable")
        addAlias("panda.core.Object")
        addAlias("panda.core.Value")
        addAlias("panda.io.Console")
    }

    @private
    method addAlias(name:String) {
        root.add(Alias(name[name.next(name.lastIndexOf("."))..], name, -1))
    }

    function resolve(type:Type):Type {
        if type.resolved {
            return type
        }
        def resolved := currentClass.peek().aliases[type.name]
        if resolved != null {
            return Type(resolved, Type.Kind.CLASS, type.offset, true)
        }
        def s := symbolTable[type.name]
        if s != null {
            match s.kind {
                when Symbol.Kind.ALIAS:
                    return Type((s->Alias).fullName, Type.Kind.CLASS, type.offset, true) -- FIXME parens
                when Symbol.Kind.TYPE:
                    return s->Type
            }
        }
        error(position(type.offset), "unknown type '\{type}'")
        return Type.Invalid()
    }

    method resolve(cl:ClassDecl) {
        if cl.resolved {
            return
        }
        if cl.rawSuper != null {
            cl.rawSuper := resolve(cl.rawSuper)
        }
        for i in 0 .. cl.rawInterfaces.get_count() {
            cl.rawInterfaces[i] := resolve(cl.rawInterfaces[i])
        }
        cl.resolved := true
    }

    method resolve(m:MethodDecl) {
        if m.resolved {
            return
        }
        for p in m.parameters {
            p.type := resolve(p.type)
        }
        m.returnType := resolve(m.returnType)
        m.resolved := true
    }

    method resolve(f:FieldDecl) {
        if f.resolved {
            return
        }
        f.type := resolve(f.type)
    }

    method resolve(expr:IRNode):IRNode? {
        return expr
    }

    method isValue(cl:ClassDecl):Bit {
        return coercionCost(cl.type(), Type.Value()) != null
    }

    method instanceFields(cl:ClassDecl):ListView<FieldDecl> {
        resolve(cl)
        def result := Array<FieldDecl>()
        if !isValue(cl) & cl.rawSuper != null {
            def s := getClass(cl.rawSuper)
            if s != null {
                result.addAll(instanceFields(s))
            }
        }
        for f in cl.fields {
            if !f.annotations.isClass() {
                result.add(f)
            }
        }
        return result
    }

    method getClass(offset:Int, fullName:String):ClassDecl? {
        var result := classes[fullName]
        if result = null {
            def suffix := fullName.replace(".", "/") + ".panda"
            var found := false
            for dir in importDirs {
                def f := dir.resolve(suffix)
                if f.exists() {
                    found := true
                    def oldErrorCount := errorCount
                    scan(f)
                    result := classes[fullName]
                    if result = null & errorCount = oldErrorCount {
                        error(Position(f.name(), 1, 1),
                                "expected file '\{f}' to contain a class named '\{fullName}'")
                    }
                }
            }
            if !found {
                error(offset, "no file named \{suffix} in any import path (\{importDirs})")
            }
        }
        return result
    }

    method getClass(type:Type):ClassDecl? {
        assert type.resolved, "unresolved type \{type}"
        return getClass(type.offset, type.name)
    }

    method addInheritedMethods(st:SymbolTable, name:String, result:Array<MethodRef>,
            types:Array<Type>) {
    }

    method getMethodReference(st:SymbolTable, target:IRNode?, name:String, offset:Int,
            types:Array<Type>):IRNode {
        def methods := Array<MethodRef>()
        def s := st[name]
        if s.kind = Symbol.Kind.METHOD {
            resolve(s->MethodDecl)
            methods.add(MethodRef(s->MethodDecl, types))
        }
        else {
            assert s.kind = Symbol.Kind.METHODS
            for m in (s->Methods).methods { -- FIXME extra parens
                resolve(m)
                methods.add(MethodRef(m, types))
            }
        }
        for p in st.parents {
            addInheritedMethods(p, name, methods, types)
        }
        def children := Array<IRNode>()
        if target != null {
            children.add(target)
        }
        if methods.get_count() = 1 {
            return IRNode(IRNode.Kind.METHOD_REFERENCE, offset, methods[0].type(), methods[0],
                    children)
        }
        else {
            def types := Array<Type>()
            for m in methods {
                types.add(m.type())
            }
            return IRNode(IRNode.Kind.UNRESOLVED_METHOD_REFERENCE, offset, Type(types), methods,
                    children)
        }
    }

    method symbolRef(offset:Int, target:IRNode?, s:Symbol, st:SymbolTable):IRNode? {
        match s.kind {
            when Symbol.Kind.ALIAS:
                assert target = null
                def cl := getClass(offset, (s->Alias).fullName) -- FIXME remove extra parens
                if cl != null {
                    return IRNode(IRNode.Kind.TYPE_REFERENCE, offset, Type.Class(), cl.type())
                }
                return null
            when Symbol.Kind.METHOD, Symbol.Kind.METHODS:
                return getMethodReference(st, target, s.name, offset, Array<Type>())
            otherwise:
                assert false, "unsupported symbol kind: \{s.kind}"
        }
    }

    function remapType(context:Type, type:Type):Type {
        return type
    }

    function variableType(type:Type):Type {
        if type = Type.IntLiteral() {
            return Type.Int64()
        }
        return type
    }

    function variableType(expr:IRNode):Type {
        return variableType(expr.type)
    }

    function coercionCost(type:Type, target:Type):Int? {
        assert type.resolved
        assert target.resolved
        if type = target {
            return 0
        }
        def cl := getClass(type)
        assert cl != null
        resolve(cl)
        if cl.rawSuper != null {
            var cost := coercionCost(remapType(type, cl.rawSuper), target)
            if cost != null {
                return cost + 1
            }
        }
        for intf in cl.rawInterfaces {
            var cost := coercionCost(remapType(type, intf), target)
            if cost != null {
                return cost + 1
            }
        }
        return null
    }

    function coercionCost(expr:IRNode, target:Type):Int? {
        match expr.kind {
            when IRNode.Kind.INT:
                if target.typeKind = Type.Kind.BUILTIN_INT {
                    return 0
                }
                if target.isNumber() {
                    return 0
                }
                if !target.isNumber() {
                    return coercionCost(variableType(expr), target)
                }
        }
        assert expr.type != null
        return coercionCost(expr.type, target)
    }

    function coerce(expr:IRNode, target:Type):IRNode? {
        assert expr.type.resolved
        assert target.resolved
        if expr.type = target {
            return expr
        }
        if expr.kind = IRNode.Kind.INT {
            if target.isBuiltinNumber() {
                return IRNode(IRNode.Kind.INT, expr.offset, target, expr.payload->UInt64)
            }
            if target.typeKind = Type.Kind.CLASS & !target.isNumber() {
                def varType := coerce(expr, variableType(expr))
                if varType != null {
                    return coerce(varType, target)
                }
            }
        }
        if coercionCost(expr, target) != null {
            def cl := getClass(target)
            if cl != null {
                for m in cl.methods {
                    if m.annotations.isImplicit() {
                        -- Internal use feature, sharp edges! We currently assume there's only one
                        -- implicit method and it's a single-argument init.
                        resolve(m)
                        assert m.methodKind = MethodDecl.Kind.INIT
                        assert m.parameters.get_count() = 1
                        if coercionCost(expr, m.parameters[0].type) != null {
                            def type := IRNode(IRNode.Kind.TYPE_REFERENCE, expr.offset,
                                    Type.Class(), cl.type())
                            def args := Array<IRNode>(1) -- FIXME literal
                            args.add(expr)
                            return call(type, args)
                        }
                    }
                }
            }
            def children := Array<IRNode>(1) -- FIXME literal
            children.add(expr)
            return IRNode(IRNode.Kind.CAST, expr.offset, target, children)
        }
        assert false, "need to coerce \{expr} to \{target}"
    }

    method callCost(m:MethodRef, args:ListView<IRNode>, expectedReturn:Type?):Int? {
        if m.parameterCount() != args.get_count() {
            return null
        }
        var result := 0
        for i in 0 .. m.parameterCount() {
            def cost := coercionCost(args[i], m.parameter(i))
            if cost = null {
                return null
            }
            result += cost
        }
        if expectedReturn != null {
            def cost := coercionCost(m.returnType(), expectedReturn)
            if cost = null {
                return null
            }
            result += cost
        }
        return result
    }

    method matchMethods(methods:Array<MethodRef>, args:ListView<IRNode>,
            expectedReturn:Type?):Int? {
        def result := Array<MethodRef>()
        var best:Int? := null
        for m in methods {
            def cost := callCost(m, args, expectedReturn)
            if cost = null {
                continue
            }
            if best = null | cost < best {
                result.clear()
                best := cost
            }
            if cost = best {
                result.add(m)
            }
        }
        methods.clear()
        methods.addAll(result)
        return best
    }

    method call(m:MethodRef, args:ListView<IRNode>):IRNode? {
        assert m.value.resolved
        assert m.parameterCount() = args.get_count()
        def finalArgs := Array<IRNode>(args.get_count())
        for i in 0 .. args.get_count() {
            def coerced := coerce(args[i], m.parameter(i))
            if coerced = null {
                return null
            }
            finalArgs.add(coerced)
        }
        return IRNode(IRNode.Kind.CALL, m.value.offset, m.returnType(), m, finalArgs)
    }

    method call(m:IRNode, args:ListView<IRNode>):IRNode? {
        match m.kind {
            when IRNode.Kind.METHOD_REFERENCE:
                return call(m.payload->MethodRef, args)
            when IRNode.Kind.UNRESOLVED_METHOD_REFERENCE:
                def methods := Array<MethodRef>(m.payload->ListView<MethodRef>)
                matchMethods(methods, args, null)
                if methods.get_count() = 1 {
                    return call(methods[0], args)
                }
                assert false
            when IRNode.Kind.TYPE_REFERENCE:
                def cl := getClass(m.payload->Type)
                assert cl != null
                def methods := getMethodReference(cl.symbolTable, null, "init", m.offset,
                        Array<Type>())
                def initCall := call(methods, args)
                if initCall = null {
                    return null
                }
                def resolved := resolve(initCall)
                if resolved = null {
                    return null
                }
                def children := Array<IRNode>() -- FIXME literal
                children.add(resolved)
                return IRNode(IRNode.Kind.CONSTRUCT, m.offset, m.payload->Type, children)
        }
        assert false
    }

    method compileCall(c:ASTNode):IRNode? {
        assert c.kind = ASTNode.Kind.CALL
        def m := compileExpression(c.children[0])
        if m != null {
            def args := Array<IRNode>()
            for i in 1 .. c.children.get_count() {
                def arg := compileExpression(c.children[i])
                if arg = null {
                    return null
                }
                args.add(arg)
            }
            return call(m, args)
        }
        return null
    }

    method compileDot(d:ASTNode):IRNode? {
        assert d.kind = ASTNode.Kind.DOT
        assert d.children.get_count() = 1
        def base := compileExpression(d.children[0])
        if base = null {
            return null
        }
        def cl:ClassDecl?
        if base.kind = IRNode.Kind.TYPE_REFERENCE {
            cl := getClass(base.payload->Type)
        }
        else {
            cl := getClass(base.type)
        }
        if cl = null {
            return null
        }
        def s := cl.symbolTable[d.payload->String]
        if s = null {
            error(d.offset, "value of type '\{base}' does not have a member named '\{d.payload}'")
            return null
        }
        return symbolRef(d.offset, base, s, cl.symbolTable)
    }

    method compileIdentifier(i:ASTNode):IRNode? {
        assert i.kind = ASTNode.Kind.IDENTIFIER
        def s := symbolTable[i.payload->String]
        if s != null {
            return symbolRef(i.offset, null, s, symbolTable)
        }
        else {
            error(i.offset, "unknown identifier '\{i.payload}'")
            return null
        }
    }

    method compileInt(i:ASTNode):IRNode {
        return IRNode(IRNode.Kind.INT, i.offset, Type.IntLiteral(), i.payload->UInt64)
    }

    method compileExpression(e:ASTNode):IRNode? {
        match e.kind {
            when ASTNode.Kind.CALL:       return compileCall(e)
            when ASTNode.Kind.DOT:        return compileDot(e)
            when ASTNode.Kind.IDENTIFIER: return compileIdentifier(e)
            when ASTNode.Kind.INT:        return compileInt(e)
        }
        assert false, "unsupported expression kind: \{e.kind}"
    }

    method compileBlock(b:ASTNode):IRNode? {
        assert b.kind = ASTNode.Kind.BLOCK
        def result := Array<IRNode>()
        for stmt in b.children {
            def compiled := compileStatement(stmt)
            if compiled = null {
                return null
            }
            result.add(compiled)
        }
        return IRNode(IRNode.Kind.BLOCK, b.offset, result)
    }

    method compileStatement(s:ASTNode):IRNode? {
        match s.kind {
            when ASTNode.Kind.BLOCK: return compileBlock(s)
            when ASTNode.Kind.CALL:  return compileCall(s)
        }
        assert false, "unsupported statement kind: \{s.kind}"
    }

    method compile(m:MethodDecl) {
        assert currentClass.peek() == m.owner
        resolve(m)
        if m.body != null {
            def compiled := compileBlock(m.body)
            if compiled != null {
                Console.printLine("writing \{compiled}")
                codeGenerator.write(m, compiled)
            }
        }
    }

    method compile(cl:ClassDecl) {
        cl.external := false
        currentClass.push(cl)
        for m in cl.methods {
            compile(m)
        }
        currentClass.pop()
    }

    method scan(file:File):ListView<ClassDecl> {
        var result := scans[file]
        if result = null {
            parser.start(file.name(), file.readFully())
            def parsed := parser.file()
            if parsed != null {
                result := scanner.scan(parsed)
                for cl in result {
                    classes[cl.name] := cl
                }
            }
            else {
                result := Array<ClassDecl>()
            }
            scans[file] := result
        }
        return result
    }

    method compile(file:File) {
        def classes := scan(file)
        for cl in classes {
            compile(cl)
        }
    }

    function position(offset:Int):Position {
        return Position("unknown", -1, -1)
    }

    method error(offset:Int, msg:String) {
        error(position(offset), msg)
    }

    @override
    method error(pos:Position, msg:String) {
        errorCount += 1
        Console.printLine("\{pos}: \{msg}")
        assert false
    }
}