package org.pandalanguage.pandac

uses org.pandalanguage.pandac.parser.Parser
uses org.pandalanguage.pandac.parser.Token

@final
class Compiler {
    choice Resolution {
        UNRESOLVED
        IN_PROGRESS
        RESOLVED
        RESOLVED_WITH_ERRORS
    }

    class Error : Immutable {
        def file:File

        def position:Position

        def message:String

        init(file:File, position:Position, message:String) {
            self.file := file
            self.position := position
            self.message := message
        }
    }

    ================================================================================================
    Represents the expected type that an expression must resolve to.
    ================================================================================================
    choice TypeContext {
        ============================================================================================
        We have no information about the expected type, e.g. when evaluating `foo()` in the
        statement `def x := foo()`.
        ============================================================================================
        UNSPECIFIED

        ============================================================================================
        We know that the result has to be immutable, but not of any specific type, e.g. when
        evaluating `foo()` in the statement `const x := foo()`.
        ============================================================================================
        IMMUTABLE

        ============================================================================================
        We expect this specific type, e.g. when evaluating `foo()` in the statement
        `def x:String := foo()`.
        ============================================================================================
        TYPE(Type)

        function description():String {
            match self {
                when UNSPECIFIED:
                    return ""
                when IMMUTABLE:
                    return " with expected return type 'panda.core.Immutable'"
                when TYPE(type):
                    return " with expected return type '\{type}'"
            }
        }

        @override
        function convert():String {
            match self {
                when UNSPECIFIED:
                    return "UNSPECIFIED"
                when IMMUTABLE:
                    return "IMMUTABLE"
                when TYPE(type):
                    return "TYPE(\{type})"
            }
        }
    }

    choice EnclosingContext {
        LOOP(String? -* label *-, IR.Block.ID -* break target *-, IR.Block.ID -* continue target *-)
        FINALLY(String -* label *-, Map<String, String> -* map from source label to return label *-)

        @override
        function convert():String {
            match self {
                when LOOP(label, breakTarget, continueTarget):
                    if label != null {
                        return "LOOP(\{label}, \{breakTarget}, \{continueTarget})"
                    }
                    return "LOOP(<null>, \{breakTarget}, \{continueTarget})"
                when FINALLY(label, map):
                    return "FINALLY(\{label}, \{map})"
            }
        }
    }

    class AutoContext {
        def compiler:Compiler

        def context:EnclosingContext

        init(compiler:Compiler, context:EnclosingContext) {
            self.compiler := compiler
            self.context := context
            compiler.enclosingContexts.push(context)
        }

        @override
        method cleanup() {
            compiler.enclosingContexts.pop(context)
        }
    }

    class AutoSymbolTable {
        def compiler:Compiler

        def oldSymbolTable:SymbolTable

        def newSymbolTable:SymbolTable

        init(compiler:Compiler) {
            init(compiler, SymbolTable(compiler.symbolTable))
        }

        init(compiler:Compiler, symbolTable:SymbolTable) {
            self.compiler := compiler
            self.oldSymbolTable := compiler.symbolTable
            self.newSymbolTable := symbolTable
            compiler.symbolTable := symbolTable
        }

        @override
        method cleanup() {
            assert compiler.symbolTable == newSymbolTable
            compiler.symbolTable := oldSymbolTable
        }
    }

    class AutoAtPreFlag {
        def compiler:Compiler

        init(compiler:Compiler) {
            self.compiler := compiler
            compiler.inAtPre := true
        }

        @override
        method cleanup() {
            assert compiler.inAtPre
            compiler.inAtPre := false
        }
    }

    constant POINTER_NAME := "panda.unsafe.Pointer"
    constant WEAK_NAME := "panda.core.Weak"
    constant RANGE_NAME := "panda.core.Range"
    constant STEPPED_RANGE_NAME := "panda.core.SteppedRange"

    class Settings : Immutable {
        def pandaHome:File

        def importDirs:ImmutableArray<File>

        def optimizationLevel:Int

        def safetyLevel:Int

        init(pandaHome:File, importDirs:ListView<File>, optimizationLevel:Int, safetyLevel:Int) {
            self.pandaHome := pandaHome
            self.importDirs := ImmutableArray<File>(importDirs)
            self.optimizationLevel := optimizationLevel
            self.safetyLevel := safetyLevel
        }
    }

    constant NONNULLABLE_TO_NULLABLE_CAST_COST := 1
    constant NULLABLE_TO_NONNULLABLE_CAST_COST := 2

    def settings:Settings

    def parser:Parser

    def scanner:Scanner

    def root:SymbolTable

    var compiling:ClassDecl? := null

    var compilationQueue := Array<ClassDecl>()

    @private
    def scans := HashMap<File, ListView<ClassDecl>>()

    @private
    def classes := HashMap<String, ClassDecl>()

    @private
    def currentClass := Stack<ClassDecl>()

    @private
    def currentMethod := Stack<MethodDecl>()

    @private
    var ir := IR()

    @private
    var symbolTable:SymbolTable

    @private
    def codeGenerator:CodeGenerator

    @private
    def errorQueue:MessageQueue<Error>

    @private
    def enclosingContexts := Stack<EnclosingContext>()

    @private
    var errorCount := 0

    @private
    var closureCount := 0

    @private
    var existenceCache := HashMap<File, Bit>()

    @private
    var reportErrors := true

    @private
    def pendingClasses := Array<ClassDecl>()

    @private
    var inAtPre := false

    init(errorQueue:MessageQueue<Error>, codeGenerator:CodeGenerator, settings:Settings) {
        self.settings := settings
        self.scanner := Scanner(self)
        self.root := SymbolTable(self)
        self.parser := Parser(errorQueue)
        self.symbolTable := root
        self.codeGenerator := codeGenerator
        self.errorQueue := errorQueue
        codeGenerator.setCompiler(self)
        root.add(Type("builtin_bit", Type.Kind.BUILTIN_BIT, 1))
        root.add(Type.BuiltinInt8())
        root.add(Type.BuiltinInt16())
        root.add(Type.BuiltinInt32())
        root.add(Type.BuiltinInt64())
        root.add(Type.BuiltinUInt8())
        root.add(Type.BuiltinUInt16())
        root.add(Type.BuiltinUInt32())
        root.add(Type.BuiltinUInt64())
        root.add(Type.BuiltinFloat32())
        root.add(Type.BuiltinFloat64())
        root.add(Alias("Int", "panda.core.Int64", Position()))
        root.add(Alias("UInt", "panda.core.UInt64", Position()))
        root.add(Alias("Real", "panda.core.Real64", Position()))
        addAlias("panda.collections.Array")
        addAlias("panda.collections.Collection")
        addAlias("panda.collections.CollectionView")
        addAlias("panda.collections.CollectionWriter")
        addAlias("panda.collections.HashSet")
        addAlias("panda.collections.IdentityMap")
        addAlias("panda.collections.ImmutableArray")
        addAlias("panda.collections.ImmutableHashMap")
        addAlias("panda.collections.Iterable")
        addAlias("panda.collections.Iterator")
        addAlias("panda.collections.Key")
        addAlias("panda.collections.List")
        addAlias("panda.collections.ListView")
        addAlias("panda.collections.ListWriter")
        addAlias("panda.collections.HashMap")
        addAlias("panda.collections.Map")
        addAlias("panda.collections.MapView")
        addAlias("panda.collections.MapWriter")
        addAlias("panda.collections.SpecializedArray")
        addAlias("panda.collections.Stack")
        addAlias("panda.core.Class")
        addAlias("panda.core.Bit")
        addAlias("panda.core.Char8")
        addAlias("panda.core.Char16")
        addAlias("panda.core.Char32")
        addAlias("panda.core.Comparable")
        addAlias("panda.core.Equatable")
        addAlias("panda.core.Formattable")
        addAlias("panda.core.Int8")
        addAlias("panda.core.Int16")
        addAlias("panda.core.Int32")
        addAlias("panda.core.Int64")
        addAlias("panda.core.Immutable")
        addAlias("panda.core.Method")
        addAlias("panda.core.MutableString")
        addAlias("panda.core.Object")
        addAlias("panda.core.Panda")
        addAlias("panda.core.Range")
        addAlias("panda.core.Real32")
        addAlias("panda.core.Real64")
        addAlias("panda.core.RegularExpression")
        addAlias("panda.core.SimpleRange")
        addAlias("panda.core.SteppedRange")
        addAlias("panda.core.String")
        addAlias("panda.core.System")
        addAlias("panda.core.UInt8")
        addAlias("panda.core.UInt16")
        addAlias("panda.core.UInt32")
        addAlias("panda.core.UInt64")
        addAlias("panda.core.Value")
        addAlias("panda.core.Weak")
        addAlias("panda.math.MersenneTwister")
        addAlias("panda.math.Random")
        addAlias("panda.math.XorShift128Plus")
        addAlias("panda.io.Console")
        addAlias("panda.io.File")
        addAlias("panda.io.IndentedOutputStream")
        addAlias("panda.io.InputStream")
        addAlias("panda.io.LineNumberInputStream")
        addAlias("panda.io.MemoryInputStream")
        addAlias("panda.io.MemoryOutputStream")
        addAlias("panda.io.OutputStream")
        addAlias("panda.io.PushbackInputStream")
        addAlias("panda.threads.Lock")
        addAlias("panda.threads.MessageQueue")
        addAlias("panda.threads.Notifier")
        addAlias("panda.threads.ScopedLock")
        addAlias("panda.threads.Thread")
        addAlias("panda.json.JSON")
        addAlias("panda.json.JSONParser")
    }

    @private
    method addAlias(name:String) {
        root.add(Alias(name[name.next(name.lastIndexOf("."))..], name, Position()))
    }

    method isRefCounted(type:Type):Bit {
        if !type.isClass() {
            return false
        }
        return !isValue(type)
    }

    ================================================================================================
    Attempts to locate a class with the given, possibly not-fully-qualified, class name. Returns
    null and does not report any errors on failure.
    ================================================================================================
    @post(currentClass.count = @pre(currentClass.count))
    method tryResolveClass(name:String):ClassDecl? {
        def current:ClassDecl?
        if currentClass.count > 0 {
            current := currentClass[0]
        }
        else {
            current := null
        }
        if current != null {
            var result := current.classResolutionCache[name]
            if result != null {
                return result.value
            }
            def alias := current.aliases[name]
            if alias != null {
                result := ClassDecl.Resolution(getClass(alias))
                current.classResolutionCache[name] := result
                return result.value
            }
        }
        var result := getClass(name)
        if current != null {
            if result = null {
                def idx := current.name.lastIndexOf(".")
                if idx != null {
                    result := getClass(current.name[...idx] + name)
                }
            }
            if result = null {
                result := getClass(current.name + "." + name)
            }
            if result = null & current.owner != null {
                currentClass.push(current.owner)
                result := tryResolveClass(name)
                currentClass.pop()
            }
        }
        if result = null {
            def rootAlias := root[name]
            if rootAlias != null & rootAlias.kind = Symbol.Kind.ALIAS {
                result := getClass(rootAlias->Alias.fullName)
            }
        }
        if result = null {
            def index := name.lastIndexOf(".")
            if index != null {
                -- could be an inner class name; see if we can locate an enclosing class
                def parent := tryResolveClass(name[..index])
                if parent != null {
                    result := getClass(parent.name + name[index..])
                }
            }
        }
        if current != null {
            current.classResolutionCache[name] := ClassDecl.Resolution(result)
        }
        return result
    }

    function typeParameters(type:Type):ListView<Type> {
        match type.typeKind {
            when Type.Kind.GENERIC_PARAMETER:
                return typeParameters(type.genericParameter.bound)
            when Type.Kind.GENERIC:
                assert type.subtypes.count >= 2
                return type.subtypes[1..]
            when Type.Kind.NULLABLE:
                return typeParameters(type.subtypes[0])
            otherwise:
                return Array<Type>()
        }
    }

    ================================================================================================
    Verifies that a type uses the correct number and kind of generic parameters for the class it
    refers to. Reports error(s) and returns false if the type is not valid.
    ================================================================================================
    method checkGenericParameters(position:Position, cl:ClassDecl, type:Type):Bit {
        resolve(cl)
        assert type.resolved
        def expectedCount := cl.parameters.count
        def foundTypes := typeParameters(type)
        def foundCount := foundTypes.count
        if expectedCount != foundCount {
            error(position, "'\{cl.name}' expected \{expectedCount} generic " +
                    "argument\{expectedCount = 1:|s}, but found \{foundCount}")
            return false
        }
        def object := Type.Object()
        for i in 0 .. expectedCount {
            def bound := cl.parameters[i].bound
            if bound = object | (bound.typeKind = Type.Kind.NULLABLE & bound.subtypes[0] = object) {
                continue
            }
            if coercionCost(foundTypes[i], remapType(type, bound)) = null {
                error(position, "generic parameter '\{cl.name}.\{cl.parameters[i].name}' must be " +
                        "of type '\{cl.parameters[i].bound}', but found '\{foundTypes[i]}'")
                return false
            }
        }
        return true
    }

    @post(@return = null | @return.resolved)
    method resolve(type:Type, checkParameters:Bit):Type? {
        if type.resolved {
            return type
        }
        match type.typeKind {
            when Type.Kind.CLASS:
                def resolved := tryResolveClass(type.name)
                if resolved != null {
                    def result := resolved.type
                    if result != null & checkParameters &
                            !checkGenericParameters(type.position, resolved, result) {
                        return null
                    }
                    return result
                }
                def s := symbolTable[type.name]
                if s != null {
                    match s.kind {
                        when Symbol.Kind.ALIAS:
                            return Type(s->Alias.fullName, Type.Kind.CLASS, type.position, true)
                        when Symbol.Kind.GENERIC_PARAMETER:
                            def gp := s->ClassDecl.GenericParameter
                            resolve(getClass(type.position, gp.owner))
                            return Type(gp)
                        when Symbol.Kind.TYPE:
                            return s->Type
                    }
                }
                error(type.position, "unknown type '\{type}'")
                return null
            when Type.Kind.NULLABLE:
                assert type.subtypes.count = 1
                def subtypes := Array<Type>()
                def sub := resolve(type.subtypes[0])
                if sub = null {
                    return null
                }
                subtypes.add(sub)
                return Type(subtypes[0].name + "?", Type.Kind.NULLABLE, type.position, subtypes, true)
            when Type.Kind.GENERIC:
                assert type.subtypes.count >= 2
                def base := resolve(type.subtypes[0], false)
                if base = null {
                    return null
                }
                def args := Array<Type>()
                for i in 1 .. type.subtypes.count {
                    def resolved := resolve(type.subtypes[i])
                    if resolved = null {
                        return null
                    }
                    args.add(resolved)
                }
                def result := Type.generic(base, args)
                def cl := getClass(result.subtypes[0])
                if cl != null & checkParameters &
                        !checkGenericParameters(type.position, cl, result) {
                    return null
                }
                return result
            when Type.Kind.METHOD, Type.Kind.FUNCTION, Type.Kind.IMMUTABLE_METHOD,
                    Type.Kind.IMMUTABLE_FUNCTION:
                def params := Array<Type>()
                for i in 0 .. type.parameterCount {
                    def resolved := resolve(type.parameterType(i))
                    if resolved = null {
                        return null
                    }
                    params.add(resolved)
                }
                def returnType := resolve(type.returnType())
                if returnType = null {
                    return null
                }
                return Type.methodType(type.position, type.typeKind, params, returnType)
            otherwise:
                assert false, "cannot resolve \{type}"
        }
    }

    method resolve(type:Type):Type? {
        return resolve(type, true)
    }

    method addAllSupertypes(cl:ClassDecl, set:HashSet<String>) {
        if set.contains(cl.name) {
            return
        }
        set.add(cl.name)
        resolve(cl)
        if cl.rawSuper != null {
            def superclass := getClass(cl.rawSuper)
            if superclass != null {
                addAllSupertypes(superclass, set)
            }
        }
        for intfType in cl.rawInterfaces {
            def intf := getClass(intfType)
            if intf != null {
                addAllSupertypes(intf, set)
            }
        }
    }

    @post(currentClass.count = @pre(currentClass.count))
    method resolve(cl:ClassDecl) {
        if cl.resolved != Resolution.UNRESOLVED {
            return
        }
        cl.resolved := Resolution.IN_PROGRESS
        currentClass.push(cl)
        def old := symbolTable
        symbolTable := cl.symbolTable
        for p in cl.parameters {
            def resolved := resolve(p.bound, false)
            if resolved != null {
                p.bound := resolved
            }
            else {
                cl.resolved := Resolution.RESOLVED_WITH_ERRORS
                currentClass.pop(cl)
                return
            }
        }
        def supertypes := HashSet<String>()
        for rawS in cl.declaredSupers {
            def s := resolve(rawS, false)
            if s != null {
                def sClass := getClass(s)
                if sClass != null {
                    resolve(sClass)
                    addAllSupertypes(sClass, supertypes)
                    if sClass.classKind = ClassDecl.Kind.CLASS {
                        if cl.classKind = ClassDecl.Kind.INTERFACE {
                            error(s.position, "interface '\{cl.name}' cannot extend class " +
                                    "'\{s.name}'")
                        }
                        if cl.rawSuper = null {
                            cl.rawSuper := s
                            if cl.rawInterfaces.count > 0 {
                                error(s.position, "superclass '\{s}' of class '\{cl.name}' must be " +
                                        "listed before any superinterfaces")
                            }
                        }
                        else {
                            error(s.position, "class '\{cl.name}' has more than one superclass")
                        }
                    }
                    else {
                        assert sClass.classKind = ClassDecl.Kind.INTERFACE
                        cl.rawInterfaces.add(s)
                    }
                }
                else {
                    cl.resolved := Resolution.RESOLVED_WITH_ERRORS
                    currentClass.pop(cl)
                    return
                }
            }
        }
        if cl.rawSuper = null & cl.name != "panda.core.Object" {
            cl.rawSuper := Type.Object()
        }
        if cl.rawSuper != null & !cl.annotations.isFinal() &
                cl.rawSuper.name = "panda.core.Value" {
            cl.annotations.flags ||= Annotations.Flag.FINAL
            for m in cl.methods {
                m.annotations.flags ||= Annotations.Flag.FINAL
                if scanner.shouldInline(m.annotations, m.body) {
                    m.annotations.flags ||= Annotations.Flag.INLINE
                }
            }
        }
        if supertypes.contains(cl.name) {
            error(cl.position, "circular inheritance; '\{cl.name}' inherits from itself")
            cl.resolved := Resolution.RESOLVED_WITH_ERRORS
        }
        if cl.rawSuper != null {
            def superclass := getClass(cl.rawSuper)
            if superclass != null {
                checkGenericParameters(cl.position, superclass, cl.rawSuper)
            }
        }
        for intf in cl.rawInterfaces {
            def intfclass := getClass(intf)
            if intfclass != null {
                checkGenericParameters(cl.position, intfclass, intf)
            }
        }
        for p in cl.parameters {
            def cl := getClass(p.bound)
            if cl != null {
                checkGenericParameters(cl.position, cl, p.bound)
            }
        }
        for cc in cl.choiceCases {
            resolve(cc)
        }
        if cl.resolved = Resolution.IN_PROGRESS {
            cl.resolved := Resolution.RESOLVED
        }
        symbolTable := old
        currentClass.pop()
    }

    @post(currentClass.count = @pre(currentClass.count))
    method resolve(m:MethodDecl):Bit {
        if m.resolved != Resolution.UNRESOLVED {
            return m.resolved = Resolution.RESOLVED
        }
        m.resolved := Resolution.IN_PROGRESS
        resolve(m.owner)
        currentClass.push(m.owner)
        def symbols := AutoSymbolTable(self, SymbolTable(m.owner.symbolTable))
        if m.genericParameters != null {
            for p in m.genericParameters {
                symbolTable.add(Type(p), p.name)
            }
        }
        for p in m.parameters {
            def resolved := resolve(p.type)
            if resolved != null {
                p.type := resolved
            }
            else {
                m.resolved := Resolution.RESOLVED_WITH_ERRORS
            }
        }
        if m.methodKind = MethodDecl.Kind.INIT {
            if isValue(m.owner) {
                m.returnType := m.owner.type
            }
        }
        else {
            def resolved := resolve(m.returnType)
            if resolved != null {
                m.returnType := resolved
            }
            else {
                m.resolved := Resolution.RESOLVED_WITH_ERRORS
            }
        }
        if m.resolved = Resolution.IN_PROGRESS {
            m.resolved := Resolution.RESOLVED
        }
        if !m.owner.external {
            def overridden := getOverriddenMethod(m)
            if overridden != null {
                if !m.annotations.isOverride() {
                    error(m.position, "\{m.declaration()} overrides \{overridden.declaration()}, " +
                            "but is not marked @override")
                }
                if m.methodKind = MethodDecl.Kind.METHOD &
                        overridden.methodKind = MethodDecl.Kind.FUNCTION {
                    error(m.position, "\{m.declaration()} overrides \{overridden.declaration()}, " +
                            "but methods cannot override functions")
                }
            }
            else if m.annotations.isOverride() {
                error(m.position, "\{m.declaration()} is marked @override, but no matching " +
                        "method exists among its ancestors")
            }
        }
        currentClass.pop()
        return m.resolved = Resolution.RESOLVED
    }

    method determineRawType(f:FieldDecl) {
        currentClass.push(f.owner)
        def old := symbolTable
        symbolTable := f.owner.symbolTable
        if f.type != Type.Void() {
            def resolved := resolve(f.type)
            if resolved != null {
                f.type := resolved
            }
            currentClass.pop()
            symbolTable := old
            return
        }
        if f.rawValue = null {
            error(f.position, "field has neither a type nor a value")
            currentClass.pop()
            symbolTable := old
            return
        }
        def preferred := preferredType(f.rawValue)
        if preferred = null {
            currentClass.pop()
            symbolTable := old
            return
        }
        f.type := preferred
        currentClass.pop()
        symbolTable := old
    }

    method resolve(f:FieldDecl):Bit {
        if f.resolved = Resolution.UNRESOLVED {
            f.resolved := Resolution.IN_PROGRESS
            if f.owner.classKind != ClassDecl.Kind.INTERFACE {
                -- we need to mark that we are in an instance context so 'self' works. Since the
                -- class is guaranteed to have at least one init method, we just pretend we're in
                -- one of those.
                def firstInit:MethodDecl? := null
                for m in f.owner.methods {
                    if m.methodKind = MethodDecl.Kind.INIT {
                        firstInit := m
                        break
                    }
                }
                assert firstInit != null | errorCount > 0,
                        "class \{f.owner.name} has no init methods"
                if firstInit = null {
                    f.resolved := Resolution.RESOLVED_WITH_ERRORS
                    return false
                }
                currentMethod.push(firstInit)
                determineRawType(f)
                currentMethod.pop(firstInit)
            }
            else {
                def old := currentMethod
                currentMethod := Stack<MethodDecl>()
                determineRawType(f)
                currentMethod := old
            }
            if f.type != Type.Void() & f.type.resolved {
                f.resolved := Resolution.RESOLVED
            }
            else {
                f.resolved := Resolution.RESOLVED_WITH_ERRORS
            }
            if f.annotations.isWeak() & f.type != Type.Void() {
                f.type := Type.WeakOf(f.type)
            }
        }
        return f.resolved = Resolution.RESOLVED
    }

    @post(currentClass.count = @pre(currentClass.count))
    method resolve(c:ChoiceCase) {
        if c.resolved != Resolution.UNRESOLVED {
            return
        }
        if c.fields.count = 0 {
            c.resolved := Resolution.RESOLVED
            createChoiceCaseInit(c)
            return
        }
        c.resolved := Resolution.IN_PROGRESS
        currentClass.push(c.owner)
        def old := symbolTable
        symbolTable := c.owner.symbolTable
        for i in 0 .. c.fields.count {
            def resolved := resolve(c.fields[i])
            if resolved != null {
                c.fields[i] := resolved
            }
            else {
                c.fields[i] := Type.Invalid()
                c.resolved := Resolution.RESOLVED_WITH_ERRORS
            }
        }
        if c.resolved = Resolution.IN_PROGRESS {
            c.resolved := Resolution.RESOLVED
        }
        createChoiceCaseInit(c)
        symbolTable := old
        currentClass.pop()
    }

    method isValue(cl:ClassDecl):Bit {
        resolve(cl)
        return cl.rawSuper != null & cl.rawSuper.name = "panda.core.Value"
    }

    method isValue(t:Type):Bit {
        if !t.isClass() {
            return true
        }
        def cl := getClass(t)
        if cl = null {
            return false
        }
        return isValue(cl)
    }

    method isImmutable(cl:ClassDecl):Bit {
        resolve(cl)
        if cl.resolved != Resolution.RESOLVED {
            return false
        }
        if cl.name = "panda.core.Immutable" {
            return true
        }
        if cl.rawSuper != null {
            def superclass := getClass(cl.rawSuper)
            if superclass = null {
                return false
            }
            return isImmutable(superclass)
        }
        return false
    }

    method isImmutable(t:Type):Bit {
        if !t.isClass() {
            return true
        }
        def cl := getClass(t)
        if cl = null {
            return false
        }
        return isImmutable(cl)
    }

    method instanceFields(cl:ClassDecl):ListView<FieldDecl> {
        resolve(cl)
        def result := Array<FieldDecl>()
        if !isValue(cl) & cl.rawSuper != null {
            def s := getClass(cl.rawSuper)
            if s != null {
                result.addAll(instanceFields(s))
            }
        }
        for f in cl.fields {
            if !f.annotations.isClass() & f.fieldKind != FieldDecl.Kind.PROPERTY {
                result.add(f)
            }
        }
        return result
    }

    method exists(f:File):Bit {
        var result := existenceCache[f]
        if result = null {
            result := f.exists()
            existenceCache[f] := result
        }
        return result
    }

    ================================================================================================
    Attempts to load the class with the given fully-qualified name. Returns null on failure, without
    reporting an error.
    ================================================================================================
    method getClass(fullName:String):ClassDecl? {
        var result := classes[fullName]
        if result = null {
            def suffix := fullName.replace(".", "/") + ".panda"
            var found := false
            for dir in settings.importDirs {
                def f := dir.resolve(suffix)
                if exists(f) {
                    found := true
                    scan(f)
                    result := classes[fullName]
                }
            }
        }
        if result = null {
            def index := fullName.lastIndexOf(".")
            if index != null {
                def parent := getClass(fullName[..index])
                if parent != null {
                    result := classes[fullName]
                }
            }
        }
        return result
    }

    method getClass(position:Position, fullName:String):ClassDecl? {
        var result := classes[fullName]
        if result = null {
            def suffix := fullName.replace(".", "/") + ".panda"
            var found := false
            for dir in settings.importDirs {
                def f := dir.resolve(suffix)
                if exists(f) {
                    found := true
                    def oldErrorCount := errorCount
                    scan(f)
                    result := classes[fullName]
                    if result = null & errorCount = oldErrorCount {
                        error(f, Position(1, 1),
                                "expected file '\{f}' to contain a class named '\{fullName}'")
                    }
                }
            }
            if !found {
                error(position, "no file named \{suffix} in any import path (\{settings.importDirs})")
            }
        }
        return result
    }

    @post(currentClass.count = @pre(currentClass.count))
    method specialize(cl:ClassDecl, rawType:Type):ClassDecl {
        resolve(cl)
        def type := resolve(rawType)
        if type.typeKind = Type.Kind.NULLABLE {
            return specialize(cl, type.subtypes[0])
        }
        if type.typeKind = Type.Kind.CLASS {
            return cl
        }
        assert type.typeKind = Type.Kind.GENERIC
        def result:ClassDecl? := classes[type.name]
        if result = null {
            currentClass.push(cl)
            def annotations := Annotations(cl.annotations.flags && !!Annotations.Flag.SPECIALIZE)
            def supertypes := Array<Type>()
            supertypes.add(remapType(type, cl.rawSuper))
            for intf in cl.rawInterfaces { -- FIXME use map
                supertypes.add(remapType(type, intf))
            }
            def aliases := HashMap<String, String>(cl.aliases)
            for i in 0 .. cl.parameters.count {
                aliases[cl.parameters[i].name] := type.subtypes[i + 1].name
            }
            result := ClassDecl(cl.source, cl.position, aliases, cl.doccomment, annotations,
                    cl.classKind, type, supertypes, Array<ClassDecl.GenericParameter>(),
                    cl.symbolTable.parents[0])
            result.external := false
            for m in cl.methods {
                resolve(m)
                def generics:Array<ClassDecl.GenericParameter>?
                if m.genericParameters != null {
                    for p in m.genericParameters {
                        generics.add(ClassDecl.GenericParameter(p.position, p.owner, p.name,
                                remapType(type, p.bound)))
                    }
                }
                def parameters := Array<MethodDecl.Parameter>() -- FIXME use map
                for p in m.parameters {
                    parameters.add(MethodDecl.Parameter(p.name, remapType(type, p.type)))
                }
                def clone := MethodDecl(result, m.position, m.doccomment, m.annotations,
                        m.methodKind, m.name, generics, parameters, remapType(type, m.returnType),
                        m.body)
                result.methods.add(clone)
                result.symbolTable.add(clone)
            }
            for f in cl.fields {
                resolve(f)
                def clone := FieldDecl(result, f.position, f.doccomment, f.annotations, f.fieldKind,
                        f.name, remapType(type, f.type), f.rawValue)
                result.fields.add(clone)
                result.symbolTable.add(clone)
            }
            classes[result.name] := result
            compilationQueue.add(result)
            currentClass.pop()
            resolve(result)
        }
        return result
    }

    @pre(type.resolved)
    method getClass(type:Type):ClassDecl? {
        var result:ClassDecl
        match type.typeKind {
            when Type.Kind.CLASS:
                result := getClass(type.position, type.name)
            when Type.Kind.NULLABLE, Type.Kind.GENERIC:
                result := getClass(type.subtypes[0])
            when Type.Kind.GENERIC_PARAMETER:
                return getClass(type.genericParameter.bound)
            when Type.Kind.METHOD, Type.Kind.FUNCTION:
                return getClass(Type.MutableMethod())
            when Type.Kind.IMMUTABLE_METHOD, Type.Kind.IMMUTABLE_FUNCTION:
                return getClass(Type.Method())
            otherwise:
                error(type.position, "type '\{type}' is not a class")
                return null
        }
        if result != null & result.annotations.isSpecialize() {
            result := specialize(result, type)
        }
        return result
    }

    method allInterfaces(t:Type):HashSet<Type> {
        def result := HashSet<Type>()
        def cl := getClass(t)
        if cl != null {
            resolve(cl)
            if cl.resolved = Resolution.RESOLVED {
                if cl.rawSuper != null {
                    result.addAll(allInterfaces(remapType(t, cl.rawSuper)))
                }
                for intf in cl.rawInterfaces {
                    result.addAll(allInterfaces(remapType(t, intf)))
                }
                if cl.classKind = ClassDecl.Kind.INTERFACE {
                    result.add(t)
                }
            }
        }
        return result
    }

    function signatureMatch(t1:Type, t2:Type):Bit {
        assert t1.isMethod()
        assert t2.isMethod()
        if t1.subtypes.count != t2.subtypes.count {
            return false
        }
        for i in 0 .. t1.subtypes.count {
            if t1.subtypes[i] != t2.subtypes[i] {
                return false
            }
        }
        return true
    }

    method findMethod(owner:Type, name:String, methodType:Type, checkInterfaces:Bit):MethodDecl? {
        def cl := getClass(owner)
        if cl = null {
            return null
        }
        resolve(cl)
        for test in cl.methods {
            if test.name = name {
                resolve(test)
                if signatureMatch(remapType(owner, declaredType(test)), methodType) {
                    return test
                }
            }
        }
        for raw in cl.rawInterfaces {
            def result := findMethod(remapType(owner, raw), name, methodType, checkInterfaces)
            if result != null & (checkInterfaces | cl.classKind = ClassDecl.Kind.INTERFACE |
                    result.body != null) {
                return result
            }
        }
        if cl.rawSuper != null {
            return findMethod(remapType(owner, cl.rawSuper), name, methodType, checkInterfaces)
        }
        return null
    }

    function getOverriddenMethod(m:MethodDecl):MethodDecl? {
        if m.overrideKnown {
            return m.overridden
        }
        if m.methodKind = MethodDecl.Kind.INIT {
            m.overrideKnown := true
            return null
        }
        resolve(m)
        def methodType := declaredType(m)
        def owner := m.owner.typeWithParameters()
        for raw in m.owner.rawInterfaces {
            def result := findMethod(remapType(owner, raw), m.name, methodType, true)
            if result != null {
                m.overrideKnown := true
                m.overridden := result
                return result
            }
        }
        resolve(m.owner)
        if m.owner.rawSuper != null {
            def result := findMethod(remapType(owner, m.owner.rawSuper), m.name, methodType, true)
            m.overrideKnown := true
            m.overridden := result
            return result
        }
        m.overrideKnown := true
        return null
    }

    method interfaceMethods(cl:ClassDecl, intf:Type):ListView<MethodDecl> {
        def intfClass := getClass(intf)
        assert intfClass != null
        def result := Array<MethodDecl>()
        for m in intfClass.methods {
            if m.annotations.isClass() {
                continue
            }
            def found := findMethod(cl.type, m.name, remapType(intf, inheritedType(m)), false)
            if found != null {
                result.add(found)
            }
            else if m.body != null {
                result.add(m)
            }
            else {
                error(cl.position, "class '\{cl.name}' does not implement interface " +
                        m.declaration())
            }
        }
        return result
    }

    method checkInterfaceMethods() {
        def cl := currentClass[0]
        for intf in allInterfaces(cl.type) {
            interfaceMethods(cl, intf)
        }
    }

    method getSymbolTable(cl:ClassDecl):SymbolTable {
        if !cl.symbolTableResolved {
            cl.symbolTableResolved := true
            resolve(cl)
            if cl.resolved = Resolution.RESOLVED {
                if cl.rawSuper != null {
                    def superCl := getClass(cl.rawSuper)
                    if superCl != null {
                        cl.symbolTable.parents.add(getSymbolTable(superCl))
                    }
                }
                for rawIntf in cl.rawInterfaces {
                    def intf := getClass(rawIntf)
                    if intf != null {
                        cl.symbolTable.parents.add(getSymbolTable(intf))
                    }
                }
                if cl.owner != null {
                    --cl.symbolTable.parents.add(getSymbolTable(cl.owner))
                }
            }
        }
        return cl.symbolTable
    }

    @post(currentClass.count = @pre(currentClass.count))
    method getVTable(cl:ClassDecl):ListView<MethodDecl> {
        if cl.virtualMethods.count = 0 {
            resolve(cl)
            currentClass.push(cl) -- FIXME Auto
            if cl.rawSuper != null {
                def superCl := getClass(cl.rawSuper)
                if superCl = null {
                    currentClass.pop()
                    return cl.virtualMethods
                }
                cl.virtualMethods.addAll(getVTable(superCl))
            }
            for derived in cl.methods {
                resolve(derived)
                if derived.methodKind = MethodDecl.Kind.INIT | derived.annotations.isClass() {
                    continue
                }
                var found := false
                for i in 0 .. cl.virtualMethods.count {
                    def base := cl.virtualMethods[i]
                    resolve(base)
                    def overridden := getOverriddenMethod(derived)
                    if overridden != null & (overridden == base |
                                overridden == getOverriddenMethod(base)) {
                        found := true
                        cl.virtualMethods[i] := derived
                        break
                    }
                }
                if !found {
                    cl.virtualMethods.add(derived)
                }
            }
            currentClass.pop()
        }
        return cl.virtualMethods
    }

    function remapType(context:Type, raw:Type):Type {
        if context.typeKind = Type.Kind.GENERIC & context.subtypes[0] = Type.Class() {
            return remapType(context.subtypes[1], raw)
        }
        match raw.typeKind {
            when Type.Kind.CLASS, Type.Kind.BUILTIN_INT, Type.Kind.BUILTIN_UINT,
                    Type.Kind.BUILTIN_BIT:
                return raw
        }
        match context.typeKind {
            when Type.Kind.NULLABLE:
                assert context.subtypes.count = 1
                return remapType(context.subtypes[0], raw)
            when Type.Kind.GENERIC:
                assert context.subtypes.count >= 2
                def typeMap := HashMap<String, Type>()
                def base := context.subtypes[0]
                def cl := tryResolveClass(base.name)
                assert cl != null
                for i in 1 .. context.subtypes.count {
                    typeMap[cl.name + "." + cl.parameters[i - 1].name] := context.subtypes[i]
                }
                return raw.remap(typeMap)
            otherwise:
                return raw
        }
    }

    function preferredType(type:Type):Type {
        if type.typeKind = Type.Kind.INT_LITERAL {
            return Type.Int64()
        }
        if type.typeKind = Type.Kind.REAL_LITERAL {
            return Type.Real64()
        }
        if type = Type.BitLiteral() {
            return Type.Bit()
        }
        if type.typeKind = Type.Kind.NULL {
            return Type.Any()
        }
        return type
    }

    method preferredType(expr:ASTNode):Type? {
        match expr {
            when ASTNode.BIT:
                return Type.Bit()
            when ASTNode.INT:
                return Type.Int64()
        }
        def possible := possibleTypes(expr)
        if possible = null {
            return null
        }
        if possible.count = 1 {
            return possible[0]
        }
        error(expr.position(), "expression type is ambiguous")
        return null
    }

    method coercionCost(type:Type, target:Type):Int? {
        assert type.resolved, "unresolved type '\{type}'"
        assert target.resolved, "unresolved type '\{target}'"
        if type = target {
            return 0
        }
        if type = Type.Void() {
            return null
        }
        if type.typeKind = Type.Kind.NULL {
            if target.typeKind = Type.Kind.NULLABLE {
                return 0
            }
            return null
        }
        if type.typeKind = Type.Kind.NULLABLE & target.typeKind != Type.Kind.NULLABLE {
            def result := coercionCost(type.subtypes[0], target)
            if result = null {
                return null
            }
            return result + NULLABLE_TO_NONNULLABLE_CAST_COST
        }
        match target.typeKind {
            when Type.Kind.NULLABLE:
                def result := coercionCost(type, target.subtypes[0])
                if result = null {
                    return null
                }
                return result + NONNULLABLE_TO_NULLABLE_CAST_COST
            when Type.Kind.GENERIC_PARAMETER:
                return null
            when Type.Kind.BUILTIN_INT, Type.Kind.BUILTIN_UINT:
                return null
            when Type.Kind.CLASS:
                if type.typeKind = Type.Kind.GENERIC {
                    return coercionCost(type.subtypes[0], target)
                }
        }
        if type.isMethod() {
            if target.isMethod() {
                if type.subtypes.count != target.subtypes.count {
                    return null
                }
                var total := 0
                def srcFunction:Bit
                def srcMutable:Bit
                match type.typeKind {
                    when Type.Kind.METHOD:
                        srcFunction := false
                        srcMutable := true
                    when Type.Kind.FUNCTION:
                        srcFunction := true
                        srcMutable := true
                    when Type.Kind.IMMUTABLE_METHOD:
                        srcFunction := false
                        srcMutable := false
                    when Type.Kind.IMMUTABLE_FUNCTION:
                        srcFunction := true
                        srcMutable := false
                }
                def targetFunction:Bit
                def targetMutable:Bit
                match target.typeKind {
                    when Type.Kind.METHOD:
                        targetFunction := false
                        targetMutable := true
                    when Type.Kind.FUNCTION:
                        targetFunction := true
                        targetMutable := true
                    when Type.Kind.IMMUTABLE_METHOD:
                        targetFunction := false
                        targetMutable := false
                    when Type.Kind.IMMUTABLE_FUNCTION:
                        targetFunction := true
                        targetMutable := false
                }
                if targetFunction & !srcFunction {
                    return null
                }
                if !targetMutable & srcMutable {
                    return null
                }
                if targetFunction != srcFunction {
                    total += 1
                }
                if targetMutable != srcMutable {
                    total += 1
                }
                for i in 0 .. type.subtypes.count {
                    def cost := coercionCost(type.subtypes[i], target.subtypes[i])
                    if cost = null {
                        return null
                    }
                    total += cost
                }
                return total
            }
            if type.typeKind = Type.Kind.IMMUTABLE_METHOD |
                    type.typeKind = Type.Kind.IMMUTABLE_FUNCTION {
                def result := coercionCost(Type.Method(), target)
                if result != null {
                    return result
                }
            }
            return coercionCost(Type.MutableMethod(), target)
        }
        match type.typeKind {
            when Type.Kind.BUILTIN_BIT:
                return coercionCost(Type.Bit(), target)
            when Type.Kind.UNRESOLVED:
                var best:Int? := null
                for t in type.subtypes {
                    def cost := coercionCost(t, target)
                    if cost != null & (best = null | cost < best) {
                        best := cost
                    }
                }
                return best
            when Type.Kind.GENERIC_PARAMETER:
                return coercionCost(type.genericParameter.bound, target)
        }
        if !target.isClass() {
            return null
        }
        if !type.isClass() {
            return null
        }
        def cl := getClass(type)
        if cl = null {
            return null
        } 
        resolve(cl)
        for m in cl.methods {
            if m.annotations.isImplicit() & m.parameters.count = 1 {
                resolve(m)
                if type = m.parameters[0].type {
                    if cl.name = "panda.core.Int64" {
                        return 1
                    }
                    return 2
                }
            }
        }
        if cl.resolved != Resolution.RESOLVED_WITH_ERRORS {
            if cl.rawSuper != null {
                var cost := coercionCost(remapType(type, remapType(type, cl.rawSuper)), target)
                if cost != null {
                    return cost + 1
                }
            }
            for intf in cl.rawInterfaces {
                var cost := coercionCost(remapType(type, remapType(type, intf)), target)
                if cost != null {
                    return cost + 1
                }
            }
        }
        return null
    }

    method coercionCost(type:Type, target:TypeContext):Int? {
        match target {
            when TypeContext.UNSPECIFIED:
                return 0
            when TypeContext.IMMUTABLE:
                if isImmutable(type) {
                    return 0
                }
                return null
            when TypeContext.TYPE(t):
                return coercionCost(type, t)
        }
    }

    method coercionCost(types:ListView<Type>, target:Type):Int? {
        def best := Int.MAX
        for t in types {
            def cost := coercionCost(t, target)
            if cost != null & cost < best {
                best := cost
            }
        }
        if best != Int.MAX {
            return best
        }
        return null
    }

    method possibleMatches(methodTypes:ListView<Type>, args:ListView<ASTNode>,
            type:TypeContext):Pair<ListView<Type>, Int>? {
        var bestCost := Int.MAX
        def best := Array<Type>()
        outer: for m in methodTypes {
            if m.typeKind != Type.Kind.METHOD &
                    m.typeKind != Type.Kind.FUNCTION &
                    m.typeKind != Type.Kind.IMMUTABLE_METHOD &
                    m.typeKind != Type.Kind.IMMUTABLE_FUNCTION {
                continue
            }
            if m.subtypes.count != args.count + 1 {
                continue
            }
            var cost := 0
            for i in 0 .. args.count {
                def argCost := coercionCost(args[i], m.subtypes[i])
                if argCost = null {
                    continue outer
                }
                cost += argCost
            }
            def returnType := m.returnType()
            match type {
                when TypeContext.IMMUTABLE:
                    if returnType = Type.Void() | !isImmutable(returnType) {
                        continue
                    }
                when TypeContext.TYPE(t):
                    def returnCost := coercionCost(returnType, t)
                    if returnCost = null {
                        continue
                    }
                    cost += returnCost
            }
            if cost < bestCost {
                bestCost := cost
                best.clear()
            }
            if cost = bestCost {
                best.add(m)
            }
        }
        if best.count = 0 {
            return null
        }
        return Pair<ListView<Type>, Int>(best, bestCost)
    }

    method callCost(methodTypes:ListView<Type>, args:ListView<ASTNode>,
            type:TypeContext):Int? {
        def result := possibleMatches(methodTypes, args, type)
        if result != null {
            -- we still might not actually be able to successfully perform the coercion, in the
            -- event that it's ambiguous, but for error reporting purposes we act like it's going to
            -- be ok right now
            return result.second
        }
        return null
    }

    function symbolType(s:Symbol):ListView<Type>? {
        def result := Array<Type>()
        match s.kind {
            when Symbol.Kind.ALIAS:
                def cl := getClass(s->Alias.fullName)
                if cl = null {
                    return null
                }
                result.add(Type.ClassLiteral(cl.type))
            when Symbol.Kind.CHOICE_CASE:
                def cc := s->ChoiceCase
                result.add(cc.owner.type)
            when Symbol.Kind.FIELD:
                def f := s->FieldDecl
                if resolve(f) {
                    result.add(f.type)
                }
                else {
                    return null
                }
            when Symbol.Kind.METHOD:
                if !resolve(s->MethodDecl) {
                    return null
                }
                result.add(s->MethodDecl.type())
            when Symbol.Kind.METHODS:
                for m in s->Methods.methods { -- FIXME use map
                    if resolve(m) {
                        result.add(m.type())
                    }
                }
            when Symbol.Kind.VARIABLE:
                result.add(s->Variable.type)
            otherwise:
                assert false, "cannot reference symbol \{s}"
        }
        return result    
    }

    method dotTypes(base:Type, name:String):ListView<Type>? {
        def cl:ClassDecl
        if base.typeKind = Type.Kind.GENERIC & base.subtypes[0] = Type.Class() {
            -- class literal, grab the class itself rather than panda.core.Class
            cl := getClass(base.subtypes[1])
        }
        else {
            cl := getClass(base)
        }
        if cl = null {
            return null
        }
        def symbol := getSymbolTable(cl)[name]
        if symbol = null {
            return null
        }
        return symbolType(symbol)
    }

    method identifierType(name:String):ListView<Type>? {
        def s := symbolTable[name]
        if s != null {
            return symbolType(s)
        }
        def cl := tryResolveClass(name)
        if cl != null {
            def result := Array<Type>()
            result.add(Type.ClassLiteral(cl.type))
            return result
        }
        return null
    }

    method getText(value:ASTNode):String? {
        match value {
            when ASTNode.IDENTIFIER(_, name):
                return name
            when ASTNode.DOT(_, base, name):
                def baseText := getText(base)
                if baseText = null {
                    return null
                }
                return "\{baseText}.\{name}"
            otherwise:
                return null
        }
    }

    ================================================================================================
    If `value` represents the name of a class, returns the corresponding [ClassDecl]. Otherwise
    returns `null` without reporting an error.
    ================================================================================================
    method tryResolveClassLiteral(value:ASTNode):ClassDecl? {
        def text := getText(value)
        if text != null {
            return tryResolveClass(text)
        }
        return null
    }

    method rangePreferredType(start:ASTNode?, end:ASTNode?, step:ASTNode?):Type? {
        var endpointType:Type? := null
        if start != null {
            def endpointType:Type
            def pref1 := preferredType(start)
            if pref1 = null {
                return null
            }
            if end != null {
                def pref2 := preferredType(end)
                if pref2 = null {
                    return null
                }
                endpointType := pref1.union(self, pref2)
            }
            else {
                endpointType := pref1.nullable()
            }
            if step != null {
                return Type.SteppedRangeOf(endpointType)
            }
            return Type.RangeOf(endpointType)
        }
        else if end != null {
            def pref := preferredType(end)
            if pref = null {
                return null
            }
            if step != null {
                return Type.SteppedRangeOf(pref)
            }
            return Type.RangeOf(pref)
        }
        if step != null {
            return Type.SteppedRangeOf(Type.Int64().nullable())
        }
        return Type.RangeOf(Type.Int64().nullable())
    }

    ================================================================================================
    Returns the types we should consider this expression to potentially be when evaluating method
    calls and field accesses against it. This is not always (nor could it reasonably be) an
    exhaustive list.

    This method never generates errors.
    ================================================================================================
    @post((@return = null | @return.count >= 1) & errorCount = @pre(errorCount))
    method possibleTypes(value:ASTNode):ListView<Type>? {
        match value {
            when ASTNode.BINARY(_, left, op, right):
                match op {
                    when Token.Kind.CAST:
                        def type := resolve(scanner.convertType(right))
                        if type = null {
                            return null
                        }
                        def result := Array<Type>() -- FIXME literal
                        result.add(type)
                        return result
                    when Token.Kind.IDENTITY, Token.Kind.NIDENTITY:
                        def result := Array<Type>() -- FIXME literal
                        result.add(Type.Bit())
                        return result
                    otherwise:
                        def matches := findOverloadedOperator(left, op, right,
                                TypeContext.UNSPECIFIED)
                        if matches != null {
                            def result := Array<Type>() -- FIXME literal
                            for m in matches.first { -- FIXME map
                                result.add(m.returnType)
                            }
                            return result
                        }
                        return null
                }
            when ASTNode.BIT:
                def result := Array<Type>() -- FIXME literal
                result.add(Type.Bit())
                result.add(Type.BuiltinBit())
                return result
            when ASTNode.CALL(_, m, args):
                def methodTypes := possibleTypes(m)
                if methodTypes = null {
                    return null
                }
                if methodTypes.count = 1 & methodTypes[0].isClass() {
                    def cl := getClass(methodTypes[0])
                    if cl != null & cl.classKind = ClassDecl.Kind.CHOICE {
                        -- choice case
                        def result := Array<Type>() -- FIXME literal
                        result.add(methodTypes[0])
                        return result
                    }
                }
                if methodTypes.count = 1 & methodTypes[0].typeKind = Type.Kind.GENERIC &
                        methodTypes[0].subtypes[0] = Type.Class() {
                    -- calling a class literal, this is actually object construction
                    def result := Array<Type>() -- FIXME literal
                    result.add(methodTypes[0].subtypes[1])
                    return result
                }
                def result := possibleMatches(methodTypes, args, TypeContext.UNSPECIFIED)
                if result != null {
                    def resultTypes := Array<Type>() -- FIXME literal
                    for m in result.first {
                        resultTypes.add(m.returnType())
                    }
                    return resultTypes
                }
                return null
            when ASTNode.DOT(position, base, name):
                def cl := tryResolveClassLiteral(value)
                if cl != null {
                    def result := Array<Type>() -- FIXME literal
                    result.add(Type.ClassLiteral(cl.type))
                    return result
                }
                def result:Array<Type>? := null
                def baseTypes := possibleTypes(base)
                if baseTypes = null {
                    return null
                }
                for t in baseTypes {
                    def list := dotTypes(t, name)
                    if list != null {
                        if result = null {
                            result := Array<Type>()
                        }
                        result.addAll(list)
                    }
                }
                return result
            when ASTNode.GENERIC_TYPE, ASTNode.TYPE:
                def t := resolve(scanner.convertType(value))
                if t = null {
                    return null
                }
                def result := Array<Type>() -- FIXME literal
                result.add(Type.ClassLiteral(t))
                return result
            when ASTNode.IDENTIFIER(_, name):
                return identifierType(name)
            when ASTNode.INT:
                def result := Array<Type>() -- FIXME literal
                result.add(Type.BuiltinInt8())
                result.add(Type.BuiltinInt16())
                result.add(Type.BuiltinInt32())
                result.add(Type.BuiltinInt64())
                result.add(Type.BuiltinUInt8())
                result.add(Type.BuiltinUInt16())
                result.add(Type.BuiltinUInt32())
                result.add(Type.BuiltinUInt64())
                result.add(Type.Int8())
                result.add(Type.Int16())
                result.add(Type.Int32())
                result.add(Type.Int64())
                result.add(Type.UInt8())
                result.add(Type.UInt16())
                result.add(Type.UInt32())
                result.add(Type.UInt64())
                result.add(Type.Real32())
                result.add(Type.Real64())
                return result
            when ASTNode.IR_WRAPPER(_, node):
                def a := Array<Type>() -- FIXME literal
                a.add(node.type())
                return a
            when ASTNode.PREFIX(position, op, operand):
                return possibleTypes(ASTNode.CALL(position,
                        ASTNode.DOT(position, operand, operatorName(op)),
                        ImmutableArray<ASTNode>() -* FIXME literal *-))
            when ASTNode.RANGE(_, start, _, end, step):
                def result := rangePreferredType(start, end, step)
                if result = null {
                    return null
                }
                def a := Array<Type>() -- FIXME literal
                a.add(result)
                return a
            when ASTNode.REAL:
                def result := Array<Type>() -- FIXME literal
                result.add(Type.Real32())
                result.add(Type.Real64())
                return result
            when ASTNode.STRING:
                def result := Array<Type>() -- FIXME literal
                result.add(Type.StringType())
                return result
            otherwise:
                assert false, "unsupported possibleType: \{value}:\{value.position()}"
        }
    }

    method binaryCost(left:ASTNode, op:Token.Kind, right:ASTNode, type:TypeContext):Int? {
        if op = Token.Kind.CAST {
            def target := resolve(scanner.convertType(right))
            if target = null {
                return null
            }
            return coercionCost(target, type)
        }
        def result := findOverloadedOperator(left, op, right, type)
        if result != null {
            return result.second
        }
        return null
    }

    method rangeCoercionCost(start:ASTNode?, end:ASTNode?, step:ASTNode?, target:Type):Int? {
        if target.typeKind = Type.Kind.NULLABLE {
            def result := rangeCoercionCost(start, end, step, target.nonnullable())
            if result = null {
                return null
            }
            return result + 1
        }
        if target.typeKind = Type.Kind.GENERIC {
            if target.subtypes[0].name = RANGE_NAME & target.subtypes.count = 2 |
                    target.subtypes[0].name = STEPPED_RANGE_NAME & target.subtypes.count = 3 {
                var cost := 0
                if start != null {
                    def startCost := coercionCost(start, target.subtypes[1])
                    if startCost = null {
                        return null
                    }
                    cost += startCost
                }
                else if target.subtypes[1].typeKind != Type.Kind.NULLABLE {
                    return null
                }
                if end != null {
                    def endCost := coercionCost(end, target.subtypes[1])
                    if endCost = null {
                        return null
                    }
                    cost += endCost
                }
                else if target.subtypes[1].typeKind != Type.Kind.NULLABLE {
                    return null
                }
                if target.subtypes[0].name = RANGE_NAME {
                    if step !== null {
                        return null
                    }
                }
                else {
                    if step == null {
                        return null
                    }
                    def stepCost := coercionCost(step, target.subtypes[2])
                    if stepCost = null {
                        return null
                    }
                    cost += stepCost
                }
                return cost
            }
        }
        def type := preferredType(ASTNode.RANGE(Position(), start, true, end, step))
        if type = null {
            return null
        }
        return coercionCost(type, target)
    }

    @pre(target.resolved)
    method coercionCost(expr:ASTNode, target:Type):Int? {
        match expr {
            when ASTNode.BINARY(_, left, op, right):
                match op {
                    when Token.Kind.CAST:
                        def type := resolve(scanner.convertType(right))
                        if type = null {
                            return null
                        }
                        return coercionCost(type, target)
                    when Token.Kind.IDENTITY, Token.Kind.NIDENTITY:
                        return coercionCost(Type.Bit(), target)
                    otherwise:
                        return binaryCost(left, op, right, TypeContext.TYPE(target))
                }
            when ASTNode.BIT:
                return coercionCost(Type.BuiltinBit(), target)
            when ASTNode.CALL(_, m, args):
                var methodTypes := possibleTypes(m)
                if methodTypes = null {
                    return null
                }
                if methodTypes.count = 1 & methodTypes[0].typeKind = Type.Kind.GENERIC &
                        methodTypes[0].subtypes[0] = Type.Class() {
                    def resultCost := coercionCost(methodTypes[0].subtypes[1], target)
                    if resultCost = null {
                        return null
                    }
                    methodTypes := possibleTypes(ASTNode.DOT(m.position(), m, "init"))
                    if methodTypes = null {
                        return null
                    }
                    def callCost := callCost(methodTypes, args, TypeContext.UNSPECIFIED)
                    if callCost = null {
                        return null
                    }
                    return callCost + resultCost
                }
                return callCost(methodTypes, args, TypeContext.TYPE(target))
            when ASTNode.DOT:
                def types := possibleTypes(expr)
                if types = null {
                    return null
                }
                return coercionCost(types, target)
            when ASTNode.IDENTIFIER(position, name):
                def types := identifierType(name)
                if types = null {
                    return null
                }
                return coercionCost(types, target)
            when ASTNode.INT(_, value):
                if (target.typeKind = Type.Kind.BUILTIN_INT &
                        requiredSize(value.convert()->Int64) <= target.size()) |
                        (target.typeKind = Type.Kind.BUILTIN_UINT &
                        requiredSize(value) <= target.size()) {
                    return 0
                }
                if target.typeKind = Type.Kind.BUILTIN_FLOAT {
                    return 2
                }
                if target.name = "panda.core.Int64" {
                    return 1
                }
                if !target.isNumber() {
                    def preferred := preferredType(expr)
                    assert preferred != null
                    return coercionCost(preferred, target)
                }
                return 2
            when ASTNode.IR_WRAPPER(_, ir):
                return coercionCost(ir.type(), target)
            when ASTNode.NULL:
                if target.typeKind = Type.Kind.NULLABLE {
                    return 0
                }
                return null
            when ASTNode.PREFIX(position, op, operand):
                return coercionCost(ASTNode.CALL(position,
                        ASTNode.DOT(position, operand, operatorName(op)),
                        ImmutableArray<ASTNode>() -* FIXME literal *-),
                        target)
            when ASTNode.RANGE(_, start, _, end, step):
                return rangeCoercionCost(start, end, step, target)
            when ASTNode.STRING:
                return coercionCost(Type.StringType(), target)
            otherwise:
                assert false, "unsupported coercionCost: \{expr}"
        }
    }

    function requiredSize(value:Int64):Int {
        if value >= -128 & value <= 127 {
            return 8
        }
        if value >= -32768 & value <= 32767 {
            return 16
        }
        if value >= -2147483648 & value <= 2147483647 {
            return 32
        }
        return 64
    }

    function requiredSize(value:UInt64):Int {
        if value <= 255 {
            return 8
        }
        if value <= 65535 {
            return 16
        }
        if value <= 4294967295 {
            return 32
        }
        return 64
    }

    method canCast(type:Type, target:Type):Bit {
        if type.isPointer() & (target.isPointer() | target.isMethod()) {
            return true
        }
        if coercionCost(type, target) != null {
            return true
        }
        if type.isBuiltinNumber() & target.isBuiltinNumber() {
            return true
        }
        if type.typeKind = Type.Kind.GENERIC_PARAMETER {
            return canCast(type.genericParameter.bound, target)
        }
        if type.typeKind = Type.Kind.INVALID {
            return false
        }
        return coercionCost(target, type) != null
    }

    -- FIXME figure out how to handle list comparisons
    function equal(a:ListView<Type>, b:ListView<Type>):Bit {
        if a.count != b.count {
            return false
        }
        for i in 0 .. a.count {
            if a[i] != b[i] {
                return false
            }
        }
        return true
    }

    method createChoiceCaseInit(entry:ChoiceCase) {
        def cl := entry.owner
        assert entry.resolved != Resolution.UNRESOLVED
        if entry.resolved != Resolution.RESOLVED {
            return
        }
        outer: for m in cl.methods {
            if m.methodKind != MethodDecl.Kind.INIT |
                    m.parameters.count != entry.fields.count + 1 {
                continue
            }
            assert m.parameters[0].type = Type.Int64()
            for i in 0 .. entry.fields.count {
                if entry.fields[i] != m.parameters[i + 1].type {
                    continue outer
                }
            }
            entry.initMethod := m
            return
        }
        -- need a synthetic init for this particular combination of parameters
        def parameters := Array<MethodDecl.Parameter>()
        parameters.add(MethodDecl.Parameter("rv", Type.Int64()))
        def statements := Array<ASTNode>()
        statements.add(ASTNode.BINARY(cl.position,
                ASTNode.IDENTIFIER(cl.position, ClassDecl.RAW_VALUE_NAME),
                Token.Kind.ASSIGNMENT,
                ASTNode.IDENTIFIER(cl.position, "rv")))
        for i in 0 .. entry.fields.count {
            parameters.add(MethodDecl.Parameter("f\{i}", entry.fields[i]))
            statements.add(ASTNode.BINARY(cl.position,
                    ASTNode.CHOICE_FIELD_REFERENCE(cl.position,
                        ASTNode.SELF(cl.position),
                        entry,
                        i),
                    Token.Kind.ASSIGNMENT,
                    ASTNode.IDENTIFIER(cl.position, "f\{i}")))
        }
        def synthetic := MethodDecl(cl, cl.position, null, Annotations(Annotations.Flag.SYNTHETIC),
                MethodDecl.Kind.INIT, "init", null, parameters, Type.Void(), statements.finish())
        entry.initMethod := synthetic
        cl.methods.add(synthetic)
        cl.symbolTable.add(synthetic)
    }

    function declaredType(m:MethodDecl):Type {
        resolve(m)
        def subtypes := Array<Type>()
        def typeName := MutableString("(")
        var separator := ""
        for p in m.parameters {
            typeName.append(separator)
            typeName.append(p.type.name)
            subtypes.add(p.type)
            separator := ", "
        }
        def kind:Type.Kind
        if m.methodKind = MethodDecl.Kind.FUNCTION {
            typeName.append(")=>(")
            kind := Type.Kind.FUNCTION
        }
        else {
            typeName.append(")=&>(")
            kind := Type.Kind.METHOD
        }
        subtypes.add(m.returnType)
        if m.returnType != Type.Void() {
            typeName.append(m.returnType.name)
        }
        typeName.append(")")
        return Type(typeName.finish(), kind, m.position, subtypes, true)
    }

    function declaredTypeWithSelf(m:MethodDecl, selfType:Type):Type {
        resolve(m)
        def subtypes := Array<Type>()
        def typeName := MutableString("(")
        typeName.append(selfType.name)
        subtypes.add(selfType)
        for p in m.parameters {
            typeName.append(", ")
            typeName.append(p.type.name)
            subtypes.add(p.type)
        }
        def kind:Type.Kind
        if m.methodKind = MethodDecl.Kind.FUNCTION {
            typeName.append(")=>(")
            kind := Type.Kind.FUNCTION
        }
        else {
            typeName.append(")=&>(")
            kind := Type.Kind.METHOD
        }
        subtypes.add(m.returnType)
        if m.returnType != Type.Void() {
            typeName.append(m.returnType.name)
        }
        typeName.append(")")
        return Type(typeName.finish(), kind, m.position, subtypes, true)
    }

    function inheritedType(m:MethodDecl):Type {
        def inherited := getOverriddenMethod(m)
        if inherited = null {
            return declaredType(m)
        }
        return inheritedType(inherited)
    }

    function inheritedTypeWithSelf(m:MethodDecl):Type {
        return inheritedTypeWithSelf(m, m.owner.type)
    }

    function inheritedTypeWithSelf(m:MethodDecl, selfType:Type):Type {
        def inherited := getOverriddenMethod(m)
        if inherited = null {
            return declaredTypeWithSelf(m, selfType)
        }
        return inheritedTypeWithSelf(inherited, selfType)
    }

    @class
    function operatorName(op:Token.Kind):String {
        match op {
            when Token.Kind.ADD:        return "+"
            when Token.Kind.SUB:        return "-"
            when Token.Kind.MUL:        return "*"
            when Token.Kind.DIV:        return "/"
            when Token.Kind.INTDIV:     return "//"
            when Token.Kind.REM:        return "%"
            when Token.Kind.POW:        return "^"
            when Token.Kind.EQ:         return "="
            when Token.Kind.NEQ:        return "!="
            when Token.Kind.GT:         return ">"
            when Token.Kind.LT:         return "<"
            when Token.Kind.GTEQ:       return ">="
            when Token.Kind.LTEQ:       return "<="
            when Token.Kind.OR:         return "|"
            when Token.Kind.BITWISEOR:  return "||"
            when Token.Kind.AND:        return "&"
            when Token.Kind.BITWISEAND: return "&&"
            when Token.Kind.XOR:        return "~"
            when Token.Kind.BITWISEXOR: return "~~"
            when Token.Kind.NOT:        return "!"
            when Token.Kind.BITWISENOT: return "!!"
            when Token.Kind.SHIFTLEFT:  return "<<"
            when Token.Kind.SHIFTRIGHT: return ">>"
            when Token.Kind.LBRACKET:   return "[]"
            when Token.Kind.ASSIGNMENT: return ":="
            when Token.Kind.IDENTITY:   return "=="
            when Token.Kind.NIDENTITY:  return "!=="
            when Token.Kind.CAST:       return "->"
            otherwise:
                assert false, "not an operator: \{op}"
        }
    }

    @class
    function isAssignment(op:Token.Kind):Bit {
        match op {
            when Token.Kind.ADDEQ, Token.Kind.SUBEQ, Token.Kind.MULEQ, Token.Kind.DIVEQ,
                    Token.Kind.INTDIVEQ, Token.Kind.REMEQ, Token.Kind.POWEQ, Token.Kind.OREQ,
                    Token.Kind.BITWISEOREQ, Token.Kind.ANDEQ, Token.Kind.BITWISEANDEQ,
                    Token.Kind.XOREQ, Token.Kind.BITWISEXOREQ, Token.Kind.SHIFTLEFTEQ,
                    Token.Kind.SHIFTRIGHTEQ:
                return true
            otherwise:
                return false
        }
    }

    @class
    function removeAssignment(op:Token.Kind):Token.Kind {
        match op {
            when Token.Kind.ADDEQ:        return Token.Kind.ADD
            when Token.Kind.SUBEQ:        return Token.Kind.SUB
            when Token.Kind.MULEQ:        return Token.Kind.MUL
            when Token.Kind.DIVEQ:        return Token.Kind.DIV
            when Token.Kind.INTDIVEQ:     return Token.Kind.INTDIV
            when Token.Kind.REMEQ:        return Token.Kind.REM
            when Token.Kind.POWEQ:        return Token.Kind.POW
            when Token.Kind.OREQ:         return Token.Kind.OR
            when Token.Kind.BITWISEOREQ:  return Token.Kind.BITWISEOR
            when Token.Kind.ANDEQ:        return Token.Kind.AND
            when Token.Kind.BITWISEANDEQ: return Token.Kind.BITWISEAND
            when Token.Kind.XOREQ:        return Token.Kind.XOR
            when Token.Kind.BITWISEXOREQ: return Token.Kind.BITWISEXOR
            when Token.Kind.SHIFTLEFTEQ:  return Token.Kind.SHIFTLEFT
            when Token.Kind.SHIFTRIGHTEQ: return Token.Kind.SHIFTRIGHT
            otherwise:
                assert false
        }
    }

    method createClosureClass(m:MethodDecl, captures:ListView<Variable>):ClassDecl {
        def p := m.position
        m.annotations := Annotations(0)
        closureCount += 1
        def result := ClassDecl(currentClass[0].source, p, HashMap<String, String>(), null,
                Annotations(Annotations.Flag.SYNTHETIC), ClassDecl.Kind.CLASS,
                "\{currentClass[0].name}._Closure\{closureCount}", Array<Type>(),
                Array<ClassDecl.GenericParameter>(), root)
        result.external := false

        -- create init method
        def statements := Array<ASTNode>()
        def parameters := Array<MethodDecl.Parameter>()
        for v in captures {
            parameters.add(MethodDecl.Parameter(v.name, v.type))
            -- self.parameterName := parameterName
            statements.add(ASTNode.BINARY(p, ASTNode.DOT(p, ASTNode.SELF(p), v.name),
                    Token.Kind.ASSIGNMENT, ASTNode.IDENTIFIER(p, v.name)))
        }
        def initMethod := MethodDecl(result, p, null,
                Annotations(Annotations.Flag.SYNTHETIC), MethodDecl.Kind.INIT, "init",
                Array<ClassDecl.GenericParameter>(), parameters,
                Type.Void(), statements.finish())
        result.methods.add(initMethod)
        result.symbolTable.add(initMethod)

        -- default cleanup
        def defaultCleanup := MethodDecl(result, p, null,
                Annotations(Annotations.Flag.OVERRIDE || Annotations.Flag.SYNTHETIC),
                MethodDecl.Kind.METHOD, "cleanup", Array<ClassDecl.GenericParameter>(),
                Array<MethodDecl.Parameter>(), Type.Void(), ImmutableArray<ASTNode>())
        result.methods.add(defaultCleanup)
        result.symbolTable.add(defaultCleanup)

        -- create fields
        for v in captures {
            def field := FieldDecl(result, p, null,
                    Annotations(Annotations.Flag.SYNTHETIC), FieldDecl.Kind.DEF, v.name, v.type,
                    null)
            result.symbolTable.add(field)
            result.fields.add(field)
        }
        m.owner := result
        result.methods.add(m)
        classes[result.name] := result
        result.owner := currentClass[0]
        return result
    }

    method createChoiceCleanup(m:MethodDecl) {
        def cl := m.owner
        def statements := Array<ASTNode>()
        def value := ASTNode.SELF(cl.position)
        def whens := Array<ASTNode>()
        for e in cl.choiceCases {
            resolve(e)
            if errorCount != 0 {
                return
            }
            def tests := Array<ASTNode>() -- FIXME literal
            def fields := Array<ASTNode>()
            for i in 0 .. e.fields.count {
                fields.add(ASTNode.IDENTIFIER(cl.position, "_f\{i}"))
            }
            tests.add(ASTNode.CALL(cl.position, ASTNode.IDENTIFIER(cl.position, e.name),
                    fields.finish()))
            def unrefs := Array<ASTNode>()
            for i in 0 .. e.fields.count {
                if isRefCounted(e.fields[i]) {
                    def p := Position()
                    def unref := ASTNode.DOT(p, ASTNode.DOT(p, ASTNode.DOT(p,
                            ASTNode.IDENTIFIER(p, "panda"), "core"), "Panda"), "unref")
                    def args := Array<ASTNode>() -- FIXME literal
                    args.add(fields[i])
                    unrefs.add(ASTNode.CALL(Position(), unref, args.finish()))
                }
            }
            whens.add(ASTNode.WHEN(cl.position, tests.finish(), unrefs.finish()))
        }
        statements.add(ASTNode.MATCH(cl.position, value, whens.finish(), null))
        m.body := statements.finish()
    }

    method checkAccessModifierCount(position:Position, a:Annotations) {
        var count := 0
        if a.flags && Annotations.Flag.PRIVATE != 0 {
            count += 1
        }
        if a.flags && Annotations.Flag.PROTECTED != 0 {
            count += 1
        }
        if a.flags && Annotations.Flag.PACKAGE != 0 {
            count += 1
        }
        if count > 1 {
            error(position, "conflicting access modifier annotations")
        }
    }

    method checkAnnotations(m:MethodDecl) {
        method disallow(compiler:Compiler -* FIXME capture this *-, m:MethodDecl -* FIXME capture this *-, flag:Int, name:String) {
            if m.annotations.flags && flag != 0 {
                compiler.error(m.position, "methods may not be annotated with '\{name}'")
            }
        }
        disallow(self, m, Annotations.Flag.SPECIALIZE,       "@specialize")
        disallow(self, m, Annotations.Flag.WEAK,             "@weak")
        disallow(self, m, Annotations.Flag.UNSAFE_IMMUTABLE, "@unsafeImmutable")
        if m.methodKind = MethodDecl.Kind.INIT {
            if m.annotations.flags && Annotations.Flag.EXTERNAL != 0 {
                error(m.position, "init methods may not be annotated with '@external'")
            }
            if m.annotations.flags && Annotations.Flag.CLASS != 0 {
                error(m.position, "init methods may not be annotated with '@class'")
            }
            if m.annotations.flags && Annotations.Flag.ABSTRACT != 0 {
                error(m.position, "init methods may not be annotated with '@abstract'")
            }
            if m.annotations.flags && Annotations.Flag.OVERRIDE != 0 {
                error(m.position, "init methods may not be annotated with '@override'")
            }
        }
        if m.annotations.flags && Annotations.Flag.EXTERNAL != 0 & m.body != null {
            error(m.position, "methods annotated with '@external' may not have a body")
        }
        if m.annotations.flags && Annotations.Flag.ABSTRACT != 0 & m.body != null {
            error(m.position, "methods annotated with '@abstract' may not have a body")
        }
        if m.annotations.flags && Annotations.Flag.OVERRIDE != 0 &
                m.annotations.flags && Annotations.Flag.CLASS != 0 {
            error(m.position, "class methods may not be annotated with '@override'")
        }
        if m.annotations.flags && Annotations.Flag.ABSTRACT = 0 &
                m.annotations.flags && Annotations.Flag.EXTERNAL = 0 &
                m.body = null {
            error(m.position, "expected non-abstract method '\{m.name}' to have a body")
        }
        if m.annotations.flags && Annotations.Flag.DEFAULT != 0 {
            if m.owner.classKind != ClassDecl.Kind.INTERFACE {
                error(m.position, "annotation '@default' may only appear on interface methods")
            }
            if m.body = null {
                error(m.position, "expected '@default' method '\{m.name}' to have a body")
            }
        }
        else if m.kind != MethodDecl.Kind.INIT & m.owner.classKind = ClassDecl.Kind.INTERFACE &
                !m.annotations.isClass() & m.body != null {
            error(m.position, "non-abstract interface method '\{m.name}' must be annotated with " +
                    "'@default'")
        }
        checkAccessModifierCount(m.position, m.annotations)
    }

    method getIndex(f:FieldDecl):Int {
        def fields := instanceFields(f.owner)
        for i in 0 .. fields.count {
            if fields[i] == f {
                return i
            }
        }
        assert false, "field '\{f}' not found in \{f.owner.name}"
    }

    method symbolRef(position:Position, target:IR.Value?, s:Symbol):IR.Value? {
        match s.kind {
            when Symbol.Kind.ALIAS:
                def cl := getClass(position, s->Alias.fullName)
                if cl != null {
                    checkGenericParameters(position, cl, cl.type)
                    return IR.Value.TYPE(Type.ClassLiteral(cl.type))
                }
                return null
            when Symbol.Kind.METHOD:
                return IR.Value.METHOD(target, s->MethodDecl)
            when Symbol.Kind.METHODS:
                return IR.Value.METHODS(target, s->Methods.methods)
            when Symbol.Kind.VARIABLE:
                def v := s->Variable
                match v.storage {
                    when Variable.Storage.LOCAL(slot):
                        def result := ir.add(IR.Statement.LOAD(IR.Value.LOCAL(slot, v.type)))
                        return IR.Value.REF(result, v.type)
                    when Variable.Storage.PARAMETER(index):
                        return IR.Value.PARAMETER(index, s->Variable.type)
                    otherwise:
                        assert false
                }
            when Symbol.Kind.FIELD:
                if resolve(s->FieldDecl) {
                    return FieldLValue(self, position, target, s->FieldDecl).compileLoad()
                }
                return null
            when Symbol.Kind.CHOICE_CASE:
                -- this handles the zero-argument case; choice cases with arguments are handled in
                -- compileCall()
                def cc := s->ChoiceCase
                if cc.fields.count > 0 {
                    error(position, "choice '\{s}' requires \{cc.fields.count} " +
                            "argument\{cc.fields.count = 1:|s}, but found 0")
                    return null
                }
                resolve(cc)
                def inits := getSymbolTable(cc.owner)["init"]
                assert inits != null
                resolve(inits->MethodDecl)
                def args := Array<ASTNode>() -- FIXME literal
                args.add(ASTNode.INT(position, cc.rawValue.convert()))
                if isValue(cc.owner) {
                    return call(position, symbolRef(position, null, inits), args,
                            TypeContext.UNSPECIFIED)
                }
                else {
                    def construct := ir.add(IR.Statement.CONSTRUCT(cc.owner))
                    def constructRef := IR.Value.REF(construct, cc.owner.type)
                    call(position, symbolRef(position, constructRef, inits), args,
                            TypeContext.UNSPECIFIED)
                    return constructRef
                }
            when Symbol.Kind.GENERIC_PARAMETER:
                error(position, "generic parameter '\{s.name}' is not an expression")
                return null
            otherwise:
                assert false, "unsupported symbol kind: \{s}"
        }
    }

    method isValueInit(m:MethodDecl):Bit {
        return m.methodKind = MethodDecl.Kind.INIT & isValue(m.owner)
    }

    method implicitInit(position:Position, value:IR.Value, m:MethodDecl):IR.Value {
        def cl := m.owner
        assert isValue(cl)
        def args := Array<IR.Value>() -- FIXME literal
        args.add(value)
        def result := ir.add(IR.Statement.STATIC_CALL(m, args.finish()))
        return IR.Value.REF(result, m.owner.type)
    }

    @pre(target != Type.Void())
    method coerce(position:Position, value:IR.Value?, target:Type):IR.Value? {
        if value = null {
            return null
        }
        if value.type() = target {
            return value
        }
        if coercionCost(value.type(), target) != null {
            def cl := getClass(target)
            if cl = null {
                return null
            }
            def inits := getSymbolTable(cl)["init"]
            assert inits != null
            match inits.kind {
                when Symbol.Kind.METHOD:
                    def m := inits->MethodDecl
                    if m.annotations.isImplicit() {
                        if resolve(m) & coercionCost(value.type(), m.parameters[0].type) != null {
                            return implicitInit(position, value, m)
                        }
                    }
                when Symbol.Kind.METHODS:
                    def methods := inits->Methods.methods
                    for m in methods {
                        if m.annotations.isImplicit() {
                            if resolve(m) {
                                if coercionCost(value.type(), m.parameters[0].type) != null {
                                    return implicitInit(position, value, m)
                                }
                            }
                        }
                    }
            }
            def result := ir.add(IR.Statement.CAST(value, target))
            return IR.Value.REF(result, target)
        }
        error(position, "expected '\{target}', but found '\{value.type()}'")
        return null
    }

    method coerce(position:Position, value:IR.Value?, type:TypeContext):IR.Value? {
        if value = null {
            return value
        }
        match type {
            when TypeContext.UNSPECIFIED:
                return value
            when TypeContext.IMMUTABLE:
                if isImmutable(value.type()) {
                    return value
                }
                error(position, "expected 'panda.core.Immutable', but found '\{value.type()}'")
                return null
            when TypeContext.TYPE(t):
                return coerce(position, value, t)
            otherwise:
                assert false
        }
    }

    @pre(target != Type.Void())
    method cast(value:IR.Value?, target:Type):IR.Value? {
        if value = null {
            return null
        }
        if value.type() = target {
            return value
        }
        return IR.Value.REF(ir.add(IR.Statement.CAST(value, target)), target)
    }

    method getVTableIndex(m:MethodDecl):Int {
        def vtable := getVTable(m.owner)
        for i in 0 .. vtable.count {
            if vtable[i] == m {
                return i
            }
        }
        assert false, "could not find \{m.declaration} in vtable for \{m.owner.name}"
        return -1
    }

    method compileIntrinsic(target:IR.Value?, m:MethodRef,
            args:ListView<IR.Value>):Pair<Bit, IR.Statement.ID?> {
        if m.target.isPointer() {
            match m.value.name {
                when "alloc":
                    return Pair<Bit, IR.Statement.ID?>(true,
                            ir.add(IR.Statement.POINTER_ALLOC(args[0], m.target.subtypes[1])))
                when "destroy":
                    ir.add(IR.Statement.POINTER_DESTROY(args[0]))
                    return Pair<Bit, IR.Statement.ID?>(true, null)
                when "get":
                    return Pair<Bit, IR.Statement.ID?>(true,
                            ir.add(IR.Statement.POINTER_GET(target)))
-*        POINTER_DESTROY(Value -* pointer *-, Value -* index *-)

        ============================================================================================
        Dereferences a raw pointer.
        ============================================================================================
        POINTER_GET(Value)

        ============================================================================================
        Reads from `pointer + index * sizeof(type)`.
        ============================================================================================
        POINTER_GET_INDEX(Value -* pointer *-, Value -* index *-)

        ============================================================================================
        Returns `pointer + index * sizeof(type)`.
        ============================================================================================
        POINTER_OFFSET(Value -* pointer *-, Value -* index *-)

        ============================================================================================
        Equivalent to the C realloc function.
        ============================================================================================
        POINTER_REALLOC(Value -* pointer *-, Value -* size *-)

        ============================================================================================
        Writes to a raw pointer.
        ============================================================================================
        POINTER_SET(Value -* value *-, Value, -* pointer *-)

        ============================================================================================
        Writes to `pointer + index * sizeof(type)`.
        ============================================================================================
        POINTER_SET_INDEX(Value -* value *-, Value -* pointer *-, Value -* index *-)*-
            }
        }
        return Pair<Bit, IR.Statement.ID?>(false, null)
    }

    @post((m.returnType = Type.Void() & @return = null) | @return != null | errorCount > 0)
    method call(position:Position, target:IR.Value?, m:MethodRef, args:ListView<ASTNode>,
            type:TypeContext):IR.Value? {
        if args.count != m.parameterCount {
            error(position, "\{m.value.declaration()} expects \{m.parameterCount}" +
                    "\{m.parameterCount = 1:|s} argument, but found \{args.count}")
            return null
        }
        def finalArgs := Array<IR.Value>(args.count)
        if target != null {
            finalArgs.add(coerce(position, target, m.value.owner.type))
        }
        def effectiveType := m.effectiveType
        for i in 0 .. args.count {
            var a := compileExpression(args[i], TypeContext.TYPE(effectiveType.parameterType(i)))
            if a = null {
                return null
            }
            if a.type() != m.value.parameters[i].type {
                a := cast(a, m.value.parameters[i].type)
            }
            if a = null {
                return null
            }
            finalArgs.add(a)
        }
        var result:IR.Statement.ID
        if m.value.isVirtual() {
            def finalTarget:IR.Value?
            if target != null {
                finalTarget := coerce(position, target, m.value.owner.type)
                if finalTarget = null {
                    return null
                }
            }
            else {
                finalTarget := coerce(position, compileSelf(position), m.value.owner.type)
                if finalTarget = null {
                    return null
                }
                finalArgs.insert(0, finalTarget)
            }
            def mref:IR.Statement.ID
            if m.value.owner.classKind = ClassDecl.Kind.INTERFACE {
                mref := ir.add(IR.Statement.GET_INTERFACE_METHOD(finalTarget, m.value.owner,
                        getVTableIndex(m.value) - getVTable(getClass(Type.Object())).count,
                        inheritedTypeWithSelf(m.value)))
            }
            else {
                mref := ir.add(IR.Statement.GET_VIRTUAL_METHOD(finalTarget, getVTableIndex(m.value),
                inheritedTypeWithSelf(m.value)))
            }
            result := ir.add(IR.Statement.DYNAMIC_CALL(IR.Value.REF(mref, m.value.type()),
                    finalArgs.finish()))
        }
        else {
            var intrinsic := compileIntrinsic(target, m, finalArgs)
            if intrinsic.first {
                result := intrinsic.second
            }
            else {
                result := ir.add(IR.Statement.STATIC_CALL(m.value, finalArgs.finish()))
            }
        }
        if m.returnType != Type.Void() {
            var resultCast := IR.Value.REF(result, m.value.returnType)
            if m.value.methodKind != MethodDecl.Kind.INIT &
                    effectiveType.returnType() != m.value.returnType {
                resultCast := cast(resultCast, effectiveType.returnType())
            }
            return coerce(position, resultCast, type)
        }
        return null
    }

    method call(position:Position, target:IR.Value, m:String, args:ListView<ASTNode>,
            type:TypeContext):IR.Value? {
        def cl := getClass(target.type())
        if cl = null {
            return null
        }
        def s := getSymbolTable(cl)[m]
        assert s != null, "could not find \{m} in \{cl.name}"
        def ref := symbolRef(position, target, s)
        return call(position, ref, args, type)
    }

    method findBestMethod(position:Position, target:IR.Value?, methods:ListView<MethodDecl>,
            args:ListView<ASTNode>, type:TypeContext):Pair<ListView<MethodRef>, Int>? {
        var bestCost := Int.MAX
        var best := Array<MethodRef>()
        outer: for m in methods {
            if m.parameters.count != args.count {
                continue
            }
            if !resolve(m) {
                continue
            }
            def ref:MethodRef
            if target != null {
                ref := MethodRef(self, target.type(), m)
            }
            else {
                ref := MethodRef(self, m.owner.type, m)
            }
            var cost := 0
            for i in 0 .. 5 { Panda.ref(ref) } -- FIXME seems to be a bug in the bootstrap compiler's refcounting
            for i in 0 .. args.count {
                def argCost := coercionCost(args[i], ref.parameterType(i))
                if argCost = null {
                    continue outer
                }
                cost += argCost
            }
            match type {
                when TypeContext.IMMUTABLE:
                    if m.returnType = Type.Void() | !isImmutable(ref.returnType) {
                        continue
                    }
                when TypeContext.TYPE(t):
                    def returnCost := coercionCost(ref.returnType, t)
                    if returnCost = null {
                        continue
                    }
                    cost += returnCost
            }
            if cost < bestCost {
                bestCost := cost
                best.clear()
            }
            if cost = bestCost {
                best.add(ref)
            }
        }
        if best.count = 0 {
            return null
        }
        return Pair<ListView<MethodRef>, Int>(best, bestCost)
    }

    method call(position:Position, m:IR.Value, args:ListView<ASTNode>,
            type:TypeContext):IR.Value? {
        match m {
            when IR.Value.METHOD(target, m):
                def targetType:Type
                if target != null {
                    targetType := target.type()
                }
                else {
                    targetType := m.owner.type
                }
                if !resolve(m) {
                    return null
                }
                return call(position, target, MethodRef(self, targetType, m), args, type)
            when IR.Value.METHODS(target, methods):
                def best := findBestMethod(position, target, methods, args, type)
                if best != null {
                    assert best.first.count = 1, "ambiguous match: \{best.first} at \{position}"
                    return call(position, target, best.first[0], args, type)
                }
                -- no match
                def argTypes := Array<Type>()
                for a in args {
                    def preferred := preferredType(a)
                    if preferred = null {
                        -- force it to produce an error
                        def oldErrorCount := errorCount
                        compileExpression(a)
                        assert errorCount > oldErrorCount, "expected error from \{a}:\{position}"
                        return null
                    }
                    argTypes.add(preferred)
                }
                error(position, "no match for \{methods[0].name}(\{argTypes.join(", ")})" +
                        type.description())
                return null
            when IR.Value.TYPE(t):
                def finalType:Type
                if t.typeKind = Type.Kind.GENERIC & t.subtypes[0] = Type.Class() {
                    finalType := t.subtypes[1]
                }
                else {
                    finalType := t
                }
                def cl := getClass(finalType)
                if cl = null {
                    return null
                }
                def inits := getSymbolTable(cl)["init"]
                assert inits != null, "no init for \{cl.name}"
                if isValue(cl) {
                    return coerce(position, cast(call(position, symbolRef(position, null, inits),
                            args, type), finalType), type)
                }
                def construct := ir.add(IR.Statement.CONSTRUCT(cl))
                def constructRef := IR.Value.REF(construct, finalType)
                call(position, symbolRef(position, constructRef, inits), args,
                        TypeContext.UNSPECIFIED)
                return coerce(position, constructRef, type)
            otherwise:
                assert false, "cannot call \{m}"
        }
    }

    method findOverloadedOperator(left:Type, op:Token.Kind, right:ASTNode,
            type:TypeContext):Pair<ListView<MethodRef>, Int>? {
        if !left.isClass() {
            return null
        }
        def cl := getClass(left)
        if cl = null {
            return null
        }
        def methods := getSymbolTable(cl)[operatorName(op)]
        if methods = null {
            return null
        }
        def args := Array<ASTNode>() -- FIXME literal
        args.add(right)
        def target := IR.Value.REF(IR.Statement.ID(-1), left)
        match methods.kind {
            when Symbol.Kind.METHOD:
                def list := Array<MethodDecl>()
                list.add(methods->MethodDecl)
                return findBestMethod(Position(), target, list, args, type)                
            when Symbol.Kind.METHODS:
                return findBestMethod(Position(), target, methods->Methods.methods, args, type)
            otherwise:
                assert false
        }
        return null
    }

    method findOverloadedOperator(left:ASTNode, op:Token.Kind, right:ASTNode,
            type:TypeContext):Pair<ListView<MethodRef>, Int>? {
        def leftTypes := possibleTypes(left)
        if leftTypes != null {
            def best:Pair<ListView<MethodRef>, Int>? := null
            for t in leftTypes {
                def selfCost := coercionCost(left, t)
                def ops := findOverloadedOperator(t, op, right, type)
                if ops != null {
                    def cost := ops.second + selfCost
                    if best = null | cost < best.second {
                        best := Pair<ListView<MethodRef>, Int>(ops.first, cost)
                    }
                }
            }
            return best
        }
        return null
    }

    ================================================================================================
    Returns the type under which a particular class was inherited. For instance,
    `HashMap<String, File>` inherits `MapView` under the type `MapView<String, File>`.
    ================================================================================================
    function findType(start:Type, target:ClassDecl):Type? {
        if !start.isClass() {
            return null
        }
        if start.typeKind = Type.Kind.GENERIC_PARAMETER {
            return findType(start.genericParameter.bound, target)
        }
        def startClass := getClass(start)
        if startClass = null {
            return null
        }
        if startClass == target {
            return start.nonnullable()
        }
        if startClass.rawSuper != null {
            def result := findType(remapType(start, startClass.rawSuper),
                    target)
            if result != null {
                return result
            }
        }
        for intf in startClass.rawInterfaces {
            def result := findType(remapType(start, intf), target)
            if result != null {
                return result
            }
        }
        return null
    }

    function findType(start:ListView<Type>, target:ClassDecl):Type? {
        for t in start {
            def result := findType(t, target)
            if result != null {
                return result
            }
        }
        return null
    }

    method foldInts(position:Position, left:ASTNode, op:Token.Kind, right:ASTNode):ASTNode? {
        def l:Int64
        def r:Int64
        -- ensure both values fit into a signed Int64
        match left {
            when ASTNode.INT(_, int):
                if int > Int64.MAX.convert() {
                    return null
                }
                l := int.convert()
            otherwise:
                return null
        }
        match right {
            when ASTNode.INT(_, int):
                if int > Int64.MAX.convert() {
                    return null
                }
                r := int.convert()
            otherwise:
                return null
        }
        match op {
            when Token.Kind.ADD:
                def v := (l + r).convert()->UInt64
                return ASTNode.INT(position, v)
            when Token.Kind.SUB:
                def v := (l - r).convert()->UInt64
                return ASTNode.INT(position, v)
            when Token.Kind.MUL:
                def v := (l * r).convert()->UInt64
                return ASTNode.INT(position, v)
            when Token.Kind.INTDIV:
                if r = 0 {
                    error(right.position(), "division by 0")
                    return null
                }
                def v := (l // r).convert()->UInt64
                return ASTNode.INT(position, v)
            when Token.Kind.REM:
                if r = 0 {
                    error(right.position(), "division by 0")
                    return null
                }
                def v := (l % r).convert()->UInt64
                return ASTNode.INT(position, v)
            when Token.Kind.EQ:
                return ASTNode.BIT(position, l = r)
            when Token.Kind.NEQ:
                return ASTNode.BIT(position, l != r)
            when Token.Kind.LT:
                return ASTNode.BIT(position, l < r)
            when Token.Kind.GT:
                return ASTNode.BIT(position, l > r)
            when Token.Kind.LTEQ:
                return ASTNode.BIT(position, l <= r)
            when Token.Kind.GTEQ:
                return ASTNode.BIT(position, l >= r)
            when Token.Kind.BITWISEAND:
                def v := (l && r).convert()->UInt64
                return ASTNode.INT(position, v)
            when Token.Kind.BITWISEOR:
                def v := (l || r).convert()->UInt64
                return ASTNode.INT(position, v)
            when Token.Kind.BITWISEXOR:
                def v := (l ~~ r).convert()->UInt64
                return ASTNode.INT(position, v)
            when Token.Kind.SHIFTLEFT:
                def v := (l << r).convert()->UInt64
                return ASTNode.INT(position, v)
            when Token.Kind.SHIFTRIGHT:
                def v := (l >> r).convert()->UInt64
                return ASTNode.INT(position, v)
        }
        error(position, "'\{operatorName(op)}' cannot operate on 'panda.core.Int64', " +
                "'panda.core.Int64'")
        return null
    }

    method compileBinary(position:Position, left:ASTNode, op:Token.Kind, right:ASTNode,
            type:TypeContext):IR.Value? {
        def folded := foldInts(position, left, op, right)
        if folded != null {
            return compileExpression(folded, type)
        }
        match op {
            when Token.Kind.CAST:
                def target := resolve(scanner.convertType(right))
                if target = null {
                    return null
                }
                return coerce(position, compileCast(position, left, target), type)
            when Token.Kind.IDENTITY, Token.Kind.NIDENTITY:
                return compileIdentityComparison(position, left, op, right, type)
            otherwise:
                def matches := findOverloadedOperator(left, op, right, type)
                if matches != null {
                    assert matches.first.count = 1,
                            "ambiguous call: \{matches.first} on \{left}, \{right}"
                    def found := findType(possibleTypes(left), matches.first[0].value.owner)
                    assert found != null
                    def target := compileExpression(left, TypeContext.TYPE(found))
                    def args := Array<ASTNode>() -- FIXME literal
                    args.add(right)
                    return call(position, IR.Value.METHOD(target, matches.first[0].value), args,
                            type)
                }
                -- generate errors
                def compiledLeft := compileExpression(left, TypeContext.UNSPECIFIED)
                def compiledRight := compileExpression(right, TypeContext.UNSPECIFIED)
                if compiledLeft != null & compiledRight != null {
                    error(position, "no match for '\{operatorName(op)}' on " +
                            "'\{compiledLeft.type()}', '\{compiledRight.type()}'")
                }
                return null
        }
    }

    method compileChoiceCaseReference(position:Position, cc:ChoiceCase,
            args:ImmutableArray<ASTNode>, type:TypeContext):IR.Value? {
        resolve(cc)
        def initMethod := cc.initMethod
        resolve(initMethod)
        if args.count != cc.fields.count {
            error(position, "'\{cc}' expected \{cc.fields.count} argument" +
                    "\{cc.fields.count = 1:|s}, but found \{args.count}")
            return null
        }
        def finalArgs := Array<ASTNode>() -- FIXME literal
        finalArgs.add(ASTNode.INT(position, cc.rawValue.convert()))
        finalArgs.addAll(args)
        if isValue(cc.owner) {
            return call(position, symbolRef(position, null, initMethod), finalArgs,
                    TypeContext.UNSPECIFIED)
        }
        else {
            def construct := ir.add(IR.Statement.CONSTRUCT(cc.owner))
            def constructRef := IR.Value.REF(construct, cc.owner.type)
            call(position, symbolRef(position, constructRef, initMethod), finalArgs,
                    TypeContext.UNSPECIFIED)
            return constructRef
        }
    }

    ================================================================================================
    If `node` is a reference to a [ChoiceCase], returns it. Otherwise, returns `null`.
    ================================================================================================
    method getChoiceCase(node:ASTNode):ChoiceCase? {
        match node {
            when ASTNode.IDENTIFIER(_, text):
                if currentClass[0].classKind = ClassDecl.Kind.CHOICE {
                    def s := getSymbolTable(currentClass[0])[text]
                    if s != null & s.kind = Symbol.Kind.CHOICE_CASE {
                        return s->ChoiceCase
                    }
                }
            when ASTNode.DOT(_, base, text):
                def baseType := preferredType(base)
                if baseType != null & baseType.typeKind = Type.Kind.GENERIC &
                        baseType.subtypes[0] = Type.Class() {
                    def cl := getClass(baseType.subtypes[1])
                    if cl != null & cl.classKind = ClassDecl.Kind.CHOICE {
                        def s := getSymbolTable(cl)[text]
                        if s != null & s.kind = Symbol.Kind.CHOICE_CASE {
                            return s->ChoiceCase
                        }
                    }
                }
        }
        return null
    }

    method compileCall(position:Position, m:ASTNode, args:ImmutableArray<ASTNode>,
                       type:TypeContext):IR.Value? {
        match m {
            when ASTNode.GENERIC_TYPE:
                def resolved := resolve(scanner.convertType(m))
                if resolved = null {
                    return null
                }
                return call(position, IR.Value.TYPE(resolved), args, type)
        }
        def cc := getChoiceCase(m)
        if cc != null {
            return compileChoiceCaseReference(position, cc, args, type)
        }
        def compiledM := compileExpression(m)
        if compiledM = null {
            return null
        }
        return call(position, compiledM, args, type)
    }

    method compileCast(position:Position, value:ASTNode, target:Type):IR.Value? {
        return compileExpression(value, TypeContext.TYPE(target))
    }

    method compileDot(position:Position, target:IR.Value?, targetType:Type, name:String):IR.Value? {
        def cl := getClass(targetType)
        if cl = null {
            return null
        }
        def symbol := getSymbolTable(cl)[name]
        if symbol = null {
            error(position, "class '\{targetType}' does not have a member named '\{name}'")
            return null
        }
        return symbolRef(position, target, symbol)
    }

    method compileDot(position:Position, base:ASTNode, name:String):IR.Value? {
        def compiledBase := compileExpression(base)
        if compiledBase = null {
            return null
        }
        match compiledBase {
            when IR.Value.TYPE(type):
                return compileDot(position, null, type.subtypes[1], name)
            otherwise:
                return compileDot(position, compiledBase, compiledBase.type(), name)
        }
    }

    method compileIdentifier(position:Position, name:String):IR.Value? {
        def s := symbolTable[name]
        if s = null {
            def cl := tryResolveClass(name)
            if cl != null {
                checkGenericParameters(position, cl, cl.type)
                return IR.Value.TYPE(Type.ClassLiteral(cl.type))
            }
        }
        if s != null {
            return symbolRef(position, null, s)
        }
        error(position, "unknown identifier")
        return null
    }

    @pre(op = Token.Kind.IDENTITY | op = Token.Kind.NIDENTITY)
    method compileIdentityComparison(position:Position, left:ASTNode, op:Token.Kind, right:ASTNode,
            type:TypeContext):IR.Value? {
        def compiledLeft := compileExpression(left, TypeContext.UNSPECIFIED)
        if compiledLeft = null {
            return null
        }
        def compiledRight := compileExpression(right, TypeContext.UNSPECIFIED)
        if compiledRight = null {
            return null
        }
        if compiledLeft.type().typeKind != Type.Kind.NULLABLE & compiledRight = IR.Value.NULL {
            if op = Token.Kind.IDENTITY {
                return coerce(position, coerce(position, IR.Value.BIT(false),
                        TypeContext.TYPE(Type.Bit())), type)
            }
            return coerce(position, coerce(position, IR.Value.BIT(true),
                    TypeContext.TYPE(Type.Bit())), type)
        }
        if compiledRight.type().typeKind != Type.Kind.NULLABLE & compiledLeft = IR.Value.NULL {
            if op = Token.Kind.IDENTITY {
                return coerce(position, coerce(position, IR.Value.BIT(false),
                        TypeContext.TYPE(Type.Bit())), type)
            }
            return coerce(position, coerce(position, IR.Value.BIT(true),
                    TypeContext.TYPE(Type.Bit())), type)
        }
        if coercionCost(compiledLeft.type(), compiledRight.type()) = null &
                coercionCost(compiledRight.type(), compiledLeft.type()) = null {
            error(position, "'\{operatorName(op)}' cannot compare dissimilar types " +
                    "'\{compiledLeft.type()}' and '\{compiledRight.type()}'")
            return null
        }
        if isValue(compiledLeft.type()) & compiledRight != IR.Value.NULL |
                isValue(compiledRight.type()) & compiledLeft != IR.Value.NULL {
            error(position, "'\{operatorName(op)}' cannot operate on value types")
            return null
        }
        def builtinBit := ir.add(IR.Statement.BINARY(compiledLeft, op, compiledRight,
                Type.BuiltinBit()))
        def bit := coerce(position, IR.Value.REF(builtinBit, Type.BuiltinBit()),
                TypeContext.TYPE(Type.Bit()))
        return coerce(position, bit, type)
    }

    method compileInt(position:Position, value:UInt64, type:TypeContext):IR.Value? {
        match type {
            when TypeContext.TYPE(t):
                if t.typeKind = Type.Kind.BUILTIN_INT | t.typeKind = Type.Kind.BUILTIN_UINT {
                    return IR.Value.INT(value, t)
                }
                if t.isNumber() {
                    def args := Array<ASTNode>()
                    args.add(ASTNode.INT(position, value))
                    return call(position, IR.Value.TYPE(t), args, type)
                }
            
        }
        return coerce(position, compileInt(position, value, TypeContext.TYPE(Type.Int64())), type)
    }

    method compileNull(position:Position, type:TypeContext):IR.Value? {
        match type {
            when TypeContext.TYPE(t):
                if t.typeKind != Type.Kind.NULLABLE {
                    error(position, "expected '\{t}', but found 'null'")
                }
                return IR.Value.NULL(t)
            otherwise:
                return IR.Value.NULL(Type.Any())
        }
    }

    method compilePrefix(position:Position, op:Token.Kind, operand:ASTNode,
            type:TypeContext):IR.Value? {
        match op {
            when Token.Kind.SUB:
                match operand {
                    when ASTNode.INT(_, value):
                        match type {
                            when TypeContext.TYPE(t):
                                if t.typeKind = Type.Kind.BUILTIN_INT |
                                        t.typeKind = Type.Kind.BUILTIN_UINT {
                                    return IR.Value.INT(-value, t)
                                }
                                if t.isNumber() {
                                    def args := Array<ASTNode>()
                                    args.add(ASTNode.INT(position, -value))
                                    return call(position, IR.Value.TYPE(t), args, type)
                                }
                        }
                }
                return coerce(position, compilePrefix(position, op, operand,
                        TypeContext.TYPE(Type.Int64())), type)
            when Token.Kind.NOT:
                def target := compileExpression(operand, TypeContext.UNSPECIFIED)
                if target = null {
                    return null
                }
                return call(position, target, "!", Array<ASTNode>() -* FIXME literal *-, type)
        }
        assert false
    }

    method compileRange(position:Position, start:ASTNode?, inclusive:Bit, end:ASTNode?,
            step:ASTNode?, type:TypeContext):IR.Value? {
        var endpointContext := TypeContext.UNSPECIFIED
        var endpointType:Type? := null
        var stepContext := TypeContext.UNSPECIFIED
        match type {
            when TypeContext.TYPE(t):
                if t.typeKind = Type.Kind.GENERIC & t.subtypes.count = 2 &
                        t.subtypes[0].name = RANGE_NAME {
                    if step != null {
                        error(position, "expected '\{t}', but found '\{STEPPED_RANGE_NAME}'")
                        return null
                    }
                    endpointContext := TypeContext.TYPE(t.subtypes[1])
                    endpointType := t.subtypes[1]
                }
                else if t.typeKind = Type.Kind.GENERIC & t.subtypes.count = 3 &
                        t.subtypes[0].name = STEPPED_RANGE_NAME {
                    if step = null {
                        error(position, "expected '\{t}', but found '\{RANGE_NAME}'")
                        return null
                    }
                    endpointContext := TypeContext.TYPE(t.subtypes[1])
                    endpointType := t.subtypes[1]
                    stepContext := TypeContext.TYPE(t.subtypes[2])
                }
        }
        def compiledStart:IR.Value?
        if start != null {
            compiledStart := compileExpression(start, endpointContext)
            if compiledStart = null {
                return null
            }
        }
        else {
            compiledStart := null
        }
        def compiledEnd:IR.Value?
        if end != null {
            compiledEnd := compileExpression(end, endpointContext)
            if compiledEnd = null {
                return null
            }
        }
        else {
            compiledEnd := null
        }
        if endpointType = null {
            if compiledStart != null {
                if compiledEnd != null {
                    endpointType := compiledStart.type().union(self, compiledEnd.type())
                    if endpointType.name = "panda.core.Value" {
                        error(position, "range endpoint type mismatch: '\{compiledStart}', " +
                                "'\{compiledEnd}'")
                    }
                }
                else {
                    endpointType := compiledStart.type().nullable()
                }
            }
            else if compiledEnd != null {
                endpointType := compiledEnd.type().nullable()
            }
            else {
                endpointType := Type.Int64().nullable()
            }
        }
        def cl := getClass(endpointType)
        if cl = null {
            return null
        }
        if !isValue(cl) {
            error(position, "range endpoints must be value types, but found '\{endpointType}'")
        }
        if compiledStart = null {
            if endpointType.typeKind != Type.Kind.NULLABLE {
                error(position, "expected '\{endpointType}', but found 'null'")
                return null
            }
            compiledStart := IR.Value.NULL(endpointType)
        }
        if compiledEnd = null {
            if endpointType.typeKind != Type.Kind.NULLABLE {
                error(position, "expected '\{endpointType}', but found 'null'")
                return null
            }
            compiledEnd := IR.Value.NULL(endpointType)
        }
        if step != null {
            def compiledStep := compileExpression(step, stepContext)
            if compiledStep = null {
                return null
            }
            def args := Array<ASTNode>()
            args.add(ASTNode.IR_WRAPPER(position, compiledStart))
            args.add(ASTNode.IR_WRAPPER(position, compiledEnd))
            args.add(ASTNode.IR_WRAPPER(step.position(), compiledStep))
            args.add(ASTNode.BIT(position, inclusive))
            return call(position, IR.Value.TYPE(Type.SteppedRangeOf(endpointType)), args, type)
        }
        else {
            def args := Array<ASTNode>()
            args.add(ASTNode.IR_WRAPPER(position, compiledStart))
            args.add(ASTNode.IR_WRAPPER(position, compiledEnd))
            args.add(ASTNode.BIT(position, inclusive))
            return call(position, IR.Value.TYPE(Type.RangeOf(endpointType)), args, type)
        }
    }

    method compileSelf(position:Position):IR.Value? {
        if currentMethod[0].annotations.isClass() {
            error(position, "cannot reference 'self' from a @class context")
            return null
        }
        def s := symbolTable["self"]
        assert s != null, "no 'self' in symboltable"
        return symbolRef(position, null, s)
    }

    method typeMatch(value:IR.Value?, type:TypeContext):Bit {
        if value = null {
            return true
        }
        match type {
            when TypeContext.UNSPECIFIED:
                return true
            when TypeContext.IMMUTABLE:
                return isImmutable(value.type())
            when TypeContext.TYPE(t):
                return value.type() = t
            otherwise:
                assert false
        }
    }

    @post(typeMatch(@return, type) & (@return != null | errorCount > 0))
    method compileExpression(expr:ASTNode, type:TypeContext):IR.Value? {
        match expr {
            when ASTNode.BINARY(position, left, op, right):
                return compileBinary(position, left, op, right, type)
            when ASTNode.BIT(_, value):
                return coerce(expr.position(), IR.Value.BIT(value), type)
            when ASTNode.CALL(position, m, args):
                return compileCall(position, m, args, type)
            when ASTNode.DOT(position, base, name):
                def cl := tryResolveClassLiteral(expr)
                if cl != null {
                    return IR.Value.TYPE(cl.type)
                }
                return coerce(expr.position(), compileDot(position, base, name), type)
            when ASTNode.IDENTIFIER(position, name):
                return coerce(expr.position(), compileIdentifier(position, name), type)
            when ASTNode.INT(position, value):
                return compileInt(position, value, type)
            when ASTNode.IR_WRAPPER(_, value):
                return coerce(expr.position(), value, type)
            when ASTNode.NULL(position):
                return compileNull(position, type)
            when ASTNode.PREFIX(position, op, operand):
                return compilePrefix(position, op, operand, type)
            when ASTNode.RANGE(position, start, inclusive, end, step):
                return compileRange(position, start, inclusive, end, step, type)
            when ASTNode.SELF(position):
                return compileSelf(position)
            when ASTNode.STRING(position, text):
                return coerce(expr.position(), IR.Value.STRING(text), type)
            when ASTNode.TYPE(position, t):
                error(position, "expected an expression, but found type '\{t}'")
            otherwise:
                assert false, "unsupported expression \{expr}"
        }
    }

    method compileExpression(expr:ASTNode):IR.Value? {
        return compileExpression(expr, TypeContext.UNSPECIFIED)
    }

    ================================================================================================
    An assignment target. It is crucial that when loading and then storing the lvalue, any side
    effects only happen once. For instance, in `foo()[0] += 1`, we will create an lvalue
    representing `foo()[0]`. We have to read from this lvalue, add 1 to it, and store the result
    back. This must not result in evaluating `foo()` twice.

    It is acceptable for the mere act of creating an lvalue to evaluate shared code (`foo()`, in
    this case) - we never create an lvalue and then not use it.
    ================================================================================================
    interface LValue {
        function type():Type

        method compileLoad():IR.Value

        method compileStore(value:IR.Value)
    }

    class VariableLValue : LValue {
        def compiler:Compiler

        def slot:Int

        init(compiler:Compiler, variable:Variable) {
            self.compiler := compiler
            match variable.storage {
                when Variable.Storage.LOCAL(slot):
                    self.slot := slot
                otherwise:
                    assert false
            }
        }

        @override
        function type():Type {
            return compiler.ir.locals[slot]
        }

        @override
        method compileLoad():IR.Value {
            def result := compiler.ir.add(IR.Statement.LOAD(IR.Value.LOCAL(slot, type())))
            return IR.Value.REF(result, compiler.ir.locals[slot])
        }

        @override
        method compileStore(value:IR.Value) {
            compiler.ir.add(IR.Statement.STORE(value, IR.Value.LOCAL(slot, type())))
        }
    }

    class FieldLValue : LValue {
        def compiler:Compiler

        def position:Position

        def target:IR.Value?

        def field:FieldDecl

        def rawType:Type

        def effectiveType:Type

        init(compiler:Compiler, position:Position, target:IR.Value?, field:FieldDecl) {
            self.compiler := compiler
            self.position := position
            assert field.resolved = Resolution.RESOLVED
            self.field := field
            if target != null {
                self.target := target
            }
            else {
                self.target := compiler.compileSelf(position)
            }
            rawType := field.type
            if self.target != null {
                effectiveType := compiler.remapType(self.target.type(), rawType)
            }
            else {
                effectiveType := rawType
            }
            if self.target != null {
                self.target := compiler.coerce(position, self.target, field.owner.type)
            }
        }

        @override
        function type():Type {
            return effectiveType
        }

        @override
        method compileLoad():IR.Value {
            if field.annotations.isClass() & field.fieldKind = FieldDecl.Kind.CONSTANT {
                return compiler.compileExpression(field.rawValue)
            }
            var result:IR.Value
            if field.fieldKind = FieldDecl.Kind.PROPERTY {
                result := compiler.call(position, target, "get_\{field.name}",
                        Array<ASTNode>(), TypeContext.TYPE(rawType))
            }
            else {
                def load:IR.Statement.ID
                if compiler.isValue(field.owner) {
                    load := compiler.ir.add(IR.Statement.EXTRACT_FIELD(target, field))
                }
                else {
                    def ptr := compiler.ir.add(IR.Statement.GET_FIELD_POINTER(target, field))
                    load := compiler.ir.add(IR.Statement.LOAD(IR.Value.REF(ptr, rawType)))
                }
                result := IR.Value.REF(load, rawType)
            }
            if effectiveType != rawType {
                result := compiler.cast(result, effectiveType)
            }
            return result
        }

        @override
        method compileStore(value:IR.Value) {
            def cast:IR.Value
            if effectiveType != rawType {
                cast := compiler.cast(value, rawType)
                if cast = null {
                    return
                }
            }
            else {
                cast := value
            }
            if field.fieldKind = FieldDecl.Kind.PROPERTY {
                def args := Array<ASTNode>()
                args.add(ASTNode.IR_WRAPPER(position, value))
                compiler.call(position, target, "set_\{field.name}", args,
                        TypeContext.TYPE(rawType))
            }
            else {
                def ptr := IR.Value.REF(compiler.ir.add(IR.Statement.GET_FIELD_POINTER(target,
                        field)), rawType)
                compiler.ir.add(IR.Statement.STORE(cast, ptr))
            }
        }
    }

    class IndexLValue : LValue {
        def compiler:Compiler

        def position:Position

        def target:IR.Value

        def rawIndex:ASTNode

        -- it's important that we don't compile the index twice, so we store it the first time it
        -- gets compiled and re-use that for the other call
        def index:IR.Value?

        init(compiler:Compiler, position:Position, target:IR.Value, rawIndex:ASTNode) {
            self.compiler := compiler
            self.position := position
            self.target := target
            self.rawIndex := rawIndex
        }

        @override
        function type():Type {
            def types := compiler.possibleTypes(ASTNode.BINARY(position,
                    ASTNode.IR_WRAPPER(position, target), Token.Kind.LBRACKET, rawIndex))
            if types = null {
                return Type.Any()
            }
            assert types.count = 1 -- FIXME handle ambiguous matches
            return types[0]
        }

        @override
        method compileLoad():IR.Value {
            if index = null {
                def m := compiler.findOverloadedOperator(target.type(), Token.Kind.LBRACKET, rawIndex,
                        TypeContext.UNSPECIFIED)
                if m != null {
                    assert m.first.count = 1 -- FIXME handle ambiguous matches
                    index := compiler.compileExpression(rawIndex,
                            TypeContext.TYPE(m.first[0].parameterType(0)))
                }
            }
            return compiler.compileBinary(position, ASTNode.IR_WRAPPER(position, target),
                    Token.Kind.LBRACKET, ASTNode.IR_WRAPPER(position, index),
                    TypeContext.UNSPECIFIED)
        }

        @override
        method compileStore(value:IR.Value) {
            if index = null {
                def cl := compiler.getClass(target.type())
                if cl = null {
                    return
                }
                def assignment := compiler.getSymbolTable(cl)["[]:="]
                def methods:ListView<MethodDecl>
                match assignment.kind {
                    when Symbol.Kind.METHOD:
                        methods := Array<MethodDecl>()
                        methods->Array<MethodDecl>.add(assignment->MethodDecl)
                    when Symbol.Kind.METHODS:
                        methods := assignment->Methods.methods
                    otherwise:
                        assert false
                }
                def args := Array<ASTNode>()
                args.add(rawIndex)
                args.add(ASTNode.IR_WRAPPER(position, value))
                def m := compiler.findBestMethod(position, target, methods, args,
                        TypeContext.UNSPECIFIED)
                if m != null {
                    assert m.first.count = 1 -- FIXME handle ambiguous matches
                    index := compiler.compileExpression(rawIndex,
                            TypeContext.TYPE(m.first[0].parameterType(0)))
                }
            }
            def args := Array<ASTNode>()
            args.add(ASTNode.IR_WRAPPER(position, index))
            args.add(ASTNode.IR_WRAPPER(position, value))
            compiler.call(position, target, "[]:=", args, TypeContext.UNSPECIFIED)
        }
    }

    class ChoiceFieldLValue : LValue {
        def compiler:Compiler

        def target:IR.Value

        def choiceCase:ChoiceCase

        def index:Int

        init(compiler:Compiler, target:IR.Value, choiceCase:ChoiceCase, index:Int) {
            self.compiler := compiler
            self.target := target
            self.choiceCase := choiceCase
            self.index := index
        }

        @override
        function type():Type {
            return choiceCase.fields[index]
        }

        @override
        method compileLoad():IR.Value {
            assert false
        }

        @override
        method compileStore(value:IR.Value) {
            def ptr := compiler.ir.add(IR.Statement.GET_CHOICE_FIELD_POINTER(target, choiceCase,
                    index))
            compiler.ir.add(IR.Statement.STORE(value, IR.Value.REF(ptr, choiceCase.fields[index])))
        }
    }

    method compileLValue(expr:ASTNode):LValue? {
        match expr {
            when ASTNode.BINARY(position, left, op, right):
                if op = Token.Kind.LBRACKET {
                    def target := compileExpression(left)
                    if target = null {
                        return null
                    }
                    return IndexLValue(self, position, target, right)
                }
            when ASTNode.CHOICE_FIELD_REFERENCE(_, base, cc, index):
                def compiledBase := compileExpression(base)
                if compiledBase = null {
                    return null
                }
                return ChoiceFieldLValue(self, compiledBase, cc, index)
            when ASTNode.DOT(_, base, name):
                def compiledBase:IR.Value
                if base = ASTNode.SELF & isValue(currentClass[0]) {
                    if currentMethod[0].methodKind != MethodDecl.Kind.INIT {
                        error(expr.position(),
                                "cannot modify value fields outside of an init method")
                        return null
                    }
                    compiledBase := IR.Value.LOCAL(0, currentClass[0].type)
                }
                else {
                    compiledBase := compileExpression(base)
                    if compiledBase = null {
                        return null
                    }
                }
                def cl := getClass(compiledBase.type())
                if cl = null {
                    return null
                }
                def symbol := getSymbolTable(cl)[name]
                if symbol != null {
                    match symbol.kind {
                        when Symbol.Kind.FIELD:
                            if resolve(symbol->FieldDecl) {
                                def f := symbol->FieldDecl
                                if resolve(f) {
                                    return FieldLValue(self, expr.position(), compiledBase, f)
                                }
                            }
                            return null
                        otherwise:
                            error(expr.position(), "cannot assign to this expression")
                            return null
                    }
                }
                error(expr.position(), "class '\{cl.name}' does not have a member named '\{name}'")
                return null
            when ASTNode.IDENTIFIER(_, id):
                def symbol := symbolTable[id]
                if symbol != null {
                    match symbol.kind {
                        when Symbol.Kind.VARIABLE:
                            return VariableLValue(self, symbol->Variable)
                        when Symbol.Kind.FIELD:
                            def f := symbol->FieldDecl
                            if !f.annotations.isClass() {
                                return compileLValue(ASTNode.DOT(expr.position(),
                                        ASTNode.SELF(expr.position()), f.name))
                            }
                            if resolve(f) {
                                return FieldLValue(self, expr.position(), null, f)
                            }
                            return null
                    }
                }
                error(expr.position(), "unknown identifier")
                return null
        }
        error(expr.position(), "cannot assign to this expression)")
        return null
    }

    method compileAssert(position:Position, test:ASTNode, msg:ASTNode?) {
        def compiledTest := compileExpression(test, TypeContext.TYPE(Type.Bit()))
        if compiledTest = null {
            return
        }
        def success := ir.newBlock("assert success")
        def failure := ir.newBlock("assert failure")
        ir.add(IR.Statement.CONDITIONAL_BRANCH(extractBuiltinBit(compiledTest), success, failure))
        ir.setCurrentBlock(failure)
        def args := Array<ASTNode>()
        args.add(ASTNode.STRING(position, currentClass[0].source.name()))
        args.add(ASTNode.INT(position, position.line.convert()))
        def m:MethodDecl
        if msg != null {
            m := getSymbolTable(getClass(Type.Panda()))["assertionFailure"]->Methods.methods[0]
            args.add(msg)
        }
        else {
            m := getSymbolTable(getClass(Type.Panda()))["assertionFailure"]->Methods.methods[1]
        }
        if !resolve(m) {
            return
        }
        call(position, null, MethodRef(self, Type.Panda(), m), args, TypeContext.UNSPECIFIED)
        ir.add(IR.Statement.UNREACHABLE)
        ir.setCurrentBlock(success)
    }

    method compileAssignment(position:Position, rawLeft:ASTNode, op:Token.Kind,
            rawRight:ASTNode) {
        def left := compileLValue(rawLeft)
        if left = null {
            return
        }
        def right:IR.Value?
        if op = Token.Kind.ASSIGNMENT {
            right := compileExpression(rawRight, TypeContext.TYPE(left.type()))
        }
        else {
            right := compileBinary(position, ASTNode.IR_WRAPPER(position, left.compileLoad()),
                    removeAssignment(op), rawRight, TypeContext.UNSPECIFIED)
        }
        if right = null {
            return
        }
        left.compileStore(right)
    }

    function findLoop(position:Position, label:String?):EnclosingContext? {
        for c in enclosingContexts {
            match c {
                when EnclosingContext.LOOP(loopLabel, _, _):
                    if label = null | loopLabel != null & label = loopLabel {
                        return c
                    }
            }
        }
        if label = null {
            error(position, "not in a loop")
        }
        else {
            error(position, "not in a loop labeled '\{label}'")
        }
        return null
    }

    method compileBreak(position:Position, label:String?) {
        def l := findLoop(position, label)
        if l != null {
            match l {
                when EnclosingContext.LOOP(_, breakTarget, _):
                    ir.add(IR.Statement.BRANCH(breakTarget))
                otherwise:
                    assert false
            }
        }
    }

    method compileContinue(position:Position, label:String?) {
        def l := findLoop(position, label)
        if l != null {
            match l {
                when EnclosingContext.LOOP(_, _, continueTarget):
                    ir.add(IR.Statement.BRANCH(continueTarget))
                otherwise:
                    assert false
            }
        }
    }

    @pre(bit.type() = Type.Bit())
    method extractBuiltinBit(bit:IR.Value):IR.Value {
        Panda.ref(bit) -- FIXME bootstrap refcounting apparently broken
        def result := ir.add(IR.Statement.EXTRACT_FIELD(bit,
                getSymbolTable(getClass(Type.Bit()))["value"]->FieldDecl))
        return IR.Value.REF(result, Type.BuiltinBit())
    }

    method compileDo(position:Position, label:String?, statements:ImmutableArray<ASTNode>,
            test:ASTNode) {
        def bodyBlock := ir.newBlock("do body")
        def testBlock := ir.newBlock("do test")
        def endBlock := ir.newBlock("do end")
        def auto := AutoContext(self, EnclosingContext.LOOP(label, endBlock, testBlock))
        ir.add(IR.Statement.BRANCH(bodyBlock))
        ir.setCurrentBlock(bodyBlock)
        for s in statements {
            compileStatement(s)
        }
        if !ir.currentBlockFinished() {
            ir.add(IR.Statement.BRANCH(testBlock))
        }
        ir.setCurrentBlock(testBlock)
        def compiledTest := compileExpression(test, TypeContext.TYPE(Type.Bit()))
        if compiledTest = null {
            return
        }
        ir.add(IR.Statement.CONDITIONAL_BRANCH(extractBuiltinBit(compiledTest), bodyBlock,
                endBlock))
        ir.setCurrentBlock(endBlock)
    }

    method checkSteppedRangeTypes(position:Position, type:Type):Bit {
        if type.typeKind = Type.Kind.NULLABLE {
            return checkSteppedRangeTypes(position, type.subtypes[0])
        }
        if type.isSteppedRange() {
            def type1 := type.subtypes[1].nonnullable()
            def type2 := type.subtypes[2]
            if type1 = type2 {
                return true
            }
            if type1.isChar() & type2.name.startsWith("panda.core.Int") &
                    type1.name.endsWith(type2.name["panda.core.Int".length()..]) {
                return true
            }
            error(position, "for loop cannot iterate over '\{type}'; endpoint and step types " +
                    "are not compatible")
            return false
        }
        return true
    }

    method compileSimpleRangeFor(position:Position, label:String?, index:Variable, range:IR.Value,
            statements:ListView<ASTNode>) {
        function arg(a:IR.Value):ListView<ASTNode> {
            -- FIXME until I have array literals
            def result := Array<ASTNode>()
            result.add(ASTNode.IR_WRAPPER(Position(), a))
            return result
        }
        assert range.type().typeKind = Type.Kind.GENERIC
        assert range.type().subtypes.count = 2
        assert range.type().subtypes[0].name = RANGE_NAME
        def indexSlot:Int
        match index.storage {
            when Variable.Storage.LOCAL(slot):
                indexSlot := slot
            otherwise:
                assert false
        }
        def indexType := range.type().subtypes[1]
        assert indexType.typeKind != Type.Kind.NULLABLE
        def rangeClass := getClass(range.type())
        if rangeClass = null {
            return
        }
        def rangeFields := instanceFields(rangeClass)

        -- extract start value from range
        def start := IR.Value.REF(ir.add(IR.Statement.EXTRACT_FIELD(range, rangeFields[0])),
                indexType)

        -- store start value
        ir.add(IR.Statement.STORE(start, IR.Value.LOCAL(indexSlot, indexType)))

        -- extract end value from range
        def end := IR.Value.REF(ir.add(IR.Statement.EXTRACT_FIELD(range, rangeFields[1])),
                indexType)

        -- extract inclusive / exclusive from range
        def inclusive := extractBuiltinBit(IR.Value.REF(ir.add(IR.Statement.EXTRACT_FIELD(range,
                rangeFields[2])), Type.Bit()))

        def step := compileExpression(ASTNode.INT(position, 1), TypeContext.TYPE(indexType))

        -- start block
        def loopStart := ir.newBlock("loopStart")
        def loopEnd := ir.newBlock("loopEnd")
        def loopTest := ir.newBlock("loopTest")
        def entryInclusive := ir.newBlock("entryInclusive")
        def entryExclusive := ir.newBlock("entryExclusive")
        def auto := AutoContext(self, EnclosingContext.LOOP(label, loopEnd, loopTest))
        ir.add(IR.Statement.CONDITIONAL_BRANCH(inclusive, entryInclusive, entryExclusive))
        ir.setCurrentBlock(entryInclusive)
        def entryInclusiveTest := extractBuiltinBit(call(position, start, "<=", arg(end),
                    TypeContext.UNSPECIFIED))
        ir.add(IR.Statement.CONDITIONAL_BRANCH(entryInclusiveTest, loopStart, loopEnd))
        ir.setCurrentBlock(entryExclusive)
        def entryExclusiveTest := extractBuiltinBit(call(position, start, "<", arg(end),
                    TypeContext.UNSPECIFIED))
        ir.add(IR.Statement.CONDITIONAL_BRANCH(entryExclusiveTest, loopStart, loopEnd))
        ir.setCurrentBlock(loopStart)
        for s in statements {
            compileStatement(s)
        }
        if !ir.currentBlockFinished() {
            ir.add(IR.Statement.BRANCH(loopTest))
        }
        ir.setCurrentBlock(loopTest)
        def loopInc := ir.newBlock("loopInc")
        -- perform the test by subtracting index from end and then comparing to step, to avoid
        -- overflows near the maximum value
        def indexLoad := IR.Value.REF(ir.add(IR.Statement.LOAD(IR.Value.LOCAL(indexSlot,
                indexType))), indexType)
        def delta := call(position, end, "-", arg(indexLoad), TypeContext.UNSPECIFIED)

        def inclusiveTest := ir.newBlock("inclusiveTest")
        def exclusiveTest := ir.newBlock("exclusiveTest")
        ir.add(IR.Statement.CONDITIONAL_BRANCH(inclusive, inclusiveTest, exclusiveTest))

        -- inclusive test
        ir.setCurrentBlock(inclusiveTest)
        -- always use unsigned comparison to avoid overflow; we know both the delta and the step are
        -- the same sign
        def inclusiveTestBit := extractBuiltinBit(call(position, delta, ">=", arg(step),
                TypeContext.UNSPECIFIED))
        ir.add(IR.Statement.CONDITIONAL_BRANCH(inclusiveTestBit, loopInc, loopEnd))

        -- exclusive test
        ir.setCurrentBlock(exclusiveTest)
        def exclusiveTestBit := extractBuiltinBit(call(position, delta, ">", arg(step),
                TypeContext.UNSPECIFIED))
        ir.add(IR.Statement.CONDITIONAL_BRANCH(exclusiveTestBit, loopInc, loopEnd))

        ir.setCurrentBlock(loopInc)
        def inc := call(position, indexLoad, "+", arg(step), TypeContext.UNSPECIFIED)
        ir.add(IR.Statement.STORE(inc, IR.Value.LOCAL(indexSlot, indexType)))
        ir.add(IR.Statement.BRANCH(loopStart))

        ir.setCurrentBlock(loopEnd)
    }

    method compileSteppedRangeFor(position:Position, label:String?, index:Variable, range:IR.Value,
            statements:ListView<ASTNode>) {
        -- I am acutely aware of how horrific this looks.
        --
        -- There's no easy way to produce clean output here, since we have to handle different step
        -- values, different loop directions, and both inclusive and exclusive ranges, all of which
        -- could potentially be determined at runtime. It gets even uglier when you consider the
        -- difficulty of handling the extremes of the numeric types. You can't just add 1 and then
        -- check to see if it's in range when the limit is MAX_INT, because you'll overflow and end
        -- up with an infinite loop. You also can't just check for being equal to the limit before
        -- adding the step, because with a step bigger than 1 (or smaller than -1) you might need to
        -- stop before actually hitting the end. So you instead check the difference between the
        -- current index and the limit, but even there you need to be careful because it could
        -- overflow in a signed test, and... ugh, it's surprisingly messy and results in a ton of
        -- code.
        --
        -- Fortunately, we can just write incredibly-awful-but-straightforward code and let LLVM
        -- optimize it to something sensible if it turns out the values are known at compile time.
        -- This works remarkably well, because LLVM is awesome.
        function arg(a:IR.Value):ListView<ASTNode> {
            -- FIXME until I have array literals
            def result := Array<ASTNode>()
            result.add(ASTNode.IR_WRAPPER(Position(), a))
            return result
        }
        assert range.type().typeKind = Type.Kind.GENERIC
        assert range.type().subtypes.count = 3
        assert range.type().subtypes[0].name = STEPPED_RANGE_NAME
        def indexSlot:Int
        match index.storage {
            when Variable.Storage.LOCAL(slot):
                indexSlot := slot
            otherwise:
                assert false
        }
        def indexType := range.type().subtypes[1]
        assert indexType.typeKind != Type.Kind.NULLABLE
        def stepType := range.type().subtypes[2]
        def rangeClass := getClass(range.type())
        if rangeClass = null {
            return
        }
        def rangeFields := instanceFields(rangeClass)

        -- extract start value from range
        def start := IR.Value.REF(ir.add(IR.Statement.EXTRACT_FIELD(range, rangeFields[0])),
                indexType)

        -- store start value
        ir.add(IR.Statement.STORE(start, IR.Value.LOCAL(indexSlot, indexType)))

        -- extract end value from range
        def end := IR.Value.REF(ir.add(IR.Statement.EXTRACT_FIELD(range, rangeFields[1])),
                indexType)

        -- extract step value from range
        def step := IR.Value.REF(ir.add(IR.Statement.EXTRACT_FIELD(range, rangeFields[2])),
                stepType)

        -- extract inclusive / exclusive from range
        def inclusive := extractBuiltinBit(IR.Value.REF(ir.add(IR.Statement.EXTRACT_FIELD(range,
                rangeFields[3])), Type.Bit()))

        -- start block
        def loopStart := ir.newBlock("loopStart")
        def loopEnd := ir.newBlock("loopEnd")
        def loopTest := ir.newBlock("loopTest")
        def forwardEntry := ir.newBlock("forwardEntry")
        def backwardEntry := ir.newBlock("backwardEntry")
        def direction:IR.Value
        def auto := AutoContext(self, EnclosingContext.LOOP(label, loopEnd, loopTest))
        if stepType.name.startsWith("panda.core.Int") {
            def args := Array<ASTNode>() -- FIXME literal
            args.add(ASTNode.INT(position, 0))
            direction := extractBuiltinBit(call(position, step, ">=", args,
                    TypeContext.UNSPECIFIED))
        }
        else {
            assert stepType.name.startsWith("panda.core.UInt")
            direction := IR.Value.BIT(true)
        }
        ir.add(IR.Statement.CONDITIONAL_BRANCH(direction, forwardEntry, backwardEntry))
        ir.setCurrentBlock(forwardEntry)
        def forwardEntryInclusive := ir.newBlock("forwardEntryInclusive")
        def forwardEntryExclusive := ir.newBlock("forwardEntryExclusive")
        ir.add(IR.Statement.CONDITIONAL_BRANCH(inclusive, forwardEntryInclusive,
                forwardEntryExclusive))
        ir.setCurrentBlock(forwardEntryInclusive)
        def forwardEntryInclusiveTest := extractBuiltinBit(call(position, start, "<=", arg(end),
                    TypeContext.UNSPECIFIED))
        ir.add(IR.Statement.CONDITIONAL_BRANCH(forwardEntryInclusiveTest, loopStart, loopEnd))
        ir.setCurrentBlock(forwardEntryExclusive)
        def forwardEntryExclusiveTest := extractBuiltinBit(call(position, start, "<", arg(end),
                    TypeContext.UNSPECIFIED))
        ir.add(IR.Statement.CONDITIONAL_BRANCH(forwardEntryExclusiveTest, loopStart, loopEnd))
        ir.setCurrentBlock(backwardEntry)
        def backwardEntryInclusive := ir.newBlock("backwardEntryInclusive")
        def backwardEntryExclusive := ir.newBlock("backwardEntryExclusive")
        ir.add(IR.Statement.CONDITIONAL_BRANCH(inclusive, backwardEntryInclusive,
                backwardEntryExclusive))
        ir.setCurrentBlock(backwardEntryInclusive)
        def backwardEntryInclusiveTest := extractBuiltinBit(call(position, start, ">=", arg(end),
                    TypeContext.UNSPECIFIED))
        ir.add(IR.Statement.CONDITIONAL_BRANCH(backwardEntryInclusiveTest, loopStart, loopEnd))
        ir.setCurrentBlock(backwardEntryExclusive)
        def backwardEntryExclusiveTest := extractBuiltinBit(call(position, start, ">", arg(end),
                    TypeContext.UNSPECIFIED))
        ir.add(IR.Statement.CONDITIONAL_BRANCH(backwardEntryExclusiveTest, loopStart, loopEnd))
        ir.setCurrentBlock(loopStart)
        for s in statements {
            compileStatement(s)
        }
        if !ir.currentBlockFinished() {
            ir.add(IR.Statement.BRANCH(loopTest))
        }
        ir.setCurrentBlock(loopTest)
        def loopInc := ir.newBlock("loopInc")
        -- beginning of loop test, load index and determine direction
        def indexLoad := IR.Value.REF(ir.add(IR.Statement.LOAD(IR.Value.LOCAL(indexSlot,
                indexType))), indexType)
        def forwardTest := ir.newBlock("forwardTest")
        def backwardTest := ir.newBlock("backwardTest")
        ir.add(IR.Statement.CONDITIONAL_BRANCH(direction, forwardTest, backwardTest))

        -- forward loop; perform the test by subtracting index from end and then comparing to step,
        -- to avoid overflows near the maximum value
        ir.setCurrentBlock(forwardTest)
        def forwardDelta := call(position, end, "-", arg(indexLoad), TypeContext.UNSPECIFIED)

        -- forward loop; determine inclusive / exclusive
        def forwardInclusiveTest := ir.newBlock("forwardInclusiveTest")
        def forwardExclusiveTest := ir.newBlock("forwardExclusiveTest")
        ir.add(IR.Statement.CONDITIONAL_BRANCH(inclusive, forwardInclusiveTest,
                forwardExclusiveTest))

        -- forward inclusive test
        ir.setCurrentBlock(forwardInclusiveTest)
        -- always use unsigned comparison to avoid overflow; we know both the delta and the step are
        -- the same sign
        def forwardInclusiveTestBit := extractBuiltinBit(call(position, forwardDelta, ">=",
                arg(step), TypeContext.UNSPECIFIED))
        ir.add(IR.Statement.CONDITIONAL_BRANCH(forwardInclusiveTestBit, loopInc, loopEnd))

        -- forward exclusive test
        ir.setCurrentBlock(forwardExclusiveTest)
        def forwardExclusiveTestBit := extractBuiltinBit(call(position, forwardDelta, ">",
                arg(step), TypeContext.UNSPECIFIED))
        ir.add(IR.Statement.CONDITIONAL_BRANCH(forwardExclusiveTestBit, loopInc, loopEnd))

        -- backward loop; perform the test by subtracting end from index and then comparing to
        -- -step, to avoid overflows near the minimum value
        ir.setCurrentBlock(backwardTest)
        def backwardDelta := call(position, indexLoad, "-", arg(end), TypeContext.UNSPECIFIED)
        def negStep := call(position, step, "-", Array<ASTNode>() -* FIXME literal *-,
                TypeContext.UNSPECIFIED)

        -- backward loop; determine inclusive / exclusive
        def backwardInclusiveTest := ir.newBlock("backwardInclusiveTest")
        def backwardExclusiveTest := ir.newBlock("backwardExclusiveTest")
        ir.add(IR.Statement.CONDITIONAL_BRANCH(inclusive, backwardInclusiveTest,
                backwardExclusiveTest))

        -- backward inclusive test
        ir.setCurrentBlock(backwardInclusiveTest)
        def backwardInclusiveTestBit := extractBuiltinBit(call(position, backwardDelta, ">=",
                arg(negStep), TypeContext.UNSPECIFIED))
        ir.add(IR.Statement.CONDITIONAL_BRANCH(backwardInclusiveTestBit, loopInc, loopEnd))

        -- backward exclusive test
        ir.setCurrentBlock(backwardExclusiveTest)
        def backwardExclusiveTestBit := extractBuiltinBit(call(position, backwardDelta, ">",
                arg(negStep), TypeContext.UNSPECIFIED))
        ir.add(IR.Statement.CONDITIONAL_BRANCH(backwardExclusiveTestBit, loopInc, loopEnd))

        ir.setCurrentBlock(loopInc)
        def inc := call(position, indexLoad, "+", arg(step), TypeContext.UNSPECIFIED)
        ir.add(IR.Statement.STORE(inc, IR.Value.LOCAL(indexSlot, indexType)))
        ir.add(IR.Statement.BRANCH(loopStart))

        ir.setCurrentBlock(loopEnd)
    }

    method compileRangeFor(position:Position, label:String?, astTarget:ASTNode, list:IR.Value,
            statements:ListView<ASTNode>) {
        assert list.type().isRange() | list.type().isSteppedRange()
        if !checkSteppedRangeTypes(position, list.type()) {
            return
        }
        def elementType:Type
        if list.type().typeKind = Type.Kind.NULLABLE {
            assert list.type().subtypes[0].typeKind = Type.Kind.GENERIC
            elementType := list.type().subtypes[0].subtypes[1]
        }
        else {
            assert list.type().typeKind = Type.Kind.GENERIC
            elementType := list.type().subtypes[1]
        }
        if !elementType.isNumeric() {
            error(position, "for loop expected a numeric range, but found '\{list.type()}'")
            return
        }
        def auto := AutoSymbolTable(self)
        def target := compileTarget(astTarget, Variable.Kind.DEF, null, elementType)
        if target = null {
            return
        }
        assert target.second = null
        if list.type().isRange() {
            compileSimpleRangeFor(position, label, target.first, list, statements)
        }
        else {
            compileSteppedRangeFor(position, label, target.first, list, statements)
        }
    }

    method compileRangeFor(position:Position, label:String?, astTarget:ASTNode, rawList:ASTNode,
            statements:ListView<ASTNode>) {
        def elementType:Type
        def list:IR.Value?
        match astTarget {
            when ASTNode.TYPED_IDENTIFIER(position, _, type):
                def t := resolve(scanner.convertType(type))
                if t.typeKind = Type.Kind.NULLABLE {
                    error(position, "for loop variable cannot have nullable type '\{t}'")
                    return
                }
                if !t.isNumeric() {
                    error(position, "for loop variable cannot have non-numeric type '\{t}'")
                    return
                }
                match rawList {
                    when ASTNode.RANGE(_, _, _, _, step):
                        def type:Type
                        if step != null {
                            type := Type.SteppedRangeOf(t)
                        }
                        else {
                            type := Type.RangeOf(t)
                        }
                        list := compileExpression(rawList, TypeContext.TYPE(type))
                    otherwise:
                        assert false -- shouldn't end up here otherwise
                }
            otherwise:
                list := compileExpression(rawList)
        }
        if list = null {
            return
        }
        compileRangeFor(position, label, astTarget, list, statements)
    }

    method compileIteratorFor(position:Position, label:String?, target:ASTNode, iterator:IR.Value,
            statements:ListView<ASTNode>) {
        assert iterator.type().typeKind = Type.Kind.GENERIC &
                iterator.type().subtypes[0] = Type.Iterator()
        def compiledTarget := compileTarget(target, Variable.Kind.DEF, null,
                iterator.type().subtypes[1])
        if compiledTarget = null {
            return
        }
        def targetType := compiledTarget.first.type
        def slot:Int
        match compiledTarget.first.storage {
            when Variable.Storage.LOCAL(varSlot):
                slot := varSlot
            otherwise:
                assert false
        }
        def testBlock := ir.newBlock("testBlock")
        def bodyBlock := ir.newBlock("bodyBlock")
        def endBlock := ir.newBlock("endBlock")
        def auto := AutoContext(self, EnclosingContext.LOOP(label, endBlock, testBlock))
        ir.add(IR.Statement.BRANCH(testBlock))
        ir.setCurrentBlock(testBlock)
        def compiledTest := call(position, iterator, "get_done", Array<ASTNode>(),
                TypeContext.UNSPECIFIED)
        if compiledTest = null {
            return
        }
        def inverted := call(position, compiledTest, "!", Array<ASTNode>(), TypeContext.UNSPECIFIED)
        ir.add(IR.Statement.CONDITIONAL_BRANCH(extractBuiltinBit(inverted), bodyBlock, endBlock))
        ir.setCurrentBlock(bodyBlock)
        def next := call(position, iterator, "next", Array<ASTNode>(), TypeContext.UNSPECIFIED)
        def coerced := coerce(position, next, targetType)
        if coerced = null {
            return
        }
        ir.add(IR.Statement.STORE(coerced, IR.Value.LOCAL(slot, targetType)))
        for s in statements {
            compileStatement(s)
        }
        if !ir.currentBlockFinished() {
            ir.add(IR.Statement.BRANCH(testBlock))
        }
        ir.setCurrentBlock(endBlock)
    }

    method compileFor(position:Position, label:String?, rawTarget:ASTNode, rawList:ASTNode,
            statements:ListView<ASTNode>) {
        if rawList = ASTNode.RANGE {
            -- need to resolve unresolved range in terms of its target, as for i:Int8 in 0 .. 10 and
            -- for i:Int64 in 0 .. 10 result in different kinds of ranges
            compileRangeFor(position, label, rawTarget, rawList, statements)
            return
        }
        def list := compileExpression(rawList)
        if list = null {
            return
        }
        def symbols := AutoSymbolTable(self, symbolTable)
        if list.type().isRange() | list.type().isSteppedRange() {
            -- it's a range, but not an unresolved one
            compileRangeFor(position, label, rawTarget, list, statements)
        }
        else {
            for intf in allInterfaces(list.type()) {
                if intf.typeKind = Type.Kind.GENERIC & intf.subtypes[0] = Type.Iterator() {
                    def iterator := coerce(rawList.position(), list, intf)
                    compileIteratorFor(position, label, rawTarget, iterator, statements)
                    return
                }
                if intf.typeKind = Type.Kind.GENERIC & intf.subtypes[0] = Type.Iterable() {
                    def iterable := coerce(rawList.position(), list, intf)
                    if iterable = null {
                        return
                    }
                    def iterator := call(position, iterable, "iterator", Array<ASTNode>(),
                            TypeContext.UNSPECIFIED)
                    assert iterator != null
                    compileIteratorFor(position, label, rawTarget, iterator, statements)
                    return
                }
            }
            error(rawList.position(), "expected a range, Iterable, or Iterator, but found " +
                    "'\{list.type()}'")
        }
    }

    method compileIf(position:Position, test:ASTNode, ifTrue:ImmutableArray<ASTNode>,
            ifFalse:ASTNode?) {
        def compiledTest := compileExpression(test, TypeContext.TYPE(Type.Bit()))
        if compiledTest = null {
            return
        }
        def ifTrueBlock := ir.newBlock("if true")
        def ifFalseBlock:IR.Block.ID
        def endBlock := ir.newBlock("if end")
        if ifFalse != null {
            ifFalseBlock := ir.newBlock("if false")
        }
        else {
            ifFalseBlock := endBlock
        }
        ir.add(IR.Statement.CONDITIONAL_BRANCH(extractBuiltinBit(compiledTest), ifTrueBlock,
                ifFalseBlock))
        ir.setCurrentBlock(ifTrueBlock)
        for s in ifTrue {
            compileStatement(s)
        }
        if !ir.currentBlockFinished() {
            ir.add(IR.Statement.BRANCH(endBlock))
        }
        if ifFalse != null {
            ir.setCurrentBlock(ifFalseBlock)
            compileStatement(ifFalse)
            if !ir.currentBlockFinished() {
                ir.add(IR.Statement.BRANCH(endBlock))
            }
        }
        ir.setCurrentBlock(endBlock)
    }

    method compileLoop(position:Position, label:String?, statements:ImmutableArray<ASTNode>) {
        def bodyBlock := ir.newBlock("loop body")
        def endBlock := ir.newBlock("loop end")
        def auto := AutoContext(self, EnclosingContext.LOOP(label, endBlock, bodyBlock))
        ir.add(IR.Statement.BRANCH(bodyBlock))
        ir.setCurrentBlock(bodyBlock)
        for s in statements {
            compileStatement(s)
        }
        if !ir.currentBlockFinished() {
            ir.add(IR.Statement.BRANCH(bodyBlock))
        }
        ir.setCurrentBlock(endBlock)
    }

    method compileTarget(t:ASTNode, kind:Variable.Kind,
            rawValue:ASTNode?, valueType:Type?):Pair<Variable, IR.Value?>? {
        match t {
            when ASTNode.IDENTIFIER(position, name):
                -- no type, infer from value
                def value:IR.Value?
                def type:Type
                if rawValue != null {
                    def preferred := preferredType(rawValue)
                    if preferred = null {
                        -- force error to be reported
                        compileExpression(rawValue)
                        return null
                    }
                    value := compileExpression(rawValue, TypeContext.TYPE(preferred))
                    if value = null {
                        return null
                    }
                    type := value.type()
                }
                else if valueType != null {
                    type := valueType
                }
                else {
                    error(position, "declaration has neither a type nor a value")
                    return null
                }
                def v := Variable(position, kind, name, type,
                        Variable.Storage.LOCAL(ir.locals.count))
                ir.locals.add(v.type)
                symbolTable.add(v)
                return Pair<Variable, IR.Value?>(v, value)
            when ASTNode.TYPED_IDENTIFIER(position, name, rawType):
                def type := resolve(scanner.convertType(rawType))
                if type = null {
                    return null
                }
                def value:IR.Value?
                if rawValue != null {
                    value := compileExpression(rawValue, TypeContext.TYPE(type))
                    if value = null {
                        return null
                    }
                }
                else {
                    value := null
                }
                def v := Variable(position, kind, name, type,
                        Variable.Storage.LOCAL(ir.locals.count))
                ir.locals.add(v.type)
                symbolTable.add(v)
                return Pair<Variable, IR.Value?>(v, value)
            otherwise:
                assert false
        }
    }

    method compileDeclaration(position:Position, target:ASTNode, value:ASTNode?,
            varKind:Variable.Kind) {
        def target := compileTarget(target, varKind, value, null)
        if target = null {
            return
        }
        if target.second != null {
            match target.first.storage {
                when Variable.Storage.LOCAL(slot):
                    ir.add(IR.Statement.STORE(target.second,
                            IR.Value.LOCAL(slot, target.first.type)))
            }
        }
    }

    method checkChoiceMatch(position:Position, cc:ChoiceCase?, choiceClass:ClassDecl?,
            value:IR.Value):Bit {
        if cc = null {
            return false
        }
        if choiceClass = null {
            error(position, "cannot match choice case '\{cc}' against '\{value.type()}'")
            return false
        }
        if cc.owner !== choiceClass {
            error(position, "cannot match choice case '\{cc}' against " +
                    "'\{choiceClass.name}'")
            return false
        }
        return true
    }

    @pre(whens.count > 0 | other != null)
    method compileChainedIfMatch(value:IR.Value, choiceClass:ClassDecl?, choiceRawValue:IR.Value?,
            whens:ImmutableArray<ASTNode>, other:ImmutableArray<ASTNode>?) {
        def end := ir.newBlock("match end")
        var nextBlock := ir.currentBlock.id
        for i in 0 .. whens.count {
            def w := whens[i]
            match w {
                when ASTNode.WHEN(position, tests, statements):
                    ir.setCurrentBlock(nextBlock)
                    var testSuccess := ir.newBlock("test success")
                    for j in 0 .. tests.count {
                        ir.setCurrentBlock(nextBlock)
                        if j < tests.count - 1 | i < whens.count - 1 | other != null {
                            nextBlock := ir.newBlock("match")
                        }
                        else {
                            nextBlock := end
                        }
                        def t := tests[j]
                        match t {
                            when ASTNode.CALL(position, base, args):
                                def cc := getChoiceCase(base)
                                if checkChoiceMatch(base.position(), cc, choiceClass, value) {
                                    if tests.count != 1 {
                                        error(position, "destructuring choice 'when' cannot be " +
                                                "used together with other 'when' comparisons")
                                        return
                                    }
                                    if args.count != cc.fields.count {
                                        error(position, "choice '\{cc}' requires " +
                                                cc.fields.count +
                                                " argument\{cc.fields.count = 1:|s}, but found " +
                                                args.count)
                                        return
                                    }
                                    if choiceRawValue = null {
                                        error(position, "'\{value.type()}' is not an instance " +
                                                "of '\{cc.owner.name}'")
                                        return
                                    }
                                    def eqArgs := Array<ASTNode>() -- FIXME literal
                                    eqArgs.add(ASTNode.INT(base.position(), cc.rawValue.convert()))
                                    def test := call(base.position(), choiceRawValue, "=", eqArgs,
                                            TypeContext.UNSPECIFIED)
                                    assert test != null
                                    ir.add(IR.Statement.CONDITIONAL_BRANCH(extractBuiltinBit(test),
                                            testSuccess, nextBlock))
                                    ir.setCurrentBlock(testSuccess)
                                    for i in 0 .. args.count {
                                        def ptr := ir.add(IR.Statement.GET_CHOICE_FIELD_POINTER(
                                                value, cc, i))
                                        def load := ir.add(IR.Statement.LOAD(IR.Value.REF(ptr,
                                                cc.fields[i])))
                                        def target := compileTarget(args[i], Variable.Kind.DEF,
                                                ASTNode.IR_WRAPPER(position,
                                                        IR.Value.REF(load, cc.fields[i])),
                                                        null)
                                        match target.first.storage {
                                            when Variable.Storage.LOCAL(slot):
                                                ir.add(IR.Statement.STORE(
                                                        IR.Value.REF(load, cc.fields[i]),
                                                        IR.Value.LOCAL(slot,
                                                            target.first.type)))
                                        }
                                    }
                                    continue
                                }
                        }
                        def test:IR.Value?
                        def cc := getChoiceCase(t)
                        if cc != null {
                            def args := Array<ASTNode>() -- FIXME literal
                            args.add(ASTNode.INT(t.position(), cc.rawValue.convert()))
                            test := call(t.position(), choiceRawValue, "=", args,
                                    TypeContext.UNSPECIFIED)
                            if test = null {
                                return
                            }
                        }
                        else {
                            def args := Array<ASTNode>() -- FIXME literal
                            args.add(t)
                            test := call(t.position(), value, "=", args, TypeContext.UNSPECIFIED)
                            if test = null {
                                return
                            }
                        }
                        ir.add(IR.Statement.CONDITIONAL_BRANCH(extractBuiltinBit(test), testSuccess,
                                nextBlock))
                    }
                    ir.setCurrentBlock(testSuccess)
                    for s in statements {
                        compileStatement(s)
                    }
                    if !ir.currentBlockFinished() {
                        ir.add(IR.Statement.BRANCH(end))
                    }
                otherwise:
                    assert false
            }
        }
        ir.setCurrentBlock(end)
    }

    method compileMatch(position:Position, value:ASTNode, whens:ImmutableArray<ASTNode>,
            other:ImmutableArray<ASTNode>?) {
        var compiledValue := compileExpression(value, TypeContext.UNSPECIFIED)
        if compiledValue = null | (whens.count = 0 & other = null) {
            return
        }
        def cl := getClass(compiledValue.type())
        if cl = null {
            return
        }
        def choiceClass:ClassDecl? := null
        def choiceRawValue:IR.Value?
        if cl.classKind = ClassDecl.Kind.CHOICE {
            choiceRawValue := compileDot(position, compiledValue, compiledValue.type(),
                    ClassDecl.RAW_VALUE_NAME)
            choiceClass := cl
        }
        else if getSymbolTable(cl)["="] == null {
            error(value.position(), "'match' value does not define the '=' operator")
            return
        }
        else {
            choiceRawValue := null
        }
        compileChainedIfMatch(compiledValue, choiceClass, choiceRawValue, whens, other)
    }

    method compileReturn(position:Position, value:ASTNode?) {
        if value != null {
            if currentMethod[0].returnType = Type.Void() {
                error(position, "cannot return a value from a method with no return type")
                return
            }
            def compiled := compileExpression(value, TypeContext.TYPE(currentMethod[0].returnType))
            if compiled = null {
                return
            }
            ir.add(IR.Statement.RETURN(compiled))
        }
        else {
            if currentMethod[0].returnType != Type.Void() {
                if currentMethod[0].methodKind = MethodDecl.Kind.INIT {
                    compileReturn(position, ASTNode.SELF(position))
                    return
                }
                error(position, "expected a return value of type '\{currentMethod[0].returnType}'")
            }
            ir.add(IR.Statement.RETURN(null))
        }
    }

    method compileVar(position:Position, kind:Variable.Kind, decls:ImmutableArray<ASTNode>) {
        for decl in decls {
            match decl {
                when ASTNode.DECLARATION(position, target, rawValue):
                    compileDeclaration(position, target, rawValue, kind)
                otherwise:
                    assert false
            }
        }
    }

    method compileWhile(position:Position, label:String?, test:ASTNode,
            statements:ImmutableArray<ASTNode>) {
        def testBlock := ir.newBlock("while test")
        def bodyBlock := ir.newBlock("while body")
        def endBlock := ir.newBlock("while end")
        def auto := AutoContext(self, EnclosingContext.LOOP(label, endBlock, testBlock))
        ir.add(IR.Statement.BRANCH(testBlock))
        ir.setCurrentBlock(testBlock)
        def compiledTest := compileExpression(test, TypeContext.TYPE(Type.Bit()))
        if compiledTest = null {
            return
        }
        ir.add(IR.Statement.CONDITIONAL_BRANCH(extractBuiltinBit(compiledTest), bodyBlock,
                endBlock))
        ir.setCurrentBlock(bodyBlock)
        for s in statements {
            compileStatement(s)
        }
        if !ir.currentBlockFinished() {
            ir.add(IR.Statement.BRANCH(testBlock))
        }
        ir.setCurrentBlock(endBlock)
    }

    method compileStatement(s:ASTNode) {
        match s {
            when ASTNode.ASSERT(position, test, msg):
                compileAssert(position, test, msg)
            when ASTNode.BINARY(position, left, op, right):
                compileAssignment(position, left, op, right)
            when ASTNode.BLOCK(position, statements):
                def symbols := AutoSymbolTable(self, symbolTable)
                for stmt in statements {
                    compileStatement(stmt)
                }
            when ASTNode.BREAK(position, label):
                compileBreak(position, label)
            when ASTNode.CALL(position, m, args):
                compileCall(position, m, args, TypeContext.UNSPECIFIED)
            when ASTNode.CONTINUE(position, label):
                compileContinue(position, label)
            when ASTNode.DO(position, label, statements, test):
                compileDo(position, label, statements, test)
            when ASTNode.FOR(position, label, target, list, statements):
                compileFor(position, label, target, list, statements)
            when ASTNode.IF(position, test, ifTrue, ifFalse):
                compileIf(position, test, ifTrue, ifFalse)
            when ASTNode.LOOP(position, label, statements):
                compileLoop(position, label, statements)
            when ASTNode.MATCH(position, value, whens, other):
                compileMatch(position, value, whens, other)
            when ASTNode.RETURN(position, value):
                compileReturn(position, value)
            when ASTNode.VAR(position, kind, decls):
                compileVar(position, kind, decls)
            when ASTNode.WHILE(position, label, test, statements):
                compileWhile(position, label, test, statements)
            otherwise:
                assert false, "unsupported statement \{s}"
        }
    }

    method hasSelfParam(m:MethodDecl):Bit {
        if m.annotations.isClass() {
            return false
        }
        if m.methodKind != MethodDecl.Kind.INIT {
            return true
        }
        return !isValue(m.owner)
    }

    function callsOtherSelf(body:ImmutableArray<ASTNode>):Bit {
        if body.count = 0 {
            return false
        }
        match body[0] {
            when ASTNode.CALL(_, target, _):
                match target {
                    when ASTNode.IDENTIFIER(_, text):
                        return text = "init"
                }
        }
        return false
    }

    method compile(m:MethodDecl) {
        ir := IR()
        currentMethod.push(m)
        def auto := AutoSymbolTable(self)
        var index := 0
        if hasSelfParam(m) {
            def selfParam := Variable(m.position, Variable.Kind.DEF, "self", m.owner.type,
                    Variable.Storage.PARAMETER(index))
            index += 1
            selfParam.owner := m
            symbolTable.add(selfParam)
        }
        else if !m.annotations.isClass() {
            def selfVar := Variable(m.position, Variable.Kind.DEF, "self", m.owner.type,
                    Variable.Storage.LOCAL(0))
            selfVar.owner := m
            ir.locals.add(selfVar.type)
            symbolTable.add(selfVar)
        }
        if m.methodKind = MethodDecl.Kind.INIT & !callsOtherSelf(m.body) {
            for f in m.owner.fields {
                if f.rawValue != null & !f.annotations.isClass() {
                    def p := f.rawValue.position()
                    compileStatement(ASTNode.BINARY(p, ASTNode.DOT(p, ASTNode.SELF(p), f.name),
                            Token.Kind.ASSIGNMENT, f.rawValue))
                }
            }
        }
        for p in m.parameters {
            def v := Variable(m.position, Variable.Kind.DEF, p.name, p.type,
                    Variable.Storage.PARAMETER(index))
            v.owner := m
            symbolTable.add(v)
            index += 1
        }
        for s in m.body {
            compileStatement(s)
        }
        if !ir.currentBlockFinished() {
            if m.returnType = Type.Void() | m.methodKind = MethodDecl.Kind.INIT {
                compileReturn(m.position, null)
            }
            else {
                compileAssert(m.position, ASTNode.BIT(m.position, false),
                        ASTNode.STRING(m.position, "\{m.declaration()} exited without returning"))
                ir.add(IR.Statement.UNREACHABLE)
            }
        }
        currentMethod.pop(m)
        codeGenerator.write(m, ir)
    }

    method markNonExternal(cl:ClassDecl) {
        cl.external := false
        for inner in cl.classes {
            markNonExternal(inner)
        }
    }

    method checkImmutable(cl:ClassDecl) {
        if !cl.annotations.isUnsafeImmutable() & isImmutable(cl) {
            for f in cl.fields {
                resolve(f)
                if f.fieldKind = FieldDecl.Kind.VAR {
                    error(f.position, "immutable class '\{cl.name}' cannot contain a 'var'")
                }
                else if !isImmutable(f.type) {
                    error(f.position, "immutable class '\{cl.name}' cannot contain mutable field " +
                            "'\{f.name}' of type '\{f.type}'")
                }
            }
        }
    }

    method checkValue(cl:ClassDecl) {
        if false & isValue(cl) {
            for f in cl.fields {
                resolve(f)
                if f.type.isClass() {
                    if !isValue(getClass(f.type)) {
                        error(f.position, "value class '\{cl.name}' cannot contain non-value " +
                                "field '\{f.name}' of type '\{f.type}'")
                    }
                }
            }
        }
    }

    method checkAnnotations(cl:ClassDecl) {
        method disallow(compiler:Compiler -* FIXME capture this *-, cl:ClassDecl -* FIXME capture this *-, flag:Int, name:String) {
            if cl.annotations.flags && flag != 0 {
                compiler.error(cl.position, "classes may not be annotated with '\{name}'")
            }
        }
        disallow(self, cl, Annotations.Flag.PROTECTED, "@protected")
        disallow(self, cl, Annotations.Flag.CLASS,     "@class")
        disallow(self, cl, Annotations.Flag.OVERRIDE,  "@override")
        disallow(self, cl, Annotations.Flag.EXTERNAL,  "@external")
        disallow(self, cl, Annotations.Flag.IMPLICIT,  "@implicit")
        disallow(self, cl, Annotations.Flag.INLINE,    "@inline")
        disallow(self, cl, Annotations.Flag.WEAK,      "@weak")
        disallow(self, cl, Annotations.Flag.DEFAULT,   "@default")
        if cl.annotations.expressions != null {
            for expr in cl.annotations.expressions {
                match expr {
                    when Annotations.Expression.PRE:
                        error(cl.position, "classes may not be annotated with '@pre'")
                    when Annotations.Expression.POST:
                        error(cl.position, "classes may not be annotated with '@post'")
                    when Annotations.Expression.PRE_OR:
                        error(cl.position, "classes may not be annotated with '@preOr'")
                    when Annotations.Expression.POST_AND:
                        error(cl.position, "classes may not be annotated with '@postAnd'")
                }
            }
        }
        checkAccessModifierCount(cl.position, cl.annotations)
    }

    method checkAnnotations(f:FieldDecl) {
        method disallow(compiler:Compiler -* FIXME capture this *-, f:FieldDecl -* FIXME capture this *-, flag:Int, name:String) {
            if f.annotations.flags && flag != 0 {
                compiler.error(f.position, "fields may not be annotated with '\{name}'")
            }
        }
        disallow(self, f, Annotations.Flag.OVERRIDE,         "@override")
        disallow(self, f, Annotations.Flag.EXTERNAL,         "@external")
        disallow(self, f, Annotations.Flag.IMPLICIT,         "@implicit")
        disallow(self, f, Annotations.Flag.ABSTRACT,         "@abstract")
        disallow(self, f, Annotations.Flag.INLINE,           "@inline")
        disallow(self, f, Annotations.Flag.SPECIALIZE,       "@specialize")
        disallow(self, f, Annotations.Flag.UNSAFE_IMMUTABLE, "@unsafeImmutable")
        disallow(self, f, Annotations.Flag.DEFAULT,          "@default")
        if f.annotations.expressions != null {
            for expr in f.annotations.expressions {
                match expr {
                    when Annotations.Expression.PRE:
                        error(f.position, "fields may not be annotated with '@pre'")
                    when Annotations.Expression.POST:
                        error(f.position, "fields may not be annotated with '@post'")
                    when Annotations.Expression.PRE_OR:
                        error(f.position, "fields may not be annotated with '@preOr'")
                    when Annotations.Expression.POST_AND:
                        error(f.position, "fields may not be annotated with '@postAnd'")
                }
            }
        }
        if f.resolved = Resolution.RESOLVED {
            if f.annotations.isClass() & !isImmutable(f.type) {
                error(f.position, "only immutable fields may be annotated with '@class'")
            }
            if f.annotations.isClass() & f.fieldKind = FieldDecl.Kind.VAR {
                error(f.position, "'var' fields may not be annotated with '@class'")
            }
        }
        checkAccessModifierCount(f.position, f.annotations)
    }

    @post(currentClass.count = @pre(currentClass.count))
    method compile(cl:ClassDecl) {
        currentClass.push(cl)
        checkAnnotations(cl)
        resolve(cl)
        if cl.resolved != Resolution.RESOLVED {
            currentClass.pop()
            return
        }
        if cl.annotations.isSpecialize() {
            codeGenerator.start(cl)
            codeGenerator.end(cl)
            currentClass.pop()
            return
        }
        def old := symbolTable
        symbolTable := getSymbolTable(cl)
        checkImmutable(cl)
        checkValue(cl)
        checkInterfaceMethods()
        var started := false
        for f in cl.fields {
            resolve(f)
            checkAnnotations(f)
        }
        for m in cl.methods {
            resolve(m)
        }
        if errorCount = 0 {
            codeGenerator.start(cl)
            started := true
        }
        for m in cl.methods {
            compile(m)
        }
        if started {
            codeGenerator.end(cl)
        }
        symbolTable := old
        currentClass.pop()

        if compilationQueue.count > 0 {
            def next := compilationQueue[0]
            compilationQueue.removeIndex(0)
            compile(next)
        }
        assert compilationQueue.count = 0
    }

    method scan(file:File):ListView<ClassDecl> {
        var result := scans[file]
        if result = null {
            parser.start(file, file.readFully())
            def parsed := parser.file()
            if parsed != null {
                result := scanner.scan(file, parsed)
                for cl in result {
                    classes[cl.name] := cl
                }
            }
            else {
                result := Array<ClassDecl>()
            }
            scans[file] := result
        }
        return result
    }

    method compile(file:File) {
        for cl in scan(file) {
            compile(cl)
        }
    }

    method error(position:Position, msg:String) {
        error(currentClass[0].source, position, msg)
    }

    method error(file:File, pos:Position, msg:String) {
        if reportErrors {
            errorCount += 1
            errorQueue.post(Error(file, pos, msg))
        }
    }

    method finish() {
        while pendingClasses.count > 0 {
            def cl := pendingClasses.removeIndex(pendingClasses.count - 1)
            compile(cl)
        }
        codeGenerator.finish()
    }
}