package org.pandalanguage.pandac

uses org.pandalanguage.pandac.parser.Parser
uses org.pandalanguage.pandac.parser.Token

class Compiler (ErrorReporter) {
    constant NULLABLE_CAST_COST := 1

    def importDirs:ListView<File>

    def parser:Parser

    def scanner:Scanner

    def root:SymbolTable

    @private
    def scans := HashMap<File, ListView<ClassDecl>>()

    @private
    def classes := HashMap<String, ClassDecl>()

    @private
    def currentFile := Stack<File>()

    @private
    def currentClass := Stack<ClassDecl>()

    @private
    def currentMethod := Stack<MethodDecl>()

    @private
    var symbolTable:SymbolTable

    @private
    def codeGenerator:CodeGenerator

    @private
    def loops := Stack<String?>()

    @private
    var reusedValueCount:UInt64 := 0

    @private
    var errorCount := 0

    init(codeGenerator:CodeGenerator, importDirs:ListView<File>) {
        self.importDirs := importDirs
        self.parser := Parser(self)
        self.scanner := Scanner(self)
        self.root := SymbolTable(self)
        self.symbolTable := root
        self.codeGenerator := codeGenerator
        codeGenerator.setCompiler(self)
        root.add(Type("builtin_bit", Type.Kind.BUILTIN_BIT, -1, true))
        root.add(Type("builtin_int8", Type.Kind.BUILTIN_INT, -1, true))
        root.add(Type("builtin_int16", Type.Kind.BUILTIN_INT, -1, true))
        root.add(Type("builtin_int32", Type.Kind.BUILTIN_INT, -1, true))
        root.add(Type("builtin_int64", Type.Kind.BUILTIN_INT, -1, true))
        root.add(Alias("Int", "panda.core.Int64", -1))
        addAlias("panda.collections.Array")
        addAlias("panda.collections.Collection")
        addAlias("panda.collections.CollectionView")
        addAlias("panda.collections.CollectionWriter")
        addAlias("panda.collections.Iterable")
        addAlias("panda.collections.Iterator")
        addAlias("panda.collections.Key")
        addAlias("panda.collections.List")
        addAlias("panda.collections.ListView")
        addAlias("panda.collections.ListWriter")
        addAlias("panda.core.Class")
        addAlias("panda.core.Bit")
        addAlias("panda.core.Char8")
        addAlias("panda.core.Comparable")
        addAlias("panda.core.Equatable")
        addAlias("panda.core.Int8")
        addAlias("panda.core.Int16")
        addAlias("panda.core.Int32")
        addAlias("panda.core.Int64")
        addAlias("panda.core.Immutable")
        addAlias("panda.core.Object")
        addAlias("panda.core.Range")
        addAlias("panda.core.String")
        addAlias("panda.core.System")
        addAlias("panda.core.Value")
        addAlias("panda.io.Console")
        addAlias("panda.io.File")
        addAlias("panda.io.InputStream")
        addAlias("panda.io.OutputStream")
        addAlias("panda.unsafe.Pointer")
    }

    @private
    method addAlias(name:String) {
        root.add(Alias(name[name.next(name.lastIndexOf("."))..], name, -1))
    }

    function tryResolveClass(name:String):ClassDecl? {
        if currentClass.get_count() > 0 {
            def alias := currentClass.peek().aliases[name]
            if alias != null {
                return getClass(alias)
            }
        }
        var result := getClass(name)
        if currentClass.get_count() > 0 {
            if result = null {
                def idx := currentClass.peek().name.lastIndexOf(".")
                if idx != null {
                    result := getClass(currentClass.peek().name[...idx] + name)
                }
            }
            if result = null {
                result := getClass(currentClass.peek().name + "." + name)
            }
        }
        return result
    }

    function resolve(type:Type):Type {
        if type.resolved {
            return type
        }
        match type.typeKind {
            when Type.Kind.CLASS:
                def resolved := tryResolveClass(type.name)
                if resolved != null {
                    return resolved.type()
                }
                def s := symbolTable[type.name]
                if s != null {
                    match s.kind {
                        when Symbol.Kind.ALIAS:
                            return Type((s->Alias).fullName, Type.Kind.CLASS, type.offset, true) -- FIXME parens
                        when Symbol.Kind.GENERIC_PARAMETER:
                            def gp := s->ClassDecl.GenericParameter
                            resolve(getClass(type.offset, gp.owner))
                            def subtypes := Array<Type>() -- FIXME literal
                            subtypes.add(gp.bound)
                            return Type(gp.owner + "." + gp.name, Type.Kind.GENERIC_PARAMETER,
                                    type.offset, subtypes, true)
                        when Symbol.Kind.TYPE:
                            return s->Type
                        when Symbol.Kind.CLASS:
                            return (s->ClassDecl).type() -- FIXME parens
                    }
                }
                error(position(type.offset), "unknown type '\{type}'")
                return Type.Invalid()
            when Type.Kind.NULLABLE:
                assert type.subtypes.get_count() = 1
                def subtypes := Array<Type>()
                subtypes.add(resolve(type.subtypes[0]))
                return Type(subtypes[0].name + "?", Type.Kind.NULLABLE, type.offset, subtypes, true)
            when Type.Kind.GENERIC:
                assert type.subtypes.get_count() >= 2
                def subtypes := Array<Type>()
                subtypes.add(resolve(type.subtypes[0]))
                def name := MutableString(subtypes[0].name)
                name.append("<")
                var separator := ""
                for i in 1 .. type.subtypes.get_count() {
                    def resolved := resolve(type.subtypes[i])
                    subtypes.add(resolved)
                    name.append(separator)
                    name.append(resolved.name)
                    separator := ", "
                }
                name.append(">")
                return Type(name.convert(), Type.Kind.GENERIC, type.offset, subtypes, true)
            otherwise:
                assert false, "cannot resolve \{type}"
        }
    }

    method resolve(cl:ClassDecl) {
        if cl.resolved {
            return
        }
        cl.resolved := true
        currentFile.push(cl.source)
        def old := symbolTable
        symbolTable := cl.symbolTable
        if cl.rawSuper != null {
            cl.rawSuper := resolve(cl.rawSuper)
            if !cl.annotations.isFinal() & cl.rawSuper.name = "panda.core.Value" {
                cl.annotations.flags ||= Annotations.Flag.FINAL
                for m in cl.methods {
                    m.annotations.flags ||= Annotations.Flag.FINAL
                }
            }
        }
        for i in 0 .. cl.rawInterfaces.get_count() {
            cl.rawInterfaces[i] := resolve(cl.rawInterfaces[i])
        }
        symbolTable := old
        currentFile.pop()
    }

    method resolve(m:MethodDecl) {
        if m.resolved {
            return
        }
        resolve(m.owner)
        currentFile.push(m.owner.source) -- FIXME use init / cleanup
        def old := symbolTable
        symbolTable := m.owner.symbolTable
        for p in m.parameters {
            p.type := resolve(p.type)
        }
        m.returnType := resolve(m.returnType)
        m.resolved := true
        symbolTable := old
        currentFile.pop()
    }

    method resolve(f:FieldDecl) {
        if f.resolved {
            return
        }
        f.resolved := true
        currentFile.push(f.owner.source) -- FIXME use init / cleanup
        def old := symbolTable
        symbolTable := f.owner.symbolTable
        if f.type != Type.Void() {
            f.type := resolve(f.type)
            currentFile.pop()
            symbolTable := old
            return
        }
        if f.rawValue = null {
            error(f.offset, "field has neither a type nor a value")
            currentFile.pop()
            symbolTable := old
            return
        }
        f.value := compileExpression(f.rawValue)
        if f.value = null {
            currentFile.pop()
            symbolTable := old
            return
        }
        f.type := variableType(f.value)
        f.value := coerce(f.value, f.type)
        currentFile.pop()
        symbolTable := old
    }

    method resolve(expr:IRNode?):IRNode? {
        if expr = null {
            return null
        }
        return coerce(expr, variableType(expr))
    }

    method isValue(cl:ClassDecl):Bit {
        return coercionCost(cl.type(), Type.Value()) != null
    }

    method instanceFields(cl:ClassDecl):ListView<FieldDecl> {
        resolve(cl)
        def result := Array<FieldDecl>()
        if !isValue(cl) & cl.rawSuper != null {
            def s := getClass(cl.rawSuper)
            if s != null {
                result.addAll(instanceFields(s))
            }
        }
        for f in cl.fields {
            if !f.annotations.isClass() {
                result.add(f)
            }
        }
        return result
    }

    method getClass(fullName:String):ClassDecl? {
        var result := classes[fullName]
        if result = null {
            def suffix := fullName.replace(".", "/") + ".panda"
            var found := false
            for dir in importDirs {
                def f := dir.resolve(suffix)
                if f.exists() {
                    found := true
                    scan(f)
                    result := classes[fullName]
                }
            }
        }
        return result
    }

    method getClass(offset:Int, fullName:String):ClassDecl? {
        var result := classes[fullName]
        if result = null {
            def suffix := fullName.replace(".", "/") + ".panda"
            var found := false
            for dir in importDirs {
                def f := dir.resolve(suffix)
                if f.exists() {
                    found := true
                    def oldErrorCount := errorCount
                    scan(f)
                    result := classes[fullName]
                    if result = null & errorCount = oldErrorCount {
                        error(Position(f.name(), 1, 1),
                                "expected file '\{f}' to contain a class named '\{fullName}'")
                    }
                }
            }
            if !found {
                error(offset, "no file named \{suffix} in any import path (\{importDirs})")
            }
        }
        return result
    }

    method getClass(type:Type):ClassDecl? {
        assert type.resolved, "unresolved type \{type}"
        match type.typeKind {
            when Type.Kind.CLASS:
                return getClass(type.offset, type.name)
            when Type.Kind.NULLABLE, Type.Kind.GENERIC, Type.Kind.GENERIC_PARAMETER:
                return getClass(type.subtypes[0])
            otherwise:
                assert false, "unsupported type \{type}"
        }
    }

    method allInterfaces(t:Type):Set<Type> {
        def cl := getClass(t)
        assert cl != null
        resolve(cl)
        def result := Set<Type>()
        if cl.rawSuper != null {
            result.addAll(allInterfaces(remapType(t, cl.rawSuper)))
        }
        for intf in cl.rawInterfaces {
            result.addAll(allInterfaces(remapType(t, intf)))
        }
        if cl.classKind = ClassDecl.Kind.INTERFACE {
            result.add(t)
        }
        return result
    }

    function signatureMatch(t1:Type, t2:Type):Bit {
        assert t1.isMethod()
        assert t2.isMethod()
        if t1.subtypes.get_count() != t2.subtypes.get_count() {
            return false
        }
        for i in 0 .. t1.subtypes.get_count() {
            if t1.subtypes[i] != t2.subtypes[i] {
                return false
            }
        }
        return true
    }

    method findMethod(owner:Type, name:String, methodType:Type, checkInterfaces:Bit):MethodDecl? {
        def cl := getClass(owner)
        assert cl != null
        for test in cl.methods {
            if test.name = name {
                resolve(test)
                if signatureMatch(remapType(owner, declaredType(test)), methodType) {
                    return test
                }
            }
        }
        if checkInterfaces | cl.classKind = ClassDecl.Kind.INTERFACE {
            for raw in cl.rawInterfaces {
                def result := findMethod(remapType(owner, raw), name, methodType, checkInterfaces)
                if result != null {
                    return result
                }
            }
        }
        if cl.rawSuper != null {
            return findMethod(remapType(owner, cl.rawSuper), name, methodType, checkInterfaces)
        }
        return null
    }

    method interfaceMethods(cl:ClassDecl, intf:Type):ListView<MethodDecl> {
        def intfClass := getClass(intf)
        assert intfClass != null
        def result := Array<MethodDecl>()
        for m in intfClass.methods {
            def found := findMethod(cl.type(), m.name, remapType(intf, inheritedType(m)), false)
            assert found != null, "internal error: interface method \{m.signature()} not found in " +
                    cl.name
            result.add(found)
        }
        return result
    }

    method getSymbolTable(cl:ClassDecl):SymbolTable {
        return cl.symbolTable
    }

    method getVTable(cl:ClassDecl):ListView<MethodDecl> {
        if cl.virtualMethods.get_count() = 0 {
            resolve(cl)
            currentClass.push(cl) -- FIXME Auto
            currentFile.push(cl.source)
            if cl.rawSuper != null {
                def superCl := getClass(cl.rawSuper)
                if superCl = null {
                    currentClass.pop()
                    currentFile.pop()
                    return cl.virtualMethods
                }
                getSymbolTable(cl).parents.add(getSymbolTable(superCl))
                cl.virtualMethods.addAll(getVTable(superCl))
            }
            for derived in cl.methods {
                resolve(derived)
                if derived.methodKind = MethodDecl.Kind.INIT | derived.annotations.isClass() {
                    continue
                }
                var found := false
                for i in 0 .. cl.virtualMethods.get_count() {
                    def base := cl.virtualMethods[i]
                    resolve(base)
                    if derived.matches(base) {
                        found := true
                        cl.virtualMethods[i] := derived
                        break
                    }
                }
                if !found {
                    cl.virtualMethods.add(derived)
                }
            }
            currentClass.pop()
            currentFile.pop()
        }
        return cl.virtualMethods
    }

    method addInheritedMethods(st:SymbolTable, name:String, result:Array<MethodRef>,
            types:ListView<Type>) {
    }

    method getMethodReference(st:SymbolTable, target:IRNode?, name:String, offset:Int,
            types:ListView<Type>):IRNode {
        def methods := Array<MethodRef>()
        def s := st[name]
        if s.kind = Symbol.Kind.METHOD {
            resolve(s->MethodDecl)
            methods.add(MethodRef(s->MethodDecl, types))
        }
        else {
            assert s.kind = Symbol.Kind.METHODS
            for m in (s->Methods).methods { -- FIXME extra parens
                resolve(m)
                methods.add(MethodRef(m, types))
            }
        }
        for p in st.parents {
            addInheritedMethods(p, name, methods, types)
        }
        def children := Array<IRNode>()
        if target != null {
            children.add(target)
        }
        if methods.get_count() = 1 {
            return IRNode(IRNode.Kind.METHOD_REFERENCE, offset, methods[0].type(), methods[0],
                    children)
        }
        else {
            assert methods.get_count() > 0
            def types := Array<Type>()
            for m in methods {
                types.add(m.type())
            }
            return IRNode(IRNode.Kind.UNRESOLVED_METHOD_REFERENCE, offset, Type(types), methods,
                    children)
        }
    }

    function typeParameters(target:IRNode?):ListView<Type> {
        if target != null {
            def type:Type
            if target.type.typeKind = Type.Kind.NULLABLE {
                type := target.type.subtypes[0]
            }
            else {
                type := target.type
            }
            if type.typeKind = Type.Kind.GENERIC {
                return type.subtypes[1..]
            }
        }
        return Array<Type>()
    }

    method symbolRef(offset:Int, target:IRNode?, s:Symbol, st:SymbolTable):IRNode? {
        match s.kind {
            when Symbol.Kind.ALIAS:
                assert target = null
                def cl := getClass(offset, (s->Alias).fullName) -- FIXME remove extra parens
                if cl != null {
                    return IRNode(IRNode.Kind.TYPE_REFERENCE, offset, Type.Class(), cl.type())
                }
                return null
            when Symbol.Kind.CLASS:
                return IRNode(IRNode.Kind.TYPE_REFERENCE, offset, Type.Class(),
                        (s->ClassDecl).type()) -- FIXME parens
            when Symbol.Kind.METHOD, Symbol.Kind.METHODS:
                return getMethodReference(st, target, s.name, offset, typeParameters(target))
            when Symbol.Kind.VARIABLE:
                return IRNode(IRNode.Kind.VARIABLE_REFERENCE, offset, (s->Variable).type, -- FIXME parens
                        s->Variable)
            when Symbol.Kind.FIELD:
                def f := s->FieldDecl
                resolve(f)
                if f.type = Type.Void() {
                    return null
                }
                def children := Array<IRNode>()
                if target != null {
                    if target.kind == IRNode.Kind.SUPER {
                        error(target.offset, "'super' can only be used as part of a method call")
                        return null
                    }
                    def effectiveType := remapType(target.type, f.type)
                    children.add(target)
                    var result := IRNode(IRNode.Kind.FIELD_REFERENCE, offset, f.type, s, children)
                    if effectiveType != result.type {
                        result := cast(result, offset, false, effectiveType)
                    }
                    return result
                }
                else {
                    children.add(IRNode(IRNode.Kind.SELF, offset, currentClass.peek().type()))
                    return IRNode(IRNode.Kind.FIELD_REFERENCE, offset, f.type, s, children)
                }
            otherwise:
                assert false, "unsupported symbol kind: \{s.kind}"
        }
    }

    function remapType(context:Type, raw:Type):Type {
        match context.typeKind {
            when Type.Kind.CLASS:
                return raw
            when Type.Kind.NULLABLE:
                assert context.subtypes.get_count() = 1
                return remapType(context.subtypes[0], raw)
            when Type.Kind.GENERIC:
                assert context.subtypes.get_count() >= 2
                def typeMap := HashMap<String, Type>()
                def base := context.subtypes[0]
                def cl := tryResolveClass(base.name)
                assert cl != null
                for i in 1 .. context.subtypes.get_count() {
                    typeMap[cl.name + "." + cl.parameters[i - 1].name] := context.subtypes[i]
                }
                return raw.remap(typeMap)
            otherwise:
                assert false
        }
    }

    function variableType(type:Type):Type {
        if type = Type.IntLiteral() {
            return Type.Int64()
        }
        if type = Type.BitLiteral() {
            return Type.Bit()
        }
        return type
    }

    function variableType(expr:IRNode):Type {
        match expr.kind {
            when IRNode.Kind.UNRESOLVED_RANGE:
                return Type.RangeOf(variableType(expr.children[0].type.union(
                        expr.children[1].type)))
        }
        return variableType(expr.type)
    }

    function coercionCost(type:Type, target:Type):Int? {
        assert type.resolved
        assert target.resolved
        if type = target {
            return 0
        }
        if type = Type.Void() {
            return null
        }
        if type.typeKind = Type.Kind.NULLABLE & target.typeKind != Type.Kind.NULLABLE {
            def result := coercionCost(type.subtypes[0], target)
            if result = null {
                return null
            }
            return result + NULLABLE_CAST_COST
        }
        match target.typeKind {
            when Type.Kind.NULLABLE:
                def result := coercionCost(type, target.subtypes[0])
                if result = null {
                    return null
                }
                return result + NULLABLE_CAST_COST
            when Type.Kind.GENERIC_PARAMETER:
                return coercionCost(type, target.subtypes[0])
            when Type.Kind.BUILTIN_INT, Type.Kind.BUILTIN_UINT:
                return null
            when Type.Kind.CLASS:
                if type.typeKind = Type.Kind.GENERIC {
                    return coercionCost(type.subtypes[0], target)
                }
            when Type.Kind.GENERIC:
                if type.typeKind = Type.Kind.GENERIC {
                    var cost := coercionCost(type.subtypes[0], target.subtypes[0])
                    return cost
                }
        }
        match type.typeKind {
            when Type.Kind.BUILTIN_BIT: return coercionCost(Type.Bit(), target)
        }
        def targetClass := getClass(target)
        if targetClass = null {
            return null
        }
        for m in targetClass.methods {
            if m.annotations.isImplicit() {
                -- Internal use feature, sharp edges! We currently assume there's only one implicit
                -- method and it's a single-argument init.
                resolve(m)
                assert m.methodKind = MethodDecl.Kind.INIT
                assert m.parameters.get_count() = 1
                def cost := coercionCost(type, m.parameters[0].type)
                if cost != null {
                    return cost
                }
            }
        }

        def cl := getClass(type)
        assert cl != null
        resolve(cl)
        if cl.rawSuper != null {
            var cost := coercionCost(remapType(type, cl.rawSuper), target)
            if cost != null {
                return cost + 1
            }
        }
        for intf in cl.rawInterfaces {
            var cost := coercionCost(remapType(type, intf), target)
            if cost != null {
                return cost + 1
            }
        }
        if type.typeKind = Type.Kind.GENERIC_PARAMETER {
            return coercionCost(type.subtypes[0], target)
        }
        return null
    }

    function coercionCost(expr:IRNode, target:Type):Int? {
        if expr.type = target {
            return 0
        }
        match target.typeKind {
            when Type.Kind.NULLABLE:
                def cost := coercionCost(expr, target.subtypes[0])
                if cost = null {
                    return null
                }
                if expr.type.typeKind = Type.Kind.NULLABLE {
                    return cost
                }
                return cost + NULLABLE_CAST_COST
            when Type.Kind.GENERIC_PARAMETER:
                return coercionCost(expr, target.subtypes[0])
        }
        match expr.kind {
            when IRNode.Kind.BIT:
                if target.typeKind = Type.Kind.BUILTIN_BIT {
                    return 0
                }
                if target.isClass() {
                    return coercionCost(Type.Bit(), target)
                }
            when IRNode.Kind.INT, IRNode.Kind.NEGATED_INT:
                if target.typeKind = Type.Kind.BUILTIN_INT {
                    return 0
                }
                if target = Type.Int64() {
                    return 0
                }
                if target.isNumber() {
                    return 1
                }
                if !target.isNumber() {
                    return coercionCost(variableType(expr), target)
                }
            when IRNode.Kind.UNRESOLVED_RANGE:
                if target.isRange() {
                    assert expr.children.get_count() = 3
                    assert target.typeKind = Type.Kind.GENERIC
                    def cost1 := coercionCost(expr.children[0], target.subtypes[1])
                    if cost1 = null {
                        return null
                    }
                    def cost2 := coercionCost(expr.children[1], target.subtypes[1])
                    if cost2 = null {
                        return null
                    }
                    return cost1 + cost2
                }
                return coercionCost(variableType(expr), target)
        }
        assert expr.type != null
        return coercionCost(expr.type, target)
    }

    function coerce(expr:IRNode?, target:Type):IRNode? {
        if expr = null {
            return null
        }
        assert expr.type.resolved
        assert target.resolved
        if expr.type = target {
            return expr
        }
        match target.typeKind {
            when Type.Kind.GENERIC_PARAMETER:
                return coerce(expr, target.subtypes[0])
            when Type.Kind.NULLABLE:
                if expr.type = target.subtypes[0] {
                    def children := Array<IRNode>() -- FIXME literal
                    children.add(expr)
                    return IRNode(IRNode.Kind.CAST, expr.offset, target, false, children)
                }
                if expr.type.typeKind != Type.Kind.NULLABLE {
                    def intermediate := coerce(expr, target.subtypes[0])
                    return coerce(intermediate, target)
                }
        }
        if expr.type.typeKind = Type.Kind.NULLABLE & target.typeKind != Type.Kind.NULLABLE {
            if expr.type.subtypes[0] = target {
                def children := Array<IRNode>() -- FIXME literal
                children.add(expr)
                return IRNode(IRNode.Kind.CAST, expr.offset, target, false, children)
            }
            def intermediate := coerce(expr, expr.type.subtypes[0])
            return coerce(intermediate, target)
        }
        if expr.kind = IRNode.Kind.INT | expr.kind = IRNode.Kind.NEGATED_INT {
            if target.isBuiltinNumber() {
                return IRNode(expr.kind, expr.offset, target, expr.payload->UInt64)
            }
            if target.isClass() & !target.isNumber() {
                def varType := coerce(expr, variableType(expr))
                if varType != null {
                    return coerce(varType, target)
                }
            }
        }
        if expr.kind = IRNode.Kind.BIT {
            if target = Type.BuiltinBit() {
                return IRNode(IRNode.Kind.BIT, expr.offset, target, expr.payload->Bit)
            }
            if target.isClass() & target != Type.Bit() {
                def varType := coerce(expr, variableType(expr))
                if varType != null {
                    return coerce(varType, target)
                }
            }
        }
        if expr.kind = IRNode.Kind.UNRESOLVED_RANGE {
            assert expr.children.get_count() = 3
            if target.isRange() {
                assert target.typeKind = Type.Kind.GENERIC
                def param := target.subtypes[1]
                def start := coerce(expr.children[0], param)
                if start = null {
                    return null
                }
                def end := coerce(expr.children[1], param)
                if end = null {
                    return null
                }
                def args := Array<IRNode>()
                args.add(start)
                args.add(end)
                args.add(expr.children[2])
                args.add(IRNode(IRNode.Kind.BIT, expr.offset, Type.BuiltinBit(), expr.payload->Bit))
                def target := IRNode(IRNode.Kind.TYPE_REFERENCE, expr.offset, Type.Class(),
                        target)
                return call(target, args)
            }
            else {
                return coerce(resolve(expr), target)
            }
        }
        if coercionCost(expr, target) != null {
            def cl := getClass(target)
            if cl != null {
                for m in cl.methods {
                    if m.annotations.isImplicit() {
                        -- Internal use feature, sharp edges! We currently assume there's only one
                        -- implicit method and it's a single-argument init.
                        resolve(m)
                        assert m.methodKind = MethodDecl.Kind.INIT
                        assert m.parameters.get_count() = 1
                        if coercionCost(expr, m.parameters[0].type) != null {
                            def type := IRNode(IRNode.Kind.TYPE_REFERENCE, expr.offset,
                                    Type.Class(), cl.type())
                            def args := Array<IRNode>(1) -- FIXME literal
                            args.add(expr)
                            return call(type, args)
                        }
                    }
                }
            }
            def children := Array<IRNode>(1) -- FIXME literal
            children.add(expr)
            return IRNode(IRNode.Kind.CAST, expr.offset, target, false, children)
        }
        error(expr.offset, "expected '\{target}', but found '\{expr.type}'")
        return null
    }

    method canCast(node:IRNode, target:Type):Bit {
        if node.type.isPointer() & target.isPointer() {
            return true
        }
        if coercionCost(node, target) != null {
            return true
        }
        if node.type.isBuiltinNumber() & target.isBuiltinNumber() {
            return true
        }
        return coercionCost(target, node.type) != null
    }

    method cast(node:IRNode, offset:Int, isExplicit:Bit, target:Type):IRNode {
        if node.type = target {
            return node
        }
        assert target != Type.Void()
        if isExplicit & !canCast(node, target) {
            error(offset, "value of type '\{node.type}' cannot possibly be an instance of " +
                    "'\{target}'")
        }
        def children := Array<IRNode>() -- FIXME literal
        children.add(node)
        return IRNode(IRNode.Kind.CAST, offset, target, isExplicit, children)
    }

    method callCost(m:MethodRef, args:ListView<IRNode>, expectedReturn:Type?):Int? {
        if m.parameterCount() != args.get_count() {
            return null
        }
        var result := 0
        for i in 0 .. m.parameterCount() {
            def cost := coercionCost(args[i], m.parameter(i))
            if cost = null {
                return null
            }
            result += cost
        }
        if expectedReturn != null {
            def cost := coercionCost(m.returnType(), expectedReturn)
            if cost = null {
                return null
            }
            result += cost
        }
        return result
    }

    method matchMethods(methods:Array<MethodRef>, args:ListView<IRNode>,
            expectedReturn:Type?):Int? {
        def result := Array<MethodRef>()
        var best:Int? := null
        for m in methods {
            def cost := callCost(m, args, expectedReturn)
            if cost = null {
                continue
            }
            if best = null | cost < best {
                result.clear()
                best := cost
            }
            if cost = best {
                result.add(m)
            }
        }
        methods.clear()
        methods.addAll(result)
        return best
    }

    method call(offset:Int, target:IRNode?, m:MethodRef, args:ListView<IRNode>):IRNode? {
        assert m.value.resolved
        assert m.parameterCount() = args.get_count(), "invalid call: \{m} with args: \{args}"
        def finalArgs := Array<IRNode>()
        if target != null & !m.value.annotations.isClass() {
            finalArgs.add(coerce(target, m.value.owner.type()))
        }
        for i in 0 .. args.get_count() {
            var coerced := coerce(args[i], m.parameter(i))
            if coerced = null {
                return null
            }
            coerced := coerce(coerced, m.value.parameters[i].type)
            if coerced = null {
                return null
            }
            finalArgs.add(coerced)
        }
        var result := IRNode(IRNode.Kind.CALL, offset, m.value.returnType, m, finalArgs)
        result := cast(result, offset, true, m.returnType())
        return result
    }

    method call(target:IRNode, name:String, args:ListView<IRNode>):IRNode? {
        return call(target, name, args, null)
    }

    method call(target:IRNode, name:String, args:ListView<IRNode>, expectedType:Type?):IRNode? {
        def resolved := resolve(target)
        if resolved = null {
            return null
        }
        def cl := getClass(resolved.type)
        if cl = null {
            return null
        }
        def s := cl.symbolTable[name]
        if s = null {
            error(target.offset, "class '\{cl.name}' does not have a member named '\{name}'")
            return null
        }
        if s.kind != Symbol.Kind.METHOD & s.kind != Symbol.Kind.METHODS {
            error(target.offset, "'\{cl.name}.\{name}' is not a method")
            return null
        }
        def ref := symbolRef(target.offset, target, s, cl.symbolTable)
        if ref = null {
            return null
        }
        return call(ref, args, expectedType)
    }

    method call(m:IRNode, args:ListView<IRNode>):IRNode? {
        return call(m, args, null)
    }

    method call(m:IRNode, args:ListView<IRNode>, expectedType:Type?):IRNode? {
        match m.kind {
            when IRNode.Kind.METHOD_REFERENCE:
                def target:IRNode?
                return call(m.offset, m.children[0], m.payload->MethodRef, args)
            when IRNode.Kind.UNRESOLVED_METHOD_REFERENCE:
                def methods := Array<MethodRef>(m.payload->ListView<MethodRef>)
                matchMethods(methods, args, expectedType)
                if methods.get_count() = 1 {
                    def target:IRNode?
                    if m.children.get_count() = 1 {
                        target := m.children[0]
                    }
                    else {
                        assert m.children.get_count() = 0
                        target := null
                    }
                    return call(m.offset, target, methods[0], args)
                }
                assert false
            when IRNode.Kind.TYPE_REFERENCE:
                def cl := getClass(m.payload->Type)
                assert cl != null
                def methods := getMethodReference(cl.symbolTable, null, "init", m.offset,
                        Array<Type>())
                def initCall := resolve(call(methods, args))
                if initCall = null {
                    return null
                }
                def children := Array<IRNode>() -- FIXME literal
                children.add(initCall)
                return IRNode(IRNode.Kind.CONSTRUCT, m.offset, m.payload->Type, children)
        }
        assert false
    }

    function declaredType(m:MethodDecl):Type {
        resolve(m)
        def subtypes := Array<Type>()
        def typeName := MutableString("(")
        var separator := ""
        for p in m.parameters {
            typeName.append(separator)
            typeName.append(p.type.name)
            subtypes.add(p.type)
            separator := ", "
        }
        def kind:Int
        if m.methodKind = MethodDecl.Kind.FUNCTION {
            typeName.append(")=>(")
            kind := Type.Kind.FUNCTION
        }
        else {
            typeName.append(")=&>(")
            kind := Type.Kind.METHOD
        }
        subtypes.add(m.returnType)
        if m.returnType != Type.Void() {
            typeName.append(m.returnType.name)
        }
        typeName.append(")")
        return Type(typeName.convert(), kind, m.offset, subtypes, true)
    }

    function declaredTypeWithSelf(m:MethodDecl, selfType:Type):Type {
        resolve(m)
        def subtypes := Array<Type>()
        def typeName := MutableString("(")
        typeName.append(selfType.name)
        subtypes.add(selfType)
        for p in m.parameters {
            typeName.append(", ")
            typeName.append(p.type.name)
            subtypes.add(p.type)
        }
        def kind:Int
        if m.methodKind = MethodDecl.Kind.FUNCTION {
            typeName.append(")=>(")
            kind := Type.Kind.FUNCTION
        }
        else {
            typeName.append(")=&>(")
            kind := Type.Kind.METHOD
        }
        subtypes.add(m.returnType)
        if m.returnType != Type.Void() {
            typeName.append(m.returnType.name)
        }
        typeName.append(")")
        return Type(typeName.convert(), kind, m.offset, subtypes, true)
    }

    function inheritedType(m:MethodDecl):Type {
        return declaredType(m)
    }

    function inheritedTypeWithSelf(m:MethodDecl):Type {
        return declaredTypeWithSelf(m, m.owner.type())
    }

    @class
    function operatorName(op:Int):String {
        match op {
            when Token.Kind.ADD: return "+"
            when Token.Kind.SUB: return "-"
            when Token.Kind.MUL: return "*"
            when Token.Kind.DIV: return "/"
            when Token.Kind.INTDIV: return "//"
            when Token.Kind.REM: return "%"
            when Token.Kind.POW: return "^"
            when Token.Kind.EQ: return "="
            when Token.Kind.NEQ: return "!="
            when Token.Kind.GT: return ">"
            when Token.Kind.LT: return "<"
            when Token.Kind.GTEQ: return ">="
            when Token.Kind.LTEQ: return "<="
            when Token.Kind.OR: return "|"
            when Token.Kind.BITWISEOR: return "||"
            when Token.Kind.AND: return "&"
            when Token.Kind.BITWISEAND: return "&&"
            when Token.Kind.XOR: return "~"
            when Token.Kind.BITWISEXOR: return "~~"
            when Token.Kind.NOT: return "!"
            when Token.Kind.BITWISENOT: return "!!"
            when Token.Kind.SHIFTLEFT: return "<<"
            when Token.Kind.SHIFTRIGHT: return ">>"
            when Token.Kind.LBRACKET: return "[]"
            when Token.Kind.ASSIGNMENT: return ":="
            otherwise: assert false, "not an operator: \{op}"
        }
    }

    @class
    function isAssignment(op:Int):Bit {
        match op {
            when Token.Kind.ADDEQ, Token.Kind.SUBEQ, Token.Kind.MULEQ, Token.Kind.DIVEQ,
                    Token.Kind.INTDIVEQ, Token.Kind.REMEQ, Token.Kind.POWEQ, Token.Kind.OREQ,
                    Token.Kind.BITWISEOREQ, Token.Kind.ANDEQ, Token.Kind.BITWISEANDEQ,
                    Token.Kind.XOREQ, Token.Kind.BITWISEXOREQ, Token.Kind.SHIFTLEFTEQ,
                    Token.Kind.SHIFTRIGHTEQ:
                return true
            otherwise:
                return false
        }
    }

    @class
    function removeAssignment(op:Int):Int {
        match op {
            when Token.Kind.ADDEQ:        return Token.Kind.ADD
            when Token.Kind.SUBEQ:        return Token.Kind.SUB
            when Token.Kind.MULEQ:        return Token.Kind.MUL
            when Token.Kind.DIVEQ:        return Token.Kind.DIV
            when Token.Kind.INTDIVEQ:     return Token.Kind.INTDIV
            when Token.Kind.REMEQ:        return Token.Kind.REM
            when Token.Kind.POWEQ:        return Token.Kind.POW
            when Token.Kind.OREQ:         return Token.Kind.OR
            when Token.Kind.BITWISEOREQ:  return Token.Kind.BITWISEOR
            when Token.Kind.ANDEQ:        return Token.Kind.AND
            when Token.Kind.BITWISEANDEQ: return Token.Kind.BITWISEAND
            when Token.Kind.XOREQ:        return Token.Kind.XOR
            when Token.Kind.BITWISEXOREQ: return Token.Kind.BITWISEXOR
            when Token.Kind.SHIFTLEFTEQ:  return Token.Kind.SHIFTLEFT
            when Token.Kind.SHIFTRIGHTEQ: return Token.Kind.SHIFTRIGHT
            otherwise:
                assert false
        }
    }

    function isLValue(expr:IRNode):Bit {
        match expr.kind {
            when IRNode.Kind.CAST:
                assert expr.children.get_count() = 1
                if !expr.payload->Bit {
                    return isLValue(expr.children[0])
                }
                return false
            when IRNode.Kind.FIELD_REFERENCE, IRNode.Kind.VARIABLE_REFERENCE:
                return true
            when IRNode.Kind.REUSED_VALUE_DEFINITION:
                return isLValue(expr.children[0])
            otherwise:
                return false
        }
    }

    method foldInts(offset:Int, left:IRNode, op:Int, right:IRNode):IRNode? {
        assert left.kind = IRNode.Kind.INT | left.kind = IRNode.Kind.NEGATED_INT
        assert right.kind = IRNode.Kind.INT | right.kind = IRNode.Kind.NEGATED_INT
        if left.kind = IRNode.Kind.NEGATED_INT | left.payload->UInt64 < Int64.MAX.convert() &
                right.kind = IRNode.Kind.NEGATED_INT | right.payload->UInt64 < Int64.MAX.convert() {
            -- both values fit into a signed Int64
            def l:Int64 := (left.payload->UInt64).convert() -- FIXME parens
            def r:Int64 := (right.payload->UInt64).convert() -- FIXME parens
            match op {
                when Token.Kind.ADD:
                    return IRNode(IRNode.Kind.INT, offset, Type.IntLiteral(),
                        (l + r).convert()->UInt64)
                when Token.Kind.SUB:
                    return IRNode(IRNode.Kind.INT, offset, Type.IntLiteral(),
                        (l - r).convert()->UInt64)
                when Token.Kind.MUL:
                    return IRNode(IRNode.Kind.INT, offset, Type.IntLiteral(),
                        (l * r).convert()->UInt64)
                when Token.Kind.INTDIV:
                    return IRNode(IRNode.Kind.INT, offset, Type.IntLiteral(),
                        (l // r).convert()->UInt64)
                when Token.Kind.REM:
                    return IRNode(IRNode.Kind.INT, offset, Type.IntLiteral(),
                        (l % r).convert()->UInt64)
                when Token.Kind.EQ:
                    return IRNode(IRNode.Kind.BIT, offset, Type.BitLiteral(), l = r)
                when Token.Kind.NEQ:
                    return IRNode(IRNode.Kind.BIT, offset, Type.BitLiteral(), l != r)
                when Token.Kind.LT:
                    return IRNode(IRNode.Kind.BIT, offset, Type.BitLiteral(), l < r)
                when Token.Kind.GT:
                    return IRNode(IRNode.Kind.BIT, offset, Type.BitLiteral(), l > r)
                when Token.Kind.LTEQ:
                    return IRNode(IRNode.Kind.BIT, offset, Type.BitLiteral(), l <= r)
                when Token.Kind.GTEQ:
                    return IRNode(IRNode.Kind.BIT, offset, Type.BitLiteral(), l >= r)
                when Token.Kind.BITWISEAND:
                    return IRNode(IRNode.Kind.INT, offset, Type.IntLiteral(),
                        (l && r).convert()->UInt64)
                when Token.Kind.BITWISEOR:
                    return IRNode(IRNode.Kind.INT, offset, Type.IntLiteral(),
                        (l || r).convert()->UInt64)
                when Token.Kind.BITWISEXOR:
                    return IRNode(IRNode.Kind.INT, offset, Type.IntLiteral(),
                        (l ~~ r).convert()->UInt64)
                when Token.Kind.SHIFTLEFT:
                    return IRNode(IRNode.Kind.INT, offset, Type.IntLiteral(),
                        (l << r).convert()->UInt64)
                when Token.Kind.SHIFTRIGHT:
                    return IRNode(IRNode.Kind.INT, offset, Type.IntLiteral(),
                        (l >> r).convert()->UInt64)
            }
        }
        error(offset, "invalid numeric operation")
        return null
    }

    method compileBinary(offset:Int, rawLeft:IRNode, op:Int, rawRight:IRNode):IRNode? {
        -- FIXME use var parameters
        var left := rawLeft
        var right := rawRight
        if op = Token.Kind.ASSIGNMENT {
            left := resolve(left)
            if left = null {
                return null
            }
            right := coerce(right, left.type)
            if right = null {
                return null
            }
            if !isLValue(left) {
                error(left.offset, "cannot assign to this expression")
                return null
            }
            def children := Array<IRNode>() -- FIXME literal
            children.add(left)
            children.add(right)
            return IRNode(IRNode.Kind.BINARY, offset, Token.Kind.ASSIGNMENT, children)
        }
        if isAssignment(op) {
            -- compound assignment
            -*if left.kind = IRNode.Kind.UNRESOLVED_INDEX {
                return convertIndexedAssignment(p, left, op, right, out)
            }*-
            left := resolve(left)
            if left = null {
                return null
            }
            if !isLValue(left) {
                error(left.offset, "cannot assign to this expression")
                return null
            }
            def children := Array<IRNode>() -- FIXME literal
            children.add(left)
            reusedValueCount += 1
            left := IRNode(IRNode.Kind.REUSED_VALUE_DEFINITION, left.offset, left.type,
                    reusedValueCount, children)
            def reusedLeft := IRNode(IRNode.Kind.REUSED_VALUE, left.offset, left.type,
                    reusedValueCount)
            right := compileBinary(offset, reusedLeft, removeAssignment(op), right)
            if right = null {
                return null
            }
            -- 32 bit promotion means that e.g. int8 += int8 will result in a 32 bit value that can't be
            -- stored back into the original lvalue. Special case this and convert it back to its
            -- original size.
            if left.type.isNumber() & left.type != right.type {
                right := call(right, "convert", Array<IRNode>(), left.type)
                if right = null {
                    return null
                }
            }
            return compileBinary(offset, left, Token.Kind.ASSIGNMENT, right)
        }
        if left.type = Type.BuiltinBit() {
            if right.type = Type.BuiltinBit() & (op = Token.Kind.AND | op = Token.Kind.OR) {
                def children := Array<IRNode>() -- FIXME literal
                children.add(left)
                children.add(right)
                return IRNode(IRNode.Kind.BINARY, offset, left.type, op, children)
            }
            error(offset, "'\{operatorName(op)}' cannot operate on '\{left.type}', '\{right.type}'")
            return null
        }
        def children := Array<IRNode>()
        if (left.kind = IRNode.Kind.INT | left.kind = IRNode.Kind.NEGATED_INT) &
                (right.kind = IRNode.Kind.INT | right.kind = IRNode.Kind.NEGATED_INT) {
            return foldInts(offset, left, op, right)
        }
        if left.type.isBuiltinNumber() & coercionCost(right, left.type) != null {
            right := coerce(right, left.type)
            assert right != null
            children.add(left)
            children.add(right)
            def resultType:Type
            match op {
                when Token.Kind.EQ, Token.Kind.NEQ, Token.Kind.GT, Token.Kind.GTEQ, Token.Kind.LT,
                        Token.Kind.LTEQ:
                    resultType := Type.BuiltinBit()
                otherwise:
                    resultType := left.type
            }
            return IRNode(IRNode.Kind.BINARY, offset, resultType, op, children)
        }
        children.add(right)
        return call(left, operatorName(op), children)
    }

    method compileBinary(b:ASTNode):IRNode? {
        def left := compileExpression(b.children[0])
        if left = null {
            return null
        }
        def right := compileExpression(b.children[1])
        if right = null {
            return null
        }
        return compileBinary(b.offset, left, b.payload->Int, right)
    }

    function typeParameters(type:Type):ListView<Type> {
        if type.kind = Type.Kind.GENERIC_PARAMETER {
            return typeParameters(type.subtypes[0])
        }
        if type.typeKind = Type.Kind.GENERIC {
            assert type.subtypes.get_count() >= 2
            return type.subtypes[1..]
        }
        else {
            return Array<Type>()
        }
    }

    method typeParameters(node:IRNode):ListView<Type> {
        if node.kind = IRNode.Kind.TYPE_REFERENCE {
            return typeParameters(node.payload->Type)
        }
        return typeParameters(node.type)
    }

    method compilePrefix(op:Int, base:IRNode, offset:Int):IRNode? {
        if base.type.isClass() {
            def name := operatorName(op)
            def cl := getClass(base.type)
            if cl = null {
                return null
            }
            def s := cl.symbolTable[name]
            if s != null {
                def m:MethodDecl? := null
                match s.kind {
                    when Symbol.Kind.METHOD:
                        m := s->MethodDecl
                        assert m.parameters.get_count() = 0
                        assert !m.annotations.isClass()
                    when Symbol.Kind.METHODS:
                        for test in (s->Methods).methods { -- FIXME ()s
                            if !test.annotations.isClass() & test.parameters.get_count() = 0 {
                                m := test
                                break
                            }
                        }
                    otherwise:
                        assert false
                }
                if m != null {
                    def ref := MethodRef(m, typeParameters(base))
                    def children := Array<IRNode>() -- FIXME literal
                    children.add(base)
                    def methodRef := IRNode(IRNode.Kind.METHOD_REFERENCE, offset,
                            Type("<method>", Type.Kind.INVALID, -1, true), ref, children)
                    def args := Array<IRNode>() -- FIXME literal
                    return call(methodRef, args)
                }
            }
        }
        match op {
            when Token.Kind.SUB:
                match base.kind {
                    when IRNode.Kind.INT:
                        return IRNode(IRNode.Kind.NEGATED_INT, offset, base.type,
                                base.payload->UInt64)
                    when IRNode.Kind.NEGATED_INT:
                        return IRNode(IRNode.Kind.INT, offset, base.type, base.payload->UInt64)
                    otherwise:
-*                        if (base.fType.isBuiltinNumber()) {
                            Type type = base.fType;
                            std::vector<IRNode> children;
                            children.push_back(std::move(base));
                            *out = IRNode(p, IRNode::Kind::PREFIX, type, (uint64_t) Operator::SUB,
                                    std::move(children));
                            return true;
                        }*-
                        assert false
                }
                error(base.offset, "expected a number, but found '\{base.type}'")
                return null
-*            case Operator::BITWISENOT:
                if (base.fType.isBuiltinNumber()) {
                    Type type = base.fType;
                    std::vector<IRNode> children;
                    children.push_back(std::move(base));
                    *out = IRNode(p, IRNode::Kind::PREFIX, type, (uint64_t) op,
                            std::move(children));
                    return true;
                }
                else {
                    this->error(base.fPosition, "expected a number, but found '" + base.fType.fName +
                            "'");
                    return false;
                }
            case Operator::NOT: {
                if (!this->coerce(&base, Type::BuiltinBit())) {
                    return false;
                }
                Type type = base.fType;
                std::vector<IRNode> children;
                children.push_back(std::move(base));
                *out = IRNode(p, IRNode::Kind::PREFIX, type, (uint64_t) op,
                        std::move(children));
                return true;
            }
            default:
                abort();*-
        }
        assert false
    }

    method compilePrefix(p:ASTNode):IRNode? {
        assert p.kind = ASTNode.Kind.PREFIX
        assert p.children.get_count() = 1
        def base := compileExpression(p.children[0])
        if base = null {
            return null
        }
        return compilePrefix(p.payload->Int, base, p.offset)
    }

    method compileCall(c:ASTNode):IRNode? {
        assert c.kind = ASTNode.Kind.CALL
        var m := compileExpression(c.children[0])
        if m != null {
            def args := Array<IRNode>()
            for i in 1 .. c.children.get_count() {
                def arg := compileExpression(c.children[i])
                if arg = null {
                    return null
                }
                args.add(arg)
            }
            return call(m, args)
        }
        return null
    }

    method compileDot(d:ASTNode):IRNode? {
        assert d.kind = ASTNode.Kind.DOT
        assert d.children.get_count() = 1
        def base := resolve(compileExpression(d.children[0]))
        if base = null {
            return null
        }
        def cl:ClassDecl?
        if base.kind = IRNode.Kind.TYPE_REFERENCE {
            cl := getClass(base.payload->Type)
        }
        else {
            cl := getClass(base.type)
        }
        if cl = null {
            return null
        }
        def s := cl.symbolTable[d.payload->String]
        if s = null {
            error(d.offset, "value of type '\{base.type}' does not have a member named " +
                    "'\{d.payload}'")
            return null
        }
        return symbolRef(d.offset, base, s, cl.symbolTable)
    }

    method compileIdentifier(i:ASTNode):IRNode? {
        assert i.kind = ASTNode.Kind.IDENTIFIER
        var s := symbolTable[i.payload->String]
        if s = null {
            s := tryResolveClass(i.payload->String)
        }
        if s != null {
            return symbolRef(i.offset, null, s, symbolTable)
        }
        error(i.offset, "unknown identifier '\{i.payload}'")
        return null
    }

    method compileType(t:ASTNode):IRNode? {
        return IRNode(IRNode.Kind.TYPE_REFERENCE, t.offset, Type.Class(),
                resolve(scanner.convertType(t)))
    }

    method compileRange(r:ASTNode):IRNode? {
        assert r.kind = ASTNode.Kind.RANGE_EXCLUSIVE | r.kind = ASTNode.Kind.RANGE_INCLUSIVE
        assert r.children.get_count() = 3
        def start:IRNode?
        if r.children[0].kind = ASTNode.Kind.VOID {
            start := IRNode(IRNode.Kind.NULL_LITERAL, r.offset, Type.Null())
        }
        else {
            start := compileExpression(r.children[0])
            if start = null {
                return null
            }
        }
        def end:IRNode?
        if r.children[1].kind = ASTNode.Kind.VOID {
            end := IRNode(IRNode.Kind.NULL_LITERAL, r.offset, Type.Null())
        }
        else {
            end := compileExpression(r.children[1])
            if end = null {
                return null
            }
        }
        def step:IRNode?
        if r.children[2].kind = ASTNode.Kind.VOID {
            step := IRNode(IRNode.Kind.INT, r.offset, Type.IntLiteral(), 1)
        }
        else {
            step := coerce(compileExpression(r.children[2]), Type.Int64())
            if step = null {
                return null
            }
        }
        def children := Array<IRNode>() -- FIXME literal
        children.add(start)
        children.add(end)
        children.add(step)
        return IRNode(IRNode.Kind.UNRESOLVED_RANGE,
                r.offset,
                Type("<unresolved range>", Type.Kind.UNRESOLVED, -1, true),
                r.kind = ASTNode.Kind.RANGE_INCLUSIVE,
                children)
    }

    method compileString(s:ASTNode):IRNode? {
        return IRNode(IRNode.Kind.STRING, s.offset, Type.StringType(), s.payload->String)
    }

    method compileSelf(s:ASTNode):IRNode? {
        assert s.kind = ASTNode.Kind.SELF
        if currentMethod.peek().annotations.isClass() {
            error(s.offset, "cannot reference 'self' from a @class method")
            return null
        }
        def type:Type
        def cl := currentClass.peek()
        if cl.parameters.get_count() > 0 {
            def subtypes := Array<Type>()
            subtypes.add(cl.type())
            def name := MutableString(cl.name)
            name.append("<")
            var separator := ""
            for p in cl.parameters {
                def pType := Array<Type>() -- FIXME literal
                pType.add(p.bound)
                def pName := "\{cl.name}.\{p.name}"
                name.append(separator)
                name.append(pName)
                subtypes.add(Type(pName, Type.Kind.GENERIC_PARAMETER, p.offset,
                             pType, true))
            }
            type := Type(name.convert(), Type.Kind.GENERIC, s.offset, subtypes, true)
        }
        else {
            type := cl.type()
        }
        return IRNode(IRNode.Kind.SELF, s.offset, type)
    }

    method compileCast(c:ASTNode):IRNode? {
        assert c.kind = ASTNode.Kind.CAST
        assert c.children.get_count() = 2
        def value := compileExpression(c.children[0])
        if value = null {
            return null
        }
        def type := resolve(scanner.convertType(c.children[1]))
        if coercionCost(value, type) != null {
            return coerce(value, type)
        }
        if canCast(value, type) {
            return cast(value, c.offset, true, type)
        }
        else {
            error(c.offset, "value of type '\{value.type}' cannot possibly be an " +
                    "instance of '\{type}'")
            return null
        }
    }

    method compileExpression(e:ASTNode):IRNode? {
        match e.kind {
            when ASTNode.Kind.BINARY:
                return compileBinary(e)
            when ASTNode.Kind.BIT:
                return IRNode(IRNode.Kind.BIT, e.offset, Type.BitLiteral(), e.payload->Bit)
            when ASTNode.Kind.CALL:
                return compileCall(e)
            when ASTNode.Kind.DOT:
                return compileDot(e)
            when ASTNode.Kind.IDENTIFIER:
                return compileIdentifier(e)
            when ASTNode.Kind.INT:
                return IRNode(IRNode.Kind.INT, e.offset, Type.IntLiteral(), e.payload->UInt64)
            when ASTNode.Kind.PREFIX:
                return compilePrefix(e)
            when ASTNode.Kind.RANGE_INCLUSIVE, ASTNode.Kind.RANGE_EXCLUSIVE:
                return compileRange(e)
            when ASTNode.Kind.STRING:
                return compileString(e)
            when ASTNode.Kind.TYPE, ASTNode.Kind.GENERIC_TYPE, ASTNode.Kind.NULLABLE_TYPE:
                return compileType(e)
            when ASTNode.Kind.SELF:
                return compileSelf(e)
            when ASTNode.Kind.CAST:
                return compileCast(e)
        }
        assert false, "unsupported expression: \{e} (\{e.kind})"
    }

    method compileBlock(b:ASTNode):IRNode? {
        assert b.kind = ASTNode.Kind.BLOCK
        def symbols := SymbolTable(symbolTable) -- FIXME auto
        symbolTable := symbols
        def result := Array<IRNode>()
        for stmt in b.children {
            def compiled := compileStatement(stmt)
            if compiled = null {
                symbolTable := symbols.parents[0]
                return null
            }
            result.add(compiled)
        }
        symbolTable := symbols.parents[0]
        return IRNode(IRNode.Kind.BLOCK, b.offset, result)
    }

    method compileIf(i:ASTNode):IRNode? {
        assert i.kind = ASTNode.Kind.IF
        assert i.children.get_count() = 2 | i.children.get_count() = 3
        def test := coerce(compileExpression(i.children[0]), Type.Bit())
        if test = null {
            return null
        }
        def ifTrue := compileStatement(i.children[1])
        def children := Array<IRNode>()
        children.add(test)
        children.add(ifTrue)
        if i.children.get_count() = 3 {
            def ifFalse := compileStatement(i.children[2])
            if ifFalse = null {
                return null
            }
            children.add(ifFalse)
        }
        return IRNode(IRNode.Kind.IF, i.offset, children)
    }

    method compileRangeFor(offset:Int, label:String?, astTarget:ASTNode, list:IRNode,
            body:ASTNode):IRNode? {
        def elementType:Type
        if list.type.typeKind = Type.Kind.NULLABLE {
            assert list.type.subtypes[0].typeKind = Type.Kind.GENERIC
            elementType := list.type.subtypes[0].subtypes[1]
        }
        else {
            assert list.type.typeKind = Type.Kind.GENERIC
            elementType := list.type.subtypes[1]
        }
        def target := compileTarget(astTarget, null, elementType)
        if target = null {
            return null
        }
        assert target.value = null
        def body := compileStatement(body)
        if body = null {
            return null
        }
        def children := Array<IRNode>() -- FIXME literal
        children.add(target.target)
        children.add(list)
        children.add(body)
        return IRNode(IRNode.Kind.RANGE_FOR, offset, label, children)
    }

    method compileIteratorFor(offset:Int, label:String?, astTarget:ASTNode, iterator:IRNode,
            body:ASTNode):IRNode? {
        -- We rewrite 'for v in <iterator> { <statements> }' to:
        -- def v$Iter := <iterator>
        -- while !v$Iter.done() {
        --     def v := v$Iter.next()
        --     <statements>
        -- }
        assert iterator.type.typeKind = Type.Kind.GENERIC &
                iterator.type.subtypes[0] = Type.Iterator()
        def target := compileTarget(astTarget, null, iterator.type.subtypes[1])
        if target = null {
            return null
        }
        assert target.target.kind = IRNode.Kind.VARIABLE_REFERENCE
        def targetVar := target.target.payload->Variable
        def subtypes := Array<Type>() -- FIXME literal
        subtypes.add(Type.Iterator())
        subtypes.add(target.target.type)
        def iterType := Type("\{subtypes[0]}<\{subtypes[1]}>", Type.Kind.GENERIC, offset, subtypes,
                true)
        def iter := Variable(iterator.offset, targetVar.name + "$Iter", iterType)
        symbolTable.add(iter)
        def statements := Array<IRNode>()
        def declChildren := Array<IRNode>() -- FIXME literal
        declChildren.add(IRNode(IRNode.Kind.VARIABLE_REFERENCE, iterator.offset, iter.type, iter))
        declChildren.add(iterator)
        def varChildren := Array<IRNode>()
        varChildren.add(IRNode(IRNode.Kind.DECLARATION, iter.offset, declChildren))
        statements.add(IRNode(IRNode.Kind.DEF, iter.offset, varChildren))
        def whileChildren := Array<IRNode>()
        def done := call(IRNode(IRNode.Kind.VARIABLE_REFERENCE, iter.offset, iter.type, iter),
                "get_done", Array<IRNode>(), null)
        if done = null {
            return null
        }
        def notCall := call(done, "!", Array<IRNode>(), null)
        if notCall = null {
            return null
        }
        whileChildren.add(notCall)
        def valueDeclChildren := Array<IRNode>() -- FIXME literal
        valueDeclChildren.add(IRNode(IRNode.Kind.VARIABLE_REFERENCE, iterator.offset,
                targetVar.type, targetVar))
        def next := call(IRNode(IRNode.Kind.VARIABLE_REFERENCE, iterator.offset, iter.type, iter),
                "next", Array<IRNode>(), null)
        assert next != null
        valueDeclChildren.add(next)
        def valueVarChildren := Array<IRNode>() -- FIXME literal
        valueVarChildren.add(IRNode(IRNode.Kind.DECLARATION, iterator.offset, valueDeclChildren))
        var block := compileStatement(body)
        if block = null {
            return null
        }
        def blockChildren := Array<IRNode>()
        blockChildren.add(IRNode(IRNode.Kind.DEF, iterator.offset, valueVarChildren))
        blockChildren.addAll(block.children)
        block := IRNode(IRNode.Kind.BLOCK, block.offset, blockChildren)
        whileChildren.add(block)
        statements.add(IRNode(IRNode.Kind.WHILE, iterator.offset, label, whileChildren))
        return IRNode(IRNode.Kind.BLOCK, iterator.offset, statements)
    }

    method compileFor(f:ASTNode):IRNode? {
        assert f.kind = ASTNode.Kind.FOR
        assert f.children.get_count() = 3
        loops.push(f.payload->String?) -- FIXME use AutoLoop
        def list := compileExpression(f.children[1])
        if list = null {
            loops.pop()
            return null
        }
        if list.kind = IRNode.Kind.UNRESOLVED_RANGE {
            list := resolve(list)
            if list = null {
                loops.pop()
                return null
            }
        }
        def symbols := SymbolTable(symbolTable) -- FIXME auto
        symbolTable := symbols
        def result:IRNode?
        if list.type.isRange() {
            result := compileRangeFor(f.offset, f.payload->String?, f.children[0], list,
                    f.children[2])
        }
        else {
            var found := false
            for intf in allInterfaces(list.type) {
                if intf.typeKind = Type.Kind.GENERIC & intf.subtypes[0] = Type.Iterator() {
                    def iterator := coerce(list, intf)
                    result := compileIteratorFor(f.offset, f.payload->String?, f.children[0],
                            iterator, f.children[2])
                    found := true
                    break
                }
                if intf.typeKind = Type.Kind.GENERIC & intf.subtypes[0] = Type.Iterable() {
                    def iterable := coerce(list, intf)
                    def iterator := call(iterable, "iterator", Array<IRNode>())
                    result := compileIteratorFor(f.offset, f.payload->String?, f.children[0],
                            iterator, f.children[2])
                    found := true
                    break
                }
            }
        }
        symbolTable := symbols.parents[0]
        loops.pop()
        return result
    }

    method compileWhile(w:ASTNode):IRNode? {
        assert w.kind = ASTNode.Kind.WHILE
        assert w.children.get_count() = 2
        loops.push(w.payload->String?) -- FIXME use AutoLoop
        def test := coerce(compileExpression(w.children[0]), Type.Bit())
        if test = null {
            loops.pop()
            return null
        }
        def stmt := compileStatement(w.children[1])
        if stmt = null {
            loops.pop()
            return null
        }
        def children := Array<IRNode>(2) -- FIXME literal
        children.add(test)
        children.add(stmt)
        loops.pop()
        return IRNode(IRNode.Kind.WHILE, w.offset, w.payload, children)
    }

    method compileDo(d:ASTNode):IRNode? {
        assert d.kind = ASTNode.Kind.DO
        assert d.children.get_count() = 2
        loops.push(d.payload->String?) -- FIXME use AutoLoop
        def stmt := compileStatement(d.children[0])
        if stmt = null {
            loops.pop()
            return null
        }
        def test := coerce(compileExpression(d.children[1]), Type.Bit())
        if test = null {
            loops.pop()
            return null
        }
        def children := Array<IRNode>(2) -- FIXME literal
        children.add(stmt)
        children.add(test)
        loops.pop()
        return IRNode(IRNode.Kind.DO, d.offset, d.payload, children)
    }

    method compileLoop(l:ASTNode):IRNode? {
        assert l.kind = ASTNode.Kind.LOOP
        assert l.children.get_count() = 1
        loops.push(l.payload->String?) -- FIXME use AutoLoop
        def stmt := compileStatement(l.children[0])
        if stmt = null {
            loops.pop()
            return null
        }
        def children := Array<IRNode>(1) -- FIXME literal
        children.add(stmt)
        loops.pop()
        return IRNode(IRNode.Kind.LOOP, l.offset, l.payload, children)
    }

    -- FIXME use tuple
    class CompileTargetResult {
        def target:org.pandalanguage.pandac.IRNode
        def value:org.pandalanguage.pandac.IRNode?

        init(target:org.pandalanguage.pandac.IRNode, value:org.pandalanguage.pandac.IRNode?) {
            self.target := target
            self.value := value
        }
    }

    method compileTarget(t:ASTNode, rawValue:IRNode?, valueType:Type?):CompileTargetResult? {
        var value:IRNode? := rawValue -- FIXME use var on parameter
        assert value = null | valueType = null
        match t.kind {
            when ASTNode.Kind.IDENTIFIER:
                def type:Type
                if t.children.get_count() = 1 {
                    type := resolve(scanner.convertType(t.children[0]))
                }
                else if value != null {
                    value := resolve(value)
                    if value = null {
                        return null
                    }
                    type := variableType(value)
                }
                else if valueType != null {
                    type := valueType
                }
                else {
                    error(t.offset, "declaration has neither a type nor a value")
                    return null
                }
                if value != null {
                    value := coerce(value, type)
                    if value = null {
                        return null
                    }
                    assert value.type = type
                }
                def v := Variable(t.offset, t.payload->String, type)
                symbolTable.add(v)
                return CompileTargetResult(IRNode(IRNode.Kind.VARIABLE_REFERENCE, v.offset, v.type,
                        v), value)
            when ASTNode.Kind.TUPLE_TARGET:
                assert false
            otherwise:
                assert false
        }
    }

    method compileDeclaration(d:ASTNode):IRNode? {
        assert d.kind = ASTNode.Kind.DECLARATION
        assert d.children.get_count() = 1 | d.children.get_count() = 2
        def value:IRNode?
        if d.children.get_count() = 2 {
            value := compileExpression(d.children[1])
            if value = null {
                return null
            }
        }
        else {
            value := null
        }
        def target := compileTarget(d.children[0], value, null)
        if target = null {
            return null
        }
        def children := Array<IRNode>()
        children.add(target.target)
        if target.value != null {
            children.add(target.value)
        }
        return IRNode(IRNode.Kind.DECLARATION, d.offset, children)
    }

    method compileBreak(b:ASTNode):IRNode? {
        assert b.kind = ASTNode.Kind.BREAK
        if b.payload != null {
            var found := false
            for label in loops {
                if label != null & label = b.payload->String { -- FIXME shouldn't need null check
                    found := true
                    break
                }
            }
            if !found {
                error(b.offset, "'break \{b.payload}' must be inside a loop labelled " +
                        "'\{b.payload}:'")
            }
        }
        else if loops.get_count() = 0 {
            error(b.offset, "'break' must be inside a loop")
        }
        return IRNode(IRNode.Kind.BREAK, b.offset, b.payload->String)
    }

    method compileContinue(c:ASTNode):IRNode? {
        assert c.kind = ASTNode.Kind.CONTINUE
        if c.payload != null {
            var found := false
            for label in loops {
                if label != null & label = c.payload->String { -- FIXME shouldn't need null check
                    found := true
                    break
                }
            }
            if !found {
                error(c.offset, "'continue \{c.payload}' must be inside a loop labelled " +
                        "'\{c.payload}:'")
            }
        }
        else if loops.get_count() = 0 {
            error(c.offset, "'continue' must be inside a loop")
        }
        return IRNode(IRNode.Kind.CONTINUE, c.offset, c.payload->String)
    }

    method compileReturn(r:ASTNode):IRNode? {
        assert r.kind = ASTNode.Kind.RETURN
        if r.children.get_count() = 1 {
            if currentMethod.peek().returnType = Type.Void() {
                error(r.offset, "cannot return a value from a method with no return type")
                return null
            }
            def value := coerce(compileExpression(r.children[0]), currentMethod.peek().returnType)
            if value = null {
                return null
            }
            def children := Array<IRNode>() -- FIXME literal
            children.add(value)
            return IRNode(IRNode.Kind.RETURN, r.offset, children)
        }
        assert r.children.get_count() = 0
        if currentMethod.peek().returnType != Type.Void() {
            error(r.offset, "expected a return value")
            return null
        }
        return IRNode(IRNode.Kind.RETURN, r.offset)
    }

    method compileAssert(a:ASTNode):IRNode? {
        assert(a.kind = ASTNode.Kind.ASSERT)
        assert(a.children.get_count() = 1 | a.children.get_count() = 2)
        var test := compileExpression(a.children[0])
        if test = null {
            return null
        }
        test := coerce(test, Type.Bit())
        if test = null {
            return null
        }
        def bit := getClass(Type.Bit())
        assert bit != null
        def value := bit.symbolTable["value"]
        resolve(value->FieldDecl)
        def fieldChildren := Array<IRNode>() -- FIXME literal
        fieldChildren.add(test)
        test := IRNode(IRNode.Kind.FIELD_REFERENCE, a.offset, Type.BuiltinBit(), value,
                fieldChildren)
        def children := Array<IRNode>() -- FIXME literal
        children.add(test)
        if a.children.get_count() = 2 {
            var msg := compileExpression(a.children[1])
            if msg = null {
                return null
            }
            msg := coerce(msg, Type.StringType())
            if msg = null {
                return null
            }
            children.add(msg)
        }
        return IRNode(IRNode.Kind.ASSERT, a.offset, children)
    }

    method compileVar(v:ASTNode):IRNode? {
        assert v.kind = ASTNode.Kind.VAR |
               v.kind = ASTNode.Kind.DEF |
               v.kind = ASTNode.Kind.PROPERTY |
               v.kind = ASTNode.Kind.CONSTANT
        def decls := Array<IRNode>()
        for astDecl in v.children {
            def decl := compileDeclaration(astDecl)
            if decl = null {
                return null
            }
            decls.add(decl)
        }
        def kind:Int
        match v.kind {
            when ASTNode.Kind.VAR:      kind := IRNode.Kind.VAR
            when ASTNode.Kind.DEF:      kind := IRNode.Kind.DEF
            when ASTNode.Kind.PROPERTY: kind := IRNode.Kind.PROPERTY
            when ASTNode.Kind.CONSTANT: kind := IRNode.Kind.CONSTANT
            otherwise: assert false
        }
        return IRNode(kind, v.offset, decls)
    }

    method compileStatement(s:ASTNode):IRNode? {
        match s.kind {
            when ASTNode.Kind.ASSERT:   return compileAssert(s)
            when ASTNode.Kind.BINARY:   return compileBinary(s)
            when ASTNode.Kind.BLOCK:    return compileBlock(s)
            when ASTNode.Kind.CALL:     return compileCall(s)
            when ASTNode.Kind.IF:       return compileIf(s)
            when ASTNode.Kind.FOR:      return compileFor(s)
            when ASTNode.Kind.WHILE:    return compileWhile(s)
            when ASTNode.Kind.DO:       return compileDo(s)
            when ASTNode.Kind.LOOP:     return compileLoop(s)
            when ASTNode.Kind.BREAK:    return compileBreak(s)
            when ASTNode.Kind.CONTINUE: return compileContinue(s)
            when ASTNode.Kind.RETURN:   return compileReturn(s)
            when ASTNode.Kind.VAR, ASTNode.Kind.DEF, ASTNode.Kind.CONSTANT, ASTNode.Kind.PROPERTY:
                return compileVar(s)
        }
        assert false, "unsupported statement kind: \{s.kind}"
    }

    method compile(m:MethodDecl) {
        assert currentClass.peek() == m.owner
        assert symbolTable == m.owner.symbolTable
        currentMethod.push(m)
        resolve(m)
        if m.body != null {
            def symbols := SymbolTable(symbolTable)
            for p in m.parameters {
                symbols.add(Variable(m.offset, p.name, p.type, Variable.Storage.PARAMETER))
            }
            symbolTable := symbols
            def compiled := compileBlock(m.body)
            if compiled != null {
                codeGenerator.write(m, compiled)
            }
            assert symbolTable == symbols
            symbolTable := m.owner.symbolTable
        }
        currentMethod.pop()
    }

    method markNonExternal(cl:ClassDecl) {
        cl.external := false
        for inner in cl.classes {
            markNonExternal(inner)
        }
    }

    method compile(cl:ClassDecl) {
        markNonExternal(cl)
        currentClass.push(cl)
        currentFile.push(cl.source)
        symbolTable := cl.symbolTable
        for m in cl.methods {
            compile(m)
        }
        currentFile.pop()
        currentClass.pop()
    }

    method scan(file:File):ListView<ClassDecl> {
        var result := scans[file]
        if result = null {
            currentFile.push(file)
            parser.start(file.name(), file.readFully())
            def parsed := parser.file()
            if parsed != null {
                result := scanner.scan(file, parsed)
                for cl in result {
                    classes[cl.name] := cl
                }
            }
            else {
                result := Array<ClassDecl>()
            }
            scans[file] := result
            currentFile.pop()
        }
        return result
    }

    method compile(file:File) {
        def classes := scan(file)
        for cl in classes {
            compile(cl)
        }
    }

    function position(offset:Int):Position {
        def source := currentFile.peek().openInputStream()
        var line := 1
        var column := 1
        for i in 0 .. offset {
            match source.read()->Char8 { -- FIXME char literals
                when Char8(10):
                    line += 1
                    column := 1
                when Char8(9):
                    column += 4 - column % 4
                otherwise:
                    column += 1
            }
        }
        return Position(currentFile.peek().name(), line, column)
    }

    method error(offset:Int, msg:String) {
        error(position(offset), msg)
    }

    @override
    method error(pos:Position, msg:String) {
        errorCount += 1
        Console.printLine("\{pos}: \{msg}")
    }
}