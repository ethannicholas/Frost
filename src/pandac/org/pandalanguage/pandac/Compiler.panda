package org.pandalanguage.pandac

uses org.pandalanguage.pandac.parser.Parser
uses org.pandalanguage.pandac.parser.Token

@final
class Compiler {
    class CompilerErrorReporter : ErrorReporter {
        @weak
        def compiler:Compiler

        init(compiler:Compiler) {
            self.compiler := compiler
        }

        @override
        method error(file:File, pos:Position, msg:String) {
            compiler.error(file, pos, msg)
        }
    }

    constant WEAK_NAME := "panda.core.Weak"
    constant RANGE_NAME := "panda.core.Range"
    constant STEPPED_RANGE_NAME := "panda.core.SteppedRange"

    class Settings : Immutable {
        def pandaHome:File

        def importDirs:ImmutableArray<File>

        def optimizationLevel:Int

        def safetyLevel:Int

        init(pandaHome:File, importDirs:ListView<File>, optimizationLevel:Int, safetyLevel:Int) {
            self.pandaHome := pandaHome
            self.importDirs := ImmutableArray<File>(importDirs)
            self.optimizationLevel := optimizationLevel
            self.safetyLevel := safetyLevel
        }
    }

    constant NONNULLABLE_TO_NULLABLE_CAST_COST := 1
    constant NULLABLE_TO_NONNULLABLE_CAST_COST := 2

    def settings:Settings

    def parser:Parser

    def scanner:Scanner

    def root:SymbolTable

    var compiling:ClassDecl? := null

    var compilationQueue := Array<ClassDecl>()

    @private
    def scans := HashMap<File, ListView<ClassDecl>>()

    @private
    def classes := HashMap<String, ClassDecl>()

    @private
    def currentClass := Stack<ClassDecl>()

    @private
    def currentMethod := Stack<MethodDecl>()

    @private
    var symbolTable:SymbolTable

    @private
    def codeGenerator:CodeGenerator

    @private
    def loops := Stack<String?>()

    @private
    var reusedValueCount := 0

    @private
    var errorCount := 0

    @private
    var tmpCount := 0

    @private
    var reportErrors := true

    @private
    var existenceCache := HashMap<File, Bit>()

    @private
    var inFieldCleanup := false

    init(codeGenerator:CodeGenerator, settings:Settings) {
        self.settings := settings
        self.scanner := Scanner(self)
        self.root := SymbolTable(self)
        def errorReporter := CompilerErrorReporter(self)
        self.parser := Parser(errorReporter)
        self.symbolTable := root
        self.codeGenerator := codeGenerator
        codeGenerator.setCompiler(self)
        root.add(Type("builtin_bit", Type.Kind.BUILTIN_BIT, 1))
        root.add(Type.BuiltinInt8())
        root.add(Type.BuiltinInt16())
        root.add(Type.BuiltinInt32())
        root.add(Type.BuiltinInt64())
        root.add(Type.BuiltinUInt8())
        root.add(Type.BuiltinUInt16())
        root.add(Type.BuiltinUInt32())
        root.add(Type.BuiltinUInt64())
        root.add(Type.BuiltinFloat32())
        root.add(Type.BuiltinFloat64())
        root.add(Alias("Int", "panda.core.Int64", Position()))
        root.add(Alias("UInt", "panda.core.UInt64", Position()))
        root.add(Alias("Real", "panda.core.Real64", Position()))
        addAlias("panda.collections.Array")
        addAlias("panda.collections.Collection")
        addAlias("panda.collections.CollectionView")
        addAlias("panda.collections.CollectionWriter")
        addAlias("panda.collections.IdentityMap")
        addAlias("panda.collections.ImmutableArray")
        addAlias("panda.collections.Iterable")
        addAlias("panda.collections.Iterator")
        addAlias("panda.collections.Key")
        addAlias("panda.collections.List")
        addAlias("panda.collections.ListView")
        addAlias("panda.collections.ListWriter")
        addAlias("panda.collections.HashMap")
        addAlias("panda.collections.Map")
        addAlias("panda.collections.MapView")
        addAlias("panda.collections.MapWriter")
        addAlias("panda.collections.Set")
        addAlias("panda.collections.SpecializedArray")
        addAlias("panda.collections.Stack")
        addAlias("panda.core.Class")
        addAlias("panda.core.Bit")
        addAlias("panda.core.Char8")
        addAlias("panda.core.Char16")
        addAlias("panda.core.Char32")
        addAlias("panda.core.Comparable")
        addAlias("panda.core.Equatable")
        addAlias("panda.core.Int8")
        addAlias("panda.core.Int16")
        addAlias("panda.core.Int32")
        addAlias("panda.core.Int64")
        addAlias("panda.core.Immutable")
        addAlias("panda.core.MutableString")
        addAlias("panda.core.Object")
        addAlias("panda.core.Panda")
        addAlias("panda.core.Range")
        addAlias("panda.core.Real32")
        addAlias("panda.core.Real64")
        addAlias("panda.core.SimpleRange")
        addAlias("panda.core.SteppedRange")
        addAlias("panda.core.String")
        addAlias("panda.core.System")
        addAlias("panda.core.UInt8")
        addAlias("panda.core.UInt16")
        addAlias("panda.core.UInt32")
        addAlias("panda.core.UInt64")
        addAlias("panda.core.Value")
        addAlias("panda.core.Weak")
        addAlias("panda.math.Random")
        addAlias("panda.math.XorShift128Plus")
        addAlias("panda.io.Console")
        addAlias("panda.io.File")
        addAlias("panda.io.IndentedOutputStream")
        addAlias("panda.io.InputStream")
        addAlias("panda.io.LineNumberInputStream")
        addAlias("panda.io.MemoryInputStream")
        addAlias("panda.io.MemoryOutputStream")
        addAlias("panda.io.OutputStream")
        addAlias("panda.io.PushbackInputStream")
        addAlias("panda.unsafe.Pointer")
    }

    @private
    method addAlias(name:String) {
        root.add(Alias(name[name.next(name.lastIndexOf("."))..], name, Position()))
    }

    method isRefCounted(type:Type):Bit {
        return type.isClass() & !isValue(getClass(type))
    }

    ================================================================================================
    Attempts to locate a class with the given, possibly not-fully-qualified, class name. Returns
    null and does not report any errors on failure.
    ================================================================================================
    method tryResolveClass(name:String):ClassDecl? {
        def current:ClassDecl?
        if currentClass.get_count() > 0 {
            current := currentClass.peek()
        }
        else {
            current := null
        }
        if current != null {
            var result := current.classResolutionCache[name]
            if result != null {
                return result.value
            }
            def alias := current.aliases[name]
            if alias != null {
                result := ClassDecl.Resolution(getClass(alias))
                current.classResolutionCache[name] := result
                return result.value
            }
        }
        var result := getClass(name)
        if current != null {
            if result = null {
                def idx := current.name.lastIndexOf(".")
                if idx != null {
                    result := getClass(current.name[...idx] + name)
                }
            }
            if result = null {
                result := getClass(current.name + "." + name)
            }
            if result = null & current.owner != null {
                currentClass.push(current.owner)
                result := tryResolveClass(name)
                currentClass.pop()
            }
        }
        if result = null {
            def rootAlias := root[name]
            if rootAlias != null & rootAlias.kind = Symbol.Kind.ALIAS {
                result := getClass(rootAlias->Alias.fullName)
            }
        }
        if result = null {
            def index := name.lastIndexOf(".")
            if index != null {
                -- could be an inner class name; see if we can locate an enclosing class
                def parent := tryResolveClass(name[..index])
                if parent != null {
                    result := getClass(parent.name + name[index..])
                }
            }
        }
        if current != null {
            current.classResolutionCache[name] := ClassDecl.Resolution(result)
        }
        return result
    }

    ================================================================================================
    Verifies that a type uses the correct number and kind of generic parameters for the class it
    refers to. Reports error(s) and returns false if the type is not valid.
    ================================================================================================
    method checkGenericParameters(position:Position, cl:ClassDecl, type:Type):Bit {
        resolve(cl)
        assert type.resolved
        def expectedCount := cl.parameters.get_count()
        def foundTypes := typeParameters(type)
        def foundCount := foundTypes.get_count()
        if expectedCount != foundCount {
            error(position, "'\{cl.name}' expected \{expectedCount} generic " +
                    "parameter\{expectedCount = 1:|s}, but found \{foundCount}")
            return false
        }
        def object := Type.Object()
        for i in 0 .. expectedCount {
            def bound := cl.parameters[i].bound
            if bound = object | (bound.typeKind = Type.Kind.NULLABLE & bound.subtypes[0] = object) {
                continue
            }
            if coercionCost(foundTypes[i], remapType(type, bound)) = null {
                error(position, "generic parameter '\{cl.name}.\{cl.parameters[i].name}' must be " +
                        "of type '\{cl.parameters[i].bound}', but found '\{foundTypes[i]}'")
                return false
            }
        }
        return true
    }

    method resolve(type:Type, checkParameters:Bit):Type? {
        if type.resolved {
            return type
        }
        match type.typeKind {
            when Type.Kind.CLASS:
                def resolved := tryResolveClass(type.name)
                if resolved != null {
                    def result := resolved.type()
                    if checkParameters {
                        if !checkGenericParameters(type.position, resolved, result) {
                            return null
                        }
                    }
                    return result
                }
                def s := symbolTable[type.name]
                if s != null {
                    match s.kind {
                        when Symbol.Kind.ALIAS:
                            return Type(s->Alias.fullName, Type.Kind.CLASS, type.position, true)
                        when Symbol.Kind.GENERIC_PARAMETER:
                            def gp := s->ClassDecl.GenericParameter
                            resolve(getClass(type.position, gp.owner))
                            return Type(gp)
                        when Symbol.Kind.TYPE:
                            return s->Type
                        when Symbol.Kind.CLASS:
                            return s->ClassDecl.type()
                    }
                }
                error(type.position, "unknown type '\{type}'")
                return null
            when Type.Kind.NULLABLE:
                assert type.subtypes.get_count() = 1
                def subtypes := Array<Type>()
                def sub := resolve(type.subtypes[0])
                if sub = null {
                    return null
                }
                subtypes.add(sub)
                return Type(subtypes[0].name + "?", Type.Kind.NULLABLE, type.position, subtypes, true)
            when Type.Kind.GENERIC:
                assert type.subtypes.get_count() >= 2
                def subtypes := Array<Type>()
                def base := resolve(type.subtypes[0], false)
                if base = null {
                    return null
                }
                subtypes.add(base)
                def name := MutableString(subtypes[0].name)
                name.append("<")
                var separator := ""
                for i in 1 .. type.subtypes.get_count() {
                    def resolved := resolve(type.subtypes[i])
                    if resolved = null {
                        return null
                    }
                    subtypes.add(resolved)
                    name.append(separator)
                    name.append(resolved.name)
                    separator := ", "
                }
                name.append(">")
                def result := Type(name.finish(), Type.Kind.GENERIC, type.position, subtypes, true)
                if checkParameters {
                    if !checkGenericParameters(type.position, getClass(result.subtypes[0]),
                            result) {
                        return null
                    }
                }
                return result
            otherwise:
                assert false, "cannot resolve \{type}"
        }
    }

    method resolve(type:Type):Type? {
        return resolve(type, true)
    }

    method resolve(cl:ClassDecl) {
        if cl.resolved {
            return
        }
        cl.resolved := true
        currentClass.push(cl)
        def old := symbolTable
        symbolTable := cl.symbolTable
        for p in cl.parameters {
            def resolved := resolve(p.bound, false)
            if resolved != null {
                p.bound := resolved
            }
        }
        for rawS in cl.declaredSupers {
            def s := resolve(rawS, false)
            if s != null {
                def sClass := getClass(s)
                resolve(sClass)
                if sClass != null {
                    if sClass.classKind = ClassDecl.Kind.CLASS {
                        if cl.classKind = ClassDecl.Kind.INTERFACE {
                            error(s.position, "interface '\{cl.name}' cannot extend class " +
                                    "'\{s.name}'")
                        }
                        if cl.rawSuper = null {
                            cl.rawSuper := s
                            if cl.rawInterfaces.get_count() > 0 {
                                error(s.position, "superclass '\{s}' of class '\{cl.name}' must be " +
                                        "listed before any superinterfaces")
                            }
                        }
                        else {
                            error(s.position, "class '\{cl.name}' has more than one superclass")
                        }
                    }
                    else {
                        assert sClass.classKind = ClassDecl.Kind.INTERFACE
                        cl.rawInterfaces.add(s)
                    }
                }
            }
        }
        if cl.rawSuper = null & cl.name != "panda.core.Object" {
            cl.rawSuper := Type.Object()
        }
        if cl.rawSuper != null & !cl.annotations.isFinal() &
                cl.rawSuper.name = "panda.core.Value" {
            cl.annotations.flags ||= Annotations.Flag.FINAL
            for m in cl.methods {
                m.annotations.flags ||= Annotations.Flag.FINAL
                if scanner.shouldInline(m.annotations, m.body) {
                    m.annotations.flags ||= Annotations.Flag.INLINE
                }
            }
        }
        if cl.rawSuper != null {
            checkGenericParameters(cl.position, getClass(cl.rawSuper), cl.rawSuper)
        }
        for intf in cl.rawInterfaces {
            checkGenericParameters(cl.position, getClass(intf), intf)
        }
        for p in cl.parameters {
            def cl := getClass(p.bound)
            if cl != null {
                checkGenericParameters(cl.position, cl, p.bound)
            }
        }
        symbolTable := old
        currentClass.pop()
    }

    method resolve(m:MethodDecl) {
        if m.resolved {
            return
        }
        resolve(m.owner)
        currentClass.push(m.owner)
        def old := symbolTable
        symbolTable := m.owner.symbolTable
        for p in m.parameters {
            p.type := resolve(p.type)
        }
        m.returnType := resolve(m.returnType)
        m.resolved := true
        if !m.owner.external {
            def overridden := getOverriddenMethod(m)
            if overridden != null {
                if !m.annotations.isOverride() {
                    error(m.position, "\{m.declaration()} overrides \{overridden.declaration()}, " +
                            "but is not marked @override")
                }
                if m.methodKind = MethodDecl.Kind.METHOD &
                        overridden.methodKind = MethodDecl.Kind.FUNCTION {
                    error(m.position, "\{m.declaration()} overrides \{overridden.declaration()}, " +
                            "but methods cannot override functions")
                }
            }
            else if m.annotations.isOverride() {
                error(m.position, "\{m.declaration()} is marked @override, but no matching " +
                        "method exists among its ancestors")
            }
        }
        symbolTable := old
        currentClass.pop()
    }

    method determineRawType(f:FieldDecl) {
        currentClass.push(f.owner)
        def old := symbolTable
        symbolTable := f.owner.symbolTable
        if f.type != Type.Void() {
            def resolved := resolve(f.type)
            if resolved != null {
                f.type := resolved
                if f.rawValue != null {
                    f.value := coerce(compileExpression(f.rawValue), f.type)
                }
            }
            currentClass.pop()
            symbolTable := old
            return
        }
        if f.rawValue = null {
            error(f.position, "field has neither a type nor a value")
            currentClass.pop()
            symbolTable := old
            return
        }
        f.value := compileExpression(f.rawValue)
        if f.value = null {
            currentClass.pop()
            symbolTable := old
            return
        }
        f.type := variableType(f.value)
        f.value := coerce(f.value, f.type)
        currentClass.pop()
        symbolTable := old
    }

    method resolve(f:FieldDecl) {
        if f.resolved {
            return
        }
        f.resolved := true
        determineRawType(f)
        if f.annotations.isWeak() & f.type != Type.Void() {
            f.type := Type.WeakOf(f.type)
            if f.value != null {
                def args := Array<IRNode>() -- FIXME literal
                args.add(f.value)
                f.value := call(IRNode.TYPE_REFERENCE(f.position, f.type), args)
            }
        }
    }

    method resolve(c:ChoiceEntry) {
        if c.resolved {
            return
        }
        c.resolved := true
        if c.fields.get_count() = 0 {
            return
        }
        currentClass.push(c.owner)
        def old := symbolTable
        symbolTable := c.owner.symbolTable
        for i in 0 .. c.fields.get_count() {
            c.fields[i] := resolve(c.fields[i])
        }
        symbolTable := old
        currentClass.pop()
    }

    method resolveMethodCall(position:Position, callTarget:IRNode?,
            methods:ImmutableArray<MethodRef>, args:ImmutableArray<IRNode>,
            targetType:Type?):IRNode? {
        var best := Array<MethodRef>()
        var bestCost:Int? := null
        for m in methods {
            def cost := callCost(m, args, targetType)
            if cost = null {
                continue
            }
            if bestCost = null {
                best.add(m)
                bestCost := cost
                continue
            }
            if cost < bestCost {
                best.clear()
                bestCost := cost
            }
            if cost = bestCost {
                best.add(m)
            }
        }
        if best.get_count() = 1 {
            var result := call(position, callTarget, best[0], args)
            if targetType != null {
                result := coerce(result, targetType)
            }
            return result
        }
        Console.printLine("no or ambiguous match on method call (\{position}, \{methods[0].value.name}, \{best})")
        assert false
        return null
    }

    method resolve(expr:IRNode?):IRNode? {
        if expr = null {
            return null
        }
        match expr {
            when IRNode.UNRESOLVED_IDENTIFIER(position, _):
                error(position, "unknown identifier")
                return null
            when IRNode.UNRESOLVED_METHOD_CALL(position, _, callTarget, methods, args):
                return resolveMethodCall(position, callTarget, methods, args, null)
            when IRNode.SUPER(position, _):
                error(position, "'super' can only be used as part of a method call")
                return null
            when IRNode.FIELD_REFERENCE(position, _, _, field):
                if field.annotations.isWeak() & !inFieldCleanup {
                    def get := compileDot(position, expr, "get")
                    assert get != null
                    return call(get, Array<IRNode>())
                }
                return expr
            otherwise:
                return coerce(expr, variableType(expr))
        }
    }

    method isValue(cl:ClassDecl):Bit {
        resolve(cl)
        return cl.rawSuper != null & cl.rawSuper.name = "panda.core.Value"
    }

    method instanceFields(cl:ClassDecl):ListView<FieldDecl> {
        resolve(cl)
        def result := Array<FieldDecl>()
        if !isValue(cl) & cl.rawSuper != null {
            def s := getClass(cl.rawSuper)
            if s != null {
                result.addAll(instanceFields(s))
            }
        }
        for f in cl.fields {
            if !f.annotations.isClass() {
                result.add(f)
            }
        }
        return result
    }

    method exists(f:File):Bit {
        var result := existenceCache[f]
        if result = null {
            result := f.exists()
            existenceCache[f] := result
        }
        return result
    }

    ================================================================================================
    Attempts to load the class with the given fully-qualified name. Returns null on failure, without
    reporting an error.
    ================================================================================================
    method getClass(fullName:String):ClassDecl? {
        var result := classes[fullName]
        if result = null {
            def suffix := fullName.replace(".", "/") + ".panda"
            var found := false
            for dir in settings.importDirs {
                def f := dir.resolve(suffix)
                if exists(f) {
                    found := true
                    scan(f)
                    result := classes[fullName]
                }
            }
        }
        if result = null {
            def index := fullName.lastIndexOf(".")
            if index != null {
                def parent := getClass(fullName[..index])
                if parent != null {
                    result := classes[fullName]
                }
            }
        }
        return result
    }

    method getClass(position:Position, fullName:String):ClassDecl? {
        var result := classes[fullName]
        if result = null {
            def suffix := fullName.replace(".", "/") + ".panda"
            var found := false
            for dir in settings.importDirs {
                def f := dir.resolve(suffix)
                if exists(f) {
                    found := true
                    def oldErrorCount := errorCount
                    scan(f)
                    result := classes[fullName]
                    if result = null & errorCount = oldErrorCount {
                        error(f, Position(1, 1),
                                "expected file '\{f}' to contain a class named '\{fullName}'")
                    }
                }
            }
            if !found {
                error(position, "no file named \{suffix} in any import path (\{settings.importDirs})")
            }
        }
        return result
    }

    method specialize(cl:ClassDecl, rawType:Type):ClassDecl {
        resolve(cl)
        def type := resolve(rawType)
        if type.typeKind = Type.Kind.NULLABLE {
            return specialize(cl, type.subtypes[0])
        }
        if type.typeKind = Type.Kind.CLASS {
            return cl
        }
        assert type.typeKind = Type.Kind.GENERIC
        def result:ClassDecl? := classes[type.name]
        if result = null {
            currentClass.push(cl)
            def annotations := Annotations(cl.annotations.flags && !!Annotations.Flag.SPECIALIZE)
            def supertypes := Array<Type>()
            supertypes.add(remapType(type, cl.rawSuper))
            for intf in cl.rawInterfaces { -- FIXME use map
                supertypes.add(remapType(type, intf))
            }
            def aliases := HashMap<String, String>(cl.aliases)
            for i in 0 .. cl.parameters.get_count() {
                aliases[cl.parameters[i].name] := type.subtypes[i + 1].name
            }
            result := ClassDecl(cl.source, cl.position, aliases, cl.doccomment, annotations,
                    cl.classKind, type.name, supertypes, Array<ClassDecl.GenericParameter>(),
                    cl.symbolTable.parents[0])
            result.external := false
            for m in cl.methods {
                resolve(m)
                def parameters := Array<MethodDecl.Parameter>() -- FIXME use map
                for p in m.parameters {
                    parameters.add(MethodDecl.Parameter(p.name, remapType(type, p.type)))
                }
                def clone := MethodDecl(result, m.position, m.doccomment, m.annotations,
                        m.methodKind, m.name, parameters, remapType(type, m.returnType), m.body)
                result.methods.add(clone)
                result.symbolTable.add(clone)
            }
            for f in cl.fields {
                resolve(f)
                def clone := FieldDecl(result, f.position, f.doccomment, f.annotations, f.fieldKind,
                        f.name, remapType(type, f.type), f.rawValue)
                result.fields.add(clone)
                result.symbolTable.add(clone)
            }
            classes[result.name] := result
            compilationQueue.add(result)
            currentClass.pop()
            resolve(result)
        }
        return result
    }

    method getClass(type:Type):ClassDecl? {
        assert type.resolved, "unresolved type \{type}"
        var result:ClassDecl
        match type.typeKind {
            when Type.Kind.CLASS:
                result := getClass(type.position, type.name)
            when Type.Kind.NULLABLE, Type.Kind.GENERIC:
                result := getClass(type.subtypes[0])
            when Type.Kind.GENERIC_PARAMETER:
                return getClass(type.parameter.bound)
            otherwise:
                assert false, "type '\{type}' is not a class"
        }
        if result.annotations.isSpecialize() {
            result := specialize(result, type)
        }
        return result
    }

    method allInterfaces(t:Type):Set<Type> {
        def cl := getClass(t)
        assert cl != null
        resolve(cl)
        def result := Set<Type>()
        if cl.rawSuper != null {
            result.addAll(allInterfaces(remapType(t, cl.rawSuper)))
        }
        for intf in cl.rawInterfaces {
            result.addAll(allInterfaces(remapType(t, intf)))
        }
        if cl.classKind = ClassDecl.Kind.INTERFACE {
            result.add(t)
        }
        return result
    }

    function signatureMatch(t1:Type, t2:Type):Bit {
        assert t1.isMethod()
        assert t2.isMethod()
        if t1.subtypes.get_count() != t2.subtypes.get_count() {
            return false
        }
        for i in 0 .. t1.subtypes.get_count() {
            if t1.subtypes[i] != t2.subtypes[i] {
                return false
            }
        }
        return true
    }

    method findMethod(owner:Type, name:String, methodType:Type, checkInterfaces:Bit):MethodDecl? {
        def cl := getClass(owner)
        assert cl != null
        resolve(cl)
        for test in cl.methods {
            if test.name = name {
                resolve(test)
                if signatureMatch(remapType(owner, declaredType(test)), methodType) {
                    return test
                }
            }
        }
        if checkInterfaces | cl.classKind = ClassDecl.Kind.INTERFACE {
            for raw in cl.rawInterfaces {
                def result := findMethod(remapType(owner, raw), name, methodType, checkInterfaces)
                if result != null {
                    return result
                }
            }
        }
        if cl.rawSuper != null {
            return findMethod(remapType(owner, cl.rawSuper), name, methodType, checkInterfaces)
        }
        return null
    }

    function getOverriddenMethod(m:MethodDecl):MethodDecl? {
        if m.overrideKnown {
            return m.overridden
        }
        if m.methodKind = MethodDecl.Kind.INIT {
            m.overrideKnown := true
            return null
        }
        resolve(m)
        def methodType := declaredType(m)
        def owner := m.owner.typeWithParameters()
        for raw in m.owner.rawInterfaces {
            def result := findMethod(remapType(owner, raw), m.name, methodType, true)
            if result != null {
                m.overrideKnown := true
                m.overridden := result
                return result
            }
        }
        resolve(m.owner)
        if m.owner.rawSuper != null {
            def result := findMethod(remapType(owner, m.owner.rawSuper), m.name, methodType, true)
            m.overrideKnown := true
            m.overridden := result
            return result
        }
        m.overrideKnown := true
        return null
    }

    method interfaceMethods(cl:ClassDecl, intf:Type):ListView<MethodDecl> {
        def intfClass := getClass(intf)
        assert intfClass != null
        def result := Array<MethodDecl>()
        for m in intfClass.methods {
            def found := findMethod(cl.type(), m.name, remapType(intf, inheritedType(m)), false)
            assert found != null, "internal error: interface \{m.declaration()} not found in " +
                    "\{cl.name}"
            result.add(found)
        }
        return result
    }

    method getSymbolTable(cl:ClassDecl):SymbolTable {
        if !cl.symbolTableResolved {
            cl.symbolTableResolved := true
            resolve(cl)
            if cl.rawSuper != null {
                def superCl := getClass(cl.rawSuper)
                if superCl != null {
                    cl.symbolTable.parents.add(getSymbolTable(superCl))
                }
            }
            for rawIntf in cl.rawInterfaces {
                def intf := getClass(rawIntf)
                if intf != null {
                    cl.symbolTable.parents.add(getSymbolTable(intf))
                }
            }
        }
        return cl.symbolTable
    }

    method getVTable(cl:ClassDecl):ListView<MethodDecl> {
        if cl.virtualMethods.get_count() = 0 {
            resolve(cl)
            currentClass.push(cl) -- FIXME Auto
            if cl.rawSuper != null {
                def superCl := getClass(cl.rawSuper)
                if superCl = null {
                    currentClass.pop()
                    return cl.virtualMethods
                }
                cl.virtualMethods.addAll(getVTable(superCl))
            }
            for derived in cl.methods {
                resolve(derived)
                if derived.methodKind = MethodDecl.Kind.INIT | derived.annotations.isClass() {
                    continue
                }
                var found := false
                for i in 0 .. cl.virtualMethods.get_count() {
                    def base := cl.virtualMethods[i]
                    resolve(base)
                    if derived.matches(base) {
                        found := true
                        cl.virtualMethods[i] := derived
                        break
                    }
                }
                if !found {
                    cl.virtualMethods.add(derived)
                }
            }
            currentClass.pop()
        }
        return cl.virtualMethods
    }

    method addInheritedMethods(st:SymbolTable, name:String, result:Array<MethodRef>,
            types:ListView<Type>) {
    }

    method getMethodReference(st:SymbolTable, target:IRNode?, name:String, position:Position,
            types:ListView<Type>):IRNode {
        def methods := Array<MethodRef>()
        def s := st[name]
        assert s != null, "could not find method '\{name}'"
        if s.kind = Symbol.Kind.METHOD {
            resolve(s->MethodDecl)
            methods.add(MethodRef(s->MethodDecl, types))
        }
        else {
            assert s.kind = Symbol.Kind.METHODS
            for m in s->Methods.methods {
                resolve(m)
                methods.add(MethodRef(m, types))
            }
        }
        for p in st.parents {
            addInheritedMethods(p, name, methods, types)
        }
        if methods.get_count() = 1 {
            return IRNode.METHOD_REFERENCE(position, target, methods[0])
        }
        else {
            return IRNode.UNRESOLVED_METHOD_REFERENCE(position, target, methods.finish())
        }
    }

    method symbolRef(position:Position, target:IRNode?, s:Symbol, st:SymbolTable):IRNode? {
        match s.kind {
            when Symbol.Kind.ALIAS:
                assert target = null
                def cl := getClass(position, s->Alias.fullName)
                if cl != null {
                    checkGenericParameters(position, cl, cl.type())
                    return IRNode.TYPE_REFERENCE(position, cl.type())
                }
                return null
            when Symbol.Kind.CLASS:
                checkGenericParameters(position, s->ClassDecl, s->ClassDecl.type())
                return IRNode.TYPE_REFERENCE(position, s->ClassDecl.type())
            when Symbol.Kind.METHOD, Symbol.Kind.METHODS:
                return getMethodReference(st, target, s.name, position, typeParameters(target))
            when Symbol.Kind.VARIABLE:
                return IRNode.VARIABLE_REFERENCE(position, s->Variable)
            when Symbol.Kind.FIELD:
                def f := s->FieldDecl
                resolve(f)
                if f.type = Type.Void() {
                    return null
                }
                def children := Array<IRNode>()
                if target != null {
                    if target = IRNode.SUPER {
                        error(target.position(),
                                "'super' can only be used as part of a method call")
                        return null
                    }
                    def effectiveType := remapType(target.type(), f.type)
                    def finalTarget:IRNode
                    if f.annotations.isClass() {
                        finalTarget := target
                    }
                    else {
                        finalTarget := coerce(target, f.owner.type())
                    }
                    var result := IRNode.FIELD_REFERENCE(position, f.type, finalTarget,
                            s->FieldDecl)
                    if effectiveType != result.type() {
                        result := cast(position, result, effectiveType, false)
                    }
                    return result
                }
                else {
                    def finalTarget := IRNode.SELF(position, currentClass.peek().type())
                    return IRNode.FIELD_REFERENCE(position, f.type, finalTarget, f)
                }
            when Symbol.Kind.CHOICE_ENTRY:
                return IRNode.CHOICE_ENTRY_REFERENCE(position, s->ChoiceEntry)
            otherwise:
                assert false, "unsupported symbol kind: \{s.kind}"
        }
    }

    function remapType(context:Type, raw:Type):Type {
        match raw.typeKind {
            when Type.Kind.CLASS, Type.Kind.BUILTIN_INT, Type.Kind.BUILTIN_UINT,
                    Type.Kind.BUILTIN_BIT:
                return raw
        }
        match context.typeKind {
            when Type.Kind.CLASS:
                return raw
            when Type.Kind.NULLABLE:
                assert context.subtypes.get_count() = 1
                return remapType(context.subtypes[0], raw)
            when Type.Kind.GENERIC:
                assert context.subtypes.get_count() >= 2
                def typeMap := HashMap<String, Type>()
                def base := context.subtypes[0]
                def cl := tryResolveClass(base.name)
                assert cl != null
                for i in 1 .. context.subtypes.get_count() {
                    typeMap[cl.name + "." + cl.parameters[i - 1].name] := context.subtypes[i]
                }
                return raw.remap(typeMap)
            when Type.Kind.GENERIC_PARAMETER:
                return raw
            otherwise:
                assert false, "cannot remap type \{context}"
        }
    }

    function variableType(type:Type):Type {
        if type.typeKind = Type.Kind.INT_LITERAL {
            return Type.Int64()
        }
        if type.typeKind = Type.Kind.REAL_LITERAL {
            return Type.Real64()
        }
        if type = Type.BitLiteral() {
            return Type.Bit()
        }
        if type.typeKind = Type.Kind.NULL {
            return Type.Any()
        }
        return type
    }

    ================================================================================================
    Given a single-character string literal, returns the size in bits of the smallest Char type that
    can hold the literal.
    ================================================================================================
    function smallestCharSize(char:IRNode):Int {
        match char {
            when IRNode.STRING(_, str):
                assert str.length() = 1
                def c := str[0].convert()->Int32
                if c <= 255 {
                    return 8
                }
                if c <= 65535 {
                    return 16
                }
                return 32
            otherwise:
                assert false
        }
    }

    function isSingleChar(node:IRNode):Bit {
        match node {
            when IRNode.STRING(_, str):
                return str.length() = 1
            otherwise:
                return false
        }
    }

    ================================================================================================
    Given one endpoint of a range that is a single-character string literal, returns the inferred
    type of the literal. We choose the smallest char type that holds both endpoints (assuming the
    other endpoint is likewise a char).
    ================================================================================================
    function rangeCharType(char:IRNode, other:IRNode):Type {
        var result := smallestCharSize(char)
        if isSingleChar(other) {
            result := result.max(smallestCharSize(other))
        }
        match other.type() {
            when Type.Char16(): result := result.max(16)
            when Type.Char32(): result := result.max(32)
        }
        match result {
            when 8: return Type.Char8()
            when 16: return Type.Char16()
            when 32: return Type.Char32()
            otherwise: assert false
        }
    }

    ================================================================================================
    Returns the type that a variable initialized from a given expression should be inferred to have.
    Often this is simply the type of the expression itself, but we need to pick a type for
    unresolved expressions.
    ================================================================================================
    function variableType(expr:IRNode):Type {
        match expr {
            when IRNode.UNRESOLVED_RANGE(_, start, end, inclusive, step):
                def startType:Type
                if isSingleChar(start) {
                    startType := rangeCharType(start, end)
                }
                else {
                    startType := start.type()
                }
                def endType:Type
                if isSingleChar(end) {
                    endType := rangeCharType(end, start)
                }
                else {
                    endType := end.type()
                }
                if step = null {
                    if start = IRNode.NULL {
                        if end = IRNode.NULL {
                            return Type.RangeOf(Type.Int64().nullable())
                        }
                        return Type.RangeOf(variableType(endType).nullable())
                    }
                    if end = IRNode.NULL {
                        return Type.RangeOf(variableType(startType).nullable())
                    }
                    return Type.RangeOf(variableType(startType.union(self, endType)))
                }
                var stepType := step.type().nonnullable()
                if start = IRNode.NULL {
                    if end = IRNode.NULL {
                        return Type.SteppedRangeOf(variableType(stepType).nullable())
                    }
                    if isSingleChar(end) {
                        return Type.SteppedRangeOf(variableType(endType).nullable())
                    }
                    def union := endType.union(self, stepType)
                    return Type.SteppedRangeOf(variableType(union).nullable())
                }
                if end = IRNode.NULL {
                    if isSingleChar(start) {
                        return Type.SteppedRangeOf(variableType(startType).nullable())
                    }
                    def union := startType.union(self, stepType)
                    return Type.SteppedRangeOf(variableType(union).nullable())
                }
                if isSingleChar(start) & isSingleChar(end) {
                    return Type.SteppedRangeOf(variableType(startType.union(self, endType)))
                }
                var union := startType.union(self, endType).union(self, stepType)
                return Type.SteppedRangeOf(variableType(union))
            when IRNode.UNRESOLVED_INDEX(_, _, base, args):
                def c := call(base, "[]", args)
                if c = null {
                    return Type.Any()
                }
                return c.type()
            when IRNode.CHOICE_ENTRY_REFERENCE(_, ce):
                return ce.owner.type()
        }
        return variableType(expr.type())
    }

    function coercionCost(type:Type, target:Type):Int? {
        assert type.resolved, "unresolved type '\{type}'"
        assert target.resolved, "unresolved type '\{target}'"
        if type = target {
            return 0
        }
        if type = Type.Void() {
            return null
        }
        if type.typeKind = Type.Kind.NULL {
            if target.typeKind = Type.Kind.NULLABLE {
                return 0
            }
            return null
        }
        if type.typeKind = Type.Kind.NULLABLE & target.typeKind != Type.Kind.NULLABLE {
            def result := coercionCost(type.subtypes[0], target)
            if result = null {
                return null
            }
            return result + NULLABLE_TO_NONNULLABLE_CAST_COST
        }
        match target.typeKind {
            when Type.Kind.NULLABLE:
                def result := coercionCost(type, target.subtypes[0])
                if result = null {
                    return null
                }
                return result + NONNULLABLE_TO_NULLABLE_CAST_COST
            when Type.Kind.GENERIC_PARAMETER:
                return null
            when Type.Kind.BUILTIN_INT, Type.Kind.BUILTIN_UINT:
                return null
            when Type.Kind.CLASS:
                if type.typeKind = Type.Kind.GENERIC {
                    return coercionCost(type.subtypes[0], target)
                }
        }
        match type.typeKind {
            when Type.Kind.BUILTIN_BIT:
                return coercionCost(Type.Bit(), target)
            when Type.Kind.UNRESOLVED:
                var best:Int? := null
                for t in type.subtypes {
                    def cost := coercionCost(t, target)
                    if cost != null & (best = null | cost < best) {
                        best := cost
                    }
                }
                return best
            when Type.Kind.GENERIC_PARAMETER:
                return coercionCost(type.parameter.bound, target)
        }
        if !target.isClass() {
            return null
        }
        if !type.isClass() {
            return null
        }
        def cl := getClass(type)
        assert cl != null
        resolve(cl)
        if cl.rawSuper != null {
            var cost := coercionCost(remapType(type, remapType(type, cl.rawSuper)), target)
            if cost != null {
                return cost + 1
            }
        }
        for intf in cl.rawInterfaces {
            var cost := coercionCost(remapType(type, remapType(type, intf)), target)
            if cost != null {
                return cost + 1
            }
        }
        return null
    }

    function requiredSize(value:Int64):Int {
        if value >= -128 & value <= 127 {
            return 8
        }
        if value >= -32768 & value <= 32767 {
            return 16
        }
        if value >= -2147483648 & value <= 2147483647 {
            return 32
        }
        return 64
    }

    function requiredSize(value:UInt64):Int {
        if value <= 255 {
            return 8
        }
        if value <= 65535 {
            return 16
        }
        if value <= 4294967295 {
            return 32
        }
        return 64
    }

    function coercionCost(expr:IRNode, target:Type):Int? {
        var base := 0
        if isSingleChar(expr) & !target.isChar() {
            -- prefer coercing single-char literals to chars rather than strings
            base := 3 -- determined empirically
        }
        if expr.type() = target {
            return base
        }
        match target.typeKind {
            when Type.Kind.NULLABLE:
                if expr = IRNode.NULL {
                    return base
                }
                def cost := coercionCost(expr, target.subtypes[0])
                if cost = null {
                    return null
                }
                if expr.type().typeKind = Type.Kind.NULLABLE {
                    return base + cost - NULLABLE_TO_NONNULLABLE_CAST_COST
                }
                return base + cost + NONNULLABLE_TO_NULLABLE_CAST_COST
            when Type.Kind.GENERIC_PARAMETER:
                assert base = 0
                return coercionCost(expr, target.parameter.bound)
        }
        match expr {
            when IRNode.BIT:
                if target.typeKind = Type.Kind.BUILTIN_BIT {
                    return base
                }
                if target.isClass() {
                    return coercionCost(Type.Bit(), target)
                }
            when IRNode.INT(_, _, int):
                if (target.typeKind = Type.Kind.BUILTIN_INT &
                        requiredSize(int.convert()->Int64) <= target.size()) |
                        (target.typeKind = Type.Kind.BUILTIN_UINT &
                        requiredSize(int) <= target.size()) {
                    return base
                }
                if target.typeKind = Type.Kind.BUILTIN_FLOAT {
                    return 1
                }
                if !target.isNumber() {
                    assert base = 0
                    return coercionCost(variableType(expr), target)
                }
            when IRNode.NEGATED_INT(_, _, int):
                if (target.typeKind = Type.Kind.BUILTIN_INT &
                        requiredSize(-int.convert()->Int64) <= target.size()) {
                    return base
                }
                if target.typeKind = Type.Kind.BUILTIN_FLOAT {
                    return 1
                }
                if !target.isNumber() {
                    assert base = 0
                    return coercionCost(variableType(expr), target)
                }
            when IRNode.REAL:
                if target.typeKind = Type.Kind.BUILTIN_FLOAT {
                    return base
                }
                if !target.isNumber() {
                    assert base = 0
                    return coercionCost(variableType(expr), target)
                }
            when IRNode.STRING(_, str):
                if target = Type.Char8() {
                    if str.length() = 1 & str[0].convert()->UInt32 <= 255 {
                        return base
                    }
                    return null
                }
                if target = Type.Char16() {
                    def utf16 := str.utf16()
                    if utf16.get_done() {
                        return null
                    }
                    utf16.next()
                    if utf16.get_done() {
                        return base + 1
                    }
                    return null
                }
                if target = Type.Char32() {
                    if str.length() = 1 {
                        return base + 2
                    }
                    return null
                }
            when IRNode.UNRESOLVED_METHOD_CALL(_, _, _, methods, args):
                var bestCost:Int? := null
                for m in methods {
                    def cost := callCost(m, args, target)
                    if cost = null {
                        continue
                    }
                    if bestCost = null | cost < bestCost {
                        bestCost := cost
                    }
                }
                return bestCost
            when IRNode.UNRESOLVED_RANGE(_, start, end, inclusive, step):
                if target.isRange() {
                    if step != null {
                        return null
                    }
                    if start = IRNode.NULL & end = IRNode.NULL {
                        if target.subtypes[1].typeKind = Type.Kind.NULLABLE {
                            if target.subtypes[1].subtypes[0].isNumber() {
                                return base
                            }
                            return base + 1
                        }
                        return null
                    }
                    assert target.typeKind = Type.Kind.GENERIC
                    def cost1 := coercionCost(start, target.subtypes[1])
                    if cost1 = null {
                        return null
                    }
                    def cost2 := coercionCost(end, target.subtypes[1])
                    if cost2 = null {
                        return null
                    }
                    return base + cost1 + cost2
                }
                if target.isSteppedRange() {
                    if step = null {
                        return null
                    }
                    var cost:Int
                    if start = IRNode.NULL & end = IRNode.NULL {
                        if target.subtypes[1].typeKind = Type.Kind.NULLABLE {
                            if target.subtypes[1].subtypes[0].isNumber() {
                                cost := 0
                            }
                            else {
                                cost := 1
                            }
                        }
                        else {
                            return null
                        }
                    }
                    else {
                        assert target.typeKind = Type.Kind.GENERIC
                        def cost1 := coercionCost(start, target.subtypes[1])
                        if cost1 = null {
                            return null
                        }
                        def cost2 := coercionCost(end, target.subtypes[1])
                        if cost2 = null {
                            return null
                        }
                        cost := cost1 + cost2
                    }
                    def cost3 := coercionCost(step, target.subtypes[2])
                    if cost3 = null {
                        return null
                    }
                    return base + cost + cost3
                }
                return coercionCost(variableType(expr), target)
            when IRNode.UNRESOLVED_INDEX(_, _, value, args):
                assert base = 0
                return coercionCost(call(value, "[]", args), target)
            when IRNode.CHOICE_ENTRY_REFERENCE(_, ce):
                return coercionCost(ce.owner.type(), target)
        }
        if !target.isClass() {
            return null
        }
        def targetClass := getClass(target)
        if targetClass = null {
            return null
        }
        for m in targetClass.methods {
            if m.annotations.isImplicit() {
                resolve(m)
                if m.methodKind = MethodDecl.Kind.INIT & m.parameters.get_count() = 1 {
                    def cost := coercionCost(expr, m.parameters[0].type)
                    if cost != null {
                        return base + cost + 2
                    }
                }
            }
        }
        def cost := coercionCost(expr.type(), target)
        if cost != null {
            return base + cost
        }
        return null
    }

    function doCoerce(expr:IRNode?, target:Type):IRNode? {
        if expr = null {
            return null
        }
        def src := expr.type()
        assert src.resolved, "unresolved type '\{src}'"
        assert target.resolved, "unresolved type '\{target}'"
        if src = target {
            return expr
        }
        if src.typeKind = Type.Kind.NULLABLE & target.typeKind != Type.Kind.NULLABLE {
            if src.subtypes[0] = target {
                return IRNode.CAST(expr.position(), expr, target, false)
            }
            def intermediate := coerce(expr, src.subtypes[0])
            return coerce(intermediate, target)
        }
        match expr {
            when IRNode.INT(_, _, int):
                if target.typeKind = Type.Kind.BUILTIN_INT &
                        requiredSize(int) <= target.size() {
                    return IRNode.INT(expr.position(), target, int)
                }
                else if target.typeKind = Type.Kind.BUILTIN_UINT &
                        requiredSize(int) <= target.size() {
                    return IRNode.INT(expr.position(), target, int)
                }
                else if target.typeKind = Type.Kind.BUILTIN_FLOAT {
                    return IRNode.REAL(expr.position(), target, int.convert()->Real64)
                }
                if target.typeKind = Type.Kind.CLASS & !target.isNumber() {
                    def coerced := coerce(expr, variableType(expr))
                    if coerced = null {
                        return null
                    }
                    return coerce(coerced, target)
                }
            when IRNode.NEGATED_INT(_, _, int):
                if target.typeKind = Type.Kind.BUILTIN_INT &
                        requiredSize(-int.convert()->Int64) <= target.size() {
                    return IRNode.NEGATED_INT(expr.position(), target, int)
                }
                else if target.typeKind = Type.Kind.BUILTIN_FLOAT {
                    return IRNode.REAL(expr.position(), target, -int.convert()->Real64)
                }
                if target.typeKind = Type.Kind.CLASS & !target.isNumber() {
                    def coerced := coerce(expr, variableType(expr))
                    if coerced = null {
                        return null
                    }
                    return coerce(coerced, target)
                }
            when IRNode.REAL(_, _, real):
                if target.typeKind = Type.Kind.BUILTIN_FLOAT {
                    return IRNode.REAL(expr.position(), target, real)
                }
                if target.typeKind = Type.Kind.CLASS & !target.isNumber() {
                    def coerced := coerce(expr, variableType(expr))
                    if coerced = null {
                        return null
                    }
                    return coerce(coerced, target)
                }
            when IRNode.BIT(_, _, bit):
                if target = Type.BuiltinBit() {
                    return IRNode.BIT(expr.position(), target, bit)
                }
                if target.isClass() & target != Type.Bit() {
                    def varType := coerce(expr, variableType(expr))
                    if varType != null {
                        return coerce(varType, target)
                    }
                }
            when IRNode.STRING(_, str):
                if target = Type.Char8() & coercionCost(expr, target) != null {
                    def args := Array<IRNode>() -- FIXME literal
                    args.add(IRNode.INT(expr.position(), Type.BuiltinUInt8(),
                            str[0].convert()->UInt64))
                    def target := IRNode.TYPE_REFERENCE(expr.position(), target)
                    return call(target, args)
                }
                if target = Type.Char16() & coercionCost(expr, target) != null {
                    def args := Array<IRNode>() -- FIXME literal
                    args.add(IRNode.INT(expr.position(), Type.BuiltinUInt16(),
                            str.utf16().next().convert()->UInt64))
                    def target := IRNode.TYPE_REFERENCE(expr.position(), target)
                    return call(target, args)
                }
                if target = Type.Char32() & coercionCost(expr, target) != null {
                    def args := Array<IRNode>() -- FIXME literal
                    args.add(IRNode.INT(expr.position(), Type.BuiltinUInt32(),
                            str[0].convert()->UInt64))
                    def target := IRNode.TYPE_REFERENCE(expr.position(), target)
                    return call(target, args)
                }
            when IRNode.UNRESOLVED_RANGE(_, start, end, inclusive, step):
                if target.isRange() {
                    if step != null {
                        error(expr.position(), "expected '\{target}', but found '\{expr}'")
                        return null
                    }
                    assert target.typeKind = Type.Kind.GENERIC
                    def param := target.subtypes[1]
                    def finalStart := coerce(start, param)
                    if finalStart = null {
                        return null
                    }
                    def finalEnd := coerce(end, param)
                    if finalEnd = null {
                        return null
                    }
                    def args := Array<IRNode>()
                    args.add(finalStart)
                    args.add(finalEnd)
                    args.add(IRNode.BIT(expr.position(), Type.BuiltinBit(), inclusive))
                    def target := IRNode.TYPE_REFERENCE(expr.position(), target)
                    return call(target, args)
                }
                else if target.isSteppedRange() {
                    if step = null {
                        error(expr.position(), "expected '\{target}', but found '\{expr}'")
                        return null
                    }
                    assert target.typeKind = Type.Kind.GENERIC
                    def endPoint := target.subtypes[1]
                    def finalStart := coerce(start, endPoint)
                    if finalStart = null {
                        return null
                    }
                    def finalEnd := coerce(end, endPoint)
                    if finalEnd = null {
                        return null
                    }
                    def finalStep := coerce(step, target.subtypes[2])
                    if finalStep = null {
                        return null
                    }
                    def args := Array<IRNode>()
                    args.add(start)
                    args.add(end)
                    args.add(step)
                    args.add(IRNode.BIT(expr.position(), Type.BuiltinBit(), inclusive))
                    def target := IRNode.TYPE_REFERENCE(expr.position(), target)
                    return call(target, args)
                }
                else {
                    return coerce(resolve(expr), target)
                }
            when IRNode.UNRESOLVED_METHOD_CALL(position, _, callTarget, methods, args):
                return resolveMethodCall(position, callTarget, methods, args, target)
            when IRNode.UNRESOLVED_INDEX(_, _, base, args):
                return coerce(call(base, "[]", args, target), target)
            when IRNode.CHOICE_ENTRY_REFERENCE(_, ce):
                if ce.fields.get_count() = 0 {
                    def owner := IRNode.TYPE_REFERENCE(expr.position(), ce.owner.type())
                    def args := Array<IRNode>()
                    def value := ce.rawValue.convert()->UInt64
                    args.add(IRNode.INT(expr.position(), Type.IntLiteral(value), value))
                    return coerce(call(owner, args), target)
                }
                error(expr.position(), "choice '\{expr}' requires \{ce.fields.get_count()} " +
                        "argument\{ce.fields.get_count() = 1:|s}, but found 0")
                return null
        }
        if target.typeKind = Type.Kind.NULLABLE {
            if expr = IRNode.NULL {
                return IRNode.NULL(expr.position(), target)
            }
            if expr.type() = target.subtypes[0] {
                return IRNode.CAST(expr.position(), expr, target, false)
            }
            if expr.type().typeKind != Type.Kind.NULLABLE {
                def intermediate := coerce(expr, target.subtypes[0])
                return coerce(intermediate, target)
            }
        }
        if coercionCost(expr, target) != null {
            def cl := getClass(target)
            if cl != null {
                for m in cl.methods {
                    if m.annotations.isImplicit() {
                        resolve(m)
                        if m.methodKind = MethodDecl.Kind.INIT & m.parameters.get_count() = 1 &
                                coercionCost(expr, m.parameters[0].type) != null {
                            def type := IRNode.TYPE_REFERENCE(expr.position(), cl.type())
                            def args := Array<IRNode>(1) -- FIXME literal
                            args.add(expr)
                            return coerce(call(type, args), target)
                        }
                    }
                }
            }
            def resolved := resolve(expr)
            if resolved = null {
                return null
            }
            var result := IRNode.CAST(resolved.position(), resolved, target, false)
            if !isRefCounted(resolved.type()) & isRefCounted(target) {
                reusedValueCount += 1
                result := IRNode.REUSED_VALUE_DEFINITION(result, reusedValueCount)
                def reused := IRNode.REUSED_VALUE(result.position(), target, reusedValueCount)
                result := IRNode.EXPRESSION_WITH_EXTRA_EFFECTS(result,
                        compilePandaCall("unref", reused))
            }
            return result
        }
        error(expr.position(), "expected '\{target}', but found '\{expr.type()}'")
        return null
    }

    -- FIXME use postcondition
    method coerce(expr:IRNode?, target:Type):IRNode? {
        def result := doCoerce(expr, target)
        assert result = null | result.type() = target,
                "coerce returned wrong type: \{expr}->\{target} yields \{result.type()}"
        return result
    }

    method canCast(type:Type, target:Type):Bit {
        if type.isPointer() & target.isPointer() {
            return true
        }
        if coercionCost(type, target) != null {
            return true
        }
        if type.isBuiltinNumber() & target.isBuiltinNumber() {
            return true
        }
        if type.typeKind = Type.Kind.INVALID {
            return false
        }
        return coercionCost(target, type) != null
    }

    method canCast(node:IRNode, target:Type):Bit {
        if coercionCost(node, target) != null {
            return true
        }
        var result := canCast(node.type(), target)
        if !result & node.type().typeKind = Type.Kind.UNRESOLVED {
            def resolved := resolve(node)
            if resolved != null & resolved !== node {
                result := canCast(resolved, target)
            }
        }
        return result
    }

    method cast(position:Position, node:IRNode, target:Type, isExplicit:Bit):IRNode {
        if node.type() = target {
            return node
        }
        assert target != Type.Void()
        if isExplicit & !canCast(node, target) {
            error(position, "value of type '\{node.type()}' cannot possibly be an instance of " +
                    "'\{target}'")
        }
        match node {
            when IRNode.INT, IRNode.NEGATED_INT, IRNode.BIT:
                return coerce(node, target)
            when IRNode.UNRESOLVED_METHOD_CALL, IRNode.UNRESOLVED_INDEX:
                if coercionCost(node, target) != null {
                    return coerce(node, target)
                }
                def resolved := resolve(node)
                if resolved != null {
                    return cast(position, resolved, target, isExplicit)
                }
        }
        var result := IRNode.CAST(position, node, target, isExplicit)
        if !isRefCounted(node.type()) & isRefCounted(target) {
            reusedValueCount += 1
            result := IRNode.REUSED_VALUE_DEFINITION(result, reusedValueCount)
            def reused := IRNode.REUSED_VALUE(result.position(), target, reusedValueCount)
            result := IRNode.EXPRESSION_WITH_EXTRA_EFFECTS(result,
                    compilePandaCall("unref", reused))
        }
        return result
    }

    method callCost(m:MethodRef, args:ListView<IRNode>, expectedReturn:Type?):Int? {
        assert m.value.resolved
        if m.parameterCount() != args.get_count() {
            return null
        }
        var result := 0
        for i in 0 .. m.parameterCount() {
            def cost := coercionCost(args[i], m.parameter(i))
            if cost = null {
                return null
            }
            result += cost
        }
        if expectedReturn != null {
            def cost := coercionCost(m.returnType(), expectedReturn)
            if cost = null {
                return null
            }
            result += cost
        }
        -- numbers prefer to operate on their own sizes, i.e. we should treat Int8 + 10 as
        -- Int8 + Int8 rather than complain about it being ambiguous
        if m.value.owner.type().isNumber() & args.get_count() = 1 &
                m.value.parameters[0].type != m.value.owner.type() {
            result += 1
        }
        return result
    }

    method matchMethods(methods:Array<MethodRef>, args:ListView<IRNode>,
            expectedReturn:Type?):Int? {
        def result := Array<MethodRef>()
        var best:Int? := null
        for m in methods {
            def cost := callCost(m, args, expectedReturn)
            if cost = null {
                continue
            }
            if best = null | cost < best {
                result.clear()
                best := cost
            }
            if cost = best {
                result.add(m)
            }
        }
        methods.clear()
        methods.addAll(result)
        return best
    }

    method actualReturnType(m:MethodRef):Type {
        if getClass(m.owner()).annotations.isSpecialize() {
            return m.returnType()
        }
        return m.value.returnType
    }

    method call(position:Position, target:IRNode?, m:MethodRef, args:ListView<IRNode>):IRNode? {
        assert m.value.resolved
        if m.parameterCount() != args.get_count() {
            error(position, "\{m.value.declaration()} expected \{m.parameterCount()} argument" +
                    "\{m.parameterCount() = 1:|s}, but received \{args.get_count()}")
            return null
        }
        def finalArgs := Array<IRNode>()
        if target != null & target != IRNode.CONSTRUCTED_OBJECT &
                !m.value.annotations.isClass() {
            finalArgs.add(cast(position, target, m.owner(), false))
        }
        if m.value.methodKind = MethodDecl.Kind.INIT {
            if target = null {
                if currentMethod.peek().methodKind = MethodDecl.Kind.INIT {
                    finalArgs.add(IRNode.SELF(position, currentClass.peek().type()))
                }
                else {
                    error(position, "cannot directly call 'init' outside of an init method")
                }
            }
            else if target != IRNode.SELF & target != IRNode.SUPER &
                    target != IRNode.CONSTRUCTED_OBJECT {
                error(position, "'init' may only be called on 'self' or 'super'")
            }
        }
        else if m.value.isInstance() & target = null {
            var selfNode := IRNode.SELF(position, currentClass.peek().type())
            selfNode := coerce(selfNode, m.value.owner.type())
            assert selfNode != null
            finalArgs.add(selfNode)
            if !currentMethod.peek().isInstance() {
                error(position, "cannot call instance \{m.value.declaration()} from a @class context")
            }
        }
        else if !m.value.isInstance() & target != null & target != IRNode.TYPE_REFERENCE {
            error(position, "cannot call class \{m.value.declaration()} on an instance")
        }
        for i in 0 .. args.get_count() {
            var coerced := coerce(args[i], m.parameter(i))
            if coerced = null {
                return null
            }
            coerced := cast(position, coerced, m.value.parameters[i].type, false)
            if coerced = null {
                return null
            }
            finalArgs.add(coerced)
        }
        if m.value.owner.name = "panda.unsafe.Pointer" {
            if isRefCounted(m.types[0]) {
                match m.value.name {
                    when "[]:=":
                        def statements := Array<IRNode>()
                        reusedValueCount += 1
                        def reusedPointer := IRNode.REUSED_VALUE_DEFINITION(finalArgs[0],
                                reusedValueCount)
                        finalArgs[0] := IRNode.REUSED_VALUE(finalArgs[0].position(),
                                finalArgs[0].type(), reusedValueCount)
                        reusedValueCount += 1
                        def reusedIndex := IRNode.REUSED_VALUE_DEFINITION(finalArgs[1],
                                reusedValueCount)
                        finalArgs[1] := IRNode.REUSED_VALUE(finalArgs[1].position(),
                                finalArgs[1].type(), reusedValueCount)
                        def idxArgs := Array<IRNode>()
                        idxArgs.add(reusedIndex)
                        statements.add(compilePandaCall("unref", call(reusedPointer, "[]",
                                idxArgs)))
                        finalArgs[2] := unwrapCast(finalArgs[2])
                        reusedValueCount += 1
                        def reusedValue := IRNode.REUSED_VALUE_DEFINITION(finalArgs[2],
                                reusedValueCount)
                        finalArgs[2] := IRNode.REUSED_VALUE(finalArgs[2].position(),
                                finalArgs[2].type(), reusedValueCount)
                        statements.add(compilePandaCall("ref", reusedValue))
                        statements.add(IRNode.CALL(position, m.returnType(), m, finalArgs.finish()))
                        return IRNode.BLOCK(position, statements.finish())
                }
            }
            return IRNode.CALL(position, m.returnType(), m, finalArgs.finish())
        }
        else {
            var result := IRNode.CALL(position, m.value.returnType, m, finalArgs.finish())
            if isRefCounted(actualReturnType(m)) {
                reusedValueCount += 1
                result := IRNode.REUSED_VALUE_DEFINITION(result, reusedValueCount)
                def reused := IRNode.REUSED_VALUE(result.position(), result.type(),
                        reusedValueCount)
                result := IRNode.EXPRESSION_WITH_EXTRA_EFFECTS(result,
                        compilePandaCall("unref", reused))
            }
            result := cast(position, result, m.returnType(), false)
            return result
        }
    }

    method call(target:IRNode, name:String, args:ListView<IRNode>):IRNode? {
        return call(target, name, args, null)
    }

    method compileChoiceComparison(left:IRNode, name:String, right:IRNode):IRNode? {
        def args := Array<IRNode>()
        match right {
            when IRNode.CHOICE_ENTRY_REFERENCE(_, rightEntry):
                def leftValue := compileDot(left.position(), left, ClassDecl.RAW_VALUE_NAME)
                def rightValue := rightEntry.rawValue.convert()->UInt64
                args.add(IRNode.INT(right.position(), Type.IntLiteral(rightValue),
                        rightValue))
                return call(leftValue, name, args)
            otherwise:
        }
        if right.type().nonnullable() = left.type().nonnullable() {
            def leftValue := compileDot(left.position(), left, ClassDecl.RAW_VALUE_NAME)
            assert leftValue != null
            def rightValue := compileDot(right.position(), right, ClassDecl.RAW_VALUE_NAME)
            assert rightValue != null
            args.add(rightValue)
            return call(leftValue, name, args)
        }
        error(left.position(), "'\{name}' cannot operate on '\{left.type()}', '\{right.type()}'")
        return null
    }

    method call(target:IRNode, name:String, args:ListView<IRNode>, expectedType:Type?):IRNode? {
        def resolved := resolve(target)
        if resolved = null {
            return null
        }
        def cl:ClassDecl?
        match resolved {
            when IRNode.TYPE_REFERENCE(_, type):
                cl := getClass(type)
            otherwise:
                if !resolved.type().isClass() {
                    error(target.position(), "cannot call a method on non-class type " +
                            "'\{resolved.type()}'")
                    return null
                }
                cl := getClass(resolved.type())
        }
        if cl = null {
            return null
        }
        def s := getSymbolTable(cl)[name]
        if s = null {
            if name = "=" | name = "!=" & cl.classKind = ClassDecl.Kind.CHOICE &
                    args.get_count() = 1 {
                return compileChoiceComparison(resolved, name, args[0])
            }
            error(resolved.position(), "class '\{cl.name}' does not have a member named '\{name}'")
            return null
        }
        if s.kind != Symbol.Kind.METHOD & s.kind != Symbol.Kind.METHODS {
            error(resolved.position(), "'\{cl.name}.\{name}' is not a method")
            return null
        }
        def ref := symbolRef(resolved.position(), resolved, s, getSymbolTable(cl))
        if ref = null {
            return null
        }
        return call(ref, args, expectedType)
    }

    method call(m:IRNode, args:ListView<IRNode>):IRNode? {
        return call(m, args, null)
    }

    method call(m:IRNode, args:ListView<IRNode>, expectedType:Type?):IRNode? {
        match m {
            when IRNode.METHOD_REFERENCE(_, target, mref):
                return call(m.position(), target, mref, args)
            when IRNode.UNRESOLVED_METHOD_REFERENCE(_, target, mrefs):
                def methods := Array<MethodRef>(mrefs)
                matchMethods(methods, args, expectedType)
                if methods.get_count() = 0 {
                    def first := mrefs[0].value
                    def msg := MutableString("no match for call to '\{first.owner.name}." +
                            "\{first.name}(")
                    var separator := ""
                    for a in args {
                        msg.append(separator)
                        msg.append(a.type())
                        separator := ", "
                    }
                    msg.append(")'")
                    if expectedType != null {
                        msg.append(" with return type '\{expectedType}'")
                    }
                    error(m.position(), msg.finish())
                    return null
                }
                if methods.get_count() = 1 {
                    return call(m.position(), target, methods[0], args)
                }
                def types := Array<Type>()
                for m in methods {
                    types.add(m.returnType())
                }
                return IRNode.UNRESOLVED_METHOD_CALL(m.position(), Type(types), target,
                        methods.finish(), ImmutableArray<IRNode>(args))
            when IRNode.TYPE_REFERENCE(_, type):
                def target := IRNode.CONSTRUCTED_OBJECT(m.position(), type)
                def initCall := resolve(call(target, "init", args))
                if initCall = null {
                    return null
                }
                var construct := IRNode.CONSTRUCT(m.position(), type, initCall)
                if isRefCounted(type) {
                    reusedValueCount += 1
                    construct := IRNode.REUSED_VALUE_DEFINITION(construct, reusedValueCount)
                    def reused := IRNode.REUSED_VALUE(construct.position(), construct.type(),
                            reusedValueCount)
                    construct := IRNode.EXPRESSION_WITH_EXTRA_EFFECTS(construct,
                            compilePandaCall("unref", reused))
                }
                return construct
            when IRNode.CHOICE_ENTRY_REFERENCE(_, ce):
                if ce.fields.get_count() != args.get_count() {
                    error(m.position(), "choice '\{m}' requires \{ce.fields.get_count()} " +
                            "argument\{ce.fields.get_count() = 1:|s}, but found " +
                            args.get_count())
                    return null
                }
                resolve(ce)
                def finalArgs := Array<IRNode>()
                def value := ce.rawValue.convert()->UInt64
                finalArgs.add(IRNode.INT(m.position(), Type.IntLiteral(value), value))
                for i in 0 .. args.get_count() {
                    def arg := coerce(args[i], ce.fields[i])
                    if arg = null {
                        return null
                    }
                    finalArgs.add(arg)
                }
                resolve(ce.initMethod)
                def owner := IRNode.TYPE_REFERENCE(m.position(), ce.owner.type())
                def initCall := call(m.position(),
                        IRNode.CONSTRUCTED_OBJECT(m.position(), ce.owner.type()),
                        MethodRef(ce.initMethod, Array<Type>()), finalArgs) -- FIXME literal
                var construct := IRNode.CONSTRUCT(m.position(), ce.owner.type(), initCall)
                if isRefCounted(ce.owner.type()) {
                    reusedValueCount += 1
                    construct := IRNode.REUSED_VALUE_DEFINITION(construct, reusedValueCount)
                    def reused := IRNode.REUSED_VALUE(construct.position(), construct.type(),
                            reusedValueCount)
                    construct := IRNode.EXPRESSION_WITH_EXTRA_EFFECTS(construct,
                            compilePandaCall("unref", reused))
                }
                return construct
            otherwise:
                def resolved := resolve(m)
                if resolved = null {
                    return null
                }
                error(resolved.position(), "value of type '\{resolved.type()}' is not a method")
                return null
        }
    }

    function declaredType(m:MethodDecl):Type {
        resolve(m)
        def subtypes := Array<Type>()
        def typeName := MutableString("(")
        var separator := ""
        for p in m.parameters {
            typeName.append(separator)
            typeName.append(p.type.name)
            subtypes.add(p.type)
            separator := ", "
        }
        def kind:Int
        if m.methodKind = MethodDecl.Kind.FUNCTION {
            typeName.append(")=>(")
            kind := Type.Kind.FUNCTION
        }
        else {
            typeName.append(")=&>(")
            kind := Type.Kind.METHOD
        }
        subtypes.add(m.returnType)
        if m.returnType != Type.Void() {
            typeName.append(m.returnType.name)
        }
        typeName.append(")")
        return Type(typeName.finish(), kind, m.position, subtypes, true)
    }

    function declaredTypeWithSelf(m:MethodDecl, selfType:Type):Type {
        resolve(m)
        def subtypes := Array<Type>()
        def typeName := MutableString("(")
        typeName.append(selfType.name)
        subtypes.add(selfType)
        for p in m.parameters {
            typeName.append(", ")
            typeName.append(p.type.name)
            subtypes.add(p.type)
        }
        def kind:Int
        if m.methodKind = MethodDecl.Kind.FUNCTION {
            typeName.append(")=>(")
            kind := Type.Kind.FUNCTION
        }
        else {
            typeName.append(")=&>(")
            kind := Type.Kind.METHOD
        }
        subtypes.add(m.returnType)
        if m.returnType != Type.Void() {
            typeName.append(m.returnType.name)
        }
        typeName.append(")")
        return Type(typeName.finish(), kind, m.position, subtypes, true)
    }

    function inheritedType(m:MethodDecl):Type {
        def inherited := getOverriddenMethod(m)
        if inherited = null {
            return declaredType(m)
        }
        return inheritedType(inherited)
    }

    function inheritedTypeWithSelf(m:MethodDecl):Type {
        return inheritedTypeWithSelf(m, m.owner.type())
    }

    function inheritedTypeWithSelf(m:MethodDecl, selfType:Type):Type {
        def inherited := getOverriddenMethod(m)
        if inherited = null {
            return declaredTypeWithSelf(m, selfType)
        }
        return inheritedTypeWithSelf(inherited, selfType)
    }

    @class
    function operatorName(op:Token.Kind):String {
        match op {
            when Token.Kind.ADD:        return "+"
            when Token.Kind.SUB:        return "-"
            when Token.Kind.MUL:        return "*"
            when Token.Kind.DIV:        return "/"
            when Token.Kind.INTDIV:     return "//"
            when Token.Kind.REM:        return "%"
            when Token.Kind.POW:        return "^"
            when Token.Kind.EQ:         return "="
            when Token.Kind.NEQ:        return "!="
            when Token.Kind.GT:         return ">"
            when Token.Kind.LT:         return "<"
            when Token.Kind.GTEQ:       return ">="
            when Token.Kind.LTEQ:       return "<="
            when Token.Kind.OR:         return "|"
            when Token.Kind.BITWISEOR:  return "||"
            when Token.Kind.AND:        return "&"
            when Token.Kind.BITWISEAND: return "&&"
            when Token.Kind.XOR:        return "~"
            when Token.Kind.BITWISEXOR: return "~~"
            when Token.Kind.NOT:        return "!"
            when Token.Kind.BITWISENOT: return "!!"
            when Token.Kind.SHIFTLEFT:  return "<<"
            when Token.Kind.SHIFTRIGHT: return ">>"
            when Token.Kind.LBRACKET:   return "[]"
            when Token.Kind.ASSIGNMENT: return ":="
            when Token.Kind.IDENTITY:   return "=="
            when Token.Kind.NIDENTITY:  return "!=="
            when Token.Kind.CAST:       return "->"
            otherwise:
                assert false, "not an operator: \{op}"
        }
    }

    @class
    function isAssignment(op:Token.Kind):Bit {
        match op {
            when Token.Kind.ADDEQ, Token.Kind.SUBEQ, Token.Kind.MULEQ, Token.Kind.DIVEQ,
                    Token.Kind.INTDIVEQ, Token.Kind.REMEQ, Token.Kind.POWEQ, Token.Kind.OREQ,
                    Token.Kind.BITWISEOREQ, Token.Kind.ANDEQ, Token.Kind.BITWISEANDEQ,
                    Token.Kind.XOREQ, Token.Kind.BITWISEXOREQ, Token.Kind.SHIFTLEFTEQ,
                    Token.Kind.SHIFTRIGHTEQ:
                return true
            otherwise:
                return false
        }
    }

    @class
    function removeAssignment(op:Token.Kind):Token.Kind {
        match op {
            when Token.Kind.ADDEQ:        return Token.Kind.ADD
            when Token.Kind.SUBEQ:        return Token.Kind.SUB
            when Token.Kind.MULEQ:        return Token.Kind.MUL
            when Token.Kind.DIVEQ:        return Token.Kind.DIV
            when Token.Kind.INTDIVEQ:     return Token.Kind.INTDIV
            when Token.Kind.REMEQ:        return Token.Kind.REM
            when Token.Kind.POWEQ:        return Token.Kind.POW
            when Token.Kind.OREQ:         return Token.Kind.OR
            when Token.Kind.BITWISEOREQ:  return Token.Kind.BITWISEOR
            when Token.Kind.ANDEQ:        return Token.Kind.AND
            when Token.Kind.BITWISEANDEQ: return Token.Kind.BITWISEAND
            when Token.Kind.XOREQ:        return Token.Kind.XOR
            when Token.Kind.BITWISEXOREQ: return Token.Kind.BITWISEXOR
            when Token.Kind.SHIFTLEFTEQ:  return Token.Kind.SHIFTLEFT
            when Token.Kind.SHIFTRIGHTEQ: return Token.Kind.SHIFTRIGHT
            otherwise:
                assert false
        }
    }

    function isLValue(expr:IRNode):Bit {
        match expr {
            when IRNode.CAST(_, value, _, explicit):
                if !explicit {
                    return isLValue(value)
                }
                return false
            when IRNode.FIELD_REFERENCE, IRNode.VARIABLE_REFERENCE,
                    IRNode.CHOICE_FIELD_REFERENCE:
                return true
            when IRNode.REUSED_VALUE_DEFINITION(value, _):
                return isLValue(value)
            otherwise:
                return false
        }
    }

    method foldInts(position:Position, left:IRNode, op:Token.Kind, right:IRNode):IRNode? {
        def l:Int64
        def r:Int64
        -- ensure both values fit into a signed Int64
        match left {
            when IRNode.INT(_, _, int):
                if int > Int64.MAX.convert() {
                    return null
                }
                l := int.convert()
            when IRNode.NEGATED_INT(_, _, int):
                l := int.convert()
            otherwise:
                assert false
        }
        match right {
            when IRNode.INT(_, _, int):
                if int > Int64.MAX.convert() {
                    return null
                }
                r := int.convert()
            when IRNode.NEGATED_INT(_, _, int):
                r := int.convert()
            otherwise:
                assert false
        }
        match op {
            when Token.Kind.ADD:
                def v := (l + r).convert()->UInt64
                return IRNode.INT(position, Type.IntLiteral(v), v)
            when Token.Kind.SUB:
                def v := (l - r).convert()->UInt64
                return IRNode.INT(position, Type.IntLiteral(v), v)
            when Token.Kind.MUL:
                def v := (l * r).convert()->UInt64
                return IRNode.INT(position, Type.IntLiteral(v), v)
            when Token.Kind.INTDIV:
                def v := (l // r).convert()->UInt64
                return IRNode.INT(position, Type.IntLiteral(v), v)
            when Token.Kind.REM:
                def v := (l % r).convert()->UInt64
                return IRNode.INT(position, Type.IntLiteral(v), v)
            when Token.Kind.EQ:
                return IRNode.BIT(position, Type.BitLiteral(), l = r)
            when Token.Kind.NEQ:
                return IRNode.BIT(position, Type.BitLiteral(), l != r)
            when Token.Kind.LT:
                return IRNode.BIT(position, Type.BitLiteral(), l < r)
            when Token.Kind.GT:
                return IRNode.BIT(position, Type.BitLiteral(), l > r)
            when Token.Kind.LTEQ:
                return IRNode.BIT(position, Type.BitLiteral(), l <= r)
            when Token.Kind.GTEQ:
                return IRNode.BIT(position, Type.BitLiteral(), l >= r)
            when Token.Kind.BITWISEAND:
                def v := (l && r).convert()->UInt64
                return IRNode.INT(position, Type.IntLiteral(v), v)
            when Token.Kind.BITWISEOR:
                def v := (l || r).convert()->UInt64
                return IRNode.INT(position, Type.IntLiteral(v), v)
            when Token.Kind.BITWISEXOR:
                def v := (l ~~ r).convert()->UInt64
                return IRNode.INT(position, Type.IntLiteral(v), v)
            when Token.Kind.SHIFTLEFT:
                def v := (l << r).convert()->UInt64
                return IRNode.INT(position, Type.IntLiteral(v), v)
            when Token.Kind.SHIFTRIGHT:
                def v := (l >> r).convert()->UInt64
                return IRNode.INT(position, Type.IntLiteral(v), v)
        }
        error(position, "invalid numeric operation")
        return null
    }

    function unwrapCast(expr:IRNode):IRNode {
        match expr {
            when IRNode.CAST(_, base, _, _):
                return base
            when IRNode.EXPRESSION_WITH_EXTRA_EFFECTS(base, extra):
                match base {
                    when IRNode.REUSED_VALUE_DEFINITION(value, idx):
                        def unwrapped := unwrapCast(value)
                        if unwrapped == value {
                            return expr
                        }
                        match extra {
                            when IRNode.CALL(_, _, m, args):
                                if m.value.owner.name = "panda.core.Panda" &
                                        m.value.name = "unref" & args.get_count() = 1 {
                                    match unwrapCast(unwrapCast(args[0])) {
                                        when IRNode.REUSED_VALUE(_, _, idx2):
                                            assert idx = idx2
                                            return unwrapped
                                        otherwise:
                                            assert false
                                    }
                                }
                        }
                }
                return expr
            otherwise:
                return expr
        }
    }

    method compileIndexedAssignment(position:Position, left:IRNode, op:Token.Kind,
            right:IRNode):IRNode? {
        match left {
            when IRNode.UNRESOLVED_INDEX(_, _, base, args):
                if op = Token.Kind.ASSIGNMENT {
                    def callArgs := Array<IRNode>() -- FIXME literal
                    assert args.get_count() = 1
                    callArgs.addAll(args)
                    callArgs.add(right)
                    return call(base, "[]:=", callArgs)
                }
                assert isAssignment(op)
                -- compound indexed assignment (e.g. foo[bar] += 1), which needs to get converted to
                -- foo.[]:=(bar, foo.[](bar) + 1). We need to reuse both the base and the index so
                -- they're only evaluated once.
                var resolved := resolve(left)
                if resolved = null {
                    return null
                }
                match resolved {
                    when IRNode.EXPRESSION_WITH_EXTRA_EFFECTS(base, _):
                        resolved := base
                }
                match resolved {
                    when IRNode.REUSED_VALUE_DEFINITION(base, _):
                        resolved := base
                }
                resolved := unwrapCast(resolved)
                match resolved {
                    when IRNode.EXPRESSION_WITH_EXTRA_EFFECTS(base, extra):
                        resolved := base
                    otherwise:
                }
                match resolved {
                    when IRNode.REUSED_VALUE_DEFINITION(base, _):
                        resolved := base
                    otherwise:
                }
                match resolved {
                    when IRNode.CALL(_, _, _, resolvedArgs):
                        assert resolvedArgs.get_count() = 2
                        reusedValueCount += 1
                        def baseId := reusedValueCount
                        def base := IRNode.REUSED_VALUE_DEFINITION(unwrapCast(resolvedArgs[0]),
                                baseId)

                        reusedValueCount += 1
                        def indexId := reusedValueCount
                        def index := IRNode.REUSED_VALUE_DEFINITION(resolvedArgs[1], indexId)
                        def baseRef := IRNode.REUSED_VALUE(base.position(), base.type(), baseId)
                        def indexRef := IRNode.REUSED_VALUE(index.position(), index.type(), indexId)
                        -- in our example, foo.[](bar)
                        def rhsIndex := compileBinary(position, baseRef, Token.Kind.LBRACKET,
                                indexRef)
                        if rhsIndex = null {
                            return null
                        }
                        -- in our example, foo.[](bar) + 1
                        var value := compileBinary(position, rhsIndex, removeAssignment(op), right)
                        if value = null {
                            return null
                        }
                        -- 32 bit promotion means that e.g. int8 += int8 will result in a 32 bit
                        -- value that can't be stored back into the original lvalue. Special case
                        -- this and convert it back to its original size.
                        if rhsIndex.type().isNumber() & right.type().isNumber() &
                                rhsIndex.type() != value.type() {
                            value := call(value, "convert", Array<IRNode>(), resolved.type()) -- FIXME literal
                            if value = null {
                                return null
                            }
                        }
                        def callArgs := Array<IRNode>() -- FIXME literal
                        callArgs.add(index)
                        callArgs.add(value)
                        return call(base, "[]:=", callArgs)
                    otherwise:
                        Console.printLine("have \{resolved}")
                        assert false
                }
            otherwise:
                assert false
        }
    }

    method compilePandaCall(name:String, arg:IRNode):IRNode {
        assert isRefCounted(arg.type())
        def p := Position()
        def mref := compileDot(p, IRNode.TYPE_REFERENCE(p, Type.Panda()), name)
        def args := Array<IRNode>() -- FIXME literal
        args.add(arg)
        def result := resolve(call(mref, args))
        assert result != null
        return result
    }

    method compileAssignment(position:Position, rawLeft:IRNode, op:Token.Kind,
            rawRight:IRNode):IRNode? {
        var left := rawLeft
        var right := rawRight
        if op = Token.Kind.ASSIGNMENT {
            if left = IRNode.UNRESOLVED_INDEX {
                return compileIndexedAssignment(position, left, op, right)
            }
            var refCount := true
            match left {
                when IRNode.FIELD_REFERENCE(_, type, _, field):
                    if field.owner.name = WEAK_NAME {
                        refCount := false
                    }
                    if field.annotations.isWeak() {
                        def args := Array<IRNode>() -- FIXME literal
                        args.add(right)
                        right := call(IRNode.TYPE_REFERENCE(position, type), args)
                    }
                otherwise:
                    left := resolve(left)
            }
            if left = null {
                return null
            }
            right := coerce(right, left.type())
            if right = null {
                return null
            }
            if !isLValue(left) {
                error(left.position(), "cannot assign to this expression")
                return null
            }
            if refCount & isRefCounted(left.type()) {
                reusedValueCount += 1
                right := IRNode.REUSED_VALUE_DEFINITION(right, reusedValueCount)
                right := IRNode.EXPRESSION_WITH_EXTRA_EFFECTS(right,
                        compilePandaCall("ref", IRNode.REUSED_VALUE(right.position(), right.type(),
                            reusedValueCount)))
                def result := Array<IRNode>()
                def reusedDef:IRNode? := null
                reusedValueCount += 1
                reusedDef := IRNode.REUSED_VALUE_DEFINITION(left, reusedValueCount)
                result.add(reusedDef)
                result.add(IRNode.BINARY(position, Type.Void(), left, Token.Kind.ASSIGNMENT, right))
                result.add(compilePandaCall("unref",
                        IRNode.REUSED_VALUE(left.position(), left.type(), reusedValueCount)))
                return IRNode.BLOCK(position, result.finish())
            }
            else {
                return IRNode.BINARY(position, Type.Void(), left, Token.Kind.ASSIGNMENT, right)
            }
        }
        if !isAssignment(op) {
            error(position, "expected a statement, but found an expression")
            return null
        }
        -- compound assignment
        if left = IRNode.UNRESOLVED_INDEX {
            return compileIndexedAssignment(position, left, op, right)
        }
        left := resolve(left)
        if left = null {
            return null
        }
        if !isLValue(left) {
            error(left.position(), "cannot assign to this expression")
            return null
        }
        reusedValueCount += 1
        left := IRNode.REUSED_VALUE_DEFINITION(left, reusedValueCount)
        def reusedLeft := IRNode.REUSED_VALUE(left.position(), left.type(),
                reusedValueCount)
        right := compileBinary(position, reusedLeft, removeAssignment(op), right)
        if right = null {
            return null
        }
        -- 32 bit promotion means that e.g. int8 += int8 will result in a 32 bit value that can't be
        -- stored back into the original lvalue. Special case this and convert it back to its
        -- original size.
        if left.type().isNumber() & left.type() != right.type() {
            right := call(right, "convert", Array<IRNode>(), left.type())
            if right = null {
                return null
            }
        }
        return compileAssignment(position, left, Token.Kind.ASSIGNMENT, right)
    }

    method compileAssignment(position:Position, rawLeft:ASTNode, op:Token.Kind,
            rawRight:ASTNode):IRNode? {
        def left := compileExpression(rawLeft)
        if left = null {
            return null
        }
        def right := compileExpression(rawRight)
        if right = null {
            return null
        }
        return compileAssignment(position, left, op, right)
    }

    method compileBinary(position:Position, rawLeft:IRNode, op:Token.Kind,
            rawRight:IRNode):IRNode? {
        -- FIXME use var parameters
        var left:IRNode? := rawLeft
        var right:IRNode? := rawRight
        if left.type().typeKind = Type.Kind.INT_LITERAL {
            right := resolve(right)
            if right = null {
                return null
            }
            if coercionCost(left, right.type()) != null {
                left := coerce(left, right.type())
                if left = null {
                    return null
                }
            }
        }
        if right.type().typeKind = Type.Kind.INT_LITERAL &
                coercionCost(right, left.type()) != null {
            right := coerce(right, left.type())
            if right = null {
                return null
            }
        }
        if op = Token.Kind.EQ | op = Token.Kind.NEQ | op = Token.Kind.IDENTITY |
                op = Token.Kind.NIDENTITY {
            def kind:Int
            if left = IRNode.NULL {
                def resolved := resolve(right)
                if resolved = null {
                    return null
                }
                if op = Token.Kind.EQ | op = Token.Kind.IDENTITY {
                    return IRNode.IS_NULL(position, resolved)
                }
                else {
                    return IRNode.IS_NONNULL(position, resolved)
                }
            }
            if right = IRNode.NULL {
                def resolved := resolve(left)
                if resolved = null {
                    return null
                }
                if op = Token.Kind.EQ | op = Token.Kind.IDENTITY {
                    return IRNode.IS_NULL(position, resolved)
                }
                else {
                    return IRNode.IS_NONNULL(position, resolved)
                }
            }
        }
        if (op = Token.Kind.EQ | op = Token.Kind.NEQ) & left.type().typeKind = Type.Kind.NULLABLE {
            -- transform 'left = right' into 'left != null ? left = right : false'
            assert right != IRNode.NULL -- foo = null should have been handled above
            reusedValueCount += 1
            left := IRNode.REUSED_VALUE_DEFINITION(left, reusedValueCount)
            def reusedLeft := IRNode.REUSED_VALUE(left.position(), left.type(), reusedValueCount)
            def toNonNullable := coerce(reusedLeft, left.type().subtypes[0])
            def comparison := compileBinary(position, toNonNullable, op, right)
            if comparison = null {
                return null
            }
            def nullCheck := compileBinary(position, left, Token.Kind.NEQ,
                    IRNode.NULL(position, Type.Null()))
            if nullCheck = null {
                return null
            }
            return IRNode.TERNARY(position, nullCheck, comparison,
                    coerce(IRNode.BIT(position, Type.BitLiteral(), op = Token.Kind.NEQ),
                    Type.Bit()))
        }
        if op = Token.Kind.IDENTITY | op = Token.Kind.NIDENTITY {
            if left.type().isClass() {
                def cl := getClass(left.type())
                if cl = null {
                    return null
                }
                if isValue(cl) {
                    error(position, "'\{operatorName(op)}' cannot operate on '\{left.type()}', " +
                            "'\{right.type()}'")
                }
            }
            if right.type().isClass() {
                def cl := getClass(right.type())
                if cl = null {
                    return null
                }
                if isValue(cl) {
                    error(position, "'\{operatorName(op)}' cannot operate on '\{left.type()}', " +
                            "'\{right.type()}'")
                }
            }
            def finalLeft := coerce(left, Type.Object())
            if finalLeft = null {
                return null
            }
            def finalRight := coerce(right, Type.Object())
            if finalRight = null {
                return null
            }
            return IRNode.BINARY(position, Type.Bit(), finalLeft, op, finalRight)
        }
        if op = Token.Kind.LBRACKET {
            left := resolve(left)
            if left = null {
                return null
            }
            if left.type().isClass() {
                def cl := getClass(left.type())
                if cl = null {
                    return null
                }
                def parameters := typeParameters(left.type())
                def methods := getSymbolTable(cl)["[]"]
                def type:Type
                if methods != null {
                    def types := Array<Type>()
                    if methods.kind = Symbol.Kind.METHOD {
                        def m := methods->MethodDecl
                        resolve(m)
                        types.add(MethodRef(m, parameters).returnType())
                    }
                    else {
                        assert methods.kind = Symbol.Kind.METHODS
                        for m in methods->Methods.methods {
                            resolve(m)
                            types.add(MethodRef(m, parameters).returnType())
                        }
                    }
                    type := Type(types)
                }
                else {
                    type := Type.Invalid()
                }
                def args := Array<IRNode>()
                args.add(right)
                return IRNode.UNRESOLVED_INDEX(position, type, left, args.finish())
            }
        }
        if left.type() = Type.BuiltinBit() {
            if right.type() = Type.BuiltinBit() & (op = Token.Kind.AND | op = Token.Kind.OR |
                    op = Token.Kind.XOR | op = Token.Kind.EQ | op = Token.Kind.NEQ) {
                return IRNode.BINARY(position, left.type(), left, op, right)
            }
            error(position, "'\{operatorName(op)}' cannot operate on '\{left.type()}', " +
                    "'\{right.type()}'")
            return null
        }
        if (left = IRNode.INT | left = IRNode.NEGATED_INT) &
                (right = IRNode.INT | right = IRNode.NEGATED_INT) {
            return foldInts(position, left, op, right)
        }
        if left.type().isBuiltinNumber() & coercionCost(right, left.type()) != null {
            right := coerce(right, left.type())
            assert right != null
            def resultType:Type
            match op {
                when Token.Kind.EQ, Token.Kind.NEQ, Token.Kind.GT, Token.Kind.GTEQ, Token.Kind.LT,
                        Token.Kind.LTEQ:
                    resultType := Type.BuiltinBit()
                otherwise:
                    resultType := left.type()
            }
            return IRNode.BINARY(position, resultType, left, op, right)
        }
        def args := Array<IRNode>()
        args.add(right)
        assert reportErrors
        reportErrors := false
        var result := call(left, operatorName(op), args)
        reportErrors := true
        if result = null {
            args.clear()
            args.add(left)
            def resolved := resolve(right)
            if resolved != null & resolved.type().isClass() {
                args.add(resolved)
                def target := IRNode.TYPE_REFERENCE(resolved.position(), resolved.type())
                result := call(target, operatorName(op), args)
            }
        }
        return result
    }

    method compileBinary(position:Position, rawLeft:ASTNode, op:Token.Kind,
            rawRight:ASTNode):IRNode? {
        if op = Token.Kind.CAST {
            return compileCast(position, rawLeft, scanner.convertType(rawRight))
        }
        def left := compileExpression(rawLeft)
        if left = null {
            return null
        }
        def right := compileExpression(rawRight)
        if right = null {
            return null
        }
        return compileBinary(position, left, op, right)
    }

    function typeParameters(type:Type):ListView<Type> {
        match type.typeKind {
            when Type.Kind.GENERIC_PARAMETER:
                return typeParameters(type.parameter.bound)
            when Type.Kind.GENERIC:
                assert type.subtypes.get_count() >= 2
                return type.subtypes[1..]
            when Type.Kind.NULLABLE:
                return typeParameters(type.subtypes[0])
            otherwise:
                return Array<Type>()
        }
    }

    function typeParameters(target:IRNode?):ListView<Type> {
        if target != null { -- FIXME should be able to match on null
            match target {
                when IRNode.TYPE_REFERENCE(_, type):
                    return typeParameters(type)
                otherwise:
                    return typeParameters(target.type())
            }
        }
        return Array<Type>()
    }

    method compilePrefix(position:Position, op:Token.Kind, base:IRNode):IRNode? {
        if base.type().isClass() {
            def name := operatorName(op)
            def cl := getClass(base.type())
            if cl = null {
                return null
            }
            def s := getSymbolTable(cl)[name]
            if s != null {
                def m:MethodDecl? := null
                match s.kind {
                    when Symbol.Kind.METHOD:
                        m := s->MethodDecl
                        assert m.parameters.get_count() = 0
                        assert !m.annotations.isClass()
                    when Symbol.Kind.METHODS:
                        for test in s->Methods.methods {
                            if !test.annotations.isClass() & test.parameters.get_count() = 0 {
                                m := test
                                break
                            }
                        }
                    otherwise:
                        assert false
                }
                if m != null {
                    resolve(m)
                    def ref := MethodRef(m, typeParameters(base))
                    def methodRef := IRNode.METHOD_REFERENCE(position, base, ref)
                    def args := Array<IRNode>() -- FIXME literal
                    return call(methodRef, args)
                }
            }
        }
        match op {
            when Token.Kind.SUB:
                match base {
                    when IRNode.INT(_, _, int):
                        return IRNode.NEGATED_INT(position, Type.NegatedIntLiteral(int), int)
                    when IRNode.NEGATED_INT(_, _, int):
                        return IRNode.INT(position, Type.NegatedIntLiteral(int), int)
                    when IRNode.REAL(_, _, real):
                        return IRNode.REAL(position, Type.RealLiteral(-real), -real)
                    otherwise:
                        if base.type().isBuiltinNumber() {
                            return IRNode.PREFIX(base.position(), Token.Kind.SUB, base)
                        }
                }
                error(base.position(), "expected a number, but found '\{base.type()}'")
                return null
            when Token.Kind.BITWISENOT:
                if base.type().isBuiltinNumber() {
                    return IRNode.PREFIX(base.position(), Token.Kind.BITWISENOT, base)
                }
                else {
                    error(base.position(), "expected a number, but found '\{base.type().name}'")
                    return null
                }
            when Token.Kind.NOT:
                def coerced := coerce(base, Type.BuiltinBit())
                if coerced = null {
                    return null
                }
                return IRNode.PREFIX(base.position(), Token.Kind.NOT, coerced)
            otherwise:
                assert false
        }
        assert false
    }

    method compilePrefix(position:Position, op:Token.Kind, rawBase:ASTNode):IRNode? {
        def base := compileExpression(rawBase)
        if base = null {
            return null
        }
        return compilePrefix(position, op, base)
    }

    method compileCall(position:Position, rawTarget:ASTNode,
            rawArgs:ImmutableArray<ASTNode>):IRNode? {
        def target := compileExpression(rawTarget)
        if target = null {
            return null
        }
        def args := Array<IRNode>()
        for arg in rawArgs {
            def compiled := compileExpression(arg)
            if compiled = null {
                return null
            }
            args.add(compiled)
        }
        return call(target, args)
    }

    method compileDot(position:Position, base:IRNode, name:String):IRNode? {
        def cl:ClassDecl?
        match base {
            when IRNode.TYPE_REFERENCE(_, type):
                cl := getClass(type)
            when IRNode.UNRESOLVED_IDENTIFIER(_, baseName):
                def fullName := "\{baseName}.\{name}"
                def cl := tryResolveClass(fullName)
                if cl != null {
                    return IRNode.TYPE_REFERENCE(position, cl.type())
                }
                return IRNode.UNRESOLVED_IDENTIFIER(position, fullName)
            when IRNode.SUPER:
                resolve(currentClass.peek())
                cl := getClass(currentClass.peek().rawSuper)
            otherwise:
                if !base.type().isClass() {
                    error(position, "type '\{base.type()}' is not a class")
                    return null
                }
                cl := getClass(base.type())
        }
        if cl = null {
            return null
        }
        def st := getSymbolTable(cl)
        def s := st[name]
        if s = null {
            error(position, "class '\{base.type()}' does not have a member named '\{name}'")
            return null
        }
        return symbolRef(position, base, s, st)
    }

    method compileDot(position:Position, rawBase:ASTNode, field:String):IRNode? {
        var base := compileExpression(rawBase)
        if base = null {
            return null
        }
        if base != IRNode.UNRESOLVED_IDENTIFIER & base != IRNode.SUPER {
            base := resolve(base)
        }
        if base = null {
            return null
        }
        return compileDot(position, base, field)
    }

    method compileIdentifier(position:Position, name:String):IRNode? {
        var s := symbolTable[name]
        if s = null {
            s := tryResolveClass(name)
        }
        if s != null {
            return symbolRef(position, null, s, symbolTable)
        }
        return IRNode.UNRESOLVED_IDENTIFIER(position, name)
    }

    method compileType(type:ASTNode):IRNode? {
        def resolved := resolve(scanner.convertType(type))
        if resolved = null {
            return null
        }
        return IRNode.TYPE_REFERENCE(type.position(), resolved)
    }

    method compileRange(position:Position, rawStart:ASTNode?, rawEnd:ASTNode?, inclusive:Bit,
            rawStep:ASTNode?):IRNode? {
        def start:IRNode?
        if rawStart != null {
            start := compileExpression(rawStart)
            if start = null {
                return null
            }
        }
        else {
            start := IRNode.NULL(position, Type.Null())
        }
        def end:IRNode?
        if rawEnd != null {
            end := compileExpression(rawEnd)
            if end = null {
                return null
            }
        }
        else {
            end := IRNode.NULL(position, Type.Null())
        }
        def step:IRNode?
        if rawStep != null {
            step := compileExpression(rawStep)
            if step = null {
                return null
            }
            if step = IRNode.NULL {
                error(step.position(), "range step cannot be null")
                return null
            }
        }
        else {
            step := null
        }
        return IRNode.UNRESOLVED_RANGE(position, start, end, inclusive, step)
    }

    method compileString(position:Position, s:String):IRNode? {
        return IRNode.STRING(position, s)
    }

    method compileSelf(position:Position):IRNode? {
        if currentMethod.peek().annotations.isClass() {
            error(position, "cannot reference 'self' from a @class method")
            return null
        }
        def type:Type
        def cl := currentClass.peek()
        if cl.parameters.get_count() > 0 {
            def subtypes := Array<Type>()
            subtypes.add(cl.type())
            def name := MutableString(cl.name)
            name.append("<")
            var separator := ""
            for p in cl.parameters {
                def pType := Array<Type>() -- FIXME literal
                pType.add(p.bound)
                def pName := "\{cl.name}.\{p.name}"
                name.append(separator)
                name.append(pName)
                subtypes.add(Type(p))
                separator := ", "
            }
            name.append(">")
            type := Type(name.finish(), Type.Kind.GENERIC, position, subtypes, true)
        }
        else {
            type := cl.type()
        }
        return IRNode.SELF(position, type)
    }

    method compileSuper(position:Position):IRNode? {
        if currentMethod.peek().annotations.isClass() {
            error(position, "cannot reference 'super' from a @class method")
            return null
        }
        def cl := currentClass.peek()
        assert cl.resolved
        return IRNode.SUPER(position, cl.rawSuper)
    }

    method compileCast(position:Position, expr:ASTNode, rawType:Type):IRNode? {
        def value := compileExpression(expr)
        if value = null {
            return null
        }
        def index := rawType.name.lastIndexOf(".")
        if rawType.typeKind = Type.Kind.CLASS & index != null {
            -- we have a dotted name which might not be entirely a type - for example we might have
            -- 'o->String.length'. This is obviously meant to be a cast to String followed by a
            -- call to get_length(), but syntactically it could just as easily be a cast to a class
            -- named String.length. We need to disambiguate these cases here.
            assert reportErrors
            reportErrors := false
            def type := resolve(rawType)
            reportErrors := true
            if type = null {
                def base := compileCast(position, expr,
                        Type(rawType.name[..index], Type.Kind.CLASS, position))
                if base = null {
                    return null
                }
                return compileDot(position, base, rawType.name[rawType.name.next(index)..])
            }
        }
        def type := resolve(rawType)
        if type = null {
            return null
        }
        if coercionCost(value, type) != null {
            return coerce(value, type)
        }
        if canCast(value, type) {
            return cast(position, value, type, true)
        }
        else {
            error(position, "value of type '\{value.type()}' cannot possibly be an instance of " +
                    "'\{type}'")
            return null
        }
    }

    method compileNull(position:Position):IRNode {
        return IRNode.NULL(position, Type.Null())
    }

    method compileChoiceFieldReference(position:Position, rawBase:ASTNode, ce:ChoiceEntry,
            field:Int):IRNode? {
        resolve(ce)
        def base := compileExpression(rawBase)
        if base = null {
            return null
        }
        return IRNode.CHOICE_FIELD_REFERENCE(position, base, ce, field)
    }

    method compileExpression(e:ASTNode):IRNode? {
        match e {
            when ASTNode.BINARY(position, left, op, right):
                return compileBinary(position, left, op, right)
            when ASTNode.BIT(position, value):
                return IRNode.BIT(position, Type.BitLiteral(), value)
            when ASTNode.CALL(position, target, args):
                def result := compileCall(position, target, args)
                if result != null & result.type() = Type.Void() {
                    match result {
                        when IRNode.CALL(_, _, mref, _):
                            error(result.position(), mref.value.declaration() +
                                    " does not return a value")
                            return null
                        otherwise:
                            assert false
                    }
                }
                return result
            when ASTNode.DOT(position, base, field):
                return compileDot(position, base, field)
            when ASTNode.IDENTIFIER(position, name):
                return compileIdentifier(position, name)
            when ASTNode.INT(position, value):
                return IRNode.INT(position, Type.IntLiteral(value), value)
            when ASTNode.REAL(position, value):
                return IRNode.REAL(position, Type.RealLiteral(value), value)
            when ASTNode.PREFIX(position, op, base):
                return compilePrefix(position, op, base)
            when ASTNode.RANGE(position, start, end, inclusive, step):
                return compileRange(position, start, end, inclusive, step)
            when ASTNode.STRING(position, str):
                return compileString(position, str)
            when ASTNode.TYPE, ASTNode.GENERIC_TYPE, ASTNode.NULLABLE_TYPE:
                return compileType(e)
            when ASTNode.SELF(position):
                return compileSelf(position)
            when ASTNode.SUPER(position):
                return compileSuper(position)
            when ASTNode.NULL(position):
                return compileNull(position)
            when ASTNode.CHOICE_FIELD_REFERENCE(position, base, ce, field):
                return compileChoiceFieldReference(position, base, ce, field)
            when ASTNode.IR_WRAPPER(ir):
                return ir
        }
        assert false, "unsupported expression: \{e} (\{e.position()})"
    }

    function endsWithBranch(statements:ListView<IRNode>):Bit {
        if statements.get_count() = 0 {
            return false
        }
        return endsWithBranch(statements[statements.get_count() - 1])
    }

    function endsWithBranch(stmt:IRNode):Bit {
        match stmt {
            when IRNode.BLOCK(_, statements):
                return endsWithBranch(statements)
            when IRNode.BREAK, IRNode.CONTINUE, IRNode.RETURN:
                return true
            otherwise: return false
        }
    }

    function inScope(label:String?, loopScopes:Stack<String?>):Bit {
        if label = null {
            return loopScopes.get_count() > 0
        }
        for i in 0 .. loopScopes.get_count() {
            if loopScopes.peek(i) = label {
                return true
            }
        }
        return false
    }

    ================================================================================================
    Modifies a statement to perform extra work prior to leaving the current scope. If the statement
    contains code which would cause the scope to be left (`return`, appropriate `break` or
    `continue`), returns a modified version of the statement which invokes `finally` prior to
    executing the `return` / `break` / `continue`. Otherwise, returns the original statement.
    ================================================================================================
    method instrumentExits(stmt:IRNode, loopScopes:Stack<String?>, finally:IRNode):IRNode {
        match stmt {
            when IRNode.RETURN(pos, value):
                def stmts := Array<IRNode>() -- FIXME literal
                if value != null {
                    tmpCount += 1
                    def tmp := Variable(stmt.position(), Variable.Kind.DEF, "tmp\{tmpCount}",
                            value.type())
                    def varChildren := Array<IRNode>()
                    def varRef := IRNode.VARIABLE_REFERENCE(pos, tmp)
                    varChildren.add(IRNode.DECLARATION(varRef, value))
                    stmts.add(IRNode.VAR(pos, Variable.Kind.DEF, varChildren.finish()))
                    stmts.add(finally)
                    stmts.add(IRNode.RETURN(pos, varRef))
                }
                else {
                    stmts.add(finally)
                    stmts.add(stmt)
                }
                return IRNode.BLOCK(pos, stmts.finish())
            when IRNode.BLOCK(pos, statements):
                return IRNode.BLOCK(pos, instrumentExits(statements, loopScopes, finally))
            when IRNode.IF(pos, test, ifTrue, ifFalse):
                return IRNode.IF(pos, test, instrumentExits(ifTrue, loopScopes, finally),
                        instrumentExits(ifFalse, loopScopes, finally))
            when IRNode.MATCH(pos, value, whens, others):
                return IRNode.MATCH(pos, value, instrumentExits(whens, loopScopes, finally),
                        instrumentExits(others, loopScopes, finally))
            when IRNode.WHEN(pos, tests, statements):
                return IRNode.WHEN(pos, tests, instrumentExits(statements, loopScopes, finally))
            when IRNode.RANGE_FOR(pos, label, target, list, statements):
                loopScopes.push(label)
                def result := IRNode.RANGE_FOR(pos, label, target, list,
                        instrumentExits(statements, loopScopes, finally))
                loopScopes.pop()
                return result
            when IRNode.WHILE(pos, label, test, statements):
                loopScopes.push(label)
                def result := IRNode.WHILE(pos, label, test,
                        instrumentExits(statements, loopScopes, finally))
                loopScopes.pop()
                return result
            when IRNode.DO(pos, label, statements, test):
                loopScopes.push(label)
                def result := IRNode.DO(pos,
                        label,
                        instrumentExits(statements, loopScopes, finally),
                        test)
                loopScopes.pop()
                return result
            when IRNode.LOOP(pos, label, statements):
                loopScopes.push(label)
                def result := IRNode.LOOP(pos, label,
                        instrumentExits(statements, loopScopes, finally))
                loopScopes.pop()
                return result
            when IRNode.BREAK(pos, label):
                if !inScope(label, loopScopes) {
                    def stmts := Array<IRNode>() -- FIXME literal
                    stmts.add(finally)
                    stmts.add(stmt)
                    return IRNode.BLOCK(pos, stmts.finish())
                }
                return stmt
            when IRNode.CONTINUE(pos, label):
                if !inScope(label, loopScopes) {
                    def stmts := Array<IRNode>() -- FIXME literal
                    stmts.add(finally)
                    stmts.add(stmt)
                    return IRNode.BLOCK(pos, stmts.finish())
                }
                return stmt
            otherwise:
                return stmt
        }
    }

    method instrumentExits(stmt:IRNode?, loopScopes:Stack<String?>, finally:IRNode):IRNode? {
        if stmt = null {
            return null
        }
        return instrumentExits(stmt->IRNode, loopScopes, finally)
    }

    method instrumentExits(stmts:ListView<IRNode>?, loopScopes:Stack<String?>,
            finally:IRNode):ImmutableArray<IRNode>? {
        if stmts = null {
            return null
        }
        def result := Array<IRNode>()
        for s in stmts {
            result.add(instrumentExits(s, loopScopes, finally))
        }
        return result.finish()
    }

    method compileBlockStatements(position:Position,
            statements:ListView<ASTNode>, finally:IRNode?):ImmutableArray<IRNode>? {
        def symbols := SymbolTable(symbolTable) -- FIXME auto
        symbolTable := symbols
        def result := Array<IRNode>()
        def unref:IRNode? := finally
        def loopScopes := Stack<String?>()
        for stmt in statements {
            var compiled := compileStatement(stmt)
            if compiled = null {
                symbolTable := symbols.parents[0]
                return null
            }
            assert compiled != IRNode.UNRESOLVED_METHOD_CALL
            if compiled = IRNode.VAR {
                def unrefs := Array<IRNode>()
                for v in symbolTable.symbols.values() {
                    if v.kind = Symbol.Kind.VARIABLE & isRefCounted(v->Variable.type) {
                        unrefs.add(compilePandaCall("unref",
                                IRNode.VARIABLE_REFERENCE(Position(), v->Variable)))
                    }
                }
                if unrefs.get_count() > 0 {
                    if unrefs.get_count() = 1 {
                        unref := unrefs[0]
                    }
                    else {
                        unref := IRNode.BLOCK(Position(), unrefs.finish())
                    }
                }
            }
            if unref != null {
                compiled := instrumentExits(compiled, loopScopes, unref)
                assert loopScopes.get_count() = 0
            }
            result.add(compiled)
        }
        if unref != null & !endsWithBranch(result) {
            result.add(unref)
        }
        symbolTable := symbols.parents[0]
        return result.finish()
    }

    method compileBlockStatements(position:Position,
            statements:ListView<ASTNode>):ImmutableArray<IRNode>? {
        return compileBlockStatements(position, statements, null)
    }


    method compileBlock(position:Position, statements:ListView<ASTNode>):IRNode? {
        def result := compileBlockStatements(position, statements)
        if result = null {
            return null
        }
        return IRNode.BLOCK(position, result)
    }

    method compileIf(position:Position, rawTest:ASTNode, rawIfTrue:ListView<ASTNode>,
            rawIfFalse:ASTNode?):IRNode? {
        def test := coerce(compileExpression(rawTest), Type.Bit())
        if test = null {
            return null
        }
        def ifTrue := compileBlockStatements(position, rawIfTrue)
        if ifTrue = null {
            return null
        }
        def ifFalse:IRNode?
        if rawIfFalse != null {
            ifFalse := compileStatement(rawIfFalse)
            if ifFalse = null {
                return null
            }
        }
        else {
            ifFalse := null
        }
        return IRNode.IF(position, test, ifTrue, ifFalse)
    }

    method checkSteppedRangeTypes(position:Position, type:Type):Bit {
        if type.typeKind = Type.Kind.NULLABLE {
            return checkSteppedRangeTypes(position, type.subtypes[0])
        }
        if type.isSteppedRange() {
            def type1 := type.subtypes[1].nonnullable()
            def type2 := type.subtypes[2]
            if type1 = type2 {
                return true
            }
            if type1.isChar() & type2.name.startsWith("panda.core.Int") &
                    type1.name.endsWith(type2.name["panda.core.Int".length()..]) {
                return true
            }
            error(position, "for loop cannot iterate over '\{type}'; endpoint and step types " +
                    "are not compatible")
            return false
        }
        return true
    }

    method compileRangeFor(position:Position, label:String?, astTarget:ASTNode, rawList:IRNode,
            rawBody:ListView<ASTNode>):IRNode? {
        def elementType:Type
        def list:IRNode?
        match astTarget {
            when ASTNode.TYPED_IDENTIFIER(position, _, type):
                def t := resolve(scanner.convertType(type))
                if t.typeKind = Type.Kind.NULLABLE {
                    error(position, "for loop variable cannot have nullable type '\{t}'")
                    return null
                }
                if !t.isNumeric() {
                    error(position, "for loop variable cannot have non-numeric type '\{t}'")
                    return null
                }
                match rawList {
                    when IRNode.UNRESOLVED_RANGE(_, _, _, _, step): -- use pattern match with "& step != null", "& step = null"
                        if step != null {
                            list := coerce(rawList, Type.SteppedRangeOf(t))
                        }
                        else {
                            list := coerce(rawList, Type.RangeOf(t))
                        }
                    otherwise:
                        if rawList.type().isSteppedRange() {
                            list := coerce(rawList, Type.SteppedRangeOf(t))
                        }
                        else if coercionCost(rawList, Type.RangeOf(t)) != null {
                            list := coerce(rawList, Type.RangeOf(t))
                        }
                        else {
                            list := coerce(rawList, Type.SteppedRangeOf(t))
                        }
                }
            otherwise:
                var listType := variableType(rawList)
                assert listType.isRange() | listType.isSteppedRange()
                if listType.subtypes[1].typeKind = Type.Kind.NULLABLE {
                    if listType.isRange() {
                        listType := Type.RangeOf(listType.subtypes[1].nonnullable())
                    }
                    else {
                        listType := Type.SteppedRangeOf(listType.subtypes[1].nonnullable())
                    }
                }
                list := coerce(rawList, listType)
        }
        if list = null {
            return null
        }
        if !checkSteppedRangeTypes(list.position(), list.type()) {
            return null
        }
        if list.type().typeKind = Type.Kind.NULLABLE {
            assert list.type().subtypes[0].typeKind = Type.Kind.GENERIC
            elementType := list.type().subtypes[0].subtypes[1]
        }
        else {
            assert list.type().typeKind = Type.Kind.GENERIC
            elementType := list.type().subtypes[1]
        }
        if !elementType.isNumeric() {
            error(list.position(), "for loop expected a numeric range, but found '\{list.type()}'")
        }
        def target := compileTarget(astTarget, Variable.Kind.DEF, null, elementType)
        if target = null {
            return null
        }
        assert target.value = null
        def body := compileBlockStatements(position, rawBody)
        if body = null {
            return null
        }
        return IRNode.RANGE_FOR(position, label, target.target, list, body)
    }

    method compileIteratorFor(position:Position, label:String?, target:ASTNode, iterator:IRNode,
            body:ListView<ASTNode>):IRNode? {
        -- We rewrite 'for v in <iterator> { <statements> }' to:
        -- def v$Iter := <iterator>
        -- while !v$Iter.done() {
        --     def v := v$Iter.next()
        --     <statements>
        -- }
        assert iterator.type().typeKind = Type.Kind.GENERIC &
                iterator.type().subtypes[0] = Type.Iterator()
        def statements := Array<ASTNode>()
        def iterDecls := Array<ASTNode>() -- FIXME literal
        def iterName := "Iter$\{position.line}$\{position.column}"
        iterDecls.add(ASTNode.DECLARATION(position, ASTNode.IDENTIFIER(position, iterName),
                ASTNode.IR_WRAPPER(iterator)))
        def iterDecl := ASTNode.VAR(position, Variable.Kind.DEF, iterDecls.finish())
        statements.add(iterDecl)
        def bodyStatements := Array<ASTNode>()
        def nextDecls := Array<ASTNode>() -- FIXME literal
        nextDecls.add(ASTNode.DECLARATION(position, target, ASTNode.CALL(position,
                ASTNode.DOT(position, ASTNode.IDENTIFIER(position, iterName), "next"),
                ImmutableArray<ASTNode>())))
        def nextDecl := ASTNode.VAR(position, Variable.Kind.DEF, nextDecls.finish())
        bodyStatements.add(nextDecl)
        bodyStatements.addAll(body)
        def notDone := ASTNode.PREFIX(position, Token.Kind.NOT, ASTNode.CALL(position,
                ASTNode.DOT(position, ASTNode.IDENTIFIER(position, iterName), "get_done"),
                ImmutableArray<ASTNode>()))
        statements.add(ASTNode.WHILE(position, label, notDone, bodyStatements.finish()))
        return compileBlock(position, statements.finish())
    }

    method compileFor(position:Position, label:String?, rawTarget:ASTNode, rawList:ASTNode,
            statements:ListView<ASTNode>):IRNode? {
        loops.push(label) -- FIXME use AutoLoop
        var list := compileExpression(rawList)
        if list = null {
            loops.pop()
            return null
        }
        def symbols := SymbolTable(symbolTable) -- FIXME auto
        symbolTable := symbols
        def result:IRNode?
        if list = IRNode.UNRESOLVED_RANGE | list.type().isRange() | list.type().isSteppedRange() {
            result := compileRangeFor(position, label, rawTarget, list, statements)
        }
        else {
            list := resolve(list)
            if list = null {
                return null
            }
            var found := false
            for intf in allInterfaces(list.type()) {
                if intf.typeKind = Type.Kind.GENERIC & intf.subtypes[0] = Type.Iterator() {
                    def iterator := coerce(list, intf)
                    result := compileIteratorFor(position, label, rawTarget, iterator, statements)
                    found := true
                    break
                }
                if intf.typeKind = Type.Kind.GENERIC & intf.subtypes[0] = Type.Iterable() {
                    def iterable := coerce(list, intf)
                    def iterator := call(iterable, "iterator", Array<IRNode>())
                    result := compileIteratorFor(position, label, rawTarget, iterator, statements)
                    found := true
                    break
                }
            }
            if !found {
                error(list.position(), "expected an Iterable or Iterator, but found " +
                        "'\{list.type()}'")
                return null
            }
        }
        symbolTable := symbols.parents[0]
        loops.pop()
        return result
    }

    method compileWhile(position:Position, label:String?, rawTest:ASTNode,
            statements:ListView<ASTNode>):IRNode? {
        loops.push(label) -- FIXME use AutoLoop
        def test := coerce(compileExpression(rawTest), Type.Bit())
        if test = null {
            loops.pop()
            return null
        }
        def block := compileBlockStatements(position, statements)
        if block = null {
            loops.pop()
            return null
        }
        loops.pop()
        return IRNode.WHILE(position, label, test, block)
    }

    method compileDo(position:Position, label:String?, statements:ListView<ASTNode>,
            rawTest:ASTNode):IRNode? {
        loops.push(label) -- FIXME use AutoLoop
        def block := compileBlockStatements(position, statements)
        if block = null {
            loops.pop()
            return null
        }
        def test := coerce(compileExpression(rawTest), Type.Bit())
        if test = null {
            loops.pop()
            return null
        }
        def children := Array<IRNode>(2) -- FIXME literal
        loops.pop()
        return IRNode.DO(position, label, block, test)
    }

    method compileLoop(position:Position, label:String?, statements:ListView<ASTNode>):IRNode? {
        loops.push(label) -- FIXME use AutoLoop
        def block := compileBlockStatements(position, statements)
        if block = null {
            loops.pop()
            return null
        }
        loops.pop()
        return IRNode.LOOP(position, label, block)
    }

    -- FIXME use tuple
    class CompileTargetResult {
        def target:org.pandalanguage.pandac.IRNode
        def value:org.pandalanguage.pandac.IRNode?

        init(target:org.pandalanguage.pandac.IRNode, value:org.pandalanguage.pandac.IRNode?) {
            self.target := target
            self.value := value
        }
    }

    method compileTarget(t:ASTNode, kind:Variable.Kind, rawValue:IRNode?,
            valueType:Type?):CompileTargetResult? {
        var value:IRNode? := rawValue -- FIXME use var on parameter
        assert value = null | valueType = null
        match t {
            when ASTNode.IDENTIFIER(position, name):
                def type:Type
                if value != null {
                    value := resolve(value)
                    if value = null {
                        return null
                    }
                    type := variableType(value)
                }
                else if valueType != null {
                    type := valueType
                }
                else {
                    error(position, "declaration has neither a type nor a value")
                    return null
                }
                if value != null {
                    value := coerce(value, type)
                    if value = null {
                        return null
                    }
                    assert value.type() = type
                }
                def v := Variable(position, kind, name, type)
                symbolTable.add(v)
                return CompileTargetResult(IRNode.VARIABLE_REFERENCE(v.position, v), value)
            when ASTNode.TYPED_IDENTIFIER(position, name, rawType):
                def type := resolve(scanner.convertType(rawType))
                if value != null {
                    value := coerce(value, type)
                    if value = null {
                        return null
                    }
                    assert value.type() = type
                }
                def v := Variable(position, kind, name, type)
                symbolTable.add(v)
                return CompileTargetResult(IRNode.VARIABLE_REFERENCE(v.position, v), value)
            otherwise:
                assert false
        }
    }

    method compileDeclaration(position:Position, target:ASTNode, rawValue:ASTNode?,
            varKind:Variable.Kind):IRNode? {
        var value:IRNode?
        if rawValue != null {
            value := compileExpression(rawValue)
            if value = null {
                return null
            }
        }
        else {
            value := null
        }
        def target := compileTarget(target, varKind, value, null)
        if target = null {
            return null
        }
        if target.value != null {
            match target.target {
                when IRNode.VARIABLE_REFERENCE(_, v):
                    v.initialValue := target.value
                    value := target.value
                    if isRefCounted(value.type()) {
                        reusedValueCount += 1
                        value := IRNode.REUSED_VALUE_DEFINITION(value, reusedValueCount)
                        def reused := IRNode.REUSED_VALUE(value.position(), value.type(),
                                reusedValueCount)
                        value := IRNode.EXPRESSION_WITH_EXTRA_EFFECTS(value,
                                compilePandaCall("ref", reused))
                    }
            }
        }
        else {
            value := null
        }
        return IRNode.DECLARATION(target.target, value)
    }

    method compileBreak(position:Position, label:String?):IRNode? {
        if label != null {
            var found := false
            for loopLabel in loops {
                if loopLabel != null & label = loopLabel { -- FIXME shouldn't need null check
                    found := true
                    break
                }
            }
            if !found {
                error(position, "'break \{label}' must be inside a loop labelled '\{label}:'")
            }
        }
        else if loops.get_count() = 0 {
            error(position, "'break' must be inside a loop")
        }
        return IRNode.BREAK(position, label)
    }

    method compileContinue(position:Position, label:String?):IRNode? {
        if label != null {
            var found := false
            for loopLabel in loops {
                if loopLabel != null & label = loopLabel { -- FIXME shouldn't need null check
                    found := true
                    break
                }
            }
            if !found {
                error(position, "'continue \{label}' must be inside a loop labelled '\{label}:'")
            }
        }
        else if loops.get_count() = 0 {
            error(position, "'continue' must be inside a loop")
        }
        return IRNode.CONTINUE(position, label)
    }

    method compileReturn(position:Position, rawValue:ASTNode?):IRNode? {
        if rawValue != null {
            if currentMethod.peek().returnType = Type.Void() {
                error(position, "cannot return a value from a method with no return type")
                return null
            }
            var value := coerce(compileExpression(rawValue), currentMethod.peek().returnType)
            if value = null {
                return null
            }
            if isRefCounted(value.type()) {
                reusedValueCount += 1
                value := IRNode.REUSED_VALUE_DEFINITION(value, reusedValueCount)
                def reused := IRNode.REUSED_VALUE(value.position(), value.type(), reusedValueCount)
                value := IRNode.EXPRESSION_WITH_EXTRA_EFFECTS(value,
                        compilePandaCall("ref", reused))
            }
            return IRNode.RETURN(position, value)
        }
        if currentMethod.peek().returnType != Type.Void() {
            error(position, "expected a return value")
            return null
        }
        return IRNode.RETURN(position, null)
    }

    method compileAssert(position:Position, rawTest:ASTNode, rawMessage:ASTNode?):IRNode? {
        var test := compileExpression(rawTest)
        if test = null {
            return null
        }
        test := coerce(test, Type.Bit())
        if test = null {
            return null
        }
        def bit := getClass(Type.Bit())
        assert bit != null
        def value := bit.symbolTable["value"]->FieldDecl
        resolve(value)
        test := IRNode.FIELD_REFERENCE(position, Type.BuiltinBit(), test, value)
        def message:IRNode?
        if rawMessage != null {
            message := compileExpression(rawMessage)
            if message = null {
                return null
            }
            message := coerce(message, Type.StringType())
            if message = null {
                return null
            }
        }
        else {
            message := null
        }
        return IRNode.ASSERT(position, test, message)
    }

    method compileVar(position:Position, kind:Variable.Kind,
            declarations:ImmutableArray<ASTNode>):IRNode? {
        def decls := Array<IRNode>()
        for astDecl in declarations {
            match astDecl {
                when ASTNode.DECLARATION(position, target, rawValue):
                    def decl := compileDeclaration(position, target, rawValue, kind)
                    if decl = null {
                        return null
                    }
                    decls.add(decl)
                otherwise:
                    assert false
            }
        }
        return IRNode.VAR(position, kind, decls.finish())
    }

    method compileWhenTest(value:Variable, test:ASTNode):IRNode? {
        def target := IRNode.VARIABLE_REFERENCE(test.position(), value)
        def testValue := compileExpression(test)
        if testValue = null {
            return null
        }
        def callChildren := Array<IRNode>()
        callChildren.add(testValue)
        return call(target, "=", callChildren)
    }

    method compileChainedIfWhen(value:Variable, position:Position, tests:ImmutableArray<ASTNode>,
                     rawStatements:ImmutableArray<ASTNode>):IRNode? {
        if tests.get_count() = 1 {
            def test := tests[0]
            if value.type.isClass() {
                match test {
                    when ASTNode.CALL(testPosition, rawBase, args):
                        def cl := getClass(value.type)
                        if cl.classKind = ClassDecl.Kind.CHOICE {
                            def base := compileExpression(rawBase)
                            if base = null {
                                return null
                            }
                            match base {
                                when IRNode.CHOICE_ENTRY_REFERENCE(_, entry):
                                    def callChildren := Array<IRNode>()
                                    callChildren.add(base)
                                    def target := IRNode.VARIABLE_REFERENCE(testPosition, value)
                                    def check := call(target, "=", callChildren)
                                    if check = null {
                                        return null
                                    }
                                    resolve(entry)
                                    def requiredCount := entry.fields.get_count()
                                    def actualCount := args.get_count()
                                    if actualCount != requiredCount {
                                        error(testPosition, "'\{entry}' requires \{requiredCount}" +
                                                " argument\{requiredCount = 1:|s}, but found " +
                                                actualCount)
                                        return null
                                    }
                                    symbolTable := SymbolTable(symbolTable)
                                    def statements := Array<IRNode>()
                                    for i in 0 .. actualCount {
                                        match args[i] {
                                            when ASTNode.IDENTIFIER(position, name):
                                                if name = "_" {
                                                    continue
                                                }
                                                def variable := Variable(position,
                                                        Variable.Kind.DEF, name, entry.fields[i])
                                                symbolTable.add(variable)
                                                def decls := Array<IRNode>()
                                                decls.add(IRNode.DECLARATION(
                                                        IRNode.VARIABLE_REFERENCE(variable.position,
                                                            variable),
                                                        IRNode.CHOICE_FIELD_REFERENCE(
                                                            variable.position,
                                                            IRNode.VARIABLE_REFERENCE(position,
                                                                value),
                                                            entry, i)))
                                                statements.add(IRNode.VAR(variable.position,
                                                        Variable.Kind.DEF, decls.finish()))
                                            otherwise:
                                                error(args[i].position(), "expected an identifier")
                                                return null
                                        }
                                    }
                                    def blockStatements := compileBlockStatements(position,
                                            rawStatements)
                                    if blockStatements = null {
                                        return null
                                    }
                                    statements.addAll(blockStatements)
                                    symbolTable := symbolTable.parents[0]
                                    return IRNode.IF(position, check, statements.finish(), null)
                            }
                    }
                }
            }
        }

        var test := compileWhenTest(value, tests[0])
        if test = null {
            return null
        }
        for i in 1 .. tests.get_count() {
            def nextTest := compileWhenTest(value, tests[i])
            if nextTest = null {
                return null
            }
            def callChildren := Array<IRNode>() -- FIXME literal
            callChildren.add(nextTest)
            test := call(test, "|", callChildren)
            if test = null {
                return null
            }
        }
        symbolTable := SymbolTable(symbolTable)
        def statements := compileBlockStatements(position, rawStatements)
        if statements = null {
            return null
        }
        symbolTable := symbolTable.parents[0]
        return IRNode.IF(position, test, statements, null)
    }

    method compileChainedIfMatch(position:Position, value:IRNode, whens:ImmutableArray<ASTNode>,
                     other:ImmutableArray<ASTNode>?):IRNode? {
        def result := Array<IRNode>()
        def valueVar := Variable(position, Variable.Kind.DEF,
                "$match$\{position.line}_\{position.column}", value.type())
        symbolTable.add(valueVar)
        def decls := Array<IRNode>()
        decls.add(IRNode.DECLARATION(IRNode.VARIABLE_REFERENCE(value.position(), valueVar), value))
        result.add(IRNode.VAR(valueVar.position, Variable.Kind.DEF, decls.finish()))
        for rawWhen in whens {
            match rawWhen {
                when ASTNode.WHEN(whenPosition, tests, statements):
                    def w := compileChainedIfWhen(valueVar, whenPosition, tests, statements)
                    if w = null {
                        return null
                    }
                    result.add(w)
                otherwise:
                    assert false
            }
        }
        if other != null {
            def statements := compileBlockStatements(position, other)
            if statements = null {
                return null
            }
            result.add(IRNode.BLOCK(position, statements))
        }
        for i in result.get_count() - 1 .. 1 by -1 {
            match result[i - 1] {
                when IRNode.IF(position, test, ifTrue, ifFalse):
                    assert ifFalse = null
                    result[i - 1] := IRNode.IF(position, test, ifTrue, result[i])
                otherwise:
                    assert false
            }
            result.removeIndex(result.get_count() - 1)
        }
        return IRNode.BLOCK(position, result.finish())
    }

    method compileWhen(type:Type, position:Position, tests:ImmutableArray<ASTNode>,
                rawStatements:ImmutableArray<ASTNode>):IRNode? {
        def finalTests := Array<IRNode>()
        for expr in tests {
            def compiled := coerce(compileExpression(expr), type)
            if compiled = null {
                return null
            }
            finalTests.add(compiled)
        }
        symbolTable := SymbolTable(symbolTable)
        def statements := compileBlockStatements(position, rawStatements)
        if statements = null {
            return null
        }
        symbolTable := symbolTable.parents[0]
        return IRNode.WHEN(position, finalTests.finish(), statements)
    }

    method compileOtherwise(rawStatements:ImmutableArray<ASTNode>):ImmutableArray<IRNode>? {
        symbolTable := SymbolTable(symbolTable)
        def statements := compileBlockStatements(Position(), rawStatements)
        if statements = null {
            return null
        }
        symbolTable := symbolTable.parents[0]
        return statements
    }

    function isConstantInt(expr:IRNode):Bit {
        match expr {
            when IRNode.INT:
                return true
            when IRNode.CONSTRUCT(_, _, initCall):
                if !expr.type().isNumber() {
                    return false
                }
                match initCall {
                    when IRNode.CALL(_, _, _, args):
                        assert args.get_count() = 1
                        return isConstantInt(args[0])
                    otherwise:
                        return false
                }
            when IRNode.FIELD_REFERENCE(_, _, _, f):
                assert f.resolved
                return f.fieldKind = FieldDecl.Kind.CONSTANT & f.value != null &
                        isConstantInt(f.value)
            when IRNode.VARIABLE_REFERENCE(_, v):
                return v.varKind = Variable.Kind.DEF | v.varKind = Variable.Kind.CONSTANT &
                        v.initialValue != null & isConstantInt(v.initialValue)
            otherwise:
                return false
        }
    }

    function getConstantInt(expr:IRNode):UInt64 {
        assert isConstantInt(expr)
        match expr {
            when IRNode.INT(_, _, value):
                return value
            when IRNode.CONSTRUCT(_, _, initCall):
                match initCall {
                    when IRNode.CALL(_, _, _, args):
                        assert args.get_count() = 1
                        return getConstantInt(args[0])
                    otherwise:
                        assert false
                }
            when IRNode.FIELD_REFERENCE(_, _, _, f):
                return getConstantInt(f.value)
            when IRNode.VARIABLE_REFERENCE(_, v):
                return getConstantInt(v.initialValue)
            otherwise:
               assert false
        }
    }

    method compileMatch(position:Position, value:ASTNode, whens:ImmutableArray<ASTNode>,
                other:ImmutableArray<ASTNode>?):IRNode? {
        def finalValue := resolve(compileExpression(value))
        if finalValue = null {
            return null
        }
        if !finalValue.type().isNumber() {
            return compileChainedIfMatch(position, finalValue, whens, other)
        }
        def finalWhens := Array<IRNode>()
        for rawWhen in whens {
            match rawWhen {
                when ASTNode.WHEN(position, tests, statements):
                    def w := compileWhen(finalValue.type(), position, tests, statements)
                    if w = null {
                        return null
                    }
                    match w {
                        when IRNode.WHEN(_, tests, _):
                            for t in tests {
                                if !isConstantInt(t) {
                                    return compileChainedIfMatch(position, finalValue, whens, other)
                                }
                            }
                            finalWhens.add(w)
                        otherwise:
                            assert false
                    }
                otherwise:
                    assert false
            }
        }
        def finalOther:ImmutableArray<IRNode>?
        if other != null {
            finalOther := compileOtherwise(other)
            if finalOther = null {
                return null
            }
        }
        else {
            finalOther := null
        }
        return IRNode.MATCH(position, finalValue, finalWhens.finish(), finalOther)
    }

    method compileStatement(s:ASTNode):IRNode? {
        match s {
            when ASTNode.ASSERT(position, test, msg):
                return compileAssert(position, test, msg)
            when ASTNode.BINARY(position, left, op, right):
                return compileAssignment(position, left, op, right)
            when ASTNode.BLOCK(position, statements):
                return compileBlock(position, statements)
            when ASTNode.IF(position, test, ifTrue, ifFalse):
                return compileIf(position, test, ifTrue, ifFalse)
            when ASTNode.FOR(position, label, target, list, statements):
                return compileFor(position, label, target, list, statements)
            when ASTNode.WHILE(position, label, test, statements):
                return compileWhile(position, label, test, statements)
            when ASTNode.DO(position, label, statements, test):
                return compileDo(position, label, statements, test)
            when ASTNode.LOOP(position, label, statements):
                return compileLoop(position, label, statements)
            when ASTNode.MATCH(position, value, whens, other):
                return compileMatch(position, value, whens, other)
            when ASTNode.BREAK(position, label):
                return compileBreak(position, label)
            when ASTNode.CONTINUE(position, label):
                return compileContinue(position, label)
            when ASTNode.RETURN(position, value):
                return compileReturn(position, value)
            when ASTNode.CALL(position, target, args):
                var result := resolve(compileCall(position, target, args))
                if result != null {
                    result := unwrapCast(result)
                }
                return result
            when ASTNode.VAR(position, kind, declarations):
                return compileVar(position, kind, declarations)
        }
        assert false, "unsupported statement: \{s}"
    }

    method compileBody(m:MethodDecl):ImmutableArray<IRNode>? {
        if m.compiledBody != null {
            return m.compiledBody
        }
        currentClass.push(m.owner)
        def old := symbolTable
        symbolTable := getSymbolTable(m.owner)
        currentMethod.push(m)
        resolve(m)
        assert m.body != null
        def symbols := SymbolTable(symbolTable)
        for p in m.parameters {
            symbols.add(Variable(m.position, Variable.Kind.DEF, p.name, p.type,
                    Variable.Storage.PARAMETER))
        }
        symbolTable := symbols
        def fieldInitializers:Array<IRNode>? := null
        if m.methodKind = MethodDecl.Kind.INIT {
            fieldInitializers := Array<IRNode>()
            for f in currentClass.peek().fields {
                resolve(f)
                if !f.annotations.isClass() & f.value != null {
                    def fieldRef := IRNode.FIELD_REFERENCE(m.position, f.type,
                            IRNode.SELF(m.position, m.owner.type()), f)
                    def value:IRNode
                    if isRefCounted(f.type) {
                        reusedValueCount += 1
                        value := IRNode.REUSED_VALUE_DEFINITION(f.value, reusedValueCount)
                        def reused := IRNode.REUSED_VALUE(value.position(), value.type(),
                                reusedValueCount)
                        value := IRNode.EXPRESSION_WITH_EXTRA_EFFECTS(value,
                                compilePandaCall("ref", reused))
                    }
                    else {
                        value := f.value
                    }
                    fieldInitializers.add(IRNode.BINARY(f.position, Type.Void(), fieldRef,
                            Token.Kind.ASSIGNMENT, value))
                }
            }
        }
        def finally:IRNode?
        if m.name = "cleanup" & m.parameters.get_count() = 0 & m.owner.name != "panda.core.Object" &
            !isValue(m.owner) {
            def cleanup := compileExpression(ASTNode.DOT(m.position, ASTNode.SUPER(m.position),
                    "cleanup"))
            assert cleanup != null
            finally := call(cleanup, ImmutableArray<IRNode>() -* FIXME literal *-)
            assert finally != null
        }
        else {
            finally := null
        }
        var compiled := compileBlockStatements(m.position, m.body, finally)
        if compiled != null {
            if fieldInitializers != null {
                def finalBody := Array<IRNode>(fieldInitializers)
                finalBody.addAll(compiled)
                compiled := finalBody.finish()
            }
            if m.name = "cleanup" & m.parameters.get_count() = 0 & m.owner.name != WEAK_NAME {
                assert !inFieldCleanup
                inFieldCleanup := true
                def finalBody := Array<IRNode>(compiled)
                for f in m.owner.fields {
                    resolve(f)
                    if !f.annotations.isClass() & isRefCounted(f.type) {
                        def fieldRef := IRNode.FIELD_REFERENCE(Position(), f.type,
                                IRNode.SELF(Position(), m.owner.type()), f)
                        finalBody.add(compilePandaCall("unref", fieldRef))
                        compiled := finalBody.finish()
                    }
                }
                assert inFieldCleanup
                inFieldCleanup := false
            }
        }
        assert symbolTable == symbols
        symbolTable := old
        currentMethod.pop()
        currentClass.pop()
        if m.annotations.isInline() {
            m.compiledBody := compiled
        }
        return compiled
    }

    method createChoiceCleanup(m:MethodDecl) {
        def cl := m.owner
        def statements := Array<ASTNode>()
        def value := ASTNode.SELF(cl.position)
        def whens := Array<ASTNode>()
        for e in cl.choiceEntries {
            resolve(e)
            def tests := Array<ASTNode>() -- FIXME literal
            def fields := Array<ASTNode>()
            for i in 0 .. e.fields.get_count() {
                fields.add(ASTNode.IDENTIFIER(cl.position, "_f\{i}"))
            }
            tests.add(ASTNode.CALL(cl.position, ASTNode.IDENTIFIER(cl.position, e.name),
                    fields.finish()))
            def unrefs := Array<ASTNode>()
            for i in 0 .. e.fields.get_count() {
                if isRefCounted(e.fields[i]) {
                    def p := Position()
                    def unref := ASTNode.DOT(p, ASTNode.DOT(p, ASTNode.DOT(p,
                            ASTNode.IDENTIFIER(p, "panda"), "core"), "Panda"), "unref")
                    def args := Array<ASTNode>() -- FIXME literal
                    args.add(fields[i])
                    unrefs.add(ASTNode.CALL(Position(), unref, args.finish()))
                }
            }
            whens.add(ASTNode.WHEN(cl.position, tests.finish(), unrefs.finish()))
        }
        statements.add(ASTNode.MATCH(cl.position, value, whens.finish(), null))
        m.body := statements.finish()
    }

    method compile(m:MethodDecl) {
        if m.owner.classKind = ClassDecl.Kind.CHOICE & m.name = "cleanup" {
            createChoiceCleanup(m)
        }
        if m.body != null {
            def compiled := compileBody(m)
            if errorCount = 0 & compiled != null {
                codeGenerator.write(m, compiled)
            }
        }
        else {
            resolve(m)
            codeGenerator.writeDeclaration(m)
        }
    }

    method markNonExternal(cl:ClassDecl) {
        cl.external := false
        for inner in cl.classes {
            markNonExternal(inner)
        }
    }

    method compile(cl:ClassDecl) {
        assert compiling = null,
                "starting compilation of \{cl.name} while already compiling \{compiling.name}"
        compiling := cl
        currentClass.push(cl)
        if cl.annotations.isSpecialize() {
            codeGenerator.start(cl)
            codeGenerator.end(cl)
            currentClass.pop()
            return
        }
        def old := symbolTable
        symbolTable := getSymbolTable(cl)
        codeGenerator.start(cl)
        for m in cl.methods {
            compile(m)
        }
        codeGenerator.end(cl)
        symbolTable := old
        currentClass.pop()
        compiling := null

        if compilationQueue.get_count() > 0 {
            def next := compilationQueue[0]
            compilationQueue.removeIndex(0)
            compile(next)
        }
        assert compilationQueue.get_count() = 0
    }

    method scan(file:File):ListView<ClassDecl> {
        var result := scans[file]
        if result = null {
            parser.start(file, file.readFully())
            def parsed := parser.file()
            if parsed != null {
                result := scanner.scan(file, parsed)
                for cl in result {
                    classes[cl.name] := cl
                }
            }
            else {
                result := Array<ClassDecl>()
            }
            scans[file] := result
        }
        return result
    }

    method compile(file:File) {
        for cl in scan(file) {
            compile(cl)
        }
    }

    method error(position:Position, msg:String) {
        error(currentClass.peek().source, position, msg)
    }

    method error(file:File, pos:Position, msg:String) {
        if reportErrors {
            errorCount += 1
            Console.printLine("\{file.name()}:\{pos}: error: \{msg}")
        }
    }

    method finish() {
        codeGenerator.finish()
    }
}