package org.pandalanguage.pandac

uses org.pandalanguage.pandac.parser.Parser
uses org.pandalanguage.pandac.parser.Token

@final
class Compiler {
    choice Resolution {
        UNRESOLVED
        IN_PROGRESS
        RESOLVED
        RESOLVED_WITH_ERRORS

        @override
        function convert():String {
            match self {
                when UNRESOLVED:
                    return "UNRESOLVED"
                when IN_PROGRESS:
                    return "IN_PROGRESS"
                when RESOLVED:
                    return "RESOLVED"
                when RESOLVED_WITH_ERRORS:
                    return "RESOLVED_WITH_ERRORS"
            }
        }
    }

    class Error : Immutable {
        def file:File

        def position:Position

        def message:String

        init(file:File, position:Position, message:String) {
            self.file := file
            self.position := position
            self.message := message
        }
    }

    ================================================================================================
    Represents the expected type that an expression must resolve to.
    ================================================================================================
    choice TypeContext {
        ============================================================================================
        We have no information about the expected type, e.g. when evaluating the statement `foo()`.
        ============================================================================================
        UNSPECIFIED

        ============================================================================================
        We know the expression cannot result in void, e.g. when evaluating `foo()` in the statement
        `def x := foo()`.
        ============================================================================================
        NON_VOID

        ============================================================================================
        We know that the result has to be immutable, but not of any specific type, e.g. when
        evaluating `foo()` in the statement `const x := foo()`.
        ============================================================================================
        IMMUTABLE

        ============================================================================================
        We expect this specific type, e.g. when evaluating `foo()` in the statement
        `def x:String := foo()`.
        ============================================================================================
        TYPE(Type)

        function description():String {
            match self {
                when UNSPECIFIED:
                    return ""
                when NON_VOID:
                    return ""
                when IMMUTABLE:
                    return " with expected return type 'panda.core.Immutable'"
                when TYPE(type):
                    return " with expected return type '\{type}'"
            }
        }

        @override
        function convert():String {
            match self {
                when UNSPECIFIED:
                    return "UNSPECIFIED"
                when NON_VOID:
                    return "NON_VOID"
                when IMMUTABLE:
                    return "IMMUTABLE"
                when TYPE(type):
                    return "TYPE(\{type})"
            }
        }
    }

    choice EnclosingContext {
        LOOP(String? -* label *-, IR.Block.ID -* break target *-, IR.Block.ID -* continue target *-)
        SCOPE
        VARIABLE_SCOPE(Variable)

        @override
        function convert():String {
            match self {
                when LOOP(label, breakTarget, continueTarget):
                    if label !== null {
                        return "LOOP(\{label}, \{breakTarget}, \{continueTarget})"
                    }
                    return "LOOP(<null>, \{breakTarget}, \{continueTarget})"
                when SCOPE:
                    return "SCOPE"
                when VARIABLE_SCOPE(v):
                    return "VARIABLE_SCOPE(\{v})"
            }
        }
    }

    class AutoContext {
        def compiler:Compiler

        def context:EnclosingContext

        init(compiler:Compiler, context:EnclosingContext) {
            self.compiler := compiler
            self.context := context
            compiler.enclosingContexts.push(context)
        }

        @override
        method cleanup() {
            compiler.enclosingContexts.pop(context)
        }
    }

    class AutoScope {
        def compiler:Compiler

        def oldSymbolTable:SymbolTable

        def newSymbolTable:SymbolTable

        init(compiler:Compiler) {
            init(compiler, SymbolTable(compiler.symbolTable))
        }

        init(compiler:Compiler, symbolTable:SymbolTable) {
            self.compiler := compiler
            self.oldSymbolTable := compiler.symbolTable
            self.newSymbolTable := symbolTable
            compiler.symbolTable := symbolTable
            compiler.enclosingContexts.push(EnclosingContext.SCOPE)
        }

        @override
        method cleanup() {
            loop {
                def pop := compiler.enclosingContexts.pop()
                match pop {
                    when EnclosingContext.SCOPE:
                        break
                    when EnclosingContext.VARIABLE_SCOPE:
                        compiler.leaveScope(pop)
                    otherwise:
                        assert false
                }
            }
            assert compiler.symbolTable == newSymbolTable
            compiler.symbolTable := oldSymbolTable
        }
    }

    class AutoUnrefs {
        def compiler:Compiler

        def old:Array<IR.Value>?

        init(compiler:Compiler) {
            self.compiler := compiler
            self.old := compiler.statementUnrefs
            compiler.statementUnrefs := Array<IR.Value>()
        }

        @override
        method cleanup() {
            if !compiler.ir.currentBlockFinished() {
                for v in compiler.statementUnrefs {
                    compiler.compileUnref(v)
                }
            }
            compiler.statementUnrefs := old
        }
    }

    class AutoAtPreFlag {
        def compiler:Compiler

        init(compiler:Compiler) {
            self.compiler := compiler
            compiler.inAtPre := true
        }

        @override
        method cleanup() {
            assert compiler.inAtPre
            compiler.inAtPre := false
        }
    }

    class Settings : Immutable {
        def pandaHome:File

        def importDirs:ImmutableArray<File>

        def optimizationLevel:Int

        def safetyLevel:Int

        init(pandaHome:File, importDirs:ListView<File>, optimizationLevel:Int, safetyLevel:Int) {
            self.pandaHome := pandaHome
            self.importDirs := ImmutableArray<File>(importDirs)
            self.optimizationLevel := optimizationLevel
            self.safetyLevel := safetyLevel
        }
    }

    choice Capture {
        VARIABLE(Variable)
        FIELD(FieldDecl)
        SELF
    }

    constant POINTER_NAME := "panda.unsafe.Pointer"
    
    constant WEAK_NAME := "panda.core.Weak"
    
    constant RANGE_NAME := "panda.core.Range"
    
    constant STEPPED_RANGE_NAME := "panda.core.SteppedRange"
    
    constant SELF_NAME := "self"
    
    -- name of the field in which we store captured "self"
    constant CAPTURED_SELF_NAME := "$self"

    -- within closures, 'self' is normally interpreted as the captured $self object. $force_self is
    -- always a reference to the actual 'self' - in a closure, this will be the closure object
    -- itself.
    constant FORCE_SELF_NAME := "$force_self"
    
    constant NONNULLABLE_TO_NULLABLE_CAST_COST := 1
    
    constant NULLABLE_TO_NONNULLABLE_CAST_COST := 2

    def settings:Settings

    def parser:Parser

    def scanner:Scanner

    def root:SymbolTable

    var compiling:ClassDecl? := null

    var compilationQueue := Array<ClassDecl>()

    @private
    def scans := HashMap<File, ListView<ClassDecl>>()

    @private
    def classes := HashMap<String, ClassDecl>()

    @private
    def currentClass := Stack<ClassDecl>()

    @private
    def currentMethod := Stack<MethodDecl>()

    @private
    var ir := IR()

    @private
    var symbolTable:SymbolTable

    @private
    var methodSymbolTable:SymbolTable

    @private
    def codeGenerator:CodeGenerator

    @private
    var errorQueue:MessageQueue<Error>

    @private
    var enclosingContexts := Stack<EnclosingContext>()

    @private
    var errorCount := 0

    @private
    var closureCount := 0

    @private
    var existenceCache := HashMap<File, Bit>()

    @private
    var reportErrors := true

    @private
    def pendingClasses := Array<ClassDecl>()

    @private
    var inAtPre := false

    @private
    var statementUnrefs:Array<IR.Value>?

    @private
    var returnValue:IR.Value? := null -- FIXME shouldn't need := null, but getting precondition failure without it

    @private
    var atPreBlock:IR.Block.ID? := null

    -- MethodDecl is the method *containing* the closure, not the closure itself
    @private
    def captures := Stack<Pair<MethodDecl, Map<String, Capture>>>()

    @private
    var writeCode := true

    -- Sometimes we need to resolve an untyped lambda against several different types, such as when
    -- calling an overloaded method which can take different types of functions. If, say, the lambda
    -- only successfully resolves for one particular type of function, then we know the type of
    -- lambda we're dealing with. But if it fails for *all* of them, it could be that the lambda
    -- simply contains an error. So we keep track of all of the types we attempted to resolve a
    -- given lambda as for error reporting purposes.
    @private
    def lambdaTypes := IdentityMap<ASTNode, HashSet<Type>>()

    init(errorQueue:MessageQueue<Error>, codeGenerator:CodeGenerator, settings:Settings) {
        self.settings := settings
        self.scanner := Scanner(self)
        self.root := SymbolTable(self)
        self.parser := Parser(errorQueue)
        self.symbolTable := root
        self.codeGenerator := codeGenerator
        self.errorQueue := errorQueue
        codeGenerator.setCompiler(self)
        root.add(Type("builtin_bit", Type.Kind.BUILTIN_BIT, 1))
        root.add(Type.BuiltinInt8())
        root.add(Type.BuiltinInt16())
        root.add(Type.BuiltinInt32())
        root.add(Type.BuiltinInt64())
        root.add(Type.BuiltinUInt8())
        root.add(Type.BuiltinUInt16())
        root.add(Type.BuiltinUInt32())
        root.add(Type.BuiltinUInt64())
        root.add(Type.BuiltinFloat32())
        root.add(Type.BuiltinFloat64())
        root.add(Alias("Int", "panda.core.Int64", Position()))
        root.add(Alias("UInt", "panda.core.UInt64", Position()))
        root.add(Alias("Real", "panda.core.Real64", Position()))
        addAlias("panda.collections.Array")
        addAlias("panda.collections.Collection")
        addAlias("panda.collections.CollectionView")
        addAlias("panda.collections.CollectionWriter")
        addAlias("panda.collections.HashSet")
        addAlias("panda.collections.IdentityMap")
        addAlias("panda.collections.ImmutableArray")
        addAlias("panda.collections.ImmutableHashMap")
        addAlias("panda.collections.Iterable")
        addAlias("panda.collections.Iterator")
        addAlias("panda.collections.Key")
        addAlias("panda.collections.List")
        addAlias("panda.collections.ListView")
        addAlias("panda.collections.ListWriter")
        addAlias("panda.collections.HashMap")
        addAlias("panda.collections.Map")
        addAlias("panda.collections.MapView")
        addAlias("panda.collections.MapWriter")
        addAlias("panda.collections.SpecializedArray")
        addAlias("panda.collections.Stack")
        addAlias("panda.core.Class")
        addAlias("panda.core.Bit")
        addAlias("panda.core.Char8")
        addAlias("panda.core.Char16")
        addAlias("panda.core.Char32")
        addAlias("panda.core.Comparable")
        addAlias("panda.core.Equatable")
        addAlias("panda.core.Formattable")
        addAlias("panda.core.Int8")
        addAlias("panda.core.Int16")
        addAlias("panda.core.Int32")
        addAlias("panda.core.Int64")
        addAlias("panda.core.Immutable")
        addAlias("panda.core.Method")
        addAlias("panda.core.MutableString")
        addAlias("panda.core.Object")
        addAlias("panda.core.Panda")
        addAlias("panda.core.Range")
        addAlias("panda.core.Real32")
        addAlias("panda.core.Real64")
        addAlias("panda.core.RegularExpression")
        addAlias("panda.core.SimpleRange")
        addAlias("panda.core.SteppedRange")
        addAlias("panda.core.String")
        addAlias("panda.core.System")
        addAlias("panda.core.UInt8")
        addAlias("panda.core.UInt16")
        addAlias("panda.core.UInt32")
        addAlias("panda.core.UInt64")
        addAlias("panda.core.Value")
        addAlias("panda.core.Weak")
        addAlias("panda.math.MersenneTwister")
        addAlias("panda.math.Random")
        addAlias("panda.math.XorShift128Plus")
        addAlias("panda.io.Console")
        addAlias("panda.io.File")
        addAlias("panda.io.IndentedOutputStream")
        addAlias("panda.io.InputStream")
        addAlias("panda.io.LineNumberInputStream")
        addAlias("panda.io.MemoryInputStream")
        addAlias("panda.io.MemoryOutputStream")
        addAlias("panda.io.OutputStream")
        addAlias("panda.io.PushbackInputStream")
        addAlias("panda.threads.Lock")
        addAlias("panda.threads.MessageQueue")
        addAlias("panda.threads.Notifier")
        addAlias("panda.threads.ScopedLock")
        addAlias("panda.threads.Thread")
        addAlias("panda.json.JSON")
        addAlias("panda.json.JSONParser")
    }

    @private
    method addAlias(name:String) {
        root.add(Alias(name[name.next(name.lastIndexOf("."))..], name, Position()))
    }

    method isRefCounted(type:Type):Bit {
        if !type.isClass() {
            return false
        }
        return !isValue(type)
    }

    ================================================================================================
    Attempts to locate a class with the given, possibly not-fully-qualified, class name. Returns
    null and does not report any errors on failure.
    ================================================================================================
    @post(currentClass.count = @pre(currentClass.count) & errorCount = @pre(errorCount))
    method tryResolveClass(name:String):ClassDecl? {
        def current:ClassDecl?
        if currentClass.count > 0 {
            current := currentClass[0]
        }
        else {
            current := null
        }
        if current !== null {
            var result := current.classResolutionCache[name]
            if result !== null {
                return result.value
            }
            def alias := current.aliases[name]
            if alias !== null {
                result := ClassDecl.Resolution(getClass(alias))
                current.classResolutionCache[name] := result
                return result.value
            }
        }
        var result := getClass(name)
        if current !== null {
            if result == null {
                def idx := current.name.lastIndexOf(".")
                if idx !== null {
                    result := getClass(current.name[...idx] + name)
                }
            }
            if result == null {
                result := getClass(current.name + "." + name)
            }
            if result == null & current.owner !== null {
                currentClass.push(current.owner)
                result := tryResolveClass(name)
                currentClass.pop()
            }
        }
        if result == null {
            def rootAlias := root[name]
            if rootAlias !== null & rootAlias.kind = Symbol.Kind.ALIAS {
                result := getClass(rootAlias->Alias.fullName)
            }
        }
        if result == null {
            def index := name.lastIndexOf(".")
            if index !== null {
                -- could be an inner class name; see if we can locate an enclosing class
                def parent := tryResolveClass(name[..index])
                if parent !== null {
                    result := getClass(parent.name + name[index..])
                }
            }
        }
        if current !== null {
            current.classResolutionCache[name] := ClassDecl.Resolution(result)
        }
        return result
    }

    function typeParameters(type:Type):ListView<Type> {
        match type.typeKind {
            when Type.Kind.GENERIC_PARAMETER:
                return typeParameters(type.genericParameter.bound)
            when Type.Kind.GENERIC:
                assert type.subtypes.count >= 2
                return type.subtypes[1..]
            when Type.Kind.NULLABLE:
                return typeParameters(type.subtypes[0])
            otherwise:
                return Array<Type>()
        }
    }

    ================================================================================================
    Verifies that a type uses the correct number and kind of generic parameters for the class it
    refers to. Reports error(s) and returns false if the type is not valid.
    ================================================================================================
    method checkGenericParameters(position:Position, cl:ClassDecl, type:Type):Bit {
        if !resolve(cl) {
            assert errorCount > 0
            return false
        }
        assert type.resolved
        def expectedCount := cl.parameters.count
        def foundTypes := typeParameters(type)
        def foundCount := foundTypes.count
        if expectedCount != foundCount {
            error(position, "'\{cl.name}' expected \{expectedCount} generic " +
                    "argument\{expectedCount = 1:|s}, but found \{foundCount}")
            return false
        }
        def object := Type.Object()
        for i in 0 .. expectedCount {
            def bound := cl.parameters[i].bound
            if bound = object | (bound.typeKind = Type.Kind.NULLABLE & bound.subtypes[0] = object) {
                continue
            }
            if coercionCost(foundTypes[i], remapType(type, bound)) == null {
                error(position, "generic parameter '\{cl.name}.\{cl.parameters[i].name}' must be " +
                        "of type '\{cl.parameters[i].bound}', but found '\{foundTypes[i]}'")
                return false
            }
        }
        return true
    }

    @post(@return == null & (errorCount > 0 | !reportErrors) | (@return !== null & @return.resolved))
    method resolve(type:Type, checkParameters:Bit):Type? {
        if type.resolved {
            return type
        }
        match type.typeKind {
            when Type.Kind.CLASS:
                def resolved := tryResolveClass(type.name)
                if resolved !== null {
                    def result := resolved.type
                    if result !== null & checkParameters &
                            !checkGenericParameters(type.position, resolved, result) {
                        return null
                    }
                    return result
                }
                def s := symbolTable[type.name]
                if s !== null {
                    match s.kind {
                        when Symbol.Kind.ALIAS:
                            return Type(s->Alias.fullName, Type.Kind.CLASS, type.position, true)
                        when Symbol.Kind.GENERIC_PARAMETER:
                            def gp := s->ClassDecl.GenericParameter
                            return Type(gp)
                        when Symbol.Kind.TYPE:
                            return s->Type
                    }
                }
                error(type.position, "unknown type '\{type}'")
                return null
            when Type.Kind.NULLABLE:
                assert type.subtypes.count = 1
                def subtypes := Array<Type>()
                def sub := resolve(type.subtypes[0])
                if sub == null {
                    return null
                }
                subtypes.add(sub)
                return Type(subtypes[0].name + "?", Type.Kind.NULLABLE, type.position, subtypes, true)
            when Type.Kind.GENERIC:
                assert type.subtypes.count >= 2
                def base := resolve(type.subtypes[0], false)
                if base == null {
                    return null
                }
                def args := Array<Type>()
                for i in 1 .. type.subtypes.count {
                    def resolved := resolve(type.subtypes[i])
                    if resolved == null {
                        return null
                    }
                    args.add(resolved)
                }
                def result := Type.generic(base, args)
                def cl := getClass(result.subtypes[0])
                if cl !== null & checkParameters &
                        !checkGenericParameters(type.position, cl, result) {
                    return null
                }
                return result
            when Type.Kind.METHOD, Type.Kind.FUNCTION, Type.Kind.IMMUTABLE_METHOD,
                    Type.Kind.IMMUTABLE_FUNCTION:
                def params := Array<Type>()
                for i in 0 .. type.parameterCount {
                    def resolved := resolve(type.parameterType(i))
                    if resolved == null {
                        return null
                    }
                    params.add(resolved)
                }
                def returnType := resolve(type.returnType())
                if returnType == null {
                    return null
                }
                return Type.methodType(type.position, type.typeKind, params, returnType, 0)
            otherwise:
                assert false, "cannot resolve \{type}"
        }
    }

    method resolve(type:Type):Type? {
        return resolve(type, true)
    }

    method addAllSupertypes(cl:ClassDecl, set:HashSet<String>) {
        if set.contains(cl.name) {
            return
        }
        set.add(cl.name)
        resolve(cl)
        if cl.rawSuper !== null {
            def superclass := getClass(cl.rawSuper)
            if superclass !== null {
                addAllSupertypes(superclass, set)
            }
        }
        for intfType in cl.rawInterfaces {
            def intf := getClass(intfType)
            if intf !== null {
                addAllSupertypes(intf, set)
            }
        }
    }

    @pre(cl.classKind = ClassDecl.Kind.CHOICE)
    method createChoiceEqualsIfNeeded(cl:ClassDecl) {
        def equatable := getClass("panda.core.Equatable")
        assert equatable !== null
        for cc in cl.choiceCases {
            assert cc.resolved != Resolution.UNRESOLVED
            if cc.resolved != Resolution.RESOLVED {
                return
            }
            for f in cc.fields {
                if findType(f, equatable) == null {
                    return
                }
            }
        }
        -- every field of every choice is equatable, make the choice equatable
        def args := Array<Type>() -- FIXME literal
        args.add(cl.type)
        cl.declaredSupers.add(Type.generic(equatable.type, args))
        def parameters := Array<MethodDecl.Parameter>()
        parameters.add(MethodDecl.Parameter("other", cl.type))
        def p := cl.position
        def body := Array<ASTNode>()
        def returnBlock := Array<ASTNode>() -- FIXME literal
        returnBlock.add(ASTNode.RETURN(p, ASTNode.BIT(p, false)))
        body.add(ASTNode.IF(p, ASTNode.BINARY(p, ASTNode.DOT(p, ASTNode.SELF(p), "$rawValue"),
                Token.Kind.NEQ, ASTNode.DOT(p, ASTNode.IDENTIFIER(p, "other"), "$rawValue")),
                returnBlock.finish(), null))
        body.add(ASTNode.RETURN(p, ASTNode.BIT(p, true)))
        def eq := MethodDecl(cl, p, null, Annotations(Annotations.Flag.OVERRIDE),
                MethodDecl.Kind.FUNCTION, "=", null, parameters, Type.Bit(), body.finish())
        cl.methods.add(eq)
    }

    @post(currentClass.count = @pre(currentClass.count) &
            (@return | errorCount > 0 | !reportErrors))
    method resolve(cl:ClassDecl):Bit {
        if cl.resolved = Resolution.UNRESOLVED {
            cl.resolved := Resolution.IN_PROGRESS
            currentClass.push(cl)
            def auto := AutoScope(self, cl.symbolTable)
            for p in cl.parameters {
                def resolved := resolve(p.bound, false)
                if resolved !== null {
                    p.bound := resolved
                }
                else {
                    cl.resolved := Resolution.RESOLVED_WITH_ERRORS
                    currentClass.pop(cl)
                    return false
                }
            }
            for cc in cl.choiceCases {
                resolve(cc)
            }
            if cl.classKind = ClassDecl.Kind.CHOICE {
                createChoiceEqualsIfNeeded(cl)
            }
            def supertypes := HashSet<String>()
            for rawS in cl.declaredSupers {
                def resolvedType := resolve(rawS, false)
                if resolvedType == null {
                    cl.resolved := Resolution.RESOLVED_WITH_ERRORS
                    currentClass.pop(cl)
                    return false
                }
                def s := resolve(resolvedType, false)
                if s !== null {
                    def sClass := getClass(s)
                    if sClass !== null {
                        resolve(sClass)
                        addAllSupertypes(sClass, supertypes)
                        if sClass.classKind = ClassDecl.Kind.CLASS {
                            if cl.classKind = ClassDecl.Kind.INTERFACE {
                                error(s.position, "interface '\{cl.name}' cannot extend class " +
                                        "'\{s.name}'")
                            }
                            if cl.rawSuper == null {
                                cl.rawSuper := s
                                if cl.rawInterfaces.count > 0 {
                                    error(s.position, "superclass '\{s}' of class '\{cl.name}' must be " +
                                            "listed before any superinterfaces")
                                }
                            }
                            else {
                                error(s.position, "class '\{cl.name}' has more than one superclass")
                            }
                        }
                        else {
                            assert sClass.classKind = ClassDecl.Kind.INTERFACE
                            cl.rawInterfaces.add(s)
                        }
                    }
                    else {
                        cl.resolved := Resolution.RESOLVED_WITH_ERRORS
                        currentClass.pop(cl)
                        return false
                    }
                }
                else {
                    cl.resolved := Resolution.RESOLVED_WITH_ERRORS
                    currentClass.pop(cl)
                    return false
                }
            }
            if cl.rawSuper == null & cl.name != "panda.core.Object" {
                cl.rawSuper := Type.Object()
            }
            if cl.rawSuper !== null & !cl.annotations.isFinal() &
                    cl.rawSuper.name = "panda.core.Value" {
                cl.annotations.flags ||= Annotations.Flag.FINAL
                for m in cl.methods {
                    m.annotations.flags ||= Annotations.Flag.FINAL
                    if scanner.shouldInline(m.annotations, m.body) {
                        m.annotations.flags ||= Annotations.Flag.INLINE
                    }
                }
            }
            if supertypes.contains(cl.name) {
                error(cl.position, "circular inheritance; '\{cl.name}' inherits from itself")
                cl.resolved := Resolution.RESOLVED_WITH_ERRORS
            }
            if cl.resolved = Resolution.IN_PROGRESS {
                cl.resolved := Resolution.RESOLVED
            }
            if cl.rawSuper !== null {
                def superclass := getClass(cl.rawSuper)
                if superclass !== null {
                    checkGenericParameters(cl.position, superclass, cl.rawSuper)
                }
            }
            for intf in cl.rawInterfaces {
                def intfclass := getClass(intf)
                if intfclass !== null {
                    checkGenericParameters(cl.position, intfclass, intf)
                }
            }
            for p in cl.parameters {
                def cl := getClass(p.bound)
                if cl !== null {
                    checkGenericParameters(cl.position, cl, p.bound)
                }
            }
            currentClass.pop()
        }
        return cl.resolved != Resolution.RESOLVED_WITH_ERRORS
    }

    @post(currentClass.count = @pre(currentClass.count))
    method resolve(m:MethodDecl):Bit {
        if m.resolved != Resolution.UNRESOLVED {
            return m.resolved = Resolution.RESOLVED
        }
        m.resolved := Resolution.IN_PROGRESS
        resolve(m.owner)
        currentClass.push(m.owner)
        def symbols := AutoScope(self, SymbolTable(m.owner.symbolTable))
        if m.genericParameters !== null {
            for p in m.genericParameters {
                symbolTable.add(Type(p), p.name)
            }
        }
        for p in m.parameters {
            def resolved := resolve(p.type)
            if resolved !== null {
                p.type := resolved
            }
            else {
                m.resolved := Resolution.RESOLVED_WITH_ERRORS
            }
        }
        if m.methodKind = MethodDecl.Kind.INIT {
            if isValue(m.owner) {
                m.returnType := m.owner.type
            }
        }
        else {
            def resolved := resolve(m.returnType)
            if resolved !== null {
                m.returnType := resolved
            }
            else {
                m.resolved := Resolution.RESOLVED_WITH_ERRORS
            }
        }
        if m.resolved = Resolution.IN_PROGRESS {
            m.resolved := Resolution.RESOLVED
        }
        if !m.owner.external {
            def overridden := getOverriddenMethod(m)
            if overridden !== null {
                if !m.annotations.isOverride() {
                    error(m.position, "\{m.declaration()} overrides \{overridden.declaration()}, " +
                            "but is not marked @override")
                }
                if m.methodKind = MethodDecl.Kind.METHOD &
                        overridden.methodKind = MethodDecl.Kind.FUNCTION {
                    error(m.position, "\{m.declaration()} overrides \{overridden.declaration()}, " +
                            "but methods cannot override functions")
                }
            }
            else if m.annotations.isOverride() {
                error(m.position, "\{m.declaration()} is marked @override, but no matching " +
                        "method exists among its ancestors")
            }
        }
        currentClass.pop()
        return m.resolved = Resolution.RESOLVED
    }

    @post(f.type != Type.Void() & f.type.resolved | errorCount > 0 | !reportErrors)
    method determineRawType(f:FieldDecl) {
        currentClass.push(f.owner)
        def auto := AutoScope(self, getSymbolTable(f.owner))
        if f.type != Type.Void() {
            def resolved := resolve(f.type)
            if resolved !== null {
                f.type := resolved
            }
            else {
                assert errorCount > 0
            }
            currentClass.pop()
            return
        }
        if f.rawValue == null {
            error(f.position, "field has neither a type nor a value")
            currentClass.pop()
            return
        }
        def preferred := preferredType(f.rawValue)
        if preferred == null {
            -- report error
            def unrefs := AutoUnrefs(self)
            if compileExpression(f.rawValue) !== null {
                error(f.position, "type of field '\{f.name}' was not specified and could not be " +
                        "determined")
            }
            currentClass.pop()
            return
        }
        f.type := preferred
        currentClass.pop()
    }

    @post(@return | errorCount > 0 | !reportErrors)
    method resolve(f:FieldDecl):Bit {
        if f.resolved = Resolution.UNRESOLVED {
            f.resolved := Resolution.IN_PROGRESS
            if f.owner.classKind != ClassDecl.Kind.INTERFACE {
                -- we need to mark that we are in an instance context so 'self' works. Since the
                -- class is guaranteed to have at least one init method, we just pretend we're in
                -- one of those.
                def firstInit:MethodDecl? := null
                for m in f.owner.methods {
                    if m.methodKind = MethodDecl.Kind.INIT {
                        firstInit := m
                        break
                    }
                }
                assert firstInit !== null | errorCount > 0,
                        "class \{f.owner.name} has no init methods"
                if firstInit == null {
                    f.resolved := Resolution.RESOLVED_WITH_ERRORS
                    return false
                }
                currentMethod.push(firstInit)
                determineRawType(f)
                currentMethod.pop(firstInit)
            }
            else {
                def old := currentMethod
                currentMethod := Stack<MethodDecl>()
                determineRawType(f)
                currentMethod := old
            }
            if f.type != Type.Void() & f.type.resolved {
                f.resolved := Resolution.RESOLVED
            }
            else {
                f.resolved := Resolution.RESOLVED_WITH_ERRORS
            }
            if f.annotations.isWeak() & f.type != Type.Void() {
                f.type := Type.WeakOf(f.type)
            }
        }
        return f.resolved = Resolution.RESOLVED
    }

    @post(currentClass.count = @pre(currentClass.count))
    method resolve(c:ChoiceCase) {
        if c.resolved != Resolution.UNRESOLVED {
            return
        }
        if c.fields.count = 0 {
            c.resolved := Resolution.RESOLVED
            createChoiceCaseInit(c)
            return
        }
        c.resolved := Resolution.IN_PROGRESS
        currentClass.push(c.owner)
        def auto := AutoScope(self, c.owner.symbolTable)
        for i in 0 .. c.fields.count {
            def resolved := resolve(c.fields[i])
            if resolved !== null {
                c.fields[i] := resolved
            }
            else {
                c.fields[i] := Type.Invalid()
                c.resolved := Resolution.RESOLVED_WITH_ERRORS
            }
        }
        if c.resolved = Resolution.IN_PROGRESS {
            c.resolved := Resolution.RESOLVED
        }
        createChoiceCaseInit(c)
        currentClass.pop()
    }

    method isValue(cl:ClassDecl?):Bit {
        if !resolve(cl) {
            return false
        }
        return cl.rawSuper !== null & cl.rawSuper.name = "panda.core.Value"
    }

    method isValue(t:Type):Bit {
        if !t.isClass() {
            return true
        }
        def cl := getClass(t)
        if cl == null {
            return false
        }
        return isValue(cl)
    }

    method isImmutable(cl:ClassDecl):Bit {
        if !resolve(cl) {
            return false
        }
        if cl.name = "panda.core.Immutable" {
            return true
        }
        if cl.rawSuper !== null {
            def superclass := getClass(cl.rawSuper)
            if superclass == null {
                return false
            }
            return isImmutable(superclass)
        }
        return false
    }

    method isImmutable(t:Type):Bit {
        if !t.isClass() {
            return true
        }
        def cl := getClass(t)
        if cl == null {
            return false
        }
        return isImmutable(cl)
    }

    method instanceFields(cl:ClassDecl):ListView<FieldDecl> {
        def result := Array<FieldDecl>()
        if resolve(cl) {
            if !isValue(cl) & cl.rawSuper !== null {
                def s := getClass(cl.rawSuper)
                if s !== null {
                    result.addAll(instanceFields(s))
                }
            }
            for f in cl.fields {
                if !f.annotations.isClass() & f.fieldKind != FieldDecl.Kind.PROPERTY {
                    result.add(f)
                }
            }
        }
        return result
    }

    method exists(f:File):Bit {
        var result := existenceCache[f]
        if result == null {
            result := f.exists()
            existenceCache[f] := result
        }
        return result
    }

    ================================================================================================
    Attempts to load the class with the given fully-qualified name. Returns null on failure, without
    reporting an error.
    ================================================================================================
    method getClass(fullName:String):ClassDecl? {
        var result := classes[fullName]
        if result == null {
            def suffix := fullName.replace(".", "/") + ".panda"
            var found := false
            for dir in settings.importDirs {
                def f := dir.resolve(suffix)
                if exists(f) {
                    found := true
                    scan(f)
                    result := classes[fullName]
                }
            }
        }
        if result == null {
            def index := fullName.lastIndexOf(".")
            if index !== null {
                def parent := getClass(fullName[..index])
                if parent !== null {
                    result := classes[fullName]
                }
            }
        }
        return result
    }

    method getClass(position:Position, fullName:String):ClassDecl? {
        var result := classes[fullName]
        if result == null {
            def suffix := fullName.replace(".", "/") + ".panda"
            var found := false
            for dir in settings.importDirs {
                def f := dir.resolve(suffix)
                if exists(f) {
                    found := true
                    def oldErrorCount := errorCount
                    scan(f)
                    result := classes[fullName]
                    if result == null & errorCount = oldErrorCount {
                        error(f, Position(1, 1),
                                "expected file '\{f}' to contain a class named '\{fullName}'")
                    }
                }
            }
            if !found {
                error(position, "no file named \{suffix} in any import path (\{settings.importDirs})")
            }
        }
        return result
    }

    @post(currentClass.count = @pre(currentClass.count))
    method specialize(cl:ClassDecl, rawType:Type):ClassDecl {
        if !resolve(cl) {
            return cl
        }
        def type := resolve(rawType)
        if type.typeKind = Type.Kind.NULLABLE {
            return specialize(cl, type.subtypes[0])
        }
        if type.typeKind = Type.Kind.CLASS {
            return cl
        }
        assert type.typeKind = Type.Kind.GENERIC
        def result:ClassDecl? := classes[type.name]
        if result == null {
            currentClass.push(cl)
            def annotations := Annotations(cl.annotations.flags && !!Annotations.Flag.SPECIALIZE)
            def supertypes := Array<Type>()
            supertypes.add(remapType(type, cl.rawSuper))
            for intf in cl.rawInterfaces { -- FIXME use map
                supertypes.add(remapType(type, intf))
            }
            def aliases := HashMap<String, String>(cl.aliases)
            for i in 0 .. cl.parameters.count {
                aliases[cl.parameters[i].name] := type.subtypes[i + 1].name
            }
            result := ClassDecl(cl.source, cl.position, aliases, cl.doccomment, annotations,
                    cl.classKind, type, supertypes, Array<ClassDecl.GenericParameter>(),
                    cl.symbolTable.parents[0])
            result.external := false
            for m in cl.methods {
                resolve(m)
                def generics:Array<ClassDecl.GenericParameter>?
                if m.genericParameters !== null {
                    for p in m.genericParameters {
                        generics.add(ClassDecl.GenericParameter(p.position, p.owner, p.name,
                                remapType(type, p.bound)))
                    }
                }
                def parameters := Array<MethodDecl.Parameter>() -- FIXME use map
                for p in m.parameters {
                    parameters.add(MethodDecl.Parameter(p.name, remapType(type, p.type)))
                }
                def clone := MethodDecl(result, m.position, m.doccomment, m.annotations,
                        m.methodKind, m.name, generics, parameters, remapType(type, m.returnType),
                        m.body)
                result.methods.add(clone)
                result.symbolTable.add(clone)
            }
            for f in cl.fields {
                resolve(f)
                def clone := FieldDecl(result, f.position, f.doccomment, f.annotations, f.fieldKind,
                        f.name, remapType(type, f.type), f.rawValue)
                result.fields.add(clone)
                result.symbolTable.add(clone)
            }
            classes[result.name] := result
            compilationQueue.add(result)
            currentClass.pop()
            resolve(result)
        }
        return result
    }

    @pre(type.resolved)
    method getClass(type:Type):ClassDecl? {
        var result:ClassDecl
        match type.typeKind {
            when Type.Kind.CLASS:
                result := getClass(type.position, type.name)
            when Type.Kind.GENERIC:
                if type.subtypes[0] = Type.Class() {
                    return getClass(type.subtypes[1])
                }
                result := getClass(type.subtypes[0])
            when Type.Kind.NULLABLE:
                result := getClass(type.subtypes[0])
            when Type.Kind.GENERIC_PARAMETER:
                assert type.genericParameter !== null
                return getClass(type.genericParameter.bound)
            when Type.Kind.METHOD, Type.Kind.FUNCTION:
                return getClass(Type.MutableMethod())
            when Type.Kind.IMMUTABLE_METHOD, Type.Kind.IMMUTABLE_FUNCTION:
                return getClass(Type.Method())
            otherwise:
                error(type.position, "type '\{type}' is not a class")
                return null
        }
        if result !== null & result.annotations.isSpecialize() {
            result := specialize(result, type)
        }
        return result
    }

    method allInterfaces(t:Type):HashSet<Type> {
        def result := HashSet<Type>()
        def cl := getClass(t)
        if cl !== null & resolve(cl) {
            if cl.resolved = Resolution.RESOLVED {
                if cl.rawSuper !== null {
                    result.addAll(allInterfaces(remapType(t, cl.rawSuper)))
                }
                for intf in cl.rawInterfaces {
                    result.addAll(allInterfaces(remapType(t, intf)))
                }
                if cl.classKind = ClassDecl.Kind.INTERFACE {
                    result.add(t)
                }
            }
        }
        return result
    }

    function signatureMatch(t1:Type, t2:Type):Bit {
        assert t1.isMethod()
        assert t2.isMethod()
        if t1.subtypes.count != t2.subtypes.count {
            return false
        }
        for i in 0 .. t1.subtypes.count {
            if t1.subtypes[i] != t2.subtypes[i] {
                return false
            }
        }
        return true
    }

    method findMethod(owner:Type, name:String, methodType:Type, checkInterfaces:Bit):MethodDecl? {
        def cl := getClass(owner)
        if cl == null {
            return null
        }
        if !resolve(cl) {
            return null
        }
        for test in cl.methods {
            if test.name = name {
                resolve(test)
                if signatureMatch(remapType(owner, declaredType(test)), methodType) {
                    return test
                }
            }
        }
        for raw in cl.rawInterfaces {
            def result := findMethod(remapType(owner, raw), name, methodType, checkInterfaces)
            if result !== null & (checkInterfaces | cl.classKind = ClassDecl.Kind.INTERFACE |
                    result.body !== null) {
                return result
            }
        }
        if cl.rawSuper !== null {
            return findMethod(remapType(owner, cl.rawSuper), name, methodType, checkInterfaces)
        }
        return null
    }

    function getOverriddenMethod(m:MethodDecl):MethodDecl? {
        if m.overrideKnown {
            return m.overridden
        }
        if m.methodKind = MethodDecl.Kind.INIT {
            m.overrideKnown := true
            return null
        }
        resolve(m)
        def methodType := declaredType(m)
        def owner := m.owner.typeWithParameters()
        for raw in m.owner.rawInterfaces {
            def result := findMethod(remapType(owner, raw), m.name, methodType, true)
            if result !== null {
                m.overrideKnown := true
                m.overridden := result
                return result
            }
        }
        resolve(m.owner)
        if m.owner.rawSuper !== null {
            def result := findMethod(remapType(owner, m.owner.rawSuper), m.name, methodType, true)
            m.overrideKnown := true
            m.overridden := result
            return result
        }
        m.overrideKnown := true
        return null
    }

    method interfaceMethods(cl:ClassDecl, intf:Type):ListView<MethodDecl> {
        def intfClass := getClass(intf)
        assert intfClass !== null
        def result := Array<MethodDecl>()
        for m in intfClass.methods {
            if m.annotations.isClass() {
                continue
            }
            def found := findMethod(cl.type, m.name, remapType(intf, inheritedType(m)), false)
            if found !== null {
                result.add(found)
            }
            else if m.body !== null {
                result.add(m)
            }
            else {
                error(cl.position, "class '\{cl.name}' does not implement interface " +
                        m.declaration())
            }
        }
        return result
    }

    method checkInterfaceMethods() {
        def cl := currentClass[0]
        for intf in allInterfaces(cl.type) {
            interfaceMethods(cl, intf)
        }
    }

    method getSymbolTable(cl:ClassDecl):SymbolTable {
        if !cl.symbolTableResolved {
            cl.symbolTableResolved := true
            if resolve(cl) {
                if cl.rawSuper !== null {
                    def superCl := getClass(cl.rawSuper)
                    if superCl !== null {
                        cl.symbolTable.parents.add(getSymbolTable(superCl))
                    }
                }
                for rawIntf in cl.rawInterfaces {
                    def intf := getClass(rawIntf)
                    if intf !== null {
                        cl.symbolTable.parents.add(getSymbolTable(intf))
                    }
                }
                if cl.owner !== null {
                    --cl.symbolTable.parents.add(getSymbolTable(cl.owner))
                }
            }
        }
        return cl.symbolTable
    }

    @post(currentClass.count = @pre(currentClass.count))
    method getVTable(cl:ClassDecl):ListView<MethodDecl> {
        if cl.virtualMethods.count = 0 {
            resolve(cl)
            currentClass.push(cl) -- FIXME Auto
            if cl.rawSuper !== null {
                def superCl := getClass(cl.rawSuper)
                if superCl == null {
                    currentClass.pop()
                    return cl.virtualMethods
                }
                cl.virtualMethods.addAll(getVTable(superCl))
            }
            for derived in cl.methods {
                resolve(derived)
                if derived.methodKind = MethodDecl.Kind.INIT | derived.annotations.isClass() {
                    continue
                }
                var found := false
                for i in 0 .. cl.virtualMethods.count {
                    def base := cl.virtualMethods[i]
                    resolve(base)
                    def overridden := getOverriddenMethod(derived)
                    if overridden !== null & (overridden == base |
                                overridden == getOverriddenMethod(base)) {
                        found := true
                        cl.virtualMethods[i] := derived
                        break
                    }
                }
                if !found {
                    cl.virtualMethods.add(derived)
                }
            }
            currentClass.pop()
        }
        return cl.virtualMethods
    }

    function remapType(context:Type, raw:Type):Type {
        if context.typeKind = Type.Kind.GENERIC & context.subtypes[0] = Type.Class() {
            return remapType(context.subtypes[1], raw)
        }
        match raw.typeKind {
            when Type.Kind.CLASS, Type.Kind.BUILTIN_INT, Type.Kind.BUILTIN_UINT,
                    Type.Kind.BUILTIN_BIT:
                return raw
        }
        match context.typeKind {
            when Type.Kind.NULLABLE:
                assert context.subtypes.count = 1
                return remapType(context.subtypes[0], raw)
            when Type.Kind.GENERIC:
                assert context.subtypes.count >= 2
                def typeMap := HashMap<String, Type>()
                def base := context.subtypes[0]
                def cl := tryResolveClass(base.name)
                assert cl !== null
                for i in 1 .. context.subtypes.count {
                    typeMap[cl.name + "." + cl.parameters[i - 1].name] := context.subtypes[i]
                }
                return raw.remap(typeMap)
            otherwise:
                return raw
        }
    }

    function preferredType(type:Type):Type {
        if type.typeKind = Type.Kind.INT_LITERAL {
            return Type.Int64()
        }
        if type.typeKind = Type.Kind.REAL_LITERAL {
            return Type.Real64()
        }
        if type = Type.BitLiteral() {
            return Type.Bit()
        }
        if type.typeKind = Type.Kind.NULL {
            return Type.Any()
        }
        return type
    }

    method preferredType(expr:ASTNode):Type? {
        match expr {
            when ASTNode.BIT:
                return Type.Bit()
            when ASTNode.INT:
                return Type.Int64()
            when ASTNode.PREFIX(_, op, base):
                def baseType := preferredType(base)
                if baseType !== null {
                    def p := expr.position()
                     -- fake target, just used for matching
                    def target := IR.Value.REF(IR.Statement.ID(-1), baseType)
                    return preferredType(ASTNode.CALL(p,
                            ASTNode.DOT(p, ASTNode.IR_WRAPPER(p, target), operatorName(op)),
                            ImmutableArray<ASTNode>()))
                }
            when ASTNode.REAL:
                return Type.Real64()
            when ASTNode.STRING:
                return Type.StringType()
        }
        def possible := possibleTypes(expr)
        if possible == null {
            return null
        }
        if possible.count = 1 {
            return possible.iterator().next()
        }
        def best := Array<Type>()
        def bestCost := Int.MAX
        var foundInt := false
        for t in possible {
            if t = Type.Int64() {
                foundInt := true
            }
            def cost := coercionCost(expr, t)
            assert cost !== null
            if cost < bestCost {
                bestCost := cost
                best.clear()
            }
            if cost = bestCost {
                best.add(t)
            }
        }
        assert best.count != 0
        if best.count = 1 {
            return best[0]
        }
        if foundInt {
            return Type.Int64()
        }
        return null
    }

    method coercionCost(type:Type, target:Type):Int? {
        assert type.resolved, "unresolved type '\{type}'"
        assert target.resolved, "unresolved type '\{target}'"
        if type = target {
            return 0
        }
        if type = Type.Void() {
            return null
        }
        if type.typeKind = Type.Kind.NULL {
            if target.typeKind = Type.Kind.NULLABLE {
                return 0
            }
            return null
        }
        if type.typeKind = Type.Kind.NULLABLE & target.typeKind != Type.Kind.NULLABLE {
            def result := coercionCost(type.subtypes[0], target)
            if result == null {
                return null
            }
            return result + NULLABLE_TO_NONNULLABLE_CAST_COST
        }
        match target.typeKind {
            when Type.Kind.NULLABLE:
                def result := coercionCost(type, target.subtypes[0])
                if result == null {
                    return null
                }
                return result + NONNULLABLE_TO_NULLABLE_CAST_COST
            when Type.Kind.GENERIC_PARAMETER:
                return null
            when Type.Kind.CLASS:
                if type.typeKind = Type.Kind.GENERIC {
                    return coercionCost(type.subtypes[0], target)
                }
        }
        if type.isMethod() {
            if target.isMethod() {
                if type.subtypes.count != target.subtypes.count {
                    return null
                }
                var total := 0
                def srcFunction:Bit
                def srcMutable:Bit
                match type.typeKind {
                    when Type.Kind.METHOD:
                        srcFunction := false
                        srcMutable := true
                    when Type.Kind.FUNCTION:
                        srcFunction := true
                        srcMutable := true
                    when Type.Kind.IMMUTABLE_METHOD:
                        srcFunction := false
                        srcMutable := false
                    when Type.Kind.IMMUTABLE_FUNCTION:
                        srcFunction := true
                        srcMutable := false
                }
                def targetFunction:Bit
                def targetMutable:Bit
                match target.typeKind {
                    when Type.Kind.METHOD:
                        targetFunction := false
                        targetMutable := true
                    when Type.Kind.FUNCTION:
                        targetFunction := true
                        targetMutable := true
                    when Type.Kind.IMMUTABLE_METHOD:
                        targetFunction := false
                        targetMutable := false
                    when Type.Kind.IMMUTABLE_FUNCTION:
                        targetFunction := true
                        targetMutable := false
                }
                if targetFunction & !srcFunction {
                    return null
                }
                if !targetMutable & srcMutable {
                    return null
                }
                if targetFunction != srcFunction {
                    total += 1
                }
                if targetMutable != srcMutable {
                    total += 1
                }
                for i in 0 .. type.subtypes.count {
                    def cost := coercionCost(type.subtypes[i], target.subtypes[i])
                    if cost == null {
                        return null
                    }
                    total += cost
                }
                return total
            }
            if type.typeKind = Type.Kind.IMMUTABLE_METHOD |
                    type.typeKind = Type.Kind.IMMUTABLE_FUNCTION {
                def result := coercionCost(Type.Method(), target)
                if result !== null {
                    return result
                }
            }
            return coercionCost(Type.MutableMethod(), target)
        }
        match type.typeKind {
            when Type.Kind.BUILTIN_BIT:
                return coercionCost(Type.Bit(), target)
            when Type.Kind.UNRESOLVED:
                var best:Int? := null
                for t in type.subtypes {
                    def cost := coercionCost(t, target)
                    if cost !== null & (best == null | cost < best) {
                        best := cost
                    }
                }
                return best
            when Type.Kind.GENERIC_PARAMETER:
                return coercionCost(type.genericParameter.bound, target)
        }
        if !target.isClass() {
            return null
        }
        def targetCl := getClass(target)
        for m in targetCl.methods {
            if m.annotations.isImplicit() & m.parameters.count = 1 {
                resolve(m)
                if type = m.parameters[0].type {
                    return 6 - m.priority
                }
            }
        }
        if !type.isClass() {
            return null
        }
        def cl := getClass(type)
        if cl == null {
            return null
        }
        resolve(cl)
        if cl.resolved != Resolution.RESOLVED_WITH_ERRORS {
            if cl.rawSuper !== null {
                var cost := coercionCost(remapType(type, remapType(type, cl.rawSuper)), target)
                if cost !== null {
                    return cost + 1
                }
            }
            for intf in cl.rawInterfaces {
                var cost := coercionCost(remapType(type, remapType(type, intf)), target)
                if cost !== null {
                    return cost + 1
                }
            }
        }
        return null
    }

    method coercionCost(type:Type, target:TypeContext):Int? {
        match target {
            when TypeContext.UNSPECIFIED:
                return 0
            when TypeContext.NON_VOID:
                if type = Type.Void() {
                    return null
                }
                return 0
            when TypeContext.IMMUTABLE:
                if isImmutable(type) {
                    return 0
                }
                return null
            when TypeContext.TYPE(t):
                return coercionCost(type, t)
        }
    }

    method coercionCost(types:CollectionView<Type>, target:Type):Int? {
        def best := Int.MAX
        for t in types {
            def cost := coercionCost(t, target)
            if cost !== null & cost < best {
                best := cost
            }
        }
        if best != Int.MAX {
            return best
        }
        return null
    }

    method possibleMatches(methodTypes:CollectionView<Type>, args:ListView<ASTNode>,
            type:TypeContext):Pair<CollectionView<Type>, Int>? {
        var bestCost := Int.MAX
        def best := Array<Type>()
        outer: for raw in methodTypes {
            def m := raw.nonnullable()
            if m.typeKind != Type.Kind.METHOD &
                    m.typeKind != Type.Kind.FUNCTION &
                    m.typeKind != Type.Kind.IMMUTABLE_METHOD &
                    m.typeKind != Type.Kind.IMMUTABLE_FUNCTION {
                continue
            }
            if m.subtypes.count != args.count + 1 {
                continue
            }
            var cost := -m.priority
            for i in 0 .. args.count {
                def argCost := coercionCost(args[i], m.subtypes[i])
                if argCost == null {
                    continue outer
                }
                cost += argCost
            }
            def returnType := m.returnType()
            match type {
                when TypeContext.IMMUTABLE:
                    if returnType = Type.Void() | !isImmutable(returnType) {
                        continue
                    }
                when TypeContext.TYPE(t):
                    def returnCost := coercionCost(returnType, t)
                    if returnCost == null {
                        continue
                    }
                    cost += returnCost
                when TypeContext.NON_VOID:
                    if returnType = Type.Void() {
                        continue
                    }
            }
            if cost < bestCost {
                bestCost := cost
                best.clear()
            }
            if cost = bestCost {
                best.add(m)
            }
        }
        if best.count = 0 {
            return null
        }
        return Pair<CollectionView<Type>, Int>(best, bestCost)
    }

    method callCost(methodTypes:CollectionView<Type>, args:ListView<ASTNode>,
            type:TypeContext):Int? {
        def result := possibleMatches(methodTypes, args, type)
        if result !== null {
            -- we still might not actually be able to successfully perform the coercion, in the
            -- event that it's ambiguous, but for error reporting purposes we act like it's going to
            -- be ok right now
            return result.second
        }
        return null
    }

    function symbolType(target:Type?, s:Symbol):ListView<Type>? {
        def result := Array<Type>()
        match s.kind {
            when Symbol.Kind.ALIAS:
                def cl := getClass(s->Alias.fullName)
                if cl == null {
                    return null
                }
                result.add(Type.ClassLiteral(cl.type))
            when Symbol.Kind.CHOICE_CASE:
                def cc := s->ChoiceCase
                if cc.fields.count > 0 {
                    result.add(Type.methodType(s.position, Type.Kind.IMMUTABLE_FUNCTION, cc.fields,
                            cc.owner.type, 0))
                }
                else {
                    result.add(cc.owner.type)
                }
            when Symbol.Kind.FIELD:
                def f := s->FieldDecl
                if resolve(f) {
                    def type:Type
                    if f.annotations.isWeak() {
                        type := f.type.subtypes[1]
                    }
                    else {
                        type := f.type
                    }
                    if target !== null {
                        result.add(remapType(target, type))
                    }
                    else {
                        result.add(type)
                    }
                }
                else {
                    return null
                }
            when Symbol.Kind.METHOD:
                def m := s->MethodDecl
                if !resolve(m) {
                    return null
                }
                if target !== null {
                    result.add(MethodRef(self, target, m).effectiveType)
                }
                else {
                    result.add(MethodRef(self, currentClass[0].type, m).effectiveType)
                }
            when Symbol.Kind.METHODS:
                for m in s->Methods.methods { -- FIXME use map
                    if resolve(m) {
                        if m.annotations.isClass() {
                            result.add(m.type())
                        }
                        else if target !== null {
                            result.add(MethodRef(self, target, m).effectiveType)
                        }
                        else {
                            result.add(MethodRef(self, currentClass[0].type, m).effectiveType)
                        }
                    }
                }
            when Symbol.Kind.VARIABLE:
                result.add(s->Variable.type)
            otherwise:
                assert false, "cannot reference symbol \{s}"
        }
        return result    
    }

    method dotTypes(base:Type, name:String):ListView<Type>? {
        if base.isClass() {
            def cl:ClassDecl
            if base.typeKind = Type.Kind.GENERIC & base.subtypes[0] = Type.Class() {
                -- class literal, grab the class itself rather than panda.core.Class
                cl := getClass(base.subtypes[1])
            }
            else {
                cl := getClass(base)
            }
            if cl == null {
                return null
            }
            def symbol := getSymbolTable(cl)[name]
            if symbol == null {
                return null
            }
            return symbolType(base, symbol)
        }
        return null
    }

    method identifierType(name:String):ListView<Type>? {
        def s := symbolTable[name]
        if s !== null {
            return symbolType(null, s)
        }
        def cl := tryResolveClass(name)
        if cl !== null {
            def result := Array<Type>()
            result.add(Type.ClassLiteral(cl.type))
            return result
        }
        return null
    }

    method getText(value:ASTNode):String? {
        match value {
            when ASTNode.DOT(_, base, name):
                def baseText := getText(base)
                if baseText == null {
                    return null
                }
                return "\{baseText}.\{name}"
            when ASTNode.IDENTIFIER(_, name):
                return name
            otherwise:
                return null
        }
    }

    ================================================================================================
    If `value` represents a type, returns the corresponding [Type]. Otherwise returns `null` without
    reporting an error.
    ================================================================================================
    @post(errorCount = @pre(errorCount))
    method tryResolveType(value:ASTNode):Type? {
        match value {
            when ASTNode.IDENTIFIER(position, text):
                return tryResolveType(ASTNode.TYPE(position, text))
            when ASTNode.DOT(position, base, name):
                def text := getText(base)
                if text !== null {
                    return tryResolveType(ASTNode.TYPE(position, "\{text}.\{name}"))
                }
                return null
        }
        def old := reportErrors
        reportErrors := false
        def result := resolve(scanner.convertType(value))
        reportErrors := old
        return result
    }

    method rangePreferredType(start:ASTNode?, end:ASTNode?, step:ASTNode?):Type? {
        var endpointType:Type? := null
        if start !== null {
            def endpointType:Type
            def pref1 := preferredType(start)
            if pref1 == null {
                return null
            }
            if end !== null {
                def pref2 := preferredType(end)
                if pref2 == null {
                    return null
                }
                endpointType := pref1.union(self, pref2)
            }
            else {
                endpointType := pref1.nullable()
            }
            if step !== null {
                return Type.SteppedRangeOf(endpointType)
            }
            return Type.RangeOf(endpointType)
        }
        else if end !== null {
            def pref := preferredType(end)
            if pref == null {
                return null
            }
            if step !== null {
                return Type.SteppedRangeOf(pref)
            }
            return Type.RangeOf(pref)
        }
        if step !== null {
            return Type.SteppedRangeOf(Type.Int64().nullable())
        }
        return Type.RangeOf(Type.Int64().nullable())
    }

    ================================================================================================
    Returns the size in bits of the smallest Char type that can this codepoint.
    ================================================================================================
    function smallestCharSize(char:Char32):Int {
        def v := char.convert()->Int32
        if v <= 255 {
            return 8
        }
        if v <= 65535 {
            return 16
        }
        return 32
    }

    function binaryType(left:ASTNode, op:Token.Kind, right:ASTNode):ListView<Type>? {
        match op {
            when Token.Kind.CAST:
                def rawTarget := scanner.convertType(right)
                def index := rawTarget.name.lastIndexOf(".")
                if rawTarget.typeKind = Type.Kind.CLASS & index !== null {
                    -- we have a dotted name which might not be entirely a type - for example we
                    -- might have 'o->String.length'. This is obviously meant to be a cast to String
                    -- followed by a call to get_length(), but syntactically it could just as easily
                    -- be a cast to a class named String.length. We need to disambiguate these cases
                    -- here.
                    def old := reportErrors
                    reportErrors := false
                    def type := resolve(rawTarget)
                    reportErrors := old
                    if type == null {
                        def base := binaryType(left, op,
                                ASTNode.TYPE(rawTarget.position, rawTarget.name[..index]))
                        if base == null {
                            return null
                        }
                        def result := Array<Type>()
                        for t in base {
                            def types := dotTypes(t, rawTarget.name[rawTarget.name.next(index)..])
                            if types !== null {
                                result.addAll(types)
                            }
                        }
                        if result.count = 0 {
                            return null
                        }
                        return result
                    }
                }
                def target := tryResolveType(right)
                if target == null {
                    return null
                }
                def types := possibleTypes(left)
                var found := false
                for t in types {
                    if canCast(t, target) {
                        found := true
                        break
                    }
                }
                if !found {
                    if target.isBuiltinNumber() {
                        def preferred := preferredType(left)
                        if preferred == null | !preferred.isBuiltinNumber() {
                            return null
                        }
                    }
                    else {
                        return null
                    }
                }
                def result := Array<Type>() -- FIXME literal
                result.add(target)
                return result
            when Token.Kind.IDENTITY, Token.Kind.NIDENTITY:
                def result := Array<Type>() -- FIXME literal
                result.add(Type.Bit())
                return result
            otherwise:
                def matches := findOverloadedOperator(left, op, right,
                        TypeContext.NON_VOID)
                if matches !== null {
                    def result := Array<Type>() -- FIXME literal
                    for m in matches.first { -- FIXME map
                        result.add(m.returnType)
                    }
                    return result
                }
                def type := preferredType(left)
                if type == null {
                    return null
                }
                if coercionCost(right, type) == null {
                    return null
                }
                if type = Type.BuiltinBit() {
                    match op {
                        when Token.Kind.AND, Token.Kind.OR, Token.Kind.XOR, Token.Kind.EQ,
                                Token.Kind.NEQ:
                            def result := Array<Type>() -- FIXME literal
                            result.add(Type.BuiltinBit())
                            return result
                    }
                }
                -- this is a bit sloppy and allows for illegal operations like Real32 << Real32,
                -- but since nobody outside of the compiler itself should be using builtin
                -- types, it's not a big deal
                if type.isBuiltinNumber() {
                    match op {
                        when Token.Kind.ADD, Token.Kind.SUB, Token.Kind.MUL, Token.Kind.DIV,
                                Token.Kind.INTDIV, Token.Kind.REM, Token.Kind.POW,
                                Token.Kind.BITWISEOR, Token.Kind.BITWISEAND,
                                Token.Kind.BITWISEXOR, Token.Kind.SHIFTLEFT,
                                Token.Kind.SHIFTRIGHT:
                            def result := Array<Type>() -- FIXME literal
                            result.add(type)
                            return result
                        when Token.Kind.EQ, Token.Kind.NEQ, Token.Kind.GT, Token.Kind.LT,
                                Token.Kind.GTEQ, Token.Kind.LTEQ:
                            def result := Array<Type>() -- FIXME literal
                            result.add(Type.BuiltinBit())
                            return result
                    }
                }
                return null
        }
    }

    ================================================================================================
    Returns the types we should consider this expression to potentially be when evaluating method
    calls and field accesses against it. This is not always (nor could it reasonably be) an
    exhaustive list.

    This method does not generate errors for the expression in question, but may generate other
    one-time errors (for instance, it may be unable to load a class or resolve a field).
    ================================================================================================
    method possibleTypes(value:ASTNode):CollectionView<Type>? {
        match value {
            when ASTNode.AT_PRE(_, expr):
                return possibleTypes(expr)
            when ASTNode.AT_RETURN:
                def a := Array<Type>() -- FIXME literal
                a.add(currentMethod[0].returnType)
                return a
            when ASTNode.BINARY(_, left, op, right):
                return binaryType(left, op, right)
            when ASTNode.BIT:
                def result := Array<Type>() -- FIXME literal
                result.add(Type.Bit())
                result.add(Type.BuiltinBit())
                return result
            when ASTNode.CALL(_, m, args):
                def methodTypes := possibleTypes(m)
                if methodTypes == null {
                    return null
                }
                if methodTypes.count = 1 {
                    def t := methodTypes.iterator().next()
                    if t.isClass() {
                        def cl := getClass(t)
                        if cl !== null & cl.classKind = ClassDecl.Kind.CHOICE {
                            -- choice case
                            def result := Array<Type>() -- FIXME literal
                            result.add(t)
                            return result
                        }
                    }
                    if t.typeKind = Type.Kind.GENERIC & t.subtypes[0] = Type.Class() {
                        -- calling a class literal, this is actually object construction
                        def result := Array<Type>() -- FIXME literal
                        result.add(t.subtypes[1])
                        return result
                    }
                }
                def result := possibleMatches(methodTypes, args, TypeContext.NON_VOID)
                if result !== null {
                    def resultTypes := HashSet<Type>()
                    for m in result.first {
                        resultTypes.add(m.returnType())
                    }
                    return resultTypes
                }
                return null
            when ASTNode.DOT(position, base, name):
                def type := tryResolveType(value)
                if type !== null {
                    def result := Array<Type>() -- FIXME literal
                    result.add(Type.ClassLiteral(type))
                    return result
                }
                def result:Array<Type>? := null
                def baseTypes := possibleTypes(base)
                if baseTypes == null {
                    return null
                }
                for t in baseTypes {
                    def list := dotTypes(t, name)
                    if list !== null {
                        if result == null {
                            result := Array<Type>()
                        }
                        result.addAll(list)
                    }
                }
                return result
            when ASTNode.GENERIC_TYPE, ASTNode.TYPE:
                def t := tryResolveType(value)
                if t == null {
                    return null
                }
                def result := Array<Type>() -- FIXME literal
                result.add(Type.ClassLiteral(t))
                return result
            when ASTNode.IDENTIFIER(_, name):
                return identifierType(name)
            when ASTNode.INT(_, value):
                def result := Array<Type>() -- FIXME literal
                def signedValue := value.convert()->Int64
                if signedValue >= Int8.MIN.convert() & signedValue <= Int8.MAX.convert() {
                    result.add(Type.BuiltinInt8())
                    result.add(Type.Int8())
                }
                if signedValue >= Int16.MIN.convert() & signedValue <= Int16.MAX.convert() {
                    result.add(Type.BuiltinInt16())
                    result.add(Type.Int16())
                }
                if signedValue >= Int32.MIN.convert() & signedValue <= Int32.MAX.convert() {
                    result.add(Type.BuiltinInt32())
                    result.add(Type.Int32())
                }
                result.add(Type.BuiltinInt64())
                result.add(Type.Int64())
                if value >= UInt8.MIN.convert() & value <= UInt8.MAX.convert() {
                    result.add(Type.BuiltinUInt8())
                    result.add(Type.UInt8())
                }
                if value >= UInt16.MIN.convert() & value <= UInt16.MAX.convert() {
                    result.add(Type.BuiltinUInt16())
                    result.add(Type.UInt16())
                }
                if value >= UInt32.MIN.convert() & value <= UInt32.MAX.convert() {
                    result.add(Type.BuiltinUInt32())
                    result.add(Type.UInt32())
                }
                result.add(Type.BuiltinUInt64())
                result.add(Type.UInt64())
                result.add(Type.Real32())
                result.add(Type.Real64())
                return result
            when ASTNode.IR_WRAPPER(_, node):
                def a := Array<Type>() -- FIXME literal
                a.add(node.type())
                return a
            when ASTNode.METHOD:
                return null
            when ASTNode.NULL:
                def a := Array<Type>() -- FIXME literal
                a.add(Type.Any())
                return a
            when ASTNode.PREFIX(position, op, operand):
                return possibleTypes(ASTNode.CALL(position,
                        ASTNode.DOT(position, operand, operatorName(op)),
                        ImmutableArray<ASTNode>() -* FIXME literal *-))
            when ASTNode.RANGE(_, start, _, end, step):
                def result := rangePreferredType(start, end, step)
                if result == null {
                    return null
                }
                def a := Array<Type>() -- FIXME literal
                a.add(result)
                return a
            when ASTNode.REAL:
                def result := Array<Type>() -- FIXME literal
                result.add(Type.BuiltinFloat32())
                result.add(Type.BuiltinFloat64())
                result.add(Type.Real32())
                result.add(Type.Real64())
                return result
            when ASTNode.REGEX:
                def a := Array<Type>() -- FIXME literal
                a.add(Type.RegularExpression())
                return a
            when ASTNode.SELF:
                var s := symbolTable[CAPTURED_SELF_NAME]
                if s == null {
                    s := symbolTable[SELF_NAME]
                }
                if s == null {
                    return null
                }
                return symbolType(null, s)
            when ASTNode.SUPER:
                var s := symbolTable[CAPTURED_SELF_NAME]
                if s == null {
                    s := symbolTable[SELF_NAME]
                }
                if s == null {
                    return null
                }
                def result := Array<Type>()
                assert s.kind = Symbol.Kind.VARIABLE
                def cl := getClass(s->Variable.type)
                if !resolve(cl) {
                    return null
                }
                result.add(remapType(s->Variable.type, cl.rawSuper))
                return result
            when ASTNode.STRING(_, text):
                def result := Array<Type>() -- FIXME literal
                result.add(Type.StringType())
                if text.length() = 1 {
                    def size := smallestCharSize(text[0])
                    if size = 8 {
                        result.add(Type.Char8())
                    }
                    if size <= 16 {
                        result.add(Type.Char16())
                    }
                    result.add(Type.Char32())
                }
                return result
            when ASTNode.TYPED_LAMBDA(position, parameters, body):
                def parameterTypes := Array<Type>()
                for p in parameters {
                    match p {
                        when ASTNode.PARAMETER(_, _, type):
                            def resolved := tryResolveType(type)
                            if resolved == null {
                                return null
                            }
                            parameterTypes.add(resolved)
                    }
                }
                def returnType := typedLambdaReturnType(parameters, body, TypeContext.NON_VOID)
                if returnType == null {
                    return null
                }
                def result := Array<Type>() -- FIXME literal
                result.add(Type.methodType(position, Type.Kind.FUNCTION, parameterTypes,
                        returnType, 0))
                return result
            when ASTNode.UNTYPED_LAMBDA:
                return null
            otherwise:
                assert false, "unsupported possibleType: \{value}:\{value.position()}"
        }
    }

    method binaryCost(left:ASTNode, op:Token.Kind, right:ASTNode, type:TypeContext):Int? {
        if op = Token.Kind.CAST {
            def target := tryResolveType(right)
            if target == null {
                return null
            }
            if coercionCost(left, target) == null {
                if target.isBuiltinNumber() {
                    def leftType := preferredType(left)
                    if leftType == null | !leftType.isBuiltinNumber() {
                        return null
                    }
                }
                else {
                    return null
                }
            }
            return coercionCost(target, type)
        }
        def result := findOverloadedOperator(left, op, right, type)
        if result !== null {
            return result.second
        }
        def preferred := preferredType(ASTNode.BINARY(left.position(), left, op, right))
        if preferred !== null {
            return coercionCost(preferred, type)
        }
        return null
    }

    method rangeCoercionCost(start:ASTNode?, end:ASTNode?, step:ASTNode?, target:Type):Int? {
        if target.typeKind = Type.Kind.NULLABLE {
            def result := rangeCoercionCost(start, end, step, target.nonnullable())
            if result == null {
                return null
            }
            return result + 1
        }
        if target.typeKind = Type.Kind.GENERIC {
            if target.subtypes[0].name = RANGE_NAME & target.subtypes.count = 2 |
                    target.subtypes[0].name = STEPPED_RANGE_NAME & target.subtypes.count = 3 {
                var cost := 0
                if start !== null {
                    def startCost := coercionCost(start, target.subtypes[1])
                    if startCost == null {
                        return null
                    }
                    cost += startCost
                }
                else if target.subtypes[1].typeKind != Type.Kind.NULLABLE {
                    return null
                }
                if end !== null {
                    def endCost := coercionCost(end, target.subtypes[1])
                    if endCost == null {
                        return null
                    }
                    cost += endCost
                }
                else if target.subtypes[1].typeKind != Type.Kind.NULLABLE {
                    return null
                }
                if target.subtypes[0].name = RANGE_NAME {
                    if step !== null {
                        return null
                    }
                }
                else {
                    if step == null {
                        return null
                    }
                    def stepCost := coercionCost(step, target.subtypes[2])
                    if stepCost == null {
                        return null
                    }
                    cost += stepCost
                }
                return cost
            }
        }
        def type := preferredType(ASTNode.RANGE(Position(), start, true, end, step))
        if type == null {
            return null
        }
        return coercionCost(type, target)
    }

    method typedLambdaCoercionCost(parameters:ListView<ASTNode>, body:ASTNode, target:Type):Int? {
        if !target.nonnullable().isMethod() {
            return coercionCost(Type.MutableMethod(), target)
        }
        if target.typeKind = Type.Kind.NULLABLE {
            def result := typedLambdaCoercionCost(parameters, body, target.nonnullable())
            if result == null {
                return null
            }
            return result + NONNULLABLE_TO_NULLABLE_CAST_COST
        }
        if target.parameterCount != parameters.count {
            return null
        }
        var cost := 0
        for i in 0 .. parameters.count {
            match parameters[i] {
                when ASTNode.PARAMETER(_, _, type):
                    def resolved := tryResolveType(type)
                    if resolved == null {
                        return null
                    }
                    def parameterCost := coercionCost(target.parameterType(i), resolved)
                    if parameterCost == null {
                        return null
                    }
                    cost += parameterCost
            }
        }
        def returnType := typedLambdaReturnType(parameters, body, TypeContext.TYPE(target))
        if returnType == null {
            return null
        }
        cost += coercionCost(returnType, target.returnType())
        return cost
    }

    method untypedLambdaCoercionCost(parameters:ListView<ASTNode>, body:ASTNode, target:Type):Int? {
        if !target.nonnullable().isMethod() {
            return coercionCost(Type.MutableMethod(), target)
        }
        if target.typeKind = Type.Kind.NULLABLE {
            def result := untypedLambdaCoercionCost(parameters, body, target.nonnullable())
            if result == null {
                return null
            }
            return result + NONNULLABLE_TO_NULLABLE_CAST_COST
        }
        if target.parameterCount != parameters.count {
            return null
        }
        def typedParameters := Array<ASTNode>()
        for i in 0 .. parameters.count {
            match parameters[i] {
                when ASTNode.IDENTIFIER(position, name):
                    typedParameters.add(ASTNode.PARAMETER(position, name,
                            ASTNode.IR_WRAPPER(position, IR.Value.TYPE(target.parameterType(i)))))
                otherwise:
                    assert false
            }
        }
        def result := typedLambdaCoercionCost(typedParameters, body, target)
        if result == null {
            var list := lambdaTypes[body]
            if list == null {
                list := HashSet<Type>()
                lambdaTypes[body] := list
            }
            list.add(target)
        }
        return result
    }

    @pre(target.resolved)
    method coercionCost(expr:ASTNode, target:Type):Int? {
        match expr {
            when ASTNode.AT_PRE(_, expr):
                return coercionCost(expr, target)
            when ASTNode.AT_RETURN:
                return coercionCost(currentMethod[0].returnType, target)
            when ASTNode.BINARY(_, left, op, right):
                match op {
                    when Token.Kind.CAST:
                        def types := possibleTypes(expr)
                        if types == null {
                            return null
                        }
                        return coercionCost(types, target)
                    when Token.Kind.IDENTITY, Token.Kind.NIDENTITY:
                        return coercionCost(Type.Bit(), target)
                    otherwise:
                        return binaryCost(left, op, right, TypeContext.TYPE(target))
                }
            when ASTNode.BIT:
                return coercionCost(Type.BuiltinBit(), target)
            when ASTNode.CALL(_, m, args):
                var methodTypes := possibleTypes(m)
                if methodTypes == null {
                    return null
                }
                if methodTypes.count = 1 {
                    def t := methodTypes.iterator().next()
                    if t.isClassLiteral() {
                        def resultCost := coercionCost(t.subtypes[1], target)
                        if resultCost == null {
                            return null
                        }
                        methodTypes := possibleTypes(ASTNode.DOT(m.position(), m, "init"))
                        if methodTypes == null {
                            return null
                        }
                        def callCost := callCost(methodTypes, args, TypeContext.UNSPECIFIED)
                        if callCost == null {
                            return null
                        }
                        return callCost + resultCost
                    }
                }
                return callCost(methodTypes, args, TypeContext.TYPE(target))
            when ASTNode.DOT:
                def types := possibleTypes(expr)
                if types == null {
                    return null
                }
                return coercionCost(types, target)
            when ASTNode.IDENTIFIER(position, name):
                def types := identifierType(name)
                if types == null {
                    return null
                }
                return coercionCost(types, target)
            when ASTNode.INT(_, value):
                if (target.typeKind = Type.Kind.BUILTIN_INT &
                        requiredSize(value.convert()->Int64) <= target.size()) |
                        (target.typeKind = Type.Kind.BUILTIN_UINT &
                        requiredSize(value) <= target.size()) {
                    return 0
                }
                if target.typeKind = Type.Kind.BUILTIN_FLOAT {
                    return 1
                }
                if target.isNumber() {
                    return 2
                }
                def preferred := preferredType(expr)
                assert preferred !== null
                return coercionCost(preferred, target)
            when ASTNode.IR_WRAPPER(_, ir):
                return coercionCost(ir.type(), target)
            when ASTNode.METHOD(position, _, _, kind, _, _, parameters, returnType, _):
                def paramTypes := Array<Type>()
                for p in parameters { -- FIXME map
                    match p {
                        when ASTNode.PARAMETER(_, _, type):
                            def resolved := tryResolveType(type)
                            if resolved == null {
                                return null
                            }
                            paramTypes.add(resolved)
                        otherwise:
                            assert false
                    }
                }
                def resolvedReturnType:Type
                if returnType !== null {
                    resolvedReturnType := tryResolveType(returnType)
                    if resolvedReturnType == null {
                        return null
                    }
                }
                else {
                    resolvedReturnType := Type.Void()
                }
                def typeKind:Type.Kind
                -- we don't actually know whether the method has any captures yet (it might turn
                -- out to be mutable), but we assume it's immutable here and let it error later if
                -- that turns out to be a problem
                if kind = MethodDecl.Kind.FUNCTION {
                    typeKind := Type.Kind.IMMUTABLE_FUNCTION
                }
                else {
                    assert kind = MethodDecl.Kind.METHOD
                    typeKind := Type.Kind.IMMUTABLE_METHOD
                }
                return coercionCost(Type.methodType(position, typeKind, paramTypes,
                        resolvedReturnType, 0), target)
            when ASTNode.NULL:
                if target.typeKind = Type.Kind.NULLABLE {
                    return 0
                }
                return null
            when ASTNode.PREFIX(position, op, operand):
                def preferred := preferredType(operand)
                if preferred !== null & (preferred = Type.BuiltinBit() |
                        preferred.isBuiltinNumber()) {
                    return coercionCost(preferred, target)
                }
                return coercionCost(ASTNode.CALL(position,
                        ASTNode.DOT(position, operand, operatorName(op)),
                        ImmutableArray<ASTNode>() -* FIXME literal *-),
                        target)
            when ASTNode.RANGE(_, start, _, end, step):
                return rangeCoercionCost(start, end, step, target)
            when ASTNode.REAL:
                if (target.typeKind = Type.Kind.BUILTIN_FLOAT) {
                    return 0
                }
                if target.isReal() {
                    return 1
                }
                def preferred := preferredType(expr)
                assert preferred !== null
                return coercionCost(preferred, target)
            when ASTNode.REGEX:
                return coercionCost(Type.RegularExpression(), target)
            when ASTNode.SELF:
                return coercionCost(currentClass[0].typeWithParameters(), target)
            when ASTNode.STRING(_, text):
                if target.isChar() & text.length() = 1 {
                    def size := smallestCharSize(text[0])
                    def targetSize:Int
                    match target {
                        when Type.Char8():  targetSize := 8
                        when Type.Char16(): targetSize := 16
                        when Type.Char32(): targetSize := 32
                    }
                    if targetSize >= size {
                        return 1
                    }
                    return null
                }
                return coercionCost(Type.StringType(), target)
            when ASTNode.TYPED_LAMBDA(_, parameters, body):
                return typedLambdaCoercionCost(parameters, body, target)
            when ASTNode.UNTYPED_LAMBDA(_, parameters, body):
                return untypedLambdaCoercionCost(parameters, body, target)
            otherwise:
                assert false, "unsupported coercionCost: \{expr}"
        }
    }

    function requiredSize(value:Int64):Int {
        if value >= -128 & value <= 127 {
            return 8
        }
        if value >= -32768 & value <= 32767 {
            return 16
        }
        if value >= -2147483648 & value <= 2147483647 {
            return 32
        }
        return 64
    }

    function requiredSize(value:UInt64):Int {
        if value <= 255 {
            return 8
        }
        if value <= 65535 {
            return 16
        }
        if value <= 4294967295 {
            return 32
        }
        return 64
    }

    method canCast(type:Type, target:Type):Bit {
        if type.isPointer() & (target.isPointer() | target.nonnullable().isMethod()) {
            return true
        }
        if coercionCost(type, target) !== null {
            return true
        }
        if type.isBuiltinNumber() & target.isBuiltinNumber() {
            return true
        }
        if type.typeKind = Type.Kind.GENERIC_PARAMETER {
            return canCast(type.genericParameter.bound, target)
        }
        if type.typeKind = Type.Kind.INVALID {
            return false
        }
        return coercionCost(target, type) !== null
    }

    -- FIXME figure out how to handle list comparisons
    function equal(a:ListView<Type>, b:ListView<Type>):Bit {
        if a.count != b.count {
            return false
        }
        for i in 0 .. a.count {
            if a[i] != b[i] {
                return false
            }
        }
        return true
    }

    method createChoiceCaseInit(entry:ChoiceCase) {
        def cl := entry.owner
        assert entry.resolved != Resolution.UNRESOLVED
        if entry.resolved != Resolution.RESOLVED {
            return
        }
        outer: for m in cl.methods {
            if m.methodKind != MethodDecl.Kind.INIT |
                    m.parameters.count != entry.fields.count + 1 {
                continue
            }
            assert m.parameters[0].type = Type.Int64()
            for i in 0 .. entry.fields.count {
                if entry.fields[i] != m.parameters[i + 1].type {
                    continue outer
                }
            }
            entry.initMethod := m
            return
        }
        -- need a synthetic init for this particular combination of parameters
        def parameters := Array<MethodDecl.Parameter>()
        parameters.add(MethodDecl.Parameter("rv", Type.Int64()))
        def statements := Array<ASTNode>()
        statements.add(ASTNode.BINARY(cl.position,
                ASTNode.IDENTIFIER(cl.position, ClassDecl.RAW_VALUE_NAME),
                Token.Kind.ASSIGNMENT,
                ASTNode.IDENTIFIER(cl.position, "rv")))
        for i in 0 .. entry.fields.count {
            parameters.add(MethodDecl.Parameter("f\{i}", entry.fields[i]))
            statements.add(ASTNode.BINARY(cl.position,
                    ASTNode.CHOICE_FIELD_REFERENCE(cl.position,
                        ASTNode.SELF(cl.position),
                        entry,
                        i),
                    Token.Kind.ASSIGNMENT,
                    ASTNode.IDENTIFIER(cl.position, "f\{i}")))
        }
        def synthetic := MethodDecl(cl, cl.position, null, Annotations(Annotations.Flag.SYNTHETIC),
                MethodDecl.Kind.INIT, "init", null, parameters, Type.Void(), statements.finish())
        entry.initMethod := synthetic
        cl.methods.add(synthetic)
        cl.symbolTable.add(synthetic)
    }

    function declaredType(m:MethodDecl):Type {
        resolve(m)
        def subtypes := Array<Type>()
        def typeName := MutableString("(")
        var separator := ""
        for p in m.parameters {
            typeName.append(separator)
            typeName.append(p.type.name)
            subtypes.add(p.type)
            separator := ", "
        }
        def kind:Type.Kind
        if m.methodKind = MethodDecl.Kind.FUNCTION {
            typeName.append(")=>(")
            kind := Type.Kind.FUNCTION
        }
        else {
            typeName.append(")=&>(")
            kind := Type.Kind.METHOD
        }
        subtypes.add(m.returnType)
        if m.returnType != Type.Void() {
            typeName.append(m.returnType.name)
        }
        typeName.append(")")
        return Type(typeName.finish(), kind, m.position, subtypes, true)
    }

    function declaredTypeWithSelf(m:MethodDecl, selfType:Type):Type {
        resolve(m)
        def subtypes := Array<Type>()
        def typeName := MutableString("(")
        typeName.append(selfType.name)
        subtypes.add(selfType)
        for p in m.parameters {
            typeName.append(", ")
            typeName.append(p.type.name)
            subtypes.add(p.type)
        }
        def kind:Type.Kind
        if m.methodKind = MethodDecl.Kind.FUNCTION {
            typeName.append(")=>(")
            kind := Type.Kind.FUNCTION
        }
        else {
            typeName.append(")=&>(")
            kind := Type.Kind.METHOD
        }
        subtypes.add(m.returnType)
        if m.returnType != Type.Void() {
            typeName.append(m.returnType.name)
        }
        typeName.append(")")
        return Type(typeName.finish(), kind, m.position, subtypes, true)
    }

    function inheritedType(m:MethodDecl):Type {
        def inherited := getOverriddenMethod(m)
        if inherited == null {
            return declaredType(m)
        }
        return inheritedType(inherited)
    }

    function inheritedTypeWithSelf(m:MethodDecl):Type {
        return inheritedTypeWithSelf(m, m.owner.type)
    }

    function inheritedTypeWithSelf(m:MethodDecl, selfType:Type):Type {
        def inherited := getOverriddenMethod(m)
        if inherited == null {
            return declaredTypeWithSelf(m, selfType)
        }
        return inheritedTypeWithSelf(inherited, selfType)
    }

    @class
    function operatorName(op:Token.Kind):String {
        match op {
            when Token.Kind.ADD:        return "+"
            when Token.Kind.SUB:        return "-"
            when Token.Kind.MUL:        return "*"
            when Token.Kind.DIV:        return "/"
            when Token.Kind.INTDIV:     return "//"
            when Token.Kind.REM:        return "%"
            when Token.Kind.POW:        return "^"
            when Token.Kind.EQ:         return "="
            when Token.Kind.NEQ:        return "!="
            when Token.Kind.GT:         return ">"
            when Token.Kind.LT:         return "<"
            when Token.Kind.GTEQ:       return ">="
            when Token.Kind.LTEQ:       return "<="
            when Token.Kind.OR:         return "|"
            when Token.Kind.BITWISEOR:  return "||"
            when Token.Kind.AND:        return "&"
            when Token.Kind.BITWISEAND: return "&&"
            when Token.Kind.XOR:        return "~"
            when Token.Kind.BITWISEXOR: return "~~"
            when Token.Kind.NOT:        return "!"
            when Token.Kind.BITWISENOT: return "!!"
            when Token.Kind.SHIFTLEFT:  return "<<"
            when Token.Kind.SHIFTRIGHT: return ">>"
            when Token.Kind.LBRACKET:   return "[]"
            when Token.Kind.ASSIGNMENT: return ":="
            when Token.Kind.IDENTITY:   return "=="
            when Token.Kind.NIDENTITY:  return "!=="
            when Token.Kind.CAST:       return "->"
            otherwise:
                assert false, "not an operator: \{op}"
        }
    }

    @class
    function isAssignment(op:Token.Kind):Bit {
        match op {
            when Token.Kind.ASSIGNMENT, Token.Kind.ADDEQ, Token.Kind.SUBEQ, Token.Kind.MULEQ,
                    Token.Kind.DIVEQ, Token.Kind.INTDIVEQ, Token.Kind.REMEQ, Token.Kind.POWEQ,
                    Token.Kind.OREQ, Token.Kind.BITWISEOREQ, Token.Kind.ANDEQ,
                    Token.Kind.BITWISEANDEQ, Token.Kind.XOREQ, Token.Kind.BITWISEXOREQ,
                    Token.Kind.SHIFTLEFTEQ, Token.Kind.SHIFTRIGHTEQ:
                return true
            otherwise:
                return false
        }
    }

    @class
    function removeAssignment(op:Token.Kind):Token.Kind {
        match op {
            when Token.Kind.ADDEQ:        return Token.Kind.ADD
            when Token.Kind.SUBEQ:        return Token.Kind.SUB
            when Token.Kind.MULEQ:        return Token.Kind.MUL
            when Token.Kind.DIVEQ:        return Token.Kind.DIV
            when Token.Kind.INTDIVEQ:     return Token.Kind.INTDIV
            when Token.Kind.REMEQ:        return Token.Kind.REM
            when Token.Kind.POWEQ:        return Token.Kind.POW
            when Token.Kind.OREQ:         return Token.Kind.OR
            when Token.Kind.BITWISEOREQ:  return Token.Kind.BITWISEOR
            when Token.Kind.ANDEQ:        return Token.Kind.AND
            when Token.Kind.BITWISEANDEQ: return Token.Kind.BITWISEAND
            when Token.Kind.XOREQ:        return Token.Kind.XOR
            when Token.Kind.BITWISEXOREQ: return Token.Kind.BITWISEXOR
            when Token.Kind.SHIFTLEFTEQ:  return Token.Kind.SHIFTLEFT
            when Token.Kind.SHIFTRIGHTEQ: return Token.Kind.SHIFTRIGHT
            otherwise:
                assert false
        }
    }

    function capturedSelfType():Type {
        var cl := currentClass[0]
        loop {
            if !cl.annotations.isSynthetic() {
                return cl.type
            }
            assert cl.owner !== null, "no non-synthetic owner for \{currentClass[0].name}"
            cl := cl.owner
        }
    }

    method createClosureClass(m:MethodDecl, captures:CollectionView<Capture>):ClassDecl {
        def p := m.position
        m.annotations := Annotations(0)
        closureCount += 1
        def supers := Array<Type>()
        if isImmutable(currentClass[0].type) {
            supers.add(Type.Immutable())
            for c in captures {
                match c {
                    when Capture.VARIABLE(v):
                        if !isImmutable(v.type) {
                            supers.clear()
                            break
                        }
                    when Capture.SELF:
                        if !isImmutable(capturedSelfType()) {
                            supers.clear()
                            break
                        }
                    otherwise:
                        assert false, c.convert()
                }
            }
        }
        def result := ClassDecl(currentClass[0].source, p, HashMap<String, String>(), null,
                Annotations(Annotations.Flag.SYNTHETIC), ClassDecl.Kind.CLASS,
                "\{currentClass[0].name}._Closure\{closureCount}", supers,
                Array<ClassDecl.GenericParameter>(), root)
        result.external := false

        -- create init method
        def statements := Array<ASTNode>()
        def parameters := Array<MethodDecl.Parameter>()
        for c in captures {
            match c {
                when Capture.VARIABLE(v):
                    parameters.add(MethodDecl.Parameter(v.name, v.type))
                    -- self.parameterName := parameterName
                    statements.add(ASTNode.BINARY(p,
                            ASTNode.DOT(p, ASTNode.IDENTIFIER(p, FORCE_SELF_NAME), v.name),
                            Token.Kind.ASSIGNMENT,
                            ASTNode.IDENTIFIER(p, v.name)))
                when Capture.FIELD(f):
                    parameters.add(MethodDecl.Parameter(f.name, f.type))
                    -- self.parameterName := parameterName
                    statements.add(ASTNode.BINARY(p,
                            ASTNode.DOT(p, ASTNode.IDENTIFIER(p, FORCE_SELF_NAME), f.name),
                            Token.Kind.ASSIGNMENT,
                            ASTNode.IDENTIFIER(p, f.name)))
                when Capture.SELF:
                    parameters.add(MethodDecl.Parameter(CAPTURED_SELF_NAME, capturedSelfType()))
                    -- self.$self := $self
                    statements.add(ASTNode.BINARY(p,
                            ASTNode.DOT(p, ASTNode.IDENTIFIER(p, FORCE_SELF_NAME),
                                CAPTURED_SELF_NAME),
                            Token.Kind.ASSIGNMENT,
                            ASTNode.IDENTIFIER(p, CAPTURED_SELF_NAME)))
            }
        }
        def initMethod := MethodDecl(result, p, null,
                Annotations(Annotations.Flag.SYNTHETIC), MethodDecl.Kind.INIT, "init",
                Array<ClassDecl.GenericParameter>(), parameters,
                Type.Void(), statements.finish())
        result.methods.add(initMethod)
        result.symbolTable.add(initMethod)

        -- default cleanup
        def defaultCleanup := MethodDecl(result, p, null,
                Annotations(Annotations.Flag.OVERRIDE || Annotations.Flag.SYNTHETIC),
                MethodDecl.Kind.METHOD, "cleanup", Array<ClassDecl.GenericParameter>(),
                Array<MethodDecl.Parameter>(), Type.Void(), ImmutableArray<ASTNode>())
        result.methods.add(defaultCleanup)
        result.symbolTable.add(defaultCleanup)

        -- create fields
        for c in captures {
            match c {
                when Capture.VARIABLE(v):
                    def field := FieldDecl(result, p, null,
                            Annotations(Annotations.Flag.SYNTHETIC), FieldDecl.Kind.DEF, v.name,
                            v.type, null)
                    result.symbolTable.add(field)
                    result.fields.add(field)
                when Capture.FIELD(f):
                    def field := FieldDecl(result, p, null,
                            Annotations(Annotations.Flag.SYNTHETIC), FieldDecl.Kind.DEF, f.name,
                            f.type, null)
                    result.symbolTable.add(field)
                    result.fields.add(field)
                when Capture.SELF:
                    def field := FieldDecl(result, p, null,
                            Annotations(Annotations.Flag.SYNTHETIC), FieldDecl.Kind.DEF,
                            CAPTURED_SELF_NAME, capturedSelfType(), null)
                    result.symbolTable.add(field)
                    result.fields.add(field)
                otherwise:
                    assert false, c.convert()
            }
        }
        m.owner := result
        result.methods.add(m)
        classes[result.name] := result
        result.owner := currentClass[0]
        return result
    }

    method createChoiceCleanup(m:MethodDecl) {
        def cl := m.owner
        def statements := Array<ASTNode>()
        def value := ASTNode.SELF(cl.position)
        def whens := Array<ASTNode>()
        for e in cl.choiceCases {
            resolve(e)
            if errorCount != 0 {
                return
            }
            def tests := Array<ASTNode>() -- FIXME literal
            def fields := Array<ASTNode>()
            for i in 0 .. e.fields.count {
                fields.add(ASTNode.IDENTIFIER(cl.position, "_f\{i}"))
            }
            tests.add(ASTNode.CALL(cl.position, ASTNode.IDENTIFIER(cl.position, e.name),
                    fields.finish()))
            def unrefs := Array<ASTNode>()
            for i in 0 .. e.fields.count {
                if isRefCounted(e.fields[i]) {
                    def p := Position()
                    def unref := ASTNode.DOT(p, ASTNode.DOT(p, ASTNode.DOT(p,
                            ASTNode.IDENTIFIER(p, "panda"), "core"), "Panda"), "unref")
                    def args := Array<ASTNode>() -- FIXME literal
                    args.add(fields[i])
                    unrefs.add(ASTNode.CALL(Position(), unref, args.finish()))
                }
            }
            whens.add(ASTNode.WHEN(cl.position, tests.finish(), unrefs.finish()))
        }
        statements.add(ASTNode.MATCH(cl.position, value, whens.finish(), null))
        m.body := statements.finish()
    }

    method checkAccessModifierCount(position:Position, a:Annotations) {
        var count := 0
        if a.flags && Annotations.Flag.PRIVATE != 0 {
            count += 1
        }
        if a.flags && Annotations.Flag.PROTECTED != 0 {
            count += 1
        }
        if a.flags && Annotations.Flag.PACKAGE != 0 {
            count += 1
        }
        if count > 1 {
            error(position, "conflicting access modifier annotations")
        }
    }

    method checkAnnotations(m:MethodDecl) {
        method disallow(compiler:Compiler -* FIXME capture this *-, m:MethodDecl -* FIXME capture this *-, flag:Int, name:String) {
            if m.annotations.flags && flag != 0 {
                compiler.error(m.position, "methods may not be annotated with '\{name}'")
            }
        }
        disallow(self, m, Annotations.Flag.SPECIALIZE,       "@specialize")
        disallow(self, m, Annotations.Flag.WEAK,             "@weak")
        disallow(self, m, Annotations.Flag.UNSAFE_IMMUTABLE, "@unsafeImmutable")
        if m.methodKind = MethodDecl.Kind.INIT {
            if m.annotations.flags && Annotations.Flag.EXTERNAL != 0 {
                error(m.position, "init methods may not be annotated with '@external'")
            }
            if m.annotations.flags && Annotations.Flag.CLASS != 0 {
                error(m.position, "init methods may not be annotated with '@class'")
            }
            if m.annotations.flags && Annotations.Flag.ABSTRACT != 0 {
                error(m.position, "init methods may not be annotated with '@abstract'")
            }
            if m.annotations.flags && Annotations.Flag.OVERRIDE != 0 {
                error(m.position, "init methods may not be annotated with '@override'")
            }
        }
        if m.annotations.flags && Annotations.Flag.EXTERNAL != 0 & m.body !== null {
            error(m.position, "methods annotated with '@external' may not have a body")
        }
        if m.annotations.flags && Annotations.Flag.ABSTRACT != 0 & m.body !== null {
            error(m.position, "methods annotated with '@abstract' may not have a body")
        }
        if m.annotations.flags && Annotations.Flag.OVERRIDE != 0 &
                m.annotations.flags && Annotations.Flag.CLASS != 0 {
            error(m.position, "class methods may not be annotated with '@override'")
        }
        if m.annotations.flags && Annotations.Flag.ABSTRACT = 0 &
                m.annotations.flags && Annotations.Flag.EXTERNAL = 0 &
                m.body == null {
            error(m.position, "expected non-abstract method '\{m.name}' to have a body")
        }
        if m.annotations.flags && Annotations.Flag.DEFAULT != 0 {
            if m.owner.classKind != ClassDecl.Kind.INTERFACE {
                error(m.position, "annotation '@default' may only appear on interface methods")
            }
            if m.body == null {
                error(m.position, "expected '@default' method '\{m.name}' to have a body")
            }
        }
        else if m.methodKind != MethodDecl.Kind.INIT &
                m.owner.classKind = ClassDecl.Kind.INTERFACE &
                !m.annotations.isClass() & m.body !== null {
            error(m.position, "non-abstract interface method '\{m.name}' must be annotated with " +
                    "'@default'")
        }
        checkAccessModifierCount(m.position, m.annotations)
    }

    method getIndex(f:FieldDecl):Int {
        def fields := instanceFields(f.owner)
        for i in 0 .. fields.count {
            if fields[i] == f {
                return i
            }
        }
        assert false, "field '\{f}' not found in \{f.owner.name}"
    }

    method capture(position:Position, v:Variable) {
        if v.name = SELF_NAME {
            for c in captures {
                c.second[SELF_NAME] := Capture.SELF
                if !c.first.annotations.isSynthetic() {
                    return
                }
            }
        }
        for c in captures {
            if v.varKind = Variable.Kind.VAR {
                error(position, "closure cannot capture 'var \{v}'; use 'def' instead")
                break
            }
            c.second[v.name] := Capture.VARIABLE(v)
            if v.owner == c.first {
                break
            }
        }
    }

    method capture(position:Position, f:FieldDecl) {
        for c in captures {
            c.second[f.name] := Capture.FIELD(f)
            if f.owner == c.first.owner {
                break
            }
        }
    }

    @post(@return !== null | errorCount > 0 | !reportErrors)
    method symbolRef(position:Position, target:IR.Value?, s:Symbol):IR.Value? {
        match s.kind {
            when Symbol.Kind.ALIAS:
                def cl := getClass(position, s->Alias.fullName)
                if cl !== null {
                    checkGenericParameters(position, cl, cl.type)
                    return IR.Value.TYPE(Type.ClassLiteral(cl.type))
                }
                return null
            when Symbol.Kind.METHOD:
                return IR.Value.METHOD(target, s->MethodDecl)
            when Symbol.Kind.METHODS:
                return IR.Value.METHODS(target, s->Methods.methods)
            when Symbol.Kind.VARIABLE:
                def v := s->Variable
                if v.owner !== null & v.owner !== currentMethod[0] {
                    capture(position, v)
                }
                match v.storage {
                    when Variable.Storage.LOCAL(slot):
                        def result := ir.add(IR.Statement.LOAD(IR.Value.LOCAL(slot, v.type)))
                        return IR.Value.REF(result, v.type)
                    when Variable.Storage.PARAMETER(index):
                        assert s->Variable.type.resolved
                        return IR.Value.PARAMETER(index, s->Variable.type)
                    otherwise:
                        assert false
                }
            when Symbol.Kind.FIELD:
                def f := s->FieldDecl
                if resolve(f) {
                    if f.annotations.isSynthetic() {
                        capture(position, f)
                    }
                    return FieldLValue(self, position, target, f).compileLoad()
                }
                return null
            when Symbol.Kind.CHOICE_CASE:
                -- this handles the zero-argument case; choice cases with arguments are handled in
                -- compileCall()
                def cc := s->ChoiceCase
                if cc.fields.count > 0 {
                    error(position, "choice '\{s}' requires \{cc.fields.count} " +
                            "argument\{cc.fields.count = 1:|s}, but found 0")
                    return null
                }
                resolve(cc)
                def inits := getSymbolTable(cc.owner)["init"]
                assert inits !== null
                resolve(inits->MethodDecl)
                def args := Array<ASTNode>() -- FIXME literal
                args.add(ASTNode.INT(position, cc.rawValue.convert()))
                if isValue(cc.owner) {
                    return call(position, symbolRef(position, null, inits), args,
                            TypeContext.UNSPECIFIED)
                }
                else {
                    def construct := ir.add(IR.Statement.CONSTRUCT(cc.owner))
                    def constructRef := IR.Value.REF(construct, cc.owner.type)
                    statementUnrefs.add(constructRef)
                    call(position, symbolRef(position, constructRef, inits), args,
                            TypeContext.UNSPECIFIED)
                    return constructRef
                }
            when Symbol.Kind.GENERIC_PARAMETER:
                error(position, "generic parameter '\{s.name}' is not an expression")
                return null
            otherwise:
                assert false, "unsupported symbol kind: \{s}"
        }
    }

    method isValueInit(m:MethodDecl):Bit {
        return m.methodKind = MethodDecl.Kind.INIT & isValue(m.owner)
    }

    method implicitInit(position:Position, value:IR.Value, m:MethodDecl):IR.Value {
        def cl := m.owner
        assert isValue(cl)
        def coerced := coerce(position, value, m.parameters[0].type)
        assert coerced !== null
        def args := Array<IR.Value>() -- FIXME literal
        args.add(coerced)
        def result := ir.add(IR.Statement.STATIC_CALL(m, args.finish()))
        return IR.Value.REF(result, m.owner.type)
    }

    method createMethodObject(position:Position, target:IR.Value?, m:MethodDecl):IR.Value? {
        def effectiveType:Type
        def irType:Type
        if target !== null {
            if m.annotations.isClass() {
                assert target.type().isClassLiteral()
                effectiveType := m.type()
                irType := Type.pointerTo(m.type())
            }
            else {
                effectiveType := MethodRef(self, target.type(), m).effectiveType
                irType := Type.pointerTo(declaredTypeWithSelf(m, m.owner.type))
            }
        }
        else {
            if m.annotations.isClass() {
                effectiveType := m.type()
                irType := Type.pointerTo(m.type())
            }
            else {
                effectiveType := declaredTypeWithSelf(m, m.owner.type)
                irType := Type.pointerTo(declaredTypeWithSelf(m, m.owner.type))
            }
        }
        def args := Array<ASTNode>()
        args.add(ASTNode.IR_WRAPPER(position, cast(IR.Value.METHOD_POINTER(m, irType),
                Type.pointerTo(Type.Int8()))))
        if m.annotations.isClass() {
            args.add(ASTNode.NULL(position))
        }
        else {
            args.add(ASTNode.IR_WRAPPER(position, target))
        }
        def methodType:Type
        if target !== null & !isImmutable(target.type()) {
            methodType := Type.MutableMethod()
        }
        else {
            methodType := Type.Method()
        }
        return cast(call(position, IR.Value.TYPE(methodType), args, TypeContext.UNSPECIFIED),
                effectiveType)
    }

    function explainCoerceFailure(m:MethodDecl, target:Type):String {
        if m.parameters.count != target.parameterCount {
            return "wrong parameter count"
        }
        for i in 0 .. m.parameters.count {
            if coercionCost(target.parameterType(i), m.parameters[i].type) == null {
                return "parameter \{i + 1} cannot be converted from '\{target.parameterType(i)}' " +
                        "to '\{m.parameters[i].type}'"
            }
        }
        if coercionCost(m.returnType, target.returnType()) == null {
            return "return type '\{m.returnType}' cannot be converted to '\{target.returnType}'"
        }
        if m.methodKind = MethodDecl.Kind.METHOD & (target.typeKind = Type.Kind.FUNCTION |
                target.typeKind = Type.Kind.IMMUTABLE_FUNCTION) {
            return "cannot use a method where a function is expected"
        }
    }

    @pre(target != Type.Void())
    method coerce(position:Position, value:IR.Value?, target:Type):IR.Value? {
        if value == null {
            return null
        }
        if value.type() = target {
            return value
        }
        match value {
            when IR.Value.METHOD(targetObj, m):
                def result := createMethodObject(position, targetObj, m)
                if coercionCost(result.type(), target) == null {
                    error(position, "expected '\{target}', but found '\{result.type()}'")
                    return null
                }
                return coerce(position, result, target)
            when IR.Value.METHODS(targetObj, methods):
                def best := Array<MethodDecl>()
                var bestCost := Int.MAX
                for m in methods {
                    if resolve(m) {
                        def cost := coercionCost(m.type(), target)
                        if cost !== null {
                            if cost < bestCost {
                                best.clear()
                                bestCost := cost
                            }
                            if cost = bestCost {
                                best.add(m)
                            }
                        }
                    }
                }
                if best.count = 1 {
                    return coerce(position, IR.Value.METHOD(targetObj, best[0]), target)
                }
                if best.count > 1 {
                    error(position, "ambiguous method reference")
                    return null
                }
                def msg := MutableString("reference to method '\{methods[0].name}' cannot be " +
                        "used as type '\{target}'. None of the following methods match this type:")
                for m in methods {
                    msg.append("\n    \{m.declaration()} (\{explainCoerceFailure(m, target)})")
                }
                error(position, msg.finish())
                return null
        }
        if coercionCost(value.type(), target) !== null {
            def cl := getClass(target)
            if cl == null {
                return null
            }
            def inits := getSymbolTable(cl)["init"]
            assert inits !== null
            match inits.kind {
                when Symbol.Kind.METHOD:
                    def m := inits->MethodDecl
                    if m.annotations.isImplicit() {
                        if resolve(m) & coercionCost(value.type(), m.parameters[0].type) !== null {
                            return implicitInit(position, value, m)
                        }
                    }
                when Symbol.Kind.METHODS:
                    def methods := inits->Methods.methods.filter(m => m.annotations.isImplicit())
                    if methods.count > 0 {
                        def args := Array<ASTNode>()
                        args.add(ASTNode.IR_WRAPPER(position, value))
                        def best := findBestMethod(position, null, methods, args,
                                TypeContext.UNSPECIFIED)
                        if best !== null {
                            if best.first.count = 1 {
                                return implicitInit(position, value, best.first[0].value)
                            }
                            assert false, "ambiguous implicit init"
                        }
                    }
            }
            assert value.type().isClass()
            def result := IR.Value.REF(ir.add(IR.Statement.CAST(value, target)), target)
            if !isRefCounted(value.type()) & isRefCounted(target) {
                statementUnrefs.add(result)
            }
            return result
        }
        error(position, "expected '\{target}', but found '\{value.type()}'")
        return null
    }

    method coerce(position:Position, value:IR.Value?, type:TypeContext):IR.Value? {
        if value == null {
            return value
        }
        match type {
            when TypeContext.UNSPECIFIED, TypeContext.NON_VOID:
                return value
            when TypeContext.IMMUTABLE:
                if isImmutable(value.type()) {
                    return value
                }
                error(position, "expected 'panda.core.Immutable', but found '\{value.type()}'")
                return null
            when TypeContext.TYPE(t):
                return coerce(position, value, t)
            otherwise:
                assert false
        }
    }

    @pre(target != Type.Void() & target.resolved)
    method cast(value:IR.Value?, target:Type):IR.Value? {
        if value == null {
            return null
        }
        if value.type() = target {
            return value
        }
        if coercionCost(value.type(), target) !== null {
            return coerce(Position(), value, TypeContext.TYPE(target))
        }
        def result := IR.Value.REF(ir.add(IR.Statement.CAST(value, target)), target)
        if !isRefCounted(value.type()) & isRefCounted(target) {
            statementUnrefs.add(result)
        }
        return result
    }

    method convert(value:IR.Value?, target:Type):IR.Value? {
        if value == null {
            return value
        }
        if value.type() = target {
            return value
        }
        return call(Position(), value, "convert", Array<ASTNode>() -* FIXME literal *-,
                TypeContext.TYPE(target))
    }

    method getVTableIndex(m:MethodDecl):Int {
        def vtable := getVTable(m.owner)
        for i in 0 .. vtable.count {
            if vtable[i] == m {
                return i
            }
        }
        assert false, "could not find \{m.declaration} in vtable for \{m.owner.name}"
        return -1
    }

    @pre(isRefCounted(v.type()))
    method compileRef(v:IR.Value) {
        def args := Array<ASTNode>()
        args.add(ASTNode.IR_WRAPPER(Position(), v))
        call(Position(), IR.Value.TYPE(Type.Panda()), "ref", args, TypeContext.UNSPECIFIED)
    }

    @pre(isRefCounted(v.type()))
    method compileUnref(v:IR.Value) {
        def args := Array<ASTNode>()
        args.add(ASTNode.IR_WRAPPER(Position(), v))
        call(Position(), IR.Value.TYPE(Type.Panda()), "unref", args, TypeContext.UNSPECIFIED)
    }

    method compileIntrinsic(target:IR.Value?, m:MethodRef,
            args:ListView<ASTNode>):Pair<Bit, IR.Value?> {
        if m.target.isPointer() | m.target.isClassLiteral() & m.target.subtypes[1].isPointer() {
            def pointerType:Type?
            if m.target.isPointer() {
                pointerType := resolve(m.target.subtypes[1])
            }
            else {
                pointerType := resolve(m.target.subtypes[1].subtypes[1])
            }
            if pointerType == null {
                return Pair<Bit, IR.Value?>(false, null)
            }
            assert m.target.typeKind = Type.Kind.GENERIC
            match m.value.name {
                when "alloc":
                    def count := compileExpression(args[0], TypeContext.TYPE(Type.Int64()))
                    if count == null {
                        return Pair<Bit, IR.Value?>(false, null)
                    }
                    def alloc := ir.add(IR.Statement.POINTER_ALLOC(extractBuiltinInt(count),
                                pointerType))
                    return Pair<Bit, IR.Value?>(true,
                            IR.Value.REF(alloc, Type.pointerTo(pointerType)))
                when "destroy":
                    assert target !== null
                    ir.add(IR.Statement.POINTER_DESTROY(target))
                    return Pair<Bit, IR.Value?>(true, null)
                when "realloc":
                    assert target !== null
                    def oldCount := compileExpression(args[0], TypeContext.TYPE(Type.Int64()))
                    if oldCount == null {
                        return Pair<Bit, IR.Value?>(false, null)
                    }
                    def newCount := compileExpression(args[1], TypeContext.TYPE(Type.Int64()))
                    if newCount == null {
                        return Pair<Bit, IR.Value?>(false, null)
                    }
                    def realloc := ir.add(IR.Statement.POINTER_REALLOC(target,
                            extractBuiltinInt(oldCount),
                            extractBuiltinInt(newCount)))
                    return Pair<Bit, IR.Value?>(true,
                            IR.Value.REF(realloc, Type.pointerTo(pointerType)))
                when "get":
                    assert target !== null
                    def get := ir.add(IR.Statement.POINTER_GET(target))
                    return Pair<Bit, IR.Value?>(true, IR.Value.REF(get, pointerType))
                when "offset":
                    assert target !== null
                    def value := compileExpression(args[0], TypeContext.TYPE(Type.Int64()))
                    def offset := ir.add(IR.Statement.POINTER_OFFSET(target,
                            extractBuiltinInt(value)))
                    return Pair<Bit, IR.Value?>(true, IR.Value.REF(offset,
                            Type.pointerTo(pointerType)))
                when "[]":
                    assert target !== null
                    def index := compileExpression(args[0], TypeContext.TYPE(Type.Int64()))
                    if index == null {
                        return Pair<Bit, IR.Value?>(false, null)
                    }
                    def get := ir.add(IR.Statement.POINTER_GET_INDEX(target,
                            extractBuiltinInt(index)))
                    return Pair<Bit, IR.Value?>(true, IR.Value.REF(get, pointerType))
                when "[]:=":
                    assert target !== null
                    def index := compileExpression(args[0], TypeContext.TYPE(Type.Int64()))
                    def value := compileExpression(args[1], TypeContext.TYPE(pointerType))
                    if index == null | value == null {
                        return Pair<Bit, IR.Value?>(false, null)
                    }
                    def indexValue := extractBuiltinInt(index)
                    if isRefCounted(value.type()) {
                        def load := ir.add(IR.Statement.POINTER_GET_INDEX(target, indexValue))
                        compileUnref(IR.Value.REF(load, value.type()))
                        compileRef(value)
                    }
                    ir.add(IR.Statement.POINTER_SET_INDEX(value, target, indexValue))
                    return Pair<Bit, IR.Value?>(true, null)
                otherwise:
                    assert false, "unsupported pointer intrinsic: \{m.value.name}"
            }
        }
        return Pair<Bit, IR.Value?>(false, null)
    }

    @post((m.returnType = Type.Void() & @return == null) | @return !== null | errorCount > 0 |
            !reportErrors)
    method call(position:Position, target:IR.Value?, m:MethodRef, args:ListView<ASTNode>,
            type:TypeContext):IR.Value? {
        if args.count != m.parameterCount {
            error(position, "\{m.value.declaration()} expects \{m.parameterCount}" +
                    "\{m.parameterCount = 1:|s} argument, but found \{args.count}")
            return null
        }
        if target !== null & m.value.annotations.isClass() {
            match target {
                when IR.Value.TYPE:
                    -- do nothing
                otherwise:
                    error(position, "cannot call class \{m.value.declaration()} on an instance")
            }
        }
        var intrinsic := compileIntrinsic(target, m, args)
        if intrinsic.first {
            return coerce(position, intrinsic.second, type)
        }
        def isSuper:Bit
        if target !== null {
            match target {
                when IR.Value.SUPER:
                    isSuper := true
                otherwise:
                    isSuper := false
            }
        }
        else {
            isSuper := false
        }
        -- actualType always has a "self", even for a @class method. This will probably be tightened
        -- up in the future, but it simplifies the logic a bit here.
        def actualType:Type
        if m.value.isVirtual {
            actualType := inheritedTypeWithSelf(m.value)
        }
        else {
            actualType := declaredTypeWithSelf(m.value, m.value.owner.type)
        }
        def effectiveType := m.effectiveType
        def finalArgs := Array<IR.Value>(args.count)
        def finalTarget:IR.Value?
        if target !== null {
            match target {
                when IR.Value.TYPE:
                    -- do nothing
                otherwise:
                    if m.value.owner.name = POINTER_NAME {
                        finalTarget := coerce(position, target, actualType.parameterType(0))
                    }
                    else if isSuper {
                        finalTarget := coerce(position, compileSelf(position, false),
                                m.value.owner.type)
                    }
                    else {
                        finalTarget := coerce(position, target, m.value.owner.type)
                    }
                    if finalTarget == null {
                        return null
                    }
                    finalArgs.add(finalTarget)
            }
        }
        else if !m.value.annotations.isClass() & !isValueInit(m.value) {
            finalTarget := coerce(position, compileSelf(position, false), m.value.owner.type)
            finalArgs.add(finalTarget)
        }
        else {
            finalTarget := null
        }
        for i in 0 .. args.count {
            var a := compileExpression(args[i],
                    TypeContext.TYPE(effectiveType.parameterType(i)))
            if a == null {
                return null
            }
            if a.type() != actualType.parameterType(i + 1) {
                a := cast(a, actualType.parameterType(i + 1))
            }
            if a == null {
                return null
            }
            finalArgs.add(a)
        }
        var result:IR.Statement.ID
        if !isSuper & m.value.isVirtual {
            def mref:IR.Statement.ID
            if m.value.owner.classKind = ClassDecl.Kind.INTERFACE {
                mref := ir.add(IR.Statement.GET_INTERFACE_METHOD(finalTarget, m.value.owner,
                        getVTableIndex(m.value) - getVTable(getClass(Type.Object())).count,
                        actualType))
            }
            else {
                mref := ir.add(IR.Statement.GET_VIRTUAL_METHOD(finalTarget, getVTableIndex(m.value),
                        actualType))
            }
            result := ir.add(IR.Statement.DYNAMIC_CALL(IR.Value.REF(mref, actualType),
                    finalArgs.finish()))
        }
        else {
            result := ir.add(IR.Statement.STATIC_CALL(m.value, finalArgs.finish()))
        }
        if m.returnType != Type.Void() {
            var resultCast:IR.Value? := IR.Value.REF(result, actualType.returnType())
            if isRefCounted(actualType.returnType()) {
                statementUnrefs.add(resultCast)
            }
            if m.value.methodKind != MethodDecl.Kind.INIT &
                    effectiveType.returnType() != actualType.returnType() {
                resultCast := cast(resultCast, effectiveType.returnType())
                if resultCast == null {
                    return null
                }
            }
            resultCast := coerce(position, resultCast, type)
            return resultCast
        }
        if type != TypeContext.UNSPECIFIED {
            error(position, "\{m.value.declaration()} does not return a value")
        }
        return null
    }

    method call(position:Position, target:IR.Value, m:String, args:ListView<ASTNode>,
            type:TypeContext):IR.Value? {
        def cl := getClass(target.type())
        if cl == null {
            return null
        }
        def s := getSymbolTable(cl)[m]
        assert s !== null, "could not find \{m} in \{cl.name}"
        def ref := symbolRef(position, target, s)
        return call(position, ref, args, type)
    }

    @post(@return == null | @return.first.count > 0)
    method findBestMethod(position:Position, target:IR.Value?, methods:ListView<MethodDecl>,
            args:ListView<ASTNode>, type:TypeContext):Pair<ListView<MethodRef>, Int>? {
        if methods.count = 0 {
            return null
        }
        var bestCost := Int.MAX
        var best := Array<MethodRef>()
        outer: for m in methods {
            if m.parameters.count != args.count {
                continue
            }
            if !resolve(m) {
                continue
            }
            def ref:MethodRef
            if target !== null {
                ref := MethodRef(self, target.type(), m)
            }
            else if m.annotations.isClass() | m.methodKind = MethodDecl.Kind.INIT {
                ref := MethodRef(self, m.owner.type, m)
            }
            else {
                ref := MethodRef(self, findType(currentClass[0].type, m.owner), m)
            }
            var cost := 0
            for i in 0 .. 5 { Panda.ref(ref) } -- FIXME seems to be a bug in the bootstrap compiler's refcounting
            for i in 0 .. args.count {
                def argCost := coercionCost(args[i], ref.parameterType(i))
                if argCost == null {
                    continue outer
                }
                cost += argCost
            }
            match type {
                when TypeContext.IMMUTABLE:
                    if m.returnType = Type.Void() | !isImmutable(ref.returnType) {
                        continue
                    }
                when TypeContext.TYPE(t):
                    def returnCost := coercionCost(ref.returnType, t)
                    if returnCost == null {
                        continue
                    }
                    cost += returnCost
            }
            cost -= m.priority
            if cost < bestCost {
                bestCost := cost
                best.clear()
            }
            if cost = bestCost {
                best.add(ref)
            }
        }
        if best.count = 0 {
            return null
        }
        return Pair<ListView<MethodRef>, Int>(best, bestCost)
    }

    method callMethodObject(position:Position, m:IR.Value, args:ListView<ASTNode>,
            type:TypeContext):IR.Value? {
        def t := m.type().nonnullable()
        if !t.isMethod() {
            error(position, "value of type '\{t}' is not a method")
            return null
        }
        if t.parameterCount != args.count {
            error(position, "method of type '\{t}' expected \{t.parameterCount} " +
                    "argument\{t.parameterCount = 1:|s}, but found \{args.count}")
            return null
        }
        def finalArgs := Array<IR.Value>(args.count)
        for i in 0 .. args.count {
            def compiled := compileExpression(args[i], TypeContext.TYPE(t.parameterType(i)))
            if compiled == null {
                return null
            }
            finalArgs.add(compiled)
        }
        def result:IR.Value?
        def resultSlot := ir.locals.count
        if t.returnType() != Type.Void() {
            ir.locals.add(t.returnType())
            result := IR.Value.LOCAL(resultSlot, t.returnType())
        }
        else {
            result := null
        }
        def methodType:Type
        def targetType:Type
        if isImmutable(m.type()) {
            methodType := Type.Method()
            targetType := Type.Immutable()
        }
        else {
            methodType := Type.MutableMethod()
            targetType := Type.Object()
        }
        def st := getSymbolTable(getClass(methodType))
        def pointerField := st["pointer"]->FieldDecl
        if !resolve(pointerField) {
            return null
        }
        def methodObj := cast(m, methodType)
        def methodPtrPtr := ir.add(IR.Statement.GET_FIELD_POINTER(methodObj, pointerField))
        def methodPtr := ir.add(IR.Statement.LOAD(IR.Value.REF(methodPtrPtr,
                Type.pointerTo(Type.Int8()))))
        def targetField := st["target"]->FieldDecl
        if !resolve(targetField) {
            return null
        }
        def targetPtr := ir.add(IR.Statement.GET_FIELD_POINTER(methodObj, targetField))
        def target := ir.add(IR.Statement.LOAD(IR.Value.REF(targetPtr, targetType)))
        def targetNonNull := ir.add(IR.Statement.BINARY(IR.Value.REF(target, targetType),
                Token.Kind.NIDENTITY, IR.Value.NULL(targetType.nullable()), Type.BuiltinBit()))
        def haveTargetBlock := ir.newBlock("dynamic call with target")
        def noTargetBlock := ir.newBlock("dynamic call without target")
        def mergeBlock := ir.newBlock("dynamic call merge")
        ir.add(IR.Statement.CONDITIONAL_BRANCH(IR.Value.REF(targetNonNull,
                Type.BuiltinBit()), haveTargetBlock, noTargetBlock))
        ir.setCurrentBlock(noTargetBlock)
        def noTargetCast := cast(IR.Value.REF(methodPtr, Type.pointerTo(Type.Int8())),
                Type.pointerTo(t))
        def noTargetResult := ir.add(IR.Statement.DYNAMIC_CALL(noTargetCast,
                ImmutableArray<IR.Value>(finalArgs)))
        if result !== null {
            ir.add(IR.Statement.STORE(IR.Value.REF(noTargetResult, t.returnType()), result))
        }
        ir.add(IR.Statement.BRANCH(mergeBlock))
        ir.setCurrentBlock(haveTargetBlock)
        def targetParams := Array<Type>()
        targetParams.add(targetType)
        for i in 0 .. t.parameterCount {
            targetParams.add(t.parameterType(i))
        }
        def haveTargetType := Type.methodType(position, t.typeKind, targetParams,
                t.returnType(), 0)
        def haveTargetCast := cast(IR.Value.REF(methodPtr, Type.pointerTo(Type.Int8())),
                Type.pointerTo(haveTargetType))
        finalArgs.insert(0, IR.Value.REF(target, targetType))
        def haveTargetResult := ir.add(IR.Statement.DYNAMIC_CALL(haveTargetCast,
                ImmutableArray<IR.Value>(finalArgs)))
        if result !== null {
            ir.add(IR.Statement.STORE(IR.Value.REF(haveTargetResult, t.returnType()), result))
        }
        ir.add(IR.Statement.BRANCH(mergeBlock))
        ir.setCurrentBlock(mergeBlock)
        if result !== null {
            def resultLoad := ir.add(IR.Statement.LOAD(result))
            def loadRef := IR.Value.REF(resultLoad, t.returnType())
            if isRefCounted(t.returnType()) {
                statementUnrefs.add(loadRef)
            }
            return coerce(position, loadRef, type)
        }
        return null
    }

    @pre(methods.count > 1)
    method reportAmbiguousMatch(position:Position, methods:ListView<MethodRef>,
            args:ListView<ASTNode>, type:TypeContext) {
        def msg := MutableString("call to '\{methods[0].value.name}' is ambiguous. The following " +
                "methods are equally good matches:")
        for m in methods {
            msg.append("\n    \{m.value.declaration()} (\{m.value.owner.source.name()}:" +
                    "\{m.value.position})")
        }
        error(position, msg.finish())
    }

    method call(position:Position, m:IR.Value, args:ListView<ASTNode>,
            type:TypeContext):IR.Value? {
        match m {
            when IR.Value.METHOD(target, m):
                def targetType:Type
                if target !== null {
                    targetType := target.type()
                }
                else if m.annotations.isClass() | m.methodKind = MethodDecl.Kind.INIT {
                    targetType := m.owner.type
                }
                else {
                    def found := findType(currentClass[0].type, m.owner)
                    assert found !== null,
                            "could not find \{currentClass[0].type} in \{m.owner.name}"
                    targetType := found
                }
                if !resolve(m) {
                    return null
                }
                return call(position, target, MethodRef(self, targetType, m), args, type)
            when IR.Value.METHODS(target, methods):
                def best := findBestMethod(position, target, methods, args, type)
                if best !== null {
                    if best.first.count > 1 {
                        reportAmbiguousMatch(position, best.first, args, type)
                        return null
                    }
                    return call(position, target, best.first[0], args, type)
                }
                -- no match
                def argTypes := Array<Type>()
                for a in args {
                    def preferred := preferredType(a)
                    if preferred == null {
                        -- force it to produce an error
                        def oldErrorCount := errorCount
                        compileExpression(a)
                        if errorCount = oldErrorCount {
                            -- could not determine type
                            error(position, "no match for call to '\{methods[0].name}'")
                        }
                        return null
                    }
                    argTypes.add(preferred)
                }
                error(position, "no match for \{methods[0].name}(\{argTypes.join(", ")})" +
                        type.description())
                return null
            when IR.Value.PARAMETER, IR.Value.REF:
                return callMethodObject(position, m, args, type)
            when IR.Value.TYPE(t):
                def finalType:Type
                if t.isClassLiteral() {
                    finalType := t.subtypes[1]
                }
                else {
                    finalType := t
                }
                def cl := getClass(finalType)
                if cl == null {
                    return null
                }
                def inits := getSymbolTable(cl)["init"]
                assert inits !== null, "no init for \{cl.name}"
                if isValue(cl) {
                    return coerce(position, cast(call(position, symbolRef(position, null, inits),
                            args, type), finalType), type)
                }
                def construct := ir.add(IR.Statement.CONSTRUCT(cl))
                def constructRef := IR.Value.REF(construct, finalType)
                assert statementUnrefs !== null
                statementUnrefs.add(constructRef)
                call(position, symbolRef(position, constructRef, inits), args,
                        TypeContext.UNSPECIFIED)
                return coerce(position, constructRef, type)
            otherwise:
                assert false, "cannot call \{m}"
        }
    }

    method findOverloadedOperator(left:Type, op:Token.Kind, right:ASTNode,
            type:TypeContext):Pair<ListView<MethodRef>, Int>? {
        if !left.isClass() {
            return null
        }
        def leftCl := getClass(left)
        if leftCl == null {
            return null
        }
        def target := IR.Value.REF(IR.Statement.ID(-1), left) -- fake target, just used for matching
        var methods := getSymbolTable(leftCl)[operatorName(op)]
        if methods !== null {
            def args := Array<ASTNode>() -- FIXME literal
            args.add(right)
            -- look for left.op(right)
            match methods.kind {
                when Symbol.Kind.METHOD:
                    if !methods->MethodDecl.annotations.isClass() {
                        def list := Array<MethodDecl>()
                        list.add(methods->MethodDecl)
                        def result := findBestMethod(Position(), target, list, args, type)
                        if result !== null {
                            return result
                        }
                    }
                when Symbol.Kind.METHODS:
                    def result := findBestMethod(Position(), target,
                            methods->Methods.methods.filter(m => !m.annotations.isClass()), args,
                                    type)
                    if result !== null {
                        return result
                    }
                otherwise:
                    assert false
            }
        }

        -- look for RightClass.op(left, right)
        def rightType := preferredType(right)
        if rightType == null {
            return null
        }
        if !rightType.isClass() {
            return null
        }
        def rightCl := getClass(rightType)
        if rightCl == null {
            return null
        }
        methods := getSymbolTable(rightCl)[operatorName(op)]
        if methods == null {
            return null
        }
        def args := Array<ASTNode>() -- FIXME literal
        args.add(ASTNode.IR_WRAPPER(Position(), target))
        args.add(right)
        match methods.kind {
            when Symbol.Kind.METHOD:
                if methods->MethodDecl.annotations.isClass() {
                    def list := Array<MethodDecl>()
                    list.add(methods->MethodDecl)
                    def result := findBestMethod(Position(), null, list, args, type)
                    if result !== null {
                        return result
                    }
                }
            when Symbol.Kind.METHODS:
                def result := findBestMethod(Position(), null,
                        methods->Methods.methods.filter(m => m.annotations.isClass()), args, type)
                if result !== null {
                    return result
                }
            otherwise:
                assert false
        }
        return null
    }

    method findOverloadedOperator(left:ASTNode, op:Token.Kind, right:ASTNode,
            type:TypeContext):Pair<ListView<MethodRef>, Int>? {
        def leftTypes := possibleTypes(left)
        if leftTypes !== null {
            def best:Pair<ListView<MethodRef>, Int>? := null
            for t in leftTypes {
                def selfCost := coercionCost(left, t)
                assert selfCost !== null, "failed self cast \{left}->\{t} at \{left.position()}"
                def ops := findOverloadedOperator(t, op, right, type)
                if ops !== null {
                    def cost := ops.second + selfCost
                    if best == null | cost < best.second {
                        best := Pair<ListView<MethodRef>, Int>(ops.first, cost)
                    }
                    else if cost = best.second {
                        def a := Array<MethodRef>()
                        a.addAll(best.first)
                        a.addAll(ops.first)
                        best := Pair<ListView<MethodRef>, Int>(a, cost)
                    }
                }
            }
            return best
        }
        return null
    }

    ================================================================================================
    Returns the type under which a particular class was inherited. For instance,
    `HashMap<String, File>` inherits `MapView` under the type `MapView<String, File>`.
    ================================================================================================
    function findType(start:Type, target:ClassDecl):Type? {
        if !start.isClass() {
            return null
        }
        if start.typeKind = Type.Kind.GENERIC_PARAMETER {
            return findType(start.genericParameter.bound, target)
        }
        def startClass := getClass(start)
        if startClass == null {
            return null
        }
        if startClass == target {
            return start.nonnullable()
        }
        assert startClass.name != target.name, "duplicate class: \{startClass.name}"
        if startClass.rawSuper !== null {
            def result := findType(remapType(start, startClass.rawSuper),
                    target)
            if result !== null {
                return result
            }
        }
        for intf in startClass.rawInterfaces {
            def result := findType(remapType(start, intf), target)
            if result !== null {
                return result
            }
        }
        return null
    }

    function findType(start:CollectionView<Type>, target:ClassDecl):Type? {
        for t in start {
            def result := findType(t, target)
            if result !== null {
                return result
            }
        }
        return null
    }

    method foldInts(left:ASTNode, op:Token.Kind, right:ASTNode):ASTNode? {
        def l:Int64
        def r:Int64
        -- ensure both values fit into a signed Int64
        match left {
            when ASTNode.INT(_, int):
                if int > Int64.MAX.convert() {
                    return null
                }
                l := int.convert()
            otherwise:
                return null
        }
        match right {
            when ASTNode.INT(_, int):
                if int > Int64.MAX.convert() {
                    return null
                }
                r := int.convert()
            otherwise:
                return null
        }
        match op {
            when Token.Kind.ADD:
                def v := (l + r).convert()->UInt64
                return ASTNode.INT(left.position(), v)
            when Token.Kind.SUB:
                def v := (l - r).convert()->UInt64
                return ASTNode.INT(left.position(), v)
            when Token.Kind.MUL:
                def v := (l * r).convert()->UInt64
                return ASTNode.INT(left.position(), v)
            when Token.Kind.INTDIV:
                if r = 0 {
                    error(right.position(), "division by 0")
                    return null
                }
                def v := (l // r).convert()->UInt64
                return ASTNode.INT(left.position(), v)
            when Token.Kind.REM:
                if r = 0 {
                    error(right.position(), "division by 0")
                    return null
                }
                def v := (l % r).convert()->UInt64
                return ASTNode.INT(left.position(), v)
            when Token.Kind.EQ:
                return ASTNode.BIT(left.position(), l = r)
            when Token.Kind.NEQ:
                return ASTNode.BIT(left.position(), l != r)
            when Token.Kind.LT:
                return ASTNode.BIT(left.position(), l < r)
            when Token.Kind.GT:
                return ASTNode.BIT(left.position(), l > r)
            when Token.Kind.LTEQ:
                return ASTNode.BIT(left.position(), l <= r)
            when Token.Kind.GTEQ:
                return ASTNode.BIT(left.position(), l >= r)
            when Token.Kind.BITWISEAND:
                def v := (l && r).convert()->UInt64
                return ASTNode.INT(left.position(), v)
            when Token.Kind.BITWISEOR:
                def v := (l || r).convert()->UInt64
                return ASTNode.INT(left.position(), v)
            when Token.Kind.BITWISEXOR:
                def v := (l ~~ r).convert()->UInt64
                return ASTNode.INT(left.position(), v)
            when Token.Kind.SHIFTLEFT:
                def v := (l << r).convert()->UInt64
                return ASTNode.INT(left.position(), v)
            when Token.Kind.SHIFTRIGHT:
                def v := (l >> r).convert()->UInt64
                return ASTNode.INT(left.position(), v)
        }
        error(left.position(), "'\{operatorName(op)}' cannot operate on 'panda.core.Int64', " +
                "'panda.core.Int64'")
        return null
    }

    function foldStrings(left:ASTNode, op:Token.Kind, right:ASTNode):ASTNode? {
        if op != Token.Kind.ADD {
            return null
        }
        match left {
            when ASTNode.STRING(position, s1):
                match right {
                    when ASTNode.STRING(_, s2):
                        return ASTNode.STRING(position, s1 + s2)
                }
        }
        return null
    }

    function fold(left:ASTNode, op:Token.Kind, right:ASTNode):ASTNode? {
        match left {
            when ASTNode.INT:
                return foldInts(left, op, right)
            when ASTNode.STRING:
                return foldStrings(left, op, right)
            otherwise:
                return null
        }
    }

    method compileAtPre(position:Position, expr:ASTNode):IR.Value? {
        if atPreBlock == null {
            error(position, "@pre may only be used within a postcondition")
            return null
        }
        def old := ir.currentBlock.id
        ir.setCurrentBlock(atPreBlock)
        def result := compileExpression(expr)
        ir.setCurrentBlock(old)
        return result
    }

    method compileAtReturn(position:Position):IR.Value? {
        if currentMethod[0].returnType = Type.Void() {
            error(position, "cannot use @return in a method with no return value")
            return null
        }
        if returnValue == null {
            error(position, "cannot use @return outside of a postcondition")
            return null
        }
        return returnValue
    }

    method compileAnd(position:Position, left:ASTNode, right:ASTNode, type:TypeContext):IR.Value? {
        -- FIXME should add phis so we can avoid using a local
        def result := IR.Value.LOCAL(ir.locals.count, Type.Bit())
        ir.locals.add(Type.Bit())
        def compiledLeft:IR.Value?
        {
            def auto := AutoUnrefs(self)
            compiledLeft := compileExpression(left, TypeContext.TYPE(Type.Bit()))
            if compiledLeft == null {
                return null
            }
        }
        def ifTrue := ir.newBlock("and true")
        def ifFalse := ir.newBlock("and false")
        def merge := ir.newBlock("and merge")
        ir.add(IR.Statement.CONDITIONAL_BRANCH(extractBuiltinBit(compiledLeft), ifTrue, ifFalse))
        ir.setCurrentBlock(ifTrue)
        def compiledRight:IR.Value?
        {
            def auto := AutoUnrefs(self)
            compiledRight := compileExpression(right, TypeContext.TYPE(Type.Bit()))
            if compiledRight == null {
                return null
            }
        }
        ir.add(IR.Statement.STORE(compiledRight, result))
        ir.add(IR.Statement.BRANCH(merge))
        ir.setCurrentBlock(ifFalse)
        ir.add(IR.Statement.STORE(compiledLeft, result))
        ir.add(IR.Statement.BRANCH(merge))
        ir.setCurrentBlock(merge)
        def load := ir.add(IR.Statement.LOAD(result))
        return IR.Value.REF(load, Type.Bit())
    }

    method compileOr(position:Position, left:ASTNode, right:ASTNode, type:TypeContext):IR.Value? {
        -- FIXME should add phis so we can avoid using a local
        def result := IR.Value.LOCAL(ir.locals.count, Type.Bit())
        ir.locals.add(Type.Bit())
        def compiledLeft:IR.Value?
        {
            def auto := AutoUnrefs(self)
            compiledLeft := compileExpression(left, TypeContext.TYPE(Type.Bit()))
            if compiledLeft == null {
                return null
            }
        }
        def ifTrue := ir.newBlock("or true")
        def ifFalse := ir.newBlock("or false")
        def merge := ir.newBlock("or merge")
        ir.add(IR.Statement.CONDITIONAL_BRANCH(extractBuiltinBit(compiledLeft), ifTrue, ifFalse))
        ir.setCurrentBlock(ifTrue)
        ir.add(IR.Statement.STORE(compiledLeft, result))
        ir.add(IR.Statement.BRANCH(merge))
        ir.setCurrentBlock(ifFalse)
        def compiledRight:IR.Value?
        {
            def auto := AutoUnrefs(self)
            compiledRight := compileExpression(right, TypeContext.TYPE(Type.Bit()))
            if compiledRight == null {
                return null
            }
        }
        ir.add(IR.Statement.STORE(compiledRight, result))
        ir.add(IR.Statement.BRANCH(merge))
        ir.setCurrentBlock(merge)
        def load := ir.add(IR.Statement.LOAD(result))
        return IR.Value.REF(load, Type.Bit())
    }

    method compileBinary(position:Position, left:ASTNode, op:Token.Kind, right:ASTNode,
            type:TypeContext):IR.Value? {
        def folded := fold(left, op, right)
        if folded !== null {
            return compileExpression(folded, type)
        }
        match op {
            when Token.Kind.CAST:
                def target := scanner.convertType(right)
                return coerce(position, compileCast(position, left, target), type)
            when Token.Kind.IDENTITY, Token.Kind.NIDENTITY:
                return compileIdentityComparison(position, left, op, right, type)
            otherwise:
                def matches := findOverloadedOperator(left, op, right, type)
                if matches !== null {
                    if matches.first.count > 1 {
                        def args := Array<ASTNode>()
                        args.add(left)
                        args.add(right)
                        reportAmbiguousMatch(position, matches.first, args, type)
                        return null
                    }
                    def args := Array<ASTNode>() -- FIXME literal
                    def m := matches.first[0].value
                    if m.annotations.isClass() {
                        args.add(left)
                        args.add(right)
                        return call(position, IR.Value.METHOD(null, m), args,
                                type)
                    }
                    if m.owner.name = "panda.core.Bit" {
                        if m.name = "&" {
                            return compileAnd(position, left, right, type)
                        }
                        if m.name = "|" {
                            return compileOr(position, left, right, type)
                        }
                    }
                    def found := findType(possibleTypes(left), m.owner)
                    assert found !== null
                    def target := compileExpression(left, TypeContext.TYPE(found))
                    if target == null {
                        return null
                    }
                    args.add(right)
                    return call(position, IR.Value.METHOD(target, m), args, type)
                }
                def compiledLeft := compileExpression(left, TypeContext.NON_VOID)
                if compiledLeft == null {
                    return null
                }
                def compiledRight := compileExpression(right, TypeContext.TYPE(compiledLeft.type()))
                if compiledRight == null {
                    return null
                }
                if (compiledLeft.type() = Type.BuiltinBit() |
                        compiledLeft.type().isBuiltinNumber()) {
                    def resultType := preferredType(ASTNode.BINARY(position, left, op,
                             right))
                    if resultType !== null {
                        def result := ir.add(IR.Statement.BINARY(compiledLeft, op,
                                compiledRight, resultType))
                        return coerce(position, IR.Value.REF(result, resultType), type)
                    }
                }
                error(position, "no match for '\{operatorName(op)}' on " +
                        "'\{compiledLeft.type()}', '\{compiledRight.type()}'" +
                        type.description())
                return null
        }
    }

    method compileChoiceCaseReference(position:Position, owner:Type, cc:ChoiceCase,
            args:ImmutableArray<ASTNode>, type:TypeContext):IR.Value? {
        resolve(cc)
        def initMethod := cc.initMethod
        resolve(initMethod)
        if args.count != cc.fields.count {
            error(position, "'\{cc}' expected \{cc.fields.count} argument" +
                    "\{cc.fields.count = 1:|s}, but found \{args.count}")
            return null
        }
        def finalArgs := Array<ASTNode>() -- FIXME literal
        finalArgs.add(ASTNode.INT(position, cc.rawValue.convert()))
        finalArgs.addAll(args)
        if isValue(cc.owner) {
            return coerce(position, call(position, symbolRef(position, null, initMethod),
                    finalArgs, TypeContext.UNSPECIFIED), type)
        }
        else {
            def construct := ir.add(IR.Statement.CONSTRUCT(cc.owner))
            def constructRef := IR.Value.REF(construct, owner)
            statementUnrefs.add(constructRef)
            call(position, symbolRef(position, constructRef, initMethod), finalArgs,
                    TypeContext.UNSPECIFIED)
            return coerce(position, constructRef, type)
        }
    }

    ================================================================================================
    If `node` is a reference to a [ChoiceCase], returns it. Otherwise, returns `null` without
    reporting an error.
    ================================================================================================
    method getChoiceCase(node:ASTNode):Pair<Type, ChoiceCase>? {
        match node {
            when ASTNode.IDENTIFIER(_, text):
                if currentClass[0].classKind = ClassDecl.Kind.CHOICE {
                    def s := getSymbolTable(currentClass[0])[text]
                    if s !== null & s.kind = Symbol.Kind.CHOICE_CASE {
                        return Pair<Type, ChoiceCase>(currentClass[0].type, s->ChoiceCase)
                    }
                }
            when ASTNode.DOT(_, base, text):
                def baseType := preferredType(base)
                if baseType !== null & baseType.isClassLiteral() {
                    def cl := getClass(baseType.subtypes[1])
                    if cl !== null & cl.classKind = ClassDecl.Kind.CHOICE {
                        def s := getSymbolTable(cl)[text]
                        if s !== null & s.kind = Symbol.Kind.CHOICE_CASE {
                            return Pair<Type, ChoiceCase>(baseType.subtypes[1], s->ChoiceCase)
                        }
                    }
                }
        }
        return null
    }

    method compileCall(position:Position, m:ASTNode, args:ImmutableArray<ASTNode>,
                       type:TypeContext):IR.Value? {
        match m {
            when ASTNode.GENERIC_TYPE:
                def resolved := resolve(scanner.convertType(m))
                if resolved == null {
                    return null
                }
                return call(position, IR.Value.TYPE(resolved), args, type)
        }
        def cc := getChoiceCase(m)
        if cc !== null {
            return compileChoiceCaseReference(position, cc.first, cc.second, args, type)
        }
        match m {
            when ASTNode.DOT(position, base, name):
                match base {
                    when ASTNode.SUPER:
                        var s := symbolTable[CAPTURED_SELF_NAME]
                        if s == null {
                            s := symbolTable[SELF_NAME]
                        }
                        if s == null {
                            return null
                        }
                        def result := Array<Type>()
                        assert s.kind = Symbol.Kind.VARIABLE
                        def cl := getClass(s->Variable.type)
                        if cl == null {
                            return null
                        }
                        def supertype := remapType(s->Variable.type, cl.rawSuper)
                        return call(position, IR.Value.SUPER(supertype), name, args, type)
                }
        }
        def compiledM := compileMethodExpression(m, TypeContext.NON_VOID)
        if compiledM == null {
            return null
        }
        return call(position, compiledM, args, type)
    }

    method compileCast(position:Position, value:ASTNode, rawTarget:Type):IR.Value? {
        def index := rawTarget.name.lastIndexOf(".")
        if rawTarget.typeKind = Type.Kind.CLASS & index !== null {
            -- we have a dotted name which might not be entirely a type - for example we might have
            -- 'o->String.length'. This is obviously meant to be a cast to String followed by a
            -- call to get_length(), but syntactically it could just as easily be a cast to a class
            -- named String.length. We need to disambiguate these cases here.
            def old := reportErrors
            reportErrors := false
            def type := resolve(rawTarget)
            reportErrors := old
            if type == null {
                def base := compileCast(position, value,
                        Type(rawTarget.name[..index], Type.Kind.CLASS, position))
                if base == null {
                    return null
                }
                return compileDot(position, base, rawTarget.name[rawTarget.name.next(index)..])
            }
        }
        def target := resolve(rawTarget)
        if target == null {
            return null
        }
        if coercionCost(value, target) !== null {
            return compileExpression(value, TypeContext.TYPE(target))
        }
        return cast(compileExpression(value, TypeContext.NON_VOID), target)
    }

    method compileClosure(position:Position, kind:MethodDecl.Kind,
            rawParameters:ImmutableArray<ASTNode>, rawReturnType:ASTNode?,
            body:ImmutableArray<ASTNode>, type:TypeContext):IR.Value? {
        closureCount += 1
        def name := "$anonymous\{closureCount}"
        def parameters := Array<MethodDecl.Parameter>()
        for p in rawParameters {
            match p {
                when ASTNode.PARAMETER(_, name, type):
                    def resolved := resolve(scanner.convertType(type))
                    if resolved == null {
                        return null
                    }
                    parameters.add(MethodDecl.Parameter(name, resolved))
                otherwise:
                    assert false
            }
        }
        def returnType:Type
        if rawReturnType !== null {
            returnType := resolve(scanner.convertType(rawReturnType))
            if returnType == null {
                return null
            }
        }
        else {
            returnType := Type.Void()
            if kind = MethodDecl.Kind.FUNCTION {
                error(position, "functions must have a return type")
                return null
            }
        }
        def currentCaptures := Pair<MethodDecl, Map<String, Capture>>(currentMethod[0],
                HashMap<String, Capture>())
        captures.push(currentCaptures)
        def annotations := Annotations(Annotations.Flag.CLASS)
        def methodDecl := MethodDecl(currentClass[0], position, null, annotations, kind, name, null,
                parameters, returnType, body)
        -- need to scan through the method to determine captures, but we don't actually want to
        -- output it yet - if it has captures, we need to put it into a closure class
        def oldWriteCode := writeCode
        def oldReportErrors := reportErrors
        writeCode := false
        reportErrors := false
        def oldContexts := enclosingContexts
        enclosingContexts := Stack<EnclosingContext>()
        compile(methodDecl, symbolTable)
        enclosingContexts := oldContexts
        writeCode := oldWriteCode
        reportErrors := oldReportErrors

        def immutable:Bit
        def target:ASTNode?
        if currentCaptures.second.count != 0 {
            -- we have captures, need to build an actual closure for it
            def cl := createClosureClass(methodDecl, currentCaptures.second.values().all())
            def args := Array<ASTNode>()
            for capture in currentCaptures.second.values() {
                match capture {
                    when Capture.VARIABLE(v):
                        args.add(ASTNode.IDENTIFIER(position, v.name))
                    when Capture.SELF:
                        args.add(ASTNode.SELF(position))
                    when Capture.FIELD(f):
                        args.add(ASTNode.DOT(position,
                                ASTNode.IDENTIFIER(position, FORCE_SELF_NAME),
                                f.name))
                }
            }
            captures.pop(currentCaptures)
            pendingClasses.add(cl)
            def rawTarget := call(position, IR.Value.TYPE(cl.type), args.finish(),
                    TypeContext.UNSPECIFIED)
            if rawTarget == null {
                return null
            }
            target := ASTNode.IR_WRAPPER(position, rawTarget)
            immutable := isImmutable(cl.type)
        }
        else {
            -- no captures, method is already good
            captures.pop(currentCaptures)
            enclosingContexts := Stack<EnclosingContext>()
            compile(methodDecl, symbolTable)
            enclosingContexts := oldContexts
            target := ASTNode.NULL(position)
            immutable := true
        }
        def args := Array<ASTNode>()
        def pandaType:Type
        if methodDecl.annotations.isClass() {
            pandaType := methodDecl.type()
        }
        else {
            pandaType := declaredTypeWithSelf(methodDecl, methodDecl.owner.type)
        }
        def irType := Type.pointerTo(pandaType)
        args.add(ASTNode.IR_WRAPPER(position, cast(IR.Value.METHOD_POINTER(methodDecl,
                irType), Type.pointerTo(Type.Int8()))))
        args.add(target)
        def methodType:Type
        if immutable {
            methodType := Type.Method()
        }
        else {
            methodType := Type.MutableMethod()
        }
        def construct := cast(call(position, IR.Value.TYPE(methodType), args,
                TypeContext.UNSPECIFIED), methodDecl.type())
        return coerce(position, construct, type)
    }

    method compileDot(position:Position, target:IR.Value, name:String):IR.Value? {
        def cl := getClass(target.type())
        if cl == null {
            return null
        }
        def symbol := getSymbolTable(cl)[name]
        if symbol == null {
            error(position, "class '\{target.type()}' does not have a member named '\{name}'")
            return null
        }
        return symbolRef(position, target, symbol)
    }

    method compileDot(position:Position, base:ASTNode, name:String):IR.Value? {
        match base {
            when ASTNode.GENERIC_TYPE:
                def resolved := resolve(scanner.convertType(base))
                if resolved == null {
                    return null
                }
                return compileDot(position, IR.Value.TYPE(resolved), name)
        }
        def compiledBase := compileExpression(base)
        if compiledBase == null {
            return null
        }
        return compileDot(position, compiledBase, name)
    }

    method compileIdentifier(position:Position, name:String):IR.Value? {
        if name = FORCE_SELF_NAME {
            def s := symbolTable[SELF_NAME]
            assert s !== null, "no 'self' in symboltable"
            return symbolRef(position, null, s)
        }
        def s := symbolTable[name]
        if s == null {
            def cl := tryResolveClass(name)
            if cl !== null {
                checkGenericParameters(position, cl, cl.type)
                return IR.Value.TYPE(Type.ClassLiteral(cl.type))
            }
        }
        if s !== null {
            return symbolRef(position, null, s)
        }
        error(position, "unknown identifier")
        return null
    }

    function isNull(v:IR.Value):Bit {
        match v {
            when IR.Value.NULL:
                return true
        }
        return false
    }

    @pre(op = Token.Kind.IDENTITY | op = Token.Kind.NIDENTITY)
    method compileIdentityComparison(position:Position, left:ASTNode, op:Token.Kind, right:ASTNode,
            type:TypeContext):IR.Value? {
        def compiledLeft := compileExpression(left, TypeContext.NON_VOID)
        if compiledLeft == null {
            return null
        }
        def compiledRight := compileExpression(right, TypeContext.NON_VOID)
        if compiledRight == null {
            return null
        }
        if compiledLeft.type().typeKind != Type.Kind.NULLABLE & isNull(compiledRight) {
            if op = Token.Kind.IDENTITY {
                return coerce(position, coerce(position, IR.Value.BIT(false),
                        TypeContext.TYPE(Type.Bit())), type)
            }
            return coerce(position, coerce(position, IR.Value.BIT(true),
                    TypeContext.TYPE(Type.Bit())), type)
        }
        if compiledRight.type().typeKind != Type.Kind.NULLABLE & isNull(compiledLeft) {
            if op = Token.Kind.IDENTITY {
                return coerce(position, coerce(position, IR.Value.BIT(false),
                        TypeContext.TYPE(Type.Bit())), type)
            }
            return coerce(position, coerce(position, IR.Value.BIT(true),
                    TypeContext.TYPE(Type.Bit())), type)
        }
        if coercionCost(compiledLeft.type(), compiledRight.type()) == null &
                coercionCost(compiledRight.type(), compiledLeft.type()) == null {
            error(position, "'\{operatorName(op)}' cannot compare dissimilar types " +
                    "'\{compiledLeft.type()}' and '\{compiledRight.type()}'")
            return null
        }
        if isValue(compiledLeft.type()) & !isNull(compiledRight) |
                isValue(compiledRight.type()) & !isNull(compiledLeft) {
            error(position, "'\{operatorName(op)}' cannot operate on value types")
            return null
        }
        def builtinBit := ir.add(IR.Statement.BINARY(compiledLeft, op, compiledRight,
                Type.BuiltinBit()))
        def bit := coerce(position, IR.Value.REF(builtinBit, Type.BuiltinBit()),
                TypeContext.TYPE(Type.Bit()))
        return coerce(position, bit, type)
    }

    method compileInt(position:Position, value:UInt64, type:TypeContext):IR.Value? {
        match type {
            when TypeContext.TYPE(t):
                if t.typeKind = Type.Kind.BUILTIN_INT | t.typeKind = Type.Kind.BUILTIN_UINT {
                    return IR.Value.INT(value, t)
                }
                if t.typeKind = Type.Kind.BUILTIN_FLOAT {
                    return IR.Value.REAL(value, t)
                }
                if t.isNumber() {
                    def args := Array<ASTNode>()
                    args.add(ASTNode.INT(position, value))
                    return call(position, IR.Value.TYPE(t), args, type)
                }
        }
        return coerce(position, compileInt(position, value, TypeContext.TYPE(Type.Int64())), type)
    }

    method compileNull(position:Position, type:TypeContext):IR.Value? {
        match type {
            when TypeContext.TYPE(t):
                if t.typeKind != Type.Kind.NULLABLE {
                    error(position, "expected '\{t}', but found 'null'")
                }
                return IR.Value.NULL(t)
            otherwise:
                return IR.Value.NULL(Type.Any())
        }
    }

    method compilePrefix(position:Position, op:Token.Kind, operand:ASTNode,
            type:TypeContext):IR.Value? {
        match op {
            when Token.Kind.SUB:
                match operand {
                    when ASTNode.INT(_, value):
                        match type {
                            when TypeContext.TYPE(t):
                                if t.typeKind = Type.Kind.BUILTIN_INT |
                                        t.typeKind = Type.Kind.BUILTIN_UINT {
                                    return IR.Value.INT(-value, t)
                                }
                                if t.isNumber() {
                                    def args := Array<ASTNode>()
                                    args.add(ASTNode.INT(position, -value))
                                    return call(position, IR.Value.TYPE(t), args, type)
                                }
                        }
                }
                def target := compileExpression(operand, TypeContext.NON_VOID)
                if target == null {
                    return null
                }
                if target.type().isBuiltinNumber() {
                    def result := ir.add(IR.Statement.NEGATE(target))
                    return coerce(position, IR.Value.REF(result, target.type()), type)
                }
                return call(position, target, "-", Array<ASTNode>() -* FIXME literal *-, type)
            when Token.Kind.NOT:
                def target := compileExpression(operand, TypeContext.NON_VOID)
                if target == null {
                    return null
                }
                if target.type() = Type.BuiltinBit() {
                    def result := ir.add(IR.Statement.NOT(target))
                    return coerce(position, IR.Value.REF(result, Type.BuiltinBit()), type)
                }
                return call(position, target, "!", Array<ASTNode>() -* FIXME literal *-, type)
            when Token.Kind.BITWISENOT:
                def target := compileExpression(operand, TypeContext.NON_VOID)
                if target == null {
                    return null
                }
                if target.type().isBuiltinNumber() {
                    def result := ir.add(IR.Statement.NOT(target))
                    return coerce(position, IR.Value.REF(result, target.type()), type)
                }
                return call(position, target, "!!", Array<ASTNode>() -* FIXME literal *-, type)
        }
        assert false
    }

    method compileRange(position:Position, start:ASTNode?, inclusive:Bit, end:ASTNode?,
            step:ASTNode?, type:TypeContext):IR.Value? {
        var endpointContext := TypeContext.NON_VOID
        var endpointType:Type? := null
        var stepContext := TypeContext.NON_VOID
        match type {
            when TypeContext.TYPE(t):
                if t.typeKind = Type.Kind.GENERIC & t.subtypes.count = 2 &
                        t.subtypes[0].name = RANGE_NAME {
                    if step !== null {
                        error(position, "expected '\{t}', but found '\{STEPPED_RANGE_NAME}'")
                        return null
                    }
                    endpointContext := TypeContext.TYPE(t.subtypes[1])
                    endpointType := t.subtypes[1]
                }
                else if t.typeKind = Type.Kind.GENERIC & t.subtypes.count = 3 &
                        t.subtypes[0].name = STEPPED_RANGE_NAME {
                    if step == null {
                        error(position, "expected '\{t}', but found '\{RANGE_NAME}'")
                        return null
                    }
                    endpointContext := TypeContext.TYPE(t.subtypes[1])
                    endpointType := t.subtypes[1]
                    stepContext := TypeContext.TYPE(t.subtypes[2])
                }
        }
        def compiledStart:IR.Value?
        if start !== null {
            compiledStart := compileExpression(start, endpointContext)
            if compiledStart == null {
                return null
            }
        }
        else {
            compiledStart := null
        }
        def compiledEnd:IR.Value?
        if end !== null {
            compiledEnd := compileExpression(end, endpointContext)
            if compiledEnd == null {
                return null
            }
        }
        else {
            compiledEnd := null
        }
        if endpointType == null {
            if compiledStart !== null {
                if compiledEnd !== null {
                    endpointType := compiledStart.type().union(self, compiledEnd.type())
                    if endpointType.name = "panda.core.Value" {
                        error(position, "range endpoint type mismatch: '\{compiledStart}', " +
                                "'\{compiledEnd}'")
                    }
                }
                else {
                    endpointType := compiledStart.type().nullable()
                }
            }
            else if compiledEnd !== null {
                endpointType := compiledEnd.type().nullable()
            }
            else {
                endpointType := Type.Int64().nullable()
            }
        }
        def cl := getClass(endpointType)
        if cl == null {
            return null
        }
        if !isValue(cl) {
            error(position, "range endpoints must be value types, but found '\{endpointType}'")
        }
        if compiledStart == null {
            if !endpointType.isNullable() {
                error(position, "expected '\{endpointType}', but found 'null'")
                return null
            }
            compiledStart := IR.Value.NULL(endpointType)
        }
        if compiledEnd == null {
            if !endpointType.isNullable() {
                error(position, "expected '\{endpointType}', but found 'null'")
                return null
            }
            compiledEnd := IR.Value.NULL(endpointType)
        }
        if step !== null {
            if stepContext = TypeContext.NON_VOID & endpointType.isNumber() {
                def p := possibleTypes(step)
                if p !== null {
                    for t in p {
                        if t = endpointType {
                            stepContext := TypeContext.TYPE(endpointType)
                            break
                        }
                    }
                }
            }
            def compiledStep := compileExpression(step, stepContext)
            if compiledStep == null {
                return null
            }
            def args := Array<ASTNode>()
            args.add(ASTNode.IR_WRAPPER(position, compiledStart))
            args.add(ASTNode.IR_WRAPPER(position, compiledEnd))
            args.add(ASTNode.IR_WRAPPER(step.position(), compiledStep))
            args.add(ASTNode.BIT(position, inclusive))
            return call(position, IR.Value.TYPE(Type.SteppedRangeOf(endpointType,
                    compiledStep.type())), args, type)
        }
        else {
            def args := Array<ASTNode>()
            args.add(ASTNode.IR_WRAPPER(position, compiledStart))
            args.add(ASTNode.IR_WRAPPER(position, compiledEnd))
            args.add(ASTNode.BIT(position, inclusive))
            return call(position, IR.Value.TYPE(Type.RangeOf(endpointType)), args, type)
        }
    }

    method compileReal(position:Position, value:Real64, type:TypeContext):IR.Value? {
        match type {
            when TypeContext.TYPE(t):
                if t.typeKind = Type.Kind.BUILTIN_FLOAT {
                    return IR.Value.REAL(value, t)
                }
                if t.isReal() {
                    def args := Array<ASTNode>()
                    args.add(ASTNode.REAL(position, value))
                    return call(position, IR.Value.TYPE(t), args, type)
                }
        }
        return coerce(position, compileReal(position, value, TypeContext.TYPE(Type.Real64())), type)
    }

    method compileRegex(position:Position, text:String):IR.Value? {
        def args := Array<ASTNode>() -- FIXME literal
        args.add(ASTNode.STRING(position, text))
        return call(position, IR.Value.TYPE(Type.RegularExpression()), args,
                TypeContext.UNSPECIFIED)
    }

    method compileSelf(position:Position, explicit:Bit):IR.Value? {
        if captures.count > 0 {
            for c in captures {
                c.second[SELF_NAME] := Capture.SELF
            }
            var cl := captures[0].first.owner
            while cl.annotations.isSynthetic() {
                assert cl.owner !== null
                cl := cl.owner
            }
            return IR.Value.REF(IR.Statement.ID(-1), cl.type)
        }
        if explicit {
            def s := symbolTable[CAPTURED_SELF_NAME]
            if s !== null {
                def actualSelf := symbolTable[SELF_NAME]
                assert actualSelf !== null, "no 'self' in symboltable"
                return symbolRef(position, symbolRef(position, null, actualSelf), s)
            }
        }
        if currentMethod[0].annotations.isClass() {
            error(position, "cannot reference 'self' from a @class context")
            return null
        }
        def s := symbolTable[SELF_NAME]
        assert s !== null, "no 'self' in symboltable at \{position}"
        return symbolRef(position, null, s)
    }

    method typedLambdaReturnType(rawParameters:ListView<ASTNode>, expr:ASTNode,
            type:TypeContext):Type? {
        def scope := AutoScope(self)
        for i in 0 .. rawParameters.count {
            def p := rawParameters[i]
            match p {
                when ASTNode.PARAMETER(position, name, rawType):
                    var type := scanner.convertType(rawType)
                    if type == null {
                        return null
                    }
                    type := resolve(type)
                    if type == null {
                        return null
                    }
                    symbolTable.add(Variable(position, Variable.Kind.DEF, name, type,
                            Variable.Storage.PARAMETER(-1)))
            }
        }
        def bodyContext:TypeContext
        match type {
            when TypeContext.TYPE(t):
                if t.nonnullable().isMethod() {
                    if coercionCost(expr, t.returnType()) == null {
                        return null
                    }
                    return t.nonnullable().returnType()
                }
        }
        return preferredType(expr)
    }

    @post(@return !== null | errorCount > 0 | !reportErrors)
    method compileTypedLambda(position:Position, rawParameters:ImmutableArray<ASTNode>,
            expr:ASTNode, type:TypeContext):IR.Value? {
        var returnType := typedLambdaReturnType(rawParameters, expr, type)
        if returnType == null {
            -- this shouldn't happen with a valid lambda. push ahead and expect an error during
            -- compilation.
            returnType := Type.Any()
            match type {
                when TypeContext.TYPE(t):
                    if t.nonnullable().isMethod() {
                        returnType := t.nonnullable().returnType()
                    }
            }
        }
        def body := Array<ASTNode>() -- FIXME literal
        body.add(ASTNode.RETURN(position, expr))
        return compileClosure(position, MethodDecl.Kind.FUNCTION, rawParameters,
                ASTNode.IR_WRAPPER(position, IR.Value.TYPE(returnType)),
                body.finish(), type)
    }

    @post(@return !== null | errorCount > 0 | !reportErrors)
    method compileUntypedLambda(position:Position, rawParameters:ImmutableArray<ASTNode>,
            expr:ASTNode, type:TypeContext):IR.Value? {
        match type {
            when TypeContext.TYPE(t):
                def methodType := t.nonnullable()
                if methodType.isMethod() {
                    if rawParameters.count != methodType.parameterCount {
                        error(position, "expected '\{t}', but found lambda with wrong number of " +
                                "parameters")
                        return null
                    }
                    def parameters := Array<ASTNode>()
                    for i in 0 .. rawParameters.count {
                        match rawParameters[i] {
                            when ASTNode.IDENTIFIER(position, name):
                                parameters.add(ASTNode.PARAMETER(position, name,
                                        ASTNode.IR_WRAPPER(position,
                                            IR.Value.TYPE(methodType.parameterType(i)))))
                            otherwise:
                                assert false
                        }
                    }
                    def returnType := t.nonnullable().returnType()
                    def body := Array<ASTNode>() -- FIXME literal
                    body.add(ASTNode.RETURN(position, expr))
                    return compileClosure(position, MethodDecl.Kind.FUNCTION, parameters.finish(),
                            ASTNode.IR_WRAPPER(position, IR.Value.TYPE(returnType)),
                            body.finish(), type)

                }
        }
        def attempts := lambdaTypes[expr]
        if attempts !== null {
            if attempts.count > 1 {
                def msg := MutableString("lambda error")
                def old := errorQueue
                for t in attempts {
                    msg.append("\n    when interpreted as '\{t}':")
                    errorQueue := MessageQueue<Error>()
                    compileUntypedLambda(position, rawParameters, expr, TypeContext.TYPE(t))
                    assert errorQueue.hasMessage()
                    msg.append("\n        \{errorQueue.getMessage().message}")
                }
                errorQueue := old
                error(position, msg.finish())
                return null
            }
            else {
                compileUntypedLambda(position, rawParameters, expr,
                        TypeContext.TYPE(attempts.iterator().next()))
                return null
            }
        }
        error(position, "lambda type was not specified and cannot be determined from context")
        return null
    }

    method typeMatch(value:IR.Value?, type:TypeContext):Bit {
        if value == null {
            return true
        }
        match type {
            when TypeContext.UNSPECIFIED, TypeContext.NON_VOID:
                return true
            when TypeContext.IMMUTABLE:
                return isImmutable(value.type())
            when TypeContext.TYPE(t):
                return value.type() = t
            otherwise:
                assert false
        }
    }

    ================================================================================================
    Compiles an expression without fully resolving method references. That is,
    `compileMethodExpression` on `Console.printLine` returns an IR.Value.METHOD, whereas fully
    resolving this expression using `compileExpression` will result in an actual `ImmutableMethod`
    object constructor.
    ================================================================================================
    @post(typeMatch(@return, type) & (@return !== null | errorCount > 0 | !reportErrors))
    method compileMethodExpression(expr:ASTNode, type:TypeContext):IR.Value? {
        match expr {
            when ASTNode.AT_PRE(position, expr):
                return compileAtPre(position, expr)
            when ASTNode.AT_RETURN(position):
                return compileAtReturn(position)
            when ASTNode.BINARY(position, left, op, right):
                return compileBinary(position, left, op, right, type)
            when ASTNode.BIT(_, value):
                match type {
                    when TypeContext.TYPE(t):
                        if t = Type.BuiltinBit() {
                            return IR.Value.BIT(value)
                        }
                }
                return coerce(expr.position(),
                        coerce(expr.position(), IR.Value.BIT(value), Type.Bit()),
                        type)
            when ASTNode.CALL(position, m, args):
                return compileCall(position, m, args, type)
            when ASTNode.DOT(position, base, name):
                def t := tryResolveType(expr)
                if t !== null {
                    return coerce(expr.position(), IR.Value.TYPE(Type.ClassLiteral(t)), type)
                }
                return coerce(expr.position(), compileDot(position, base, name), type)
            when ASTNode.IDENTIFIER(position, name):
                return coerce(expr.position(), compileIdentifier(position, name), type)
            when ASTNode.INT(position, value):
                return compileInt(position, value, type)
            when ASTNode.IR_WRAPPER(_, value):
                return coerce(expr.position(), value, type)
            when ASTNode.METHOD(position, _, _, kind, _, _, parameters, returnType, body):
                return compileClosure(position, kind, parameters, returnType, body, type)
            when ASTNode.NULL(position):
                return compileNull(position, type)
            when ASTNode.PREFIX(position, op, operand):
                return compilePrefix(position, op, operand, type)
            when ASTNode.RANGE(position, start, inclusive, end, step):
                return compileRange(position, start, inclusive, end, step, type)
            when ASTNode.REAL(position, value):
                return compileReal(position, value, type)
            when ASTNode.REGEX(position, text):
                return compileRegex(position, text)
            when ASTNode.SELF(position):
                return coerce(position, compileSelf(position, true), type)
            when ASTNode.SUPER(position):
                error(position, "'super' may not appear in this context")
                return null
            when ASTNode.STRING(position, text):
                match type {
                    when TypeContext.TYPE(t):
                        if t.isChar() & text.length() = 1 {
                            def args := Array<ASTNode>()
                            args.add(ASTNode.INT(position, text[0].convert()))
                            return compileExpression(ASTNode.CALL(position,
                                    ASTNode.IR_WRAPPER(position, IR.Value.TYPE(t)),
                                    args.finish()))
                        }
                }
                return coerce(expr.position(), IR.Value.STRING(text), type)
            when ASTNode.TYPE, ASTNode.GENERIC_TYPE:
                def type := resolve(scanner.convertType(expr))
                if type == null {
                    return null
                }
                return IR.Value.TYPE(type)
            when ASTNode.TYPED_LAMBDA(position, parameters, body):
                return compileTypedLambda(position, parameters, body, type)
            when ASTNode.UNTYPED_LAMBDA(position, parameters, body):
                return compileUntypedLambda(position, parameters, body, type)
            otherwise:
                assert false, "unsupported expression \{expr}:\{expr.position()}"
        }
    }

    @post(typeMatch(@return, type) & (@return !== null | errorCount > 0 | !reportErrors))
    method compileExpression(expr:ASTNode, type:TypeContext):IR.Value? {
        def unresolved := compileMethodExpression(expr, type)
        if unresolved == null {
            return null
        }
        match unresolved {
            when IR.Value.METHOD(target, m):
                return coerce(expr.position(), createMethodObject(expr.position(), target, m), type)
            when IR.Value.METHODS(target, methods):
                match type {
                    when TypeContext.TYPE(t):
                        if !t.nonnullable().isMethod() {
                            error(expr.position(), "unresolved method reference cannot possibly " +
                                    "be an instance of '\{t}'")
                        }
                        def best := Array<MethodDecl>()
                        var bestCost := Int.MAX
                        for m in methods {
                            if resolve(m) {
                                def cost := coercionCost(m.type(), t)
                                if cost !== null {
                                    if cost < bestCost {
                                        bestCost := cost
                                        best.clear()
                                    }
                                    if cost = bestCost {
                                        best.add(m)
                                    }
                                }
                            }
                        }
                        if best.count = 1 {
                            return compileExpression(ASTNode.IR_WRAPPER(expr.position(),
                                    IR.Value.METHOD(target, best[0])), type)
                        }
                        if best.count = 0 {
                            error(expr.position(), "no method '\{methods[0].name}' matching " +
                                    "expected type '\{t}'")
                            return null
                        }
                }
                error(expr.position(), "ambiguous reference to method '\{methods[0].name}'")
                return null
            otherwise:
                return unresolved
        }
    }

    method compileExpression(expr:ASTNode):IR.Value? {
        return compileExpression(expr, TypeContext.UNSPECIFIED)
    }

    ================================================================================================
    An assignment target. It is crucial that when loading and then storing the lvalue, any side
    effects only happen once. For instance, in `foo()[0] += 1`, we will create an lvalue
    representing `foo()[0]`. We have to read from this lvalue, add 1 to it, and store the result
    back. This must not result in evaluating `foo()` twice.

    It is acceptable for the mere act of creating an lvalue to evaluate shared code (`foo()`, in
    this case) - we never create an lvalue and then not use it.
    ================================================================================================
    interface LValue {
        function type():Type

        method compileLoad():IR.Value?

        method compileStore(value:IR.Value)
    }

    class VariableLValue : LValue {
        def compiler:Compiler

        def slot:Int

        init(compiler:Compiler, variable:Variable) {
            self.compiler := compiler
            match variable.storage {
                when Variable.Storage.LOCAL(slot):
                    self.slot := slot
                otherwise:
                    assert false
            }
        }

        @override
        function type():Type {
            return compiler.ir.locals[slot]
        }

        @override
        method compileLoad():IR.Value? {
            def result := compiler.ir.add(IR.Statement.LOAD(IR.Value.LOCAL(slot, type())))
            return IR.Value.REF(result, compiler.ir.locals[slot])
        }

        @override
        method compileStore(value:IR.Value) {
            if compiler.isRefCounted(type()) {
                compiler.compileUnref(compileLoad())
                compiler.compileRef(value)
            }
            compiler.ir.add(IR.Statement.STORE(value, IR.Value.LOCAL(slot, type())))
        }
    }

    class FieldLValue : LValue {
        def compiler:Compiler

        def position:Position

        def target:IR.Value?

        def field:FieldDecl

        def rawType:Type

        def effectiveType:Type

        init(compiler:Compiler, position:Position, target:IR.Value?, field:FieldDecl) {
            self.compiler := compiler
            self.position := position
            assert field.resolved = Resolution.RESOLVED
            self.field := field
            if target !== null & !target.type().isClassLiteral() {
                self.target := target
            }
            else if !field.annotations.isClass() {
                if field.owner.annotations.isSynthetic() & !compiler.reportErrors {
                    -- nested closure capture during pre-scan
                    self.target := IR.Value.REF(IR.Statement.ID(-1), field.owner.type)
                }
                else {
                    self.target := compiler.compileSelf(position, false)
                }
            }
            rawType := field.type
            def base:Type
            if field.annotations.isWeak() {
                base := rawType.subtypes[1]
            }
            else {
                base := rawType
            }
            if self.target !== null {
                effectiveType := compiler.remapType(self.target.type(), base)
            }
            else {
                effectiveType := base
            }
            if self.target !== null {
                self.target := compiler.coerce(position, self.target, field.owner.type)
            }
        }

        @override
        function type():Type {
            return effectiveType
        }

        @override
        method compileLoad():IR.Value? {
            if field.annotations.isClass() & field.fieldKind = FieldDecl.Kind.CONSTANT {
                compiler.currentClass.push(field.owner)
                def auto := AutoScope(compiler, compiler.getSymbolTable(field.owner))
                def result := compiler.compileExpression(field.rawValue, TypeContext.TYPE(type()))
                compiler.currentClass.pop()
                return result
            }
            if target == null {
                -- should have already reported an error
                return null
            }
            var result:IR.Value
            if field.fieldKind = FieldDecl.Kind.PROPERTY {
                result := compiler.call(position, target, "get_\{field.name}",
                        Array<ASTNode>(), TypeContext.TYPE(rawType))
            }
            else {
                def load:IR.Statement.ID
                if compiler.isValue(field.owner) {
                    load := compiler.ir.add(IR.Statement.EXTRACT_FIELD(target, field))
                }
                else {
                    def ptr := compiler.ir.add(IR.Statement.GET_FIELD_POINTER(target, field))
                    load := compiler.ir.add(IR.Statement.LOAD(IR.Value.REF(ptr, rawType)))
                }
                result := IR.Value.REF(load, rawType)
            }
            if field.annotations.isWeak() {
                def auto := AutoUnrefs(compiler)
                result := compiler.call(position, result, "get", ImmutableArray<ASTNode>(),
                        TypeContext.UNSPECIFIED)
            }
            if effectiveType != result.type() {
                result := compiler.cast(result, effectiveType)
            }
            return result
        }

        @override
        method compileStore(rawValue:IR.Value) {
            if target == null {
                -- should have already reported an error
                return
            }
            def cast:IR.Value
            def value:IR.Value
            if field.annotations.isWeak() {
                def args := Array<ASTNode>() -- FIXME literal
                args.add(ASTNode.IR_WRAPPER(position, rawValue))
                value := compiler.compileExpression(ASTNode.CALL(position,
                        ASTNode.IR_WRAPPER(position, IR.Value.TYPE(Type.WeakOf(effectiveType))),
                        args.finish()))
            }
            else {
                value := rawValue
            }
            if effectiveType != rawType {
                cast := compiler.cast(value, rawType)
                if cast == null {
                    return
                }
            }
            else {
                cast := value
            }
            if field.fieldKind = FieldDecl.Kind.PROPERTY {
                def args := Array<ASTNode>()
                args.add(ASTNode.IR_WRAPPER(position, value))
                compiler.call(position, target, "set_\{field.name}", args,
                        TypeContext.TYPE(rawType))
            }
            else {
                if compiler.isRefCounted(rawType) {
                    compileUnref()
                    compiler.compileRef(value)
                }
                def ptr := IR.Value.REF(compiler.ir.add(IR.Statement.GET_FIELD_POINTER(target,
                        field)), rawType)
                compiler.ir.add(IR.Statement.STORE(cast, ptr))
            }
        }

        method compileUnref() {
            var result:IR.Value
            if field.fieldKind = FieldDecl.Kind.PROPERTY {
                return
            }
            def load:IR.Statement.ID
            if compiler.isValue(field.owner) {
                load := compiler.ir.add(IR.Statement.EXTRACT_FIELD(target, field))
            }
            else {
                def ptr := compiler.ir.add(IR.Statement.GET_FIELD_POINTER(target, field))
                load := compiler.ir.add(IR.Statement.LOAD(IR.Value.REF(ptr, rawType)))
            }
            result := IR.Value.REF(load, rawType)
            if field.annotations.isWeak() {
                def nonNullBlock := compiler.ir.newBlock("unref non-null")
                def mergeBlock := compiler.ir.newBlock("unref merge")
                def nonNullTest := compiler.ir.add(IR.Statement.BINARY(result, Token.Kind.NIDENTITY,
                        IR.Value.NULL(rawType.nullable()), Type.BuiltinBit()))
                compiler.ir.add(IR.Statement.CONDITIONAL_BRANCH(IR.Value.REF(nonNullTest,
                        Type.BuiltinBit()), nonNullBlock, mergeBlock))
                compiler.ir.setCurrentBlock(nonNullBlock)
                {
                    def auto := AutoUnrefs(compiler)
                    def get := compiler.call(position, result, "get", ImmutableArray<ASTNode>(),
                            TypeContext.UNSPECIFIED)
                    compiler.compileUnref(get)
                }
                compiler.ir.add(IR.Statement.BRANCH(mergeBlock))
                compiler.ir.setCurrentBlock(mergeBlock)
            }
            else {
                compiler.compileUnref(result)
            }
        }
    }

    class IndexLValue : LValue {
        def compiler:Compiler

        def position:Position

        def target:IR.Value

        def rawIndex:ASTNode

        -- it's important that we don't compile the index twice, so we store it the first time it
        -- gets compiled and re-use that for the other call
        def index:IR.Value?

        init(compiler:Compiler, position:Position, target:IR.Value, rawIndex:ASTNode) {
            self.compiler := compiler
            self.position := position
            self.target := target
            self.rawIndex := rawIndex
        }

        @override
        function type():Type {
            def types := compiler.possibleTypes(ASTNode.BINARY(position,
                    ASTNode.IR_WRAPPER(position, target), Token.Kind.LBRACKET, rawIndex))
            if types == null {
                return Type.Any()
            }
            assert types.count = 1 -- FIXME handle ambiguous matches
            return types.iterator().next()
        }

        @override
        method compileLoad():IR.Value? {
            if index == null {
                def m := compiler.findOverloadedOperator(target.type(), Token.Kind.LBRACKET,
                        rawIndex, TypeContext.NON_VOID)
                if m !== null {
                    assert m.first.count = 1 -- FIXME handle ambiguous matches
                    index := compiler.compileExpression(rawIndex,
                            TypeContext.TYPE(m.first[0].parameterType(0)))
                }
            }
            if index == null {
                index := IR.Value.REF(IR.Statement.ID(-1), type())
                return null
            }
            return compiler.compileBinary(position, ASTNode.IR_WRAPPER(position, target),
                    Token.Kind.LBRACKET, ASTNode.IR_WRAPPER(position, index),
                    TypeContext.NON_VOID)
        }

        @override
        method compileStore(value:IR.Value) {
            if index == null {
                def cl := compiler.getClass(target.type())
                if cl == null {
                    return
                }
                def assignment := compiler.getSymbolTable(cl)["[]:="]
                if assignment == null {
                    compiler.error(position, "no match for '[]:=' on '\{target.type()}', " +
                            "'\{value.type()}'")
                    return
                }
                def methods:ListView<MethodDecl>
                match assignment.kind {
                    when Symbol.Kind.METHOD:
                        methods := Array<MethodDecl>()
                        methods->Array<MethodDecl>.add(assignment->MethodDecl)
                    when Symbol.Kind.METHODS:
                        methods := assignment->Methods.methods
                    otherwise:
                        assert false
                }
                def args := Array<ASTNode>()
                args.add(rawIndex)
                args.add(ASTNode.IR_WRAPPER(position, value))
                def m := compiler.findBestMethod(position, target, methods, args,
                        TypeContext.UNSPECIFIED)
                if m !== null {
                    assert m.first.count = 1 -- FIXME handle ambiguous matches
                    index := compiler.compileExpression(rawIndex,
                            TypeContext.TYPE(m.first[0].parameterType(0)))
                }
                if index == null {
                    index := IR.Value.REF(IR.Statement.ID(-1), type())
                    return
                }
            }
            def args := Array<ASTNode>()
            args.add(ASTNode.IR_WRAPPER(position, index))
            args.add(ASTNode.IR_WRAPPER(position, value))
            compiler.call(position, target, "[]:=", args, TypeContext.UNSPECIFIED)
        }
    }

    class ChoiceFieldLValue : LValue {
        def compiler:Compiler

        def target:IR.Value

        def choiceCase:ChoiceCase

        def index:Int

        init(compiler:Compiler, target:IR.Value, choiceCase:ChoiceCase, index:Int) {
            self.compiler := compiler
            self.target := target
            self.choiceCase := choiceCase
            self.index := index
        }

        @override
        function type():Type {
            return choiceCase.fields[index]
        }

        @override
        method compileLoad():IR.Value? {
            assert false
        }

        @override
        method compileStore(value:IR.Value) {
            def ptr := compiler.ir.add(IR.Statement.GET_CHOICE_FIELD_POINTER(target, choiceCase,
                    index))
            compiler.ir.add(IR.Statement.STORE(value, IR.Value.REF(ptr, choiceCase.fields[index])))
        }
    }

    method compileLValue(expr:ASTNode):LValue? {
        match expr {
            when ASTNode.BINARY(position, left, op, right):
                if op = Token.Kind.LBRACKET {
                    def target := compileExpression(left)
                    if target == null {
                        return null
                    }
                    return IndexLValue(self, position, target, right)
                }
            when ASTNode.CHOICE_FIELD_REFERENCE(_, base, cc, index):
                def compiledBase := compileExpression(base)
                if compiledBase == null {
                    return null
                }
                return ChoiceFieldLValue(self, compiledBase, cc, index)
            when ASTNode.DOT(_, base, name):
                def compiledBase:IR.Value
                match base {
                    when ASTNode.SELF:
                        if isValue(currentClass[0]) {
                            if currentMethod[0].methodKind != MethodDecl.Kind.INIT {
                                error(expr.position(),
                                        "cannot modify value fields outside of an init method")
                                return null
                            }
                            compiledBase := IR.Value.LOCAL(0, currentClass[0].type)
                        }
                        else {
                            compiledBase := compileExpression(base)
                            if compiledBase == null {
                                return null
                            }
                        }
                    otherwise:
                        compiledBase := compileExpression(base)
                        if compiledBase == null {
                            return null
                        }
                }
                def cl := getClass(compiledBase.type())
                if cl == null {
                    return null
                }
                def symbol := getSymbolTable(cl)[name]
                if symbol !== null {
                    match symbol.kind {
                        when Symbol.Kind.FIELD:
                            if resolve(symbol->FieldDecl) {
                                def f := symbol->FieldDecl
                                if resolve(f) {
                                    return FieldLValue(self, expr.position(), compiledBase, f)
                                }
                            }
                            return null
                        otherwise:
                            error(expr.position(), "cannot assign to this expression")
                            return null
                    }
                }
                error(expr.position(), "class '\{cl.name}' does not have a member named '\{name}'")
                return null
            when ASTNode.IDENTIFIER(_, id):
                def symbol := symbolTable[id]
                if symbol !== null {
                    match symbol.kind {
                        when Symbol.Kind.VARIABLE:
                            return VariableLValue(self, symbol->Variable)
                        when Symbol.Kind.FIELD:
                            def f := symbol->FieldDecl
                            if !f.annotations.isClass() {
                                return compileLValue(ASTNode.DOT(expr.position(),
                                        ASTNode.SELF(expr.position()), f.name))
                            }
                            if resolve(f) {
                                return FieldLValue(self, expr.position(), null, f)
                            }
                            return null
                    }
                }
                error(expr.position(), "unknown identifier")
                return null
        }
        error(expr.position(), "cannot assign to this expression)")
        return null
    }

    method compileAssertFail(position:Position, msg:ASTNode?) {
        def args := Array<ASTNode>()
        args.add(ASTNode.STRING(position, currentClass[0].source.name()))
        args.add(ASTNode.INT(position, position.line.convert()))
        def m:MethodDecl
        if msg !== null {
            m := getSymbolTable(getClass(Type.Panda()))["assertionFailure"]->Methods.methods[0]
            args.add(msg)
        }
        else {
            m := getSymbolTable(getClass(Type.Panda()))["assertionFailure"]->Methods.methods[1]
        }
        if !resolve(m) {
            return
        }
        {
            def unrefs := AutoUnrefs(self)
            call(position, null, MethodRef(self, Type.Panda(), m), args, TypeContext.UNSPECIFIED)
        }
        ir.add(IR.Statement.UNREACHABLE)
    }

    method compileAssert(position:Position, test:ASTNode, msg:ASTNode?) {
        def compiledTest := compileExpression(test, TypeContext.TYPE(Type.Bit()))
        if compiledTest == null {
            return
        }
        def success := ir.newBlock("assert success")
        def failure := ir.newBlock("assert failure")
        ir.add(IR.Statement.CONDITIONAL_BRANCH(extractBuiltinBit(compiledTest), success, failure))
        ir.setCurrentBlock(failure)
        compileAssertFail(position, msg)
        ir.setCurrentBlock(success)
    }

    method compileAssignment(position:Position, rawLeft:ASTNode, op:Token.Kind,
            rawRight:ASTNode) {
        if !isAssignment(op) {
            error(position, "not a statement")
            return
        }
        def left := compileLValue(rawLeft)
        if left == null {
            return
        }
        def right:IR.Value?
        if op = Token.Kind.ASSIGNMENT {
            right := compileExpression(rawRight, TypeContext.TYPE(left.type()))
        }
        else {
            right := compileBinary(position, ASTNode.IR_WRAPPER(position, left.compileLoad()),
                    removeAssignment(op), rawRight, TypeContext.TYPE(left.type()))
        }
        if right == null {
            return
        }
        left.compileStore(right)
    }

    method findAndLeaveLoopScope(position:Position, label:String?):EnclosingContext? {
        for c in enclosingContexts {
            leaveScope(c)
            match c {
                when EnclosingContext.LOOP(loopLabel, _, _):
                    if label == null | loopLabel !== null & label = loopLabel {
                        return c
                    }
            }
        }
        if label == null {
            error(position, "not in a loop")
        }
        else {
            error(position, "not in a loop labeled '\{label}'")
        }
        return null
    }

    method compileBreak(position:Position, label:String?) {
        def l := findAndLeaveLoopScope(position, label)
        if l !== null {
            match l {
                when EnclosingContext.LOOP(_, breakTarget, _):
                    ir.add(IR.Statement.BRANCH(breakTarget))
                otherwise:
                    assert false
            }
        }
    }

    method compileContinue(position:Position, label:String?) {
        def l := findAndLeaveLoopScope(position, label)
        if l !== null {
            match l {
                when EnclosingContext.LOOP(_, _, continueTarget):
                    ir.add(IR.Statement.BRANCH(continueTarget))
                otherwise:
                    assert false
            }
        }
    }

    @pre(bit.type() = Type.Bit())
    method extractBuiltinBit(bit:IR.Value):IR.Value {
        Panda.ref(bit) -- FIXME bootstrap refcounting apparently broken
        def result := ir.add(IR.Statement.EXTRACT_FIELD(bit,
                getSymbolTable(getClass(Type.Bit()))["value"]->FieldDecl))
        return IR.Value.REF(result, Type.BuiltinBit())
    }

    @pre(int.type() = Type.Int64())
    method extractBuiltinInt(int:IR.Value):IR.Value {
        def result := ir.add(IR.Statement.EXTRACT_FIELD(int,
                getSymbolTable(getClass(Type.Int64()))["value"]->FieldDecl))
        return IR.Value.REF(result, Type.BuiltinInt64())
    }

    method compileDo(position:Position, label:String?, statements:ImmutableArray<ASTNode>,
            test:ASTNode) {
        def bodyBlock := ir.newBlock("do body")
        def testBlock := ir.newBlock("do test")
        def endBlock := ir.newBlock("do end")
        def context := AutoContext(self, EnclosingContext.LOOP(label, endBlock, testBlock))
        def scope := AutoScope(self)
        ir.add(IR.Statement.BRANCH(bodyBlock))
        ir.setCurrentBlock(bodyBlock)
        for s in statements {
            compileStatement(s)
        }
        if !ir.currentBlockFinished() {
            ir.add(IR.Statement.BRANCH(testBlock))
        }
        ir.setCurrentBlock(testBlock)
        def compiledTest:IR.Value?
        {
            def unrefs := AutoUnrefs(self)
            compiledTest := compileExpression(test, TypeContext.TYPE(Type.Bit()))
            if compiledTest == null {
                return
            }
        }
        ir.add(IR.Statement.CONDITIONAL_BRANCH(extractBuiltinBit(compiledTest), bodyBlock,
                endBlock))
        ir.setCurrentBlock(endBlock)
    }

    method checkSteppedRangeTypes(position:Position, type:Type):Bit {
        if type.typeKind = Type.Kind.NULLABLE {
            return checkSteppedRangeTypes(position, type.subtypes[0])
        }
        if type.isSteppedRange() {
            def type1 := type.subtypes[1].nonnullable()
            def type2 := type.subtypes[2]
            if type1 = type2 {
                return true
            }
            if type1.isChar() & type2.name.startsWith("panda.core.Int") &
                    type1.name.endsWith(type2.name["panda.core.Int".length()..]) {
                return true
            }
            error(position, "for loop cannot iterate over '\{type}'; endpoint and step types " +
                    "are not compatible")
            return false
        }
        return true
    }

    function signed(type:Type):Type {
        match type.nonnullable() {
            when Type.UInt8():  return Type.Int8()
            when Type.UInt16(): return Type.Int16()
            when Type.UInt32(): return Type.Int32()
            when Type.UInt64(): return Type.Int64()
            otherwise: return type
        }
    }
    function unsigned(type:Type):Type {
        match type.nonnullable() {
            when Type.Int8():  return Type.UInt8()
            when Type.Int16(): return Type.UInt16()
            when Type.Int32(): return Type.UInt32()
            when Type.Int64(): return Type.UInt64()
            otherwise: return type
        }
    }

    method debugPrint(value:IR.Value) {
        def auto := AutoUnrefs(self)
        def p := Position()
        def args := Array<ASTNode>() -- FIXME literal
        args.add(ASTNode.IR_WRAPPER(p, value))
        compileCall(p, ASTNode.DOT(p, ASTNode.IDENTIFIER(p, "Console"), "printLine"), args.finish(),
                TypeContext.UNSPECIFIED)
    }

    method compileSimpleRangeFor(position:Position, label:String?, index:Variable, range:IR.Value,
            statements:ListView<ASTNode>) {
        function arg(a:IR.Value):ListView<ASTNode> {
            -- FIXME until I have array literals
            def result := Array<ASTNode>()
            result.add(ASTNode.IR_WRAPPER(Position(), a))
            return result
        }
        assert range.type().typeKind = Type.Kind.GENERIC
        assert range.type().subtypes.count = 2
        assert range.type().subtypes[0].name = RANGE_NAME
        def indexSlot:Int
        match index.storage {
            when Variable.Storage.LOCAL(slot):
                indexSlot := slot
            otherwise:
                assert false
        }
        def indexType := range.type().subtypes[1].nonnullable()
        def rangeClass := getClass(range.type())
        if rangeClass == null {
            return
        }
        def rangeFields := instanceFields(rangeClass)

        -- extract start value from range
        def start := coerce(position, IR.Value.REF(ir.add(IR.Statement.EXTRACT_FIELD(range,
                rangeFields[0])), range.type().subtypes[1]), indexType)

        -- store start value
        ir.add(IR.Statement.STORE(start, IR.Value.LOCAL(indexSlot, indexType)))

        -- extract end value from range
        def end := coerce(position, IR.Value.REF(ir.add(IR.Statement.EXTRACT_FIELD(range,
                rangeFields[1])), range.type().subtypes[1]), indexType)

        -- extract inclusive / exclusive from range
        def inclusive := extractBuiltinBit(IR.Value.REF(ir.add(IR.Statement.EXTRACT_FIELD(range,
                rangeFields[2])), Type.Bit()))

        def step := compileExpression(ASTNode.INT(position, 1), TypeContext.TYPE(indexType))
        def stepComparison:IR.Value
        if step.type() = Type.Int64() {
            stepComparison := convert(step, Type.UInt64())
        }
        else {
            stepComparison := step
        }

        -- start block
        def loopStart := ir.newBlock("loopStart")
        def loopEnd := ir.newBlock("loopEnd")
        def loopTest := ir.newBlock("loopTest")
        def entryInclusive := ir.newBlock("entryInclusive")
        def entryExclusive := ir.newBlock("entryExclusive")
        def context := AutoContext(self, EnclosingContext.LOOP(label, loopEnd, loopTest))
        {
            def scope := AutoScope(self)
            ir.add(IR.Statement.CONDITIONAL_BRANCH(inclusive, entryInclusive, entryExclusive))
            ir.setCurrentBlock(entryInclusive)
            def entryInclusiveTest := extractBuiltinBit(call(position, start, "<=", arg(end),
                        TypeContext.TYPE(Type.Bit())))
            ir.add(IR.Statement.CONDITIONAL_BRANCH(entryInclusiveTest, loopStart, loopEnd))
            ir.setCurrentBlock(entryExclusive)
            def entryExclusiveTest := extractBuiltinBit(call(position, start, "<", arg(end),
                        TypeContext.TYPE(Type.Bit())))
            ir.add(IR.Statement.CONDITIONAL_BRANCH(entryExclusiveTest, loopStart, loopEnd))
            ir.setCurrentBlock(loopStart)
            for s in statements {
                compileStatement(s)
            }
        }
        if !ir.currentBlockFinished() {
            ir.add(IR.Statement.BRANCH(loopTest))
        }
        ir.setCurrentBlock(loopTest)
        def loopInc := ir.newBlock("loopInc")
        -- perform the test by subtracting index from end and then comparing to step, to avoid
        -- overflows near the maximum value
        def indexLoad := IR.Value.REF(ir.add(IR.Statement.LOAD(IR.Value.LOCAL(indexSlot,
                indexType))), indexType)
        -- always use unsigned comparison to avoid overflow; we know both the delta and the step are
        -- the same sign
        def delta := convert(call(position, end, "-", arg(indexLoad), TypeContext.NON_VOID),
                unsigned(indexType))
        assert delta !== null, "can't negate \{arg(indexLoad)}"

        def inclusiveTest := ir.newBlock("inclusiveTest")
        def exclusiveTest := ir.newBlock("exclusiveTest")
        ir.add(IR.Statement.CONDITIONAL_BRANCH(inclusive, inclusiveTest, exclusiveTest))

        -- inclusive test
        ir.setCurrentBlock(inclusiveTest)
        def inclusiveTestBit := extractBuiltinBit(call(position, delta, ">=", arg(stepComparison),
                TypeContext.TYPE(Type.Bit())))
        ir.add(IR.Statement.CONDITIONAL_BRANCH(inclusiveTestBit, loopInc, loopEnd))

        -- exclusive test
        ir.setCurrentBlock(exclusiveTest)
        def exclusiveTestBit := extractBuiltinBit(call(position, delta, ">", arg(stepComparison),
                TypeContext.TYPE(Type.Bit())))
        ir.add(IR.Statement.CONDITIONAL_BRANCH(exclusiveTestBit, loopInc, loopEnd))

        ir.setCurrentBlock(loopInc)
        def inc := convert(call(position, indexLoad, "+", arg(step), TypeContext.NON_VOID),
                indexType)
        ir.add(IR.Statement.STORE(inc, IR.Value.LOCAL(indexSlot, indexType)))
        ir.add(IR.Statement.BRANCH(loopStart))

        ir.setCurrentBlock(loopEnd)
    }

    method compileSteppedRangeFor(position:Position, label:String?, index:Variable, range:IR.Value,
            statements:ListView<ASTNode>) {
        -- I am acutely aware of how horrific this looks.
        --
        -- There's no easy way to produce clean output here, since we have to handle different step
        -- values, different loop directions, and both inclusive and exclusive ranges, all of which
        -- could potentially be determined at runtime. It gets even uglier when you consider the
        -- difficulty of handling the extremes of the numeric types. You can't just add 1 and then
        -- check to see if it's in range when the limit is MAX_INT, because you'll overflow and end
        -- up with an infinite loop. You also can't just check for being equal to the limit before
        -- adding the step, because with a step bigger than 1 (or smaller than -1) you might need to
        -- stop before actually hitting the end. So you instead check the difference between the
        -- current index and the limit, but even there you need to be careful because it could
        -- overflow in a signed test, and... ugh, it's surprisingly messy and results in a ton of
        -- code.
        --
        -- Fortunately, we can just write incredibly-awful-but-straightforward code and let LLVM
        -- optimize it to something sensible if it turns out the values are known at compile time.
        -- This works remarkably well, because LLVM is awesome.
        function arg(a:IR.Value):ListView<ASTNode> {
            -- FIXME until I have array literals
            def result := Array<ASTNode>()
            result.add(ASTNode.IR_WRAPPER(Position(), a))
            return result
        }
        assert range.type().typeKind = Type.Kind.GENERIC
        assert range.type().subtypes.count = 3
        assert range.type().subtypes[0].name = STEPPED_RANGE_NAME
        def indexSlot:Int
        match index.storage {
            when Variable.Storage.LOCAL(slot):
                indexSlot := slot
            otherwise:
                assert false
        }
        def indexType := range.type().subtypes[1]
        assert indexType.typeKind != Type.Kind.NULLABLE
        def stepType := range.type().subtypes[2]
        def rangeClass := getClass(range.type())
        if rangeClass == null {
            return
        }
        def rangeFields := instanceFields(rangeClass)

        -- extract start value from range
        def start := IR.Value.REF(ir.add(IR.Statement.EXTRACT_FIELD(range, rangeFields[0])),
                indexType)

        -- store start value
        ir.add(IR.Statement.STORE(start, IR.Value.LOCAL(indexSlot, indexType)))

        -- extract end value from range
        def end := IR.Value.REF(ir.add(IR.Statement.EXTRACT_FIELD(range, rangeFields[1])),
                indexType)

        -- extract step value from range
        def step := IR.Value.REF(ir.add(IR.Statement.EXTRACT_FIELD(range, rangeFields[2])),
                stepType)
        def stepComparison:IR.Value
        if step.type() = Type.Int64() {
            stepComparison := convert(step, Type.UInt64())
        }
        else {
            stepComparison := step
        }
        def negStep := convert(call(position, convert(step, signed(step.type())), "-",
                Array<ASTNode>() -* FIXME literal *-, TypeContext.NON_VOID), stepType)
        def negStepComparison:IR.Value
        if step.type() = Type.Int64() {
            negStepComparison := convert(negStep, Type.UInt64())
        }
        else {
            negStepComparison := negStep
        }

        -- extract inclusive / exclusive from range
        def inclusive := extractBuiltinBit(IR.Value.REF(ir.add(IR.Statement.EXTRACT_FIELD(range,
                rangeFields[3])), Type.Bit()))

        -- start block
        def loopStart := ir.newBlock("loopStart")
        def loopEnd := ir.newBlock("loopEnd")
        def loopTest := ir.newBlock("loopTest")
        def forwardEntry := ir.newBlock("forwardEntry")
        def backwardEntry := ir.newBlock("backwardEntry")
        def direction:IR.Value
        def context := AutoContext(self, EnclosingContext.LOOP(label, loopEnd, loopTest))
        {
            def scope := AutoScope(self)
            if stepType.name.startsWith("panda.core.Int") {
                def args := Array<ASTNode>() -- FIXME literal
                args.add(ASTNode.INT(position, 0))
                direction := extractBuiltinBit(call(position, step, ">=", args,
                        TypeContext.TYPE(Type.Bit())))
            }
            else {
                assert stepType.name.startsWith("panda.core.UInt")
                direction := IR.Value.BIT(true)
            }
            ir.add(IR.Statement.CONDITIONAL_BRANCH(direction, forwardEntry, backwardEntry))
            ir.setCurrentBlock(forwardEntry)
            def forwardEntryInclusive := ir.newBlock("forwardEntryInclusive")
            def forwardEntryExclusive := ir.newBlock("forwardEntryExclusive")
            ir.add(IR.Statement.CONDITIONAL_BRANCH(inclusive, forwardEntryInclusive,
                    forwardEntryExclusive))
            ir.setCurrentBlock(forwardEntryInclusive)
            def forwardEntryInclusiveTest := extractBuiltinBit(call(position, start, "<=", arg(end),
                        TypeContext.TYPE(Type.Bit())))
            ir.add(IR.Statement.CONDITIONAL_BRANCH(forwardEntryInclusiveTest, loopStart, loopEnd))
            ir.setCurrentBlock(forwardEntryExclusive)
            def forwardEntryExclusiveTest := extractBuiltinBit(call(position, start, "<", arg(end),
                        TypeContext.TYPE(Type.Bit())))
            ir.add(IR.Statement.CONDITIONAL_BRANCH(forwardEntryExclusiveTest, loopStart, loopEnd))
            ir.setCurrentBlock(backwardEntry)
            def backwardEntryInclusive := ir.newBlock("backwardEntryInclusive")
            def backwardEntryExclusive := ir.newBlock("backwardEntryExclusive")
            ir.add(IR.Statement.CONDITIONAL_BRANCH(inclusive, backwardEntryInclusive,
                    backwardEntryExclusive))
            ir.setCurrentBlock(backwardEntryInclusive)
            def backwardEntryInclusiveTest := extractBuiltinBit(call(position, start, ">=", arg(end),
                        TypeContext.TYPE(Type.Bit())))
            ir.add(IR.Statement.CONDITIONAL_BRANCH(backwardEntryInclusiveTest, loopStart, loopEnd))
            ir.setCurrentBlock(backwardEntryExclusive)
            def backwardEntryExclusiveTest := extractBuiltinBit(call(position, start, ">", arg(end),
                        TypeContext.TYPE(Type.Bit())))
            ir.add(IR.Statement.CONDITIONAL_BRANCH(backwardEntryExclusiveTest, loopStart, loopEnd))
            ir.setCurrentBlock(loopStart)
            for s in statements {
                compileStatement(s)
            }
        }
        if !ir.currentBlockFinished() {
            ir.add(IR.Statement.BRANCH(loopTest))
        }
        ir.setCurrentBlock(loopTest)
        def loopInc := ir.newBlock("loopInc")
        -- beginning of loop test, load index and determine direction
        def indexLoad := IR.Value.REF(ir.add(IR.Statement.LOAD(IR.Value.LOCAL(indexSlot,
                indexType))), indexType)
        def forwardTest := ir.newBlock("forwardTest")
        def backwardTest := ir.newBlock("backwardTest")
        ir.add(IR.Statement.CONDITIONAL_BRANCH(direction, forwardTest, backwardTest))

        -- forward loop; perform the test by subtracting index from end and then comparing to step,
        -- to avoid overflows near the maximum value
        ir.setCurrentBlock(forwardTest)
        -- always use unsigned comparison to avoid overflow; we know both the delta and the step are
        -- the same sign
        def forwardDelta := convert(call(position, end, "-", arg(indexLoad), TypeContext.NON_VOID),
                unsigned(indexType))

        -- forward loop; determine inclusive / exclusive
        def forwardInclusiveTest := ir.newBlock("forwardInclusiveTest")
        def forwardExclusiveTest := ir.newBlock("forwardExclusiveTest")
        ir.add(IR.Statement.CONDITIONAL_BRANCH(inclusive, forwardInclusiveTest,
                forwardExclusiveTest))

        -- forward inclusive test
        ir.setCurrentBlock(forwardInclusiveTest)
        def forwardInclusiveTestBit := extractBuiltinBit(call(position, forwardDelta, ">=",
                arg(stepComparison), TypeContext.TYPE(Type.Bit())))
        ir.add(IR.Statement.CONDITIONAL_BRANCH(forwardInclusiveTestBit, loopInc, loopEnd))

        -- forward exclusive test
        ir.setCurrentBlock(forwardExclusiveTest)
        def forwardExclusiveTestBit := extractBuiltinBit(call(position, forwardDelta, ">",
                arg(stepComparison), TypeContext.TYPE(Type.Bit())))
        ir.add(IR.Statement.CONDITIONAL_BRANCH(forwardExclusiveTestBit, loopInc, loopEnd))

        -- backward loop; perform the test by subtracting end from index and then comparing to
        -- -step, to avoid overflows near the minimum value
        ir.setCurrentBlock(backwardTest)
        def backwardDelta := convert(call(position, indexLoad, "-", arg(end), TypeContext.NON_VOID),
                unsigned(indexType))

        -- backward loop; determine inclusive / exclusive
        def backwardInclusiveTest := ir.newBlock("backwardInclusiveTest")
        def backwardExclusiveTest := ir.newBlock("backwardExclusiveTest")
        ir.add(IR.Statement.CONDITIONAL_BRANCH(inclusive, backwardInclusiveTest,
                backwardExclusiveTest))

        -- backward inclusive test
        ir.setCurrentBlock(backwardInclusiveTest)
        def backwardInclusiveTestBit := extractBuiltinBit(call(position, backwardDelta, ">=",
                arg(negStepComparison), TypeContext.TYPE(Type.Bit())))
        ir.add(IR.Statement.CONDITIONAL_BRANCH(backwardInclusiveTestBit, loopInc, loopEnd))

        -- backward exclusive test
        ir.setCurrentBlock(backwardExclusiveTest)
        def backwardExclusiveTestBit := extractBuiltinBit(call(position, backwardDelta, ">",
                arg(negStepComparison), TypeContext.TYPE(Type.Bit())))
        ir.add(IR.Statement.CONDITIONAL_BRANCH(backwardExclusiveTestBit, loopInc, loopEnd))

        ir.setCurrentBlock(loopInc)
        def inc := convert(call(position, indexLoad, "+", arg(step), TypeContext.NON_VOID),
                indexType)
        ir.add(IR.Statement.STORE(inc, IR.Value.LOCAL(indexSlot, indexType)))
        ir.add(IR.Statement.BRANCH(loopStart))

        ir.setCurrentBlock(loopEnd)
    }

    method compileRangeFor(position:Position, label:String?, astTarget:ASTNode, list:IR.Value,
            statements:ListView<ASTNode>) {
        assert list.type().isRange() | list.type().isSteppedRange()
        if !checkSteppedRangeTypes(position, list.type()) {
            return
        }
        def elementType:Type
        if list.type().typeKind = Type.Kind.NULLABLE {
            assert list.type().subtypes[0].typeKind = Type.Kind.GENERIC
            elementType := list.type().subtypes[0].subtypes[1]
        }
        else {
            assert list.type().typeKind = Type.Kind.GENERIC
            elementType := list.type().subtypes[1]
        }
        if !elementType.isNumeric() {
            error(position, "for loop expected a numeric range, but found '\{list.type()}'")
            return
        }
        def scope := AutoScope(self)
        def target := compileTarget(astTarget, Variable.Kind.DEF, null, elementType.nonnullable())
        if target == null {
            return
        }
        assert target.second == null
        if list.type().isRange() {
            compileSimpleRangeFor(position, label, target.first, list, statements)
        }
        else {
            compileSteppedRangeFor(position, label, target.first, list, statements)
        }
    }

    method compileRangeFor(position:Position, label:String?, astTarget:ASTNode, rawList:ASTNode,
            statements:ListView<ASTNode>) {
        def elementType:Type
        def list:IR.Value?
        match astTarget {
            when ASTNode.TYPED_IDENTIFIER(position, _, type):
                def t := resolve(scanner.convertType(type))
                if t.typeKind = Type.Kind.NULLABLE {
                    error(position, "for loop variable cannot have nullable type '\{t}'")
                    return
                }
                if !t.isNumeric() {
                    error(position, "for loop variable cannot have non-numeric type '\{t}'")
                    return
                }
                match rawList {
                    when ASTNode.RANGE(_, _, _, _, step):
                        def type:Type
                        if step !== null {
                            type := Type.SteppedRangeOf(t)
                        }
                        else {
                            type := Type.RangeOf(t)
                        }
                        list := compileExpression(rawList, TypeContext.TYPE(type))
                    otherwise:
                        assert false -- shouldn't end up here otherwise
                }
            otherwise:
                def preferred := preferredType(rawList)
                var type := TypeContext.NON_VOID
                if preferred !== null & preferred.isRange() {
                    type := TypeContext.TYPE(Type.RangeOf(preferred.subtypes[1].nonnullable()))
                }
                else if preferred !== null & preferred.isSteppedRange() {
                    type := TypeContext.TYPE(Type.SteppedRangeOf(
                            preferred.subtypes[1].nonnullable(), preferred.subtypes[2]))
                }
                list := compileExpression(rawList, type)
        }
        if list == null {
            return
        }
        compileRangeFor(position, label, astTarget, list, statements)
    }

    method compileIteratorFor(position:Position, label:String?, target:ASTNode, iterator:IR.Value,
            statements:ListView<ASTNode>) {
        def testBlock := ir.newBlock("testBlock")
        def bodyBlock := ir.newBlock("bodyBlock")
        def endBlock := ir.newBlock("endBlock")
        def context := AutoContext(self, EnclosingContext.LOOP(label, endBlock, testBlock))
        assert iterator.type().typeKind = Type.Kind.GENERIC &
                iterator.type().subtypes[0] = Type.Iterator()
        ir.add(IR.Statement.BRANCH(testBlock))
        ir.setCurrentBlock(testBlock)
        def compiledTest := call(position, iterator, "get_done", Array<ASTNode>(),
                TypeContext.TYPE(Type.Bit()))
        if compiledTest == null {
            return
        }
        ir.add(IR.Statement.CONDITIONAL_BRANCH(extractBuiltinBit(compiledTest), endBlock,
                bodyBlock))
        ir.setCurrentBlock(bodyBlock)
        {
            def auto := AutoScope(self)
            def unrefs := AutoUnrefs(self)
            def compiledTarget := compileTarget(target, Variable.Kind.DEF, null,
                    iterator.type().subtypes[1])
            if compiledTarget == null {
                return
            }
            def targetType := compiledTarget.first.type
            def next := call(position, iterator, "next", Array<ASTNode>(),
                    TypeContext.TYPE(targetType))
            if next == null {
                return
            }
            VariableLValue(self, compiledTarget.first).compileStore(next)
            for s in statements {
                compileStatement(s)
            }
        }
        if !ir.currentBlockFinished() {
            ir.add(IR.Statement.BRANCH(testBlock))
        }
        ir.setCurrentBlock(endBlock)
    }

    method compileFor(position:Position, label:String?, rawTarget:ASTNode, rawList:ASTNode,
            statements:ListView<ASTNode>) {
        match rawList {
            when ASTNode.RANGE:
                -- need to resolve unresolved range in terms of its target, as for i:Int8 in 0 .. 10
                -- and for i:Int64 in 0 .. 10 result in different kinds of ranges
                compileRangeFor(position, label, rawTarget, rawList, statements)
                return
        }
        def list := compileExpression(rawList)
        if list == null {
            return
        }
        if list.type().isRange() | list.type().isSteppedRange() {
            -- it's a range, but not an unresolved one
            compileRangeFor(position, label, rawTarget, list, statements)
        }
        else {
            for intf in allInterfaces(list.type()) {
                if intf.typeKind = Type.Kind.GENERIC & intf.subtypes[0] = Type.Iterator() {
                    def iterator := coerce(rawList.position(), list, intf)
                    compileIteratorFor(position, label, rawTarget, iterator, statements)
                    return
                }
                if intf.typeKind = Type.Kind.GENERIC & intf.subtypes[0] = Type.Iterable() {
                    def iterable := coerce(rawList.position(), list, intf)
                    if iterable == null {
                        return
                    }
                    def iterator := call(position, iterable, "iterator", Array<ASTNode>(),
                            TypeContext.NON_VOID)
                    assert iterator !== null
                    compileIteratorFor(position, label, rawTarget, iterator, statements)
                    return
                }
            }
            error(rawList.position(), "expected a range, Iterable, or Iterator, but found " +
                    "'\{list.type()}'")
        }
    }

    method compileIf(position:Position, test:ASTNode, ifTrue:ImmutableArray<ASTNode>,
            ifFalse:ASTNode?) {
        def compiledTest:IR.Value?
        {
            def unrefs := AutoUnrefs(self)
            compiledTest := compileExpression(test, TypeContext.TYPE(Type.Bit()))
            if compiledTest == null {
                return
            }
        }
        def ifTrueBlock := ir.newBlock("if true")
        def ifFalseBlock:IR.Block.ID
        def endBlock := ir.newBlock("if end")
        if ifFalse !== null {
            ifFalseBlock := ir.newBlock("if false")
        }
        else {
            ifFalseBlock := endBlock
        }
        ir.add(IR.Statement.CONDITIONAL_BRANCH(extractBuiltinBit(compiledTest), ifTrueBlock,
                ifFalseBlock))
        ir.setCurrentBlock(ifTrueBlock)
        {
            def scope := AutoScope(self)
            for s in ifTrue {
                compileStatement(s)
            }
        }
        if !ir.currentBlockFinished() {
            ir.add(IR.Statement.BRANCH(endBlock))
        }
        if ifFalse !== null {
            ir.setCurrentBlock(ifFalseBlock)
            compileStatement(ifFalse)
            if !ir.currentBlockFinished() {
                ir.add(IR.Statement.BRANCH(endBlock))
            }
        }
        ir.setCurrentBlock(endBlock)
    }

    method compileInnerMethod(position:Position, kind:MethodDecl.Kind, name:String,
            rawParameters:ImmutableArray<ASTNode>, rawReturnType:ASTNode?,
            body:ImmutableArray<ASTNode>) {
        def methodRef := compileClosure(position, kind, rawParameters, rawReturnType, body,
                TypeContext.NON_VOID)
        if methodRef == null {
            return
        }
        def decl := ASTNode.DECLARATION(position, ASTNode.IDENTIFIER(position, name),
                ASTNode.IR_WRAPPER(position, methodRef))
        def decls := Array<ASTNode>() -- FIXME literal
        decls.add(decl)
        compileStatement(ASTNode.VAR(position, Variable.Kind.DEF, decls.finish()))
    }

    method compileLoop(position:Position, label:String?, statements:ImmutableArray<ASTNode>) {
        def bodyBlock := ir.newBlock("loop body")
        def endBlock := ir.newBlock("loop end")
        def auto := AutoContext(self, EnclosingContext.LOOP(label, endBlock, bodyBlock))
        def scope := AutoScope(self)
        ir.add(IR.Statement.BRANCH(bodyBlock))
        ir.setCurrentBlock(bodyBlock)
        for s in statements {
            compileStatement(s)
        }
        if !ir.currentBlockFinished() {
            ir.add(IR.Statement.BRANCH(bodyBlock))
        }
        ir.setCurrentBlock(endBlock)
    }

    method compileTarget(t:ASTNode, kind:Variable.Kind,
            rawValue:ASTNode?, valueType:Type?):Pair<Variable, IR.Value?>? {
        match t {
            when ASTNode.IDENTIFIER(position, name):
                -- no type, infer from value
                def value:IR.Value?
                def type:Type
                if rawValue !== null {
                    var preferred := preferredType(rawValue)
                    if preferred == null {
                        value := compileExpression(rawValue, TypeContext.NON_VOID)
                        if value == null {
                            return null
                        }
                        preferred := value.type()
                    }
                    else {
                        value := compileExpression(rawValue, TypeContext.TYPE(preferred))
                    }
                    if value == null {
                        return null
                    }
                    type := value.type()
                }
                else if valueType !== null {
                    type := valueType
                }
                else {
                    error(position, "declaration has neither a type nor a value")
                    return null
                }
                def v := Variable(position, kind, name, type,
                        Variable.Storage.LOCAL(ir.locals.count))
                v.owner := currentMethod[0]
                if isRefCounted(v.type) {
                    enclosingContexts.push(EnclosingContext.VARIABLE_SCOPE(v))
                    ir.add(IR.Statement.STORE(IR.Value.NULL(v.type.nullable()),
                            IR.Value.LOCAL(ir.locals.count, v.type)))
                }
                ir.locals.add(v.type)
                symbolTable.add(v)
                return Pair<Variable, IR.Value?>(v, value)
            when ASTNode.TYPED_IDENTIFIER(position, name, rawType):
                def type := resolve(scanner.convertType(rawType))
                if type == null {
                    return null
                }
                def value:IR.Value?
                if rawValue !== null {
                    value := compileExpression(rawValue, TypeContext.TYPE(type))
                    if value == null {
                        return null
                    }
                }
                else {
                    value := null
                }
                def v := Variable(position, kind, name, type,
                        Variable.Storage.LOCAL(ir.locals.count))
                v.owner := currentMethod[0]
                if isRefCounted(v.type) {
                    enclosingContexts.push(EnclosingContext.VARIABLE_SCOPE(v))
                    ir.add(IR.Statement.STORE(IR.Value.NULL(v.type.nullable()),
                            IR.Value.LOCAL(ir.locals.count, v.type)))
                }
                ir.locals.add(v.type)
                symbolTable.add(v)
                return Pair<Variable, IR.Value?>(v, value)
            otherwise:
                assert false
        }
    }

    method compileDeclaration(position:Position, target:ASTNode, value:ASTNode?,
            varKind:Variable.Kind) {
        def compiledTarget := compileTarget(target, varKind, value, null)
        if compiledTarget == null {
            return
        }
        if compiledTarget.second !== null {
            VariableLValue(self, compiledTarget.first).compileStore(compiledTarget.second)
        }
    }

    method checkChoiceMatch(position:Position, cc:ChoiceCase?, choiceClass:ClassDecl?,
            value:IR.Value):Bit {
        if cc == null {
            return false
        }
        if choiceClass == null {
            error(position, "cannot match choice case '\{cc}' against '\{value.type()}'")
            return false
        }
        if cc.owner !== choiceClass {
            error(position, "cannot match choice case '\{cc}' against " +
                    "'\{choiceClass.name}'")
            return false
        }
        return true
    }

    @pre(whens.count > 0 | other !== null)
    method compileChainedIfMatch(value:IR.Value, choiceClass:ClassDecl?, choiceRawValue:IR.Value?,
            whens:ImmutableArray<ASTNode>, other:ImmutableArray<ASTNode>?) {
        def end := ir.newBlock("match end")
        var nextBlock := ir.currentBlock.id
        for i in 0 .. whens.count {
            def w := whens[i]
            match w {
                when ASTNode.WHEN(position, tests, statements):
                    def auto := AutoScope(self)
                    ir.setCurrentBlock(nextBlock)
                    var testSuccess := ir.newBlock("test success")
                    for j in 0 .. tests.count {
                        ir.setCurrentBlock(nextBlock)
                        if j < tests.count - 1 | i < whens.count - 1 | other !== null {
                            nextBlock := ir.newBlock("match")
                        }
                        else {
                            nextBlock := end
                        }
                        def t := tests[j]
                        match t {
                            when ASTNode.CALL(position, base, args):
                                def cc := getChoiceCase(base)
                                if cc !== null {
                                    if checkChoiceMatch(base.position(), cc.second, choiceClass,
                                            value) {
                                        if tests.count != 1 {
                                            error(position, "destructuring choice 'when' cannot " +
                                                    "be used together with other 'when' " +
                                                    "comparisons")
                                            return
                                        }
                                        if args.count != cc.second.fields.count {
                                            error(position, "choice '\{cc.second}' requires " +
                                                    cc.second.fields.count +
                                                    " argument\{cc.second.fields.count = 1:|s}, " +
                                                    "but found " + args.count)
                                            return
                                        }
                                        if choiceRawValue == null {
                                            error(position, "'\{value.type()}' is not an " +
                                                    "instance of '\{cc.second.owner.name}'")
                                            return
                                        }
                                        def eqArgs := Array<ASTNode>() -- FIXME literal
                                        eqArgs.add(ASTNode.INT(base.position(),
                                                cc.second.rawValue.convert()))
                                        def test := call(base.position(), choiceRawValue, "=",
                                                eqArgs, TypeContext.TYPE(Type.Bit()))
                                        assert test !== null
                                        ir.add(IR.Statement.CONDITIONAL_BRANCH(
                                                extractBuiltinBit(test), testSuccess, nextBlock))
                                        ir.setCurrentBlock(testSuccess)
                                        for i in 0 .. args.count {
                                            def ptr := ir.add(IR.Statement.GET_CHOICE_FIELD_POINTER(
                                                    value, cc.second, i))
                                            def load := ir.add(IR.Statement.LOAD(IR.Value.REF(ptr,
                                                    cc.second.fields[i])))
                                            if getText(args[i]) = "_" {
                                                continue
                                            }
                                            def target := compileTarget(args[i], Variable.Kind.DEF,
                                                    ASTNode.IR_WRAPPER(position,
                                                            IR.Value.REF(load,
                                                                cc.second.fields[i])),
                                                            null)
                                            VariableLValue(self, target.first).compileStore(
                                                    IR.Value.REF(load, cc.second.fields[i]))
                                        }
                                        continue
                                    }
                                }
                        }
                        def test:IR.Value?
                        def cc := getChoiceCase(t)
                        if cc !== null {
                            def args := Array<ASTNode>() -- FIXME literal
                            args.add(ASTNode.INT(t.position(), cc.second.rawValue.convert()))
                            test := call(t.position(), choiceRawValue, "=", args,
                                    TypeContext.TYPE(Type.Bit()))
                            if test == null {
                                return
                            }
                        }
                        else {
                            def args := Array<ASTNode>() -- FIXME literal
                            args.add(t)
                            test := call(t.position(), value, "=", args,
                                    TypeContext.TYPE(Type.Bit()))
                            if test == null {
                                return
                            }
                        }
                        ir.add(IR.Statement.CONDITIONAL_BRANCH(extractBuiltinBit(test), testSuccess,
                                nextBlock))
                    }
                    ir.setCurrentBlock(testSuccess)
                    for s in statements {
                        compileStatement(s)
                    }
                    if !ir.currentBlockFinished() {
                        ir.add(IR.Statement.BRANCH(end))
                    }
                otherwise:
                    assert false
            }
        }
        if other !== null {
            ir.setCurrentBlock(nextBlock)
            for s in other {
                compileStatement(s)
            }
            if !ir.currentBlockFinished() {
                ir.add(IR.Statement.BRANCH(end))
            }
        }
        ir.setCurrentBlock(end)
    }

    method compileMatch(position:Position, value:ASTNode, whens:ImmutableArray<ASTNode>,
            other:ImmutableArray<ASTNode>?) {
        var compiledValue := compileExpression(value, TypeContext.NON_VOID)
        if compiledValue == null | (whens.count = 0 & other == null) {
            return
        }
        def cl := getClass(compiledValue.type())
        if cl == null {
            return
        }
        def choiceClass:ClassDecl? := null
        def choiceRawValue:IR.Value?
        if cl.classKind = ClassDecl.Kind.CHOICE {
            choiceRawValue := compileDot(position, compiledValue, ClassDecl.RAW_VALUE_NAME)
            choiceClass := cl
        }
        else if getSymbolTable(cl)["="] == null {
            error(value.position(), "'match' value does not define the '=' operator")
            return
        }
        else {
            choiceRawValue := null
        }
        compileChainedIfMatch(compiledValue, choiceClass, choiceRawValue, whens, other)
    }

    method leaveScope(c:EnclosingContext) {
        if ir.currentBlockFinished() {
            -- we've already left the scope by other means; cleanup will have happened there
            return
        }
        match c {
            when EnclosingContext.VARIABLE_SCOPE(v):
                def ref := symbolRef(v.position, null, v)
                assert ref !== null
                compileUnref(ref)
                match v.storage {
                    when Variable.Storage.LOCAL(slot):
                        ir.add(IR.Statement.STORE(
                                IR.Value.NULL(v.type.nullable()),
                                IR.Value.LOCAL(slot, v.type.nullable())))
                    otherwise:
                        assert false
                }
        }
    }

    method leaveAllScopes() {
        for c in enclosingContexts {
            leaveScope(c)
        }
    }

    @pre(returnValue == null)
    method compileReturn(position:Position, value:ASTNode?) {
        if currentMethod[0].name = "cleanup" & currentMethod[0].parameters.count = 0 &
                currentMethod[0].owner.name != WEAK_NAME {
            for f in currentMethod[0].owner.fields {
                if resolve(f) & !f.annotations.isClass() & f.fieldKind != FieldDecl.Kind.PROPERTY &
                        isRefCounted(f.type) {
                    def load := FieldLValue(self, position,
                            compileExpression(ASTNode.IDENTIFIER(position, FORCE_SELF_NAME),
                                TypeContext.UNSPECIFIED),
                            f).compileLoad()
                    if load == null {
                        return
                    }
                    compileUnref(load)
                }
            }
        }
        if value !== null {
            if currentMethod[0].returnType = Type.Void() {
                error(position, "cannot return a value from a method with no return type")
                return
            }
            def compiled:IR.Value?
            {
                def unrefs := AutoUnrefs(self)
                compiled := compileExpression(value, TypeContext.TYPE(currentMethod[0].returnType))
                if compiled == null {
                    return
                }
                returnValue := compiled
                if isRefCounted(compiled.type()) {
                    compileRef(compiled)
                }
            }
            leaveAllScopes()
            compilePostconditions()
            ir.add(IR.Statement.RETURN(compiled))
            returnValue := null
        }
        else {
            if currentMethod[0].returnType != Type.Void() {
                if currentMethod[0].methodKind = MethodDecl.Kind.INIT {
                    compileReturn(position, ASTNode.SELF(position))
                    return
                }
                error(position, "expected a return value of type '\{currentMethod[0].returnType}'")
            }
            leaveAllScopes()
            compilePostconditions()
            ir.add(IR.Statement.RETURN(null))
        }
    }

    method compileVar(position:Position, kind:Variable.Kind, decls:ImmutableArray<ASTNode>) {
        for decl in decls {
            match decl {
                when ASTNode.DECLARATION(position, target, rawValue):
                    compileDeclaration(position, target, rawValue, kind)
                otherwise:
                    assert false
            }
        }
    }

    method compileWhile(position:Position, label:String?, test:ASTNode,
            statements:ImmutableArray<ASTNode>) {
        def testBlock := ir.newBlock("while test")
        def bodyBlock := ir.newBlock("while body")
        def endBlock := ir.newBlock("while end")
        def context := AutoContext(self, EnclosingContext.LOOP(label, endBlock, testBlock))
        def scope := AutoScope(self)
        ir.add(IR.Statement.BRANCH(testBlock))
        ir.setCurrentBlock(testBlock)
        def compiledTest:IR.Value?
        {
            def unrefs := AutoUnrefs(self)
            compiledTest := compileExpression(test, TypeContext.TYPE(Type.Bit()))
            if compiledTest == null {
                return
            }
        }
        ir.add(IR.Statement.CONDITIONAL_BRANCH(extractBuiltinBit(compiledTest), bodyBlock,
                endBlock))
        ir.setCurrentBlock(bodyBlock)
        for s in statements {
            compileStatement(s)
        }
        if !ir.currentBlockFinished() {
            ir.add(IR.Statement.BRANCH(testBlock))
        }
        ir.setCurrentBlock(endBlock)
    }

    @post(symbolTable == @pre(symbolTable))
    method compileStatement(s:ASTNode) {
        ir.add(IR.Statement.COMMENT("line \{s.position().line}"))
        def unrefs := AutoUnrefs(self)
        match s {
            when ASTNode.ASSERT(position, test, msg):
                compileAssert(position, test, msg)
            when ASTNode.BINARY(position, left, op, right):
                compileAssignment(position, left, op, right)
            when ASTNode.BLOCK(position, statements):
                def symbols := AutoScope(self)
                for stmt in statements {
                    compileStatement(stmt)
                }
            when ASTNode.BREAK(position, label):
                compileBreak(position, label)
            when ASTNode.CALL(position, m, args):
                compileCall(position, m, args, TypeContext.UNSPECIFIED)
            when ASTNode.CONTINUE(position, label):
                compileContinue(position, label)
            when ASTNode.DO(position, label, statements, test):
                compileDo(position, label, statements, test)
            when ASTNode.FOR(position, label, target, list, statements):
                compileFor(position, label, target, list, statements)
            when ASTNode.IF(position, test, ifTrue, ifFalse):
                compileIf(position, test, ifTrue, ifFalse)
            when ASTNode.LOOP(position, label, statements):
                compileLoop(position, label, statements)
            when ASTNode.MATCH(position, value, whens, other):
                compileMatch(position, value, whens, other)
            when ASTNode.METHOD(position, _, _, kind, name, _, parameters, returnType, body):
                compileInnerMethod(position, kind, name, parameters, returnType, body)
            when ASTNode.RETURN(position, value):
                compileReturn(position, value)
            when ASTNode.VAR(position, kind, decls):
                compileVar(position, kind, decls)
            when ASTNode.WHILE(position, label, test, statements):
                compileWhile(position, label, test, statements)
            otherwise:
                assert false, "unsupported statement \{s}"
        }
    }

    method hasSelfParam(m:MethodDecl):Bit {
        if m.annotations.isClass() {
            return false
        }
        if m.methodKind != MethodDecl.Kind.INIT {
            return true
        }
        return !isValue(m.owner)
    }

    function callsOtherSelf(body:ImmutableArray<ASTNode>):Bit {
        if body.count = 0 {
            return false
        }
        match body[0] {
            when ASTNode.CALL(_, target, _):
                match target {
                    when ASTNode.IDENTIFIER(_, text):
                        return text = "init"
                }
        }
        return false
    }

    ================================================================================================
    Compiles an expression (which was found attached to `owner`) for use within `context`. The
    expression may reference parameters of `owner`, and these references will be interpreted as if
    they refer to the corresponding parameters of `context`. For instance, if we have two methods:

        @pre(param.count() > 0)
        method check(param:Array<Object>)

    and:

        @override
        method check(arr:Array<Object>)

    where the second method overrides the first, we need to attach the precondition expression to
    both methods. Since the second `check` method does not have a parameter named `param`, we need
    to use `compileExpressionInContext` to be able to compile the expression correctly.
    ================================================================================================
    @pre(owner.name = context.name & owner.parameters.count = context.parameters.count)
    method compileExpressionInContext(expr:ASTNode, type:TypeContext, owner:MethodDecl,
            context:MethodDecl):IR.Value? {
        def symbols := AutoScope(self)
        def unrefs := AutoUnrefs(self)
        for i in 0 .. owner.parameters.count {
            symbolTable.add(symbols.oldSymbolTable[context.parameters[i].name],
                    owner.parameters[i].name)
        }
        return compileExpression(expr, type)
    }

    method compilePreconditions() {
        def m := currentMethod[0]
        var start:IR.Block.ID? := null
        var fail:IR.Block.ID? := null
        var current := m
        loop {
            var havePre := false
            if current.annotations.expressions !== null {
                for ann in current.annotations.expressions {
                    match ann {
                        when Annotations.Expression.PRE(_, expr):
                            if current == m {
                                if m.overridden !== null {
                                    error(expr.position(), "cannot use '@pre' in a method which " +
                                            "overrides another method; did you mean '@preOr'?")
                                }
                                if havePre {
                                    error(expr.position(), "found more than one precondition")
                                }
                            }
                            havePre := true
                            def value := compileExpressionInContext(expr,
                                    TypeContext.TYPE(Type.Bit()), current, m)
                            if value == null {
                                return
                            }
                            if start == null {
                                start := ir.newBlock("precondition success")
                            }
                            fail := ir.newBlock("precondition fail")
                            ir.add(IR.Statement.CONDITIONAL_BRANCH(extractBuiltinBit(value), start,
                                    fail))
                            ir.setCurrentBlock(fail)
                        when Annotations.Expression.PRE_OR(_, expr):
                            if current == m {
                                if m.overridden == null {
                                    error(expr.position(), "cannot use '@preOr' in a method " +
                                            "which does not override another method; did you " +
                                            "mean '@pre'?")
                                }
                                if havePre {
                                    error(expr.position(), "found more than one precondition")
                                }
                            }
                            havePre := true
                            def value := compileExpressionInContext(expr,
                                    TypeContext.TYPE(Type.Bit()), current, m)
                            if value == null {
                                return
                            }
                            if start == null {
                                start := ir.newBlock("precondition success")
                            }
                            fail := ir.newBlock("precondition fail")
                            ir.add(IR.Statement.CONDITIONAL_BRANCH(extractBuiltinBit(value), start,
                                    fail))
                            ir.setCurrentBlock(fail)
                    }
                }
            }
            if current.overridden == null {
                break
            }
            current := current.overridden
        }
        if fail !== null {
            compileAssertFail(m.position, ASTNode.STRING(m.position,
                    "precondition failure for \{m.declaration()}"))
            assert start !== null
            ir.setCurrentBlock(start)
        }
    }

    method compilePostconditions() {
        if true {
            return
        }
        def auto := AutoScope(self, methodSymbolTable)
        def m := currentMethod[0]
        var success:IR.Block.ID? := null
        var fail:IR.Block.ID? := null
        var current := m
        loop {
            var havePost := false
            if current.annotations.expressions !== null {
                for ann in current.annotations.expressions {
                    match ann {
                        when Annotations.Expression.POST(_, expr):
                            if current == m {
                                if m.overridden !== null {
                                    error(expr.position(), "cannot use '@post' in a method which " +
                                            "overrides another method; did you mean '@postAnd'?")
                                }
                                if havePost {
                                    error(expr.position(), "found more than one postcondition")
                                }
                            }
                            havePost := true
                            if atPreBlock == null {
                                atPreBlock := ir.newBlock("@pre")
                            }
                            def value := compileExpressionInContext(expr,
                                    TypeContext.TYPE(Type.Bit()), current, m)
                            if value == null {
                                return
                            }
                            success := ir.newBlock("postcondition success")
                            if fail == null {
                                fail := ir.newBlock("postcondition fail")
                                def old := ir.currentBlock.id
                                ir.setCurrentBlock(fail)
                                compileAssertFail(m.position, ASTNode.STRING(m.position,
                                        "postcondition failure for \{m.declaration()}"))
                                ir.setCurrentBlock(old)
                            }
                            ir.add(IR.Statement.CONDITIONAL_BRANCH(extractBuiltinBit(value),
                                    success, fail))
                            ir.setCurrentBlock(success)
                        when Annotations.Expression.POST_AND(_, expr):
                            if current == m {
                                if m.overridden == null {
                                    error(expr.position(), "cannot use '@postAnd' in a method " +
                                            "which does not override another method; did you " +
                                            "mean '@post'?")
                                }
                                if havePost {
                                    error(expr.position(), "found more than one postcondition")
                                }
                            }
                            havePost := true
                            if atPreBlock == null {
                                atPreBlock := ir.newBlock("@pre")
                            }
                            def value := compileExpressionInContext(expr,
                                    TypeContext.TYPE(Type.Bit()), current, m)
                            if value == null {
                                return
                            }
                            success := ir.newBlock("postcondition success")
                            if fail == null {
                                fail := ir.newBlock("postcondition fail")
                                ir.setCurrentBlock(fail)
                                compileAssertFail(m.position, ASTNode.STRING(m.position,
                                        "postcondition failure for \{m.declaration()}"))
                            }
                            ir.add(IR.Statement.CONDITIONAL_BRANCH(extractBuiltinBit(value),
                                    success, fail))
                            ir.setCurrentBlock(success)
                    }
                }
            }
            if current.overridden == null {
                break
            }
            current := current.overridden
        }
    }

    method compile(m:MethodDecl) {
        compile(m, null)
    }

    method compile(m:MethodDecl, enclosingContext:SymbolTable?) {
        if !resolve(m) {
            return
        }
        currentMethod.push(m)
        checkAnnotations(m)
        assert atPreBlock == null
        if m.body !== null {
            def oldIR := ir
            ir := IR()
            {
                def auto := AutoScope(self)
                methodSymbolTable := symbolTable
                if enclosingContext !== null {
                    symbolTable.parents.add(enclosingContext)
                }
                if m.name = "main" {
                    if m.methodKind != MethodDecl.Kind.METHOD {
                        error(m.position, "'main' must be a method")
                    }
                    if m.returnType != Type.Void() {
                        error(m.position, "'main' must not have a return type")
                    }
                    if !m.annotations.isClass() {
                        error(m.position, "'main' must be declared @class")
                    }
                    def required := "panda.collections.ListView<panda.core.String>"
                    if m.parameters.count > 1 |
                            (m.parameters.count = 1 & m.parameters[0].type.name != required) {
                        error(m.position, "'main' must have either zero parameters or one " +
                                "parameter of type '\{required}'")
                    }
                }
                var index := 0
                if hasSelfParam(m) {
                    def selfParam := Variable(m.position, Variable.Kind.DEF, SELF_NAME,
                            m.owner.typeWithParameters(), Variable.Storage.PARAMETER(index))
                    index += 1
                    selfParam.owner := m
                    symbolTable.add(selfParam)
                }
                else if !m.annotations.isClass() {
                    def selfVar := Variable(m.position, Variable.Kind.DEF, SELF_NAME,
                            m.owner.typeWithParameters(), Variable.Storage.LOCAL(0))
                    selfVar.owner := m
                    ir.locals.add(selfVar.type)
                    symbolTable.add(selfVar)
                }
                if m.methodKind = MethodDecl.Kind.INIT & !callsOtherSelf(m.body) {
                    for f in m.owner.fields {
                        if f.rawValue !== null & !f.annotations.isClass() {
                            def p := f.rawValue.position()
                            compileStatement(ASTNode.BINARY(p,
                                    ASTNode.DOT(p, ASTNode.SELF(p), f.name),
                                    Token.Kind.ASSIGNMENT,
                                    f.rawValue))
                        }
                    }
                }
                for p in m.parameters {
                    def v := Variable(m.position, Variable.Kind.DEF, p.name, p.type,
                            Variable.Storage.PARAMETER(index))
                    v.owner := m
                    symbolTable.add(v)
                    index += 1
                }
                compilePreconditions()
                for s in m.body {
                    compileStatement(s)
                }
                if !ir.currentBlockFinished() {
                    if m.returnType = Type.Void() | m.methodKind = MethodDecl.Kind.INIT {
                        compileReturn(m.position, null)
                    }
                    else {
                        compileAssert(m.position, ASTNode.BIT(m.position, false),
                                ASTNode.STRING(m.position,
                                    "\{m.declaration()} exited without returning"))
                        ir.add(IR.Statement.UNREACHABLE)
                    }
                }
            }
            if atPreBlock !== null {
                def index:Int?
                for i in 0 .. ir.blocks.count {
                    if ir.blocks[i].id = atPreBlock {
                        index := i
                        break
                    }
                }
                assert index !== null
                if ir.blocks[index].statements.count > 0 {
                    ir.setCurrentBlock(atPreBlock)
                    ir.add(IR.Statement.BRANCH(ir.blocks[0].id))
                    def tmp := ir.blocks[0]
                    ir.blocks[0] := ir.blocks[index]
                    ir.blocks[index] := tmp
                }
                else {
                    ir.blocks.removeIndex(index)
                }
                atPreBlock := null
            }
            if writeCode {
                codeGenerator.write(m, ir)
            }
            ir := oldIR
        }
        else {
            codeGenerator.writeDeclaration(m)
        }
        currentMethod.pop(m)
    }

    method markNonExternal(cl:ClassDecl) {
        cl.external := false
        for inner in cl.classes {
            markNonExternal(inner)
        }
    }

    method checkImmutable(cl:ClassDecl) {
        if !cl.annotations.isUnsafeImmutable() & isImmutable(cl) {
            for f in cl.fields {
                resolve(f)
                if f.fieldKind = FieldDecl.Kind.VAR {
                    error(f.position, "immutable class '\{cl.name}' cannot contain a 'var'")
                }
                else if !isImmutable(f.type) {
                    error(f.position, "immutable class '\{cl.name}' cannot contain mutable field " +
                            "'\{f.name}' of type '\{f.type}'")
                }
            }
        }
    }

    method checkValue(cl:ClassDecl) {
        if false & isValue(cl) {
            for f in cl.fields {
                resolve(f)
                if f.type.isClass() {
                    if !isValue(getClass(f.type)) {
                        error(f.position, "value class '\{cl.name}' cannot contain non-value " +
                                "field '\{f.name}' of type '\{f.type}'")
                    }
                }
            }
        }
    }

    method checkAnnotations(cl:ClassDecl) {
        method disallow(compiler:Compiler -* FIXME capture this *-, cl:ClassDecl -* FIXME capture this *-, flag:Int, name:String) {
            if cl.annotations.flags && flag != 0 {
                compiler.error(cl.position, "classes may not be annotated with '\{name}'")
            }
        }
        disallow(self, cl, Annotations.Flag.PROTECTED, "@protected")
        disallow(self, cl, Annotations.Flag.CLASS,     "@class")
        disallow(self, cl, Annotations.Flag.OVERRIDE,  "@override")
        disallow(self, cl, Annotations.Flag.EXTERNAL,  "@external")
        disallow(self, cl, Annotations.Flag.IMPLICIT,  "@implicit")
        disallow(self, cl, Annotations.Flag.INLINE,    "@inline")
        disallow(self, cl, Annotations.Flag.WEAK,      "@weak")
        disallow(self, cl, Annotations.Flag.DEFAULT,   "@default")
        if cl.annotations.expressions !== null {
            for expr in cl.annotations.expressions {
                match expr {
                    when Annotations.Expression.PRE:
                        error(cl.position, "classes may not be annotated with '@pre'")
                    when Annotations.Expression.POST:
                        error(cl.position, "classes may not be annotated with '@post'")
                    when Annotations.Expression.PRE_OR:
                        error(cl.position, "classes may not be annotated with '@preOr'")
                    when Annotations.Expression.POST_AND:
                        error(cl.position, "classes may not be annotated with '@postAnd'")
                }
            }
        }
        checkAccessModifierCount(cl.position, cl.annotations)
    }

    method checkAnnotations(f:FieldDecl) {
        method disallow(compiler:Compiler -* FIXME capture this *-, f:FieldDecl -* FIXME capture this *-, flag:Int, name:String) {
            if f.annotations.flags && flag != 0 {
                compiler.error(f.position, "fields may not be annotated with '\{name}'")
            }
        }
        disallow(self, f, Annotations.Flag.OVERRIDE,         "@override")
        disallow(self, f, Annotations.Flag.EXTERNAL,         "@external")
        disallow(self, f, Annotations.Flag.IMPLICIT,         "@implicit")
        disallow(self, f, Annotations.Flag.ABSTRACT,         "@abstract")
        disallow(self, f, Annotations.Flag.INLINE,           "@inline")
        disallow(self, f, Annotations.Flag.SPECIALIZE,       "@specialize")
        disallow(self, f, Annotations.Flag.UNSAFE_IMMUTABLE, "@unsafeImmutable")
        disallow(self, f, Annotations.Flag.DEFAULT,          "@default")
        if f.annotations.expressions !== null {
            for expr in f.annotations.expressions {
                match expr {
                    when Annotations.Expression.PRE:
                        error(f.position, "fields may not be annotated with '@pre'")
                    when Annotations.Expression.POST:
                        error(f.position, "fields may not be annotated with '@post'")
                    when Annotations.Expression.PRE_OR:
                        error(f.position, "fields may not be annotated with '@preOr'")
                    when Annotations.Expression.POST_AND:
                        error(f.position, "fields may not be annotated with '@postAnd'")
                }
            }
        }
        if f.resolved = Resolution.RESOLVED {
            if f.annotations.isClass() & !isImmutable(f.type) {
                error(f.position, "only immutable fields may be annotated with '@class'")
            }
            if f.annotations.isClass() & f.fieldKind = FieldDecl.Kind.VAR {
                error(f.position, "'var' fields may not be annotated with '@class'")
            }
        }
        checkAccessModifierCount(f.position, f.annotations)
    }

    @post(currentClass.count = @pre(currentClass.count))
    method compile(cl:ClassDecl) {
        currentClass.push(cl)
        checkAnnotations(cl)
        resolve(cl)
        if cl.resolved != Resolution.RESOLVED {
            currentClass.pop()
            return
        }
        if cl.annotations.isSpecialize() {
            codeGenerator.start(cl)
            codeGenerator.end(cl)
            currentClass.pop()
            return
        }
        def auto := AutoScope(self, getSymbolTable(cl))
        checkImmutable(cl)
        checkValue(cl)
        checkInterfaceMethods()
        var started := false
        for f in cl.fields {
            resolve(f)
            checkAnnotations(f)
        }
        for m in cl.methods {
            resolve(m)
        }
        if errorCount = 0 {
            codeGenerator.start(cl)
            started := true
        }
        for m in cl.methods {
            compile(m)
        }
        if started {
            codeGenerator.end(cl)
        }
        currentClass.pop()

        if compilationQueue.count > 0 {
            def next := compilationQueue[0]
            compilationQueue.removeIndex(0)
            compile(next)
        }
        assert compilationQueue.count = 0
    }

    method scan(raw:File):ListView<ClassDecl> {
        def file := raw.absolute().get()
        var result := scans[file]
        if result == null {
            parser.start(file, file.readFully())
            def parsed := parser.file()
            if parsed !== null {
                result := scanner.scan(file, parsed)
                for cl in result {
                    classes[cl.name] := cl
                }
            }
            else {
                result := Array<ClassDecl>()
            }
            scans[file] := result
        }
        return result
    }

    method compile(file:File) {
        for cl in scan(file) {
            compile(cl)
        }
    }

    method error(position:Position, msg:String) {
        error(currentClass[0].source, position, msg)
    }

    method error(file:File, pos:Position, msg:String) {
        if reportErrors {
            errorCount += 1
            errorQueue.post(Error(file, pos, msg))
        }
    }

    method finish() {
        while pendingClasses.count > 0 {
            def cl := pendingClasses.removeIndex(pendingClasses.count - 1)
            compile(cl)
        }
        codeGenerator.finish()
    }
}
