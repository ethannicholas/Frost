package org.pandalanguage.pandac

uses org.pandalanguage.pandac.parser.Parser
uses org.pandalanguage.pandac.parser.Token

@final
class Compiler : ErrorReporter {
    constant RANGE_NAME := "panda.core.Range"
    constant STEPPED_RANGE_NAME := "panda.core.SteppedRange"

    class Settings : Immutable {
        def pandaHome:File

        def importDirs:ImmutableArray<File>

        def optimizationLevel:Int

        def safetyLevel:Int

        init(pandaHome:File, importDirs:ListView<File>, optimizationLevel:Int, safetyLevel:Int) {
            self.pandaHome := pandaHome
            self.importDirs := ImmutableArray<File>(importDirs)
            self.optimizationLevel := optimizationLevel
            self.safetyLevel := safetyLevel
        }
    }

    constant NONNULLABLE_TO_NULLABLE_CAST_COST := 1
    constant NULLABLE_TO_NONNULLABLE_CAST_COST := 2

    def settings:Settings

    def parser:Parser

    def scanner:Scanner

    def root:SymbolTable

    var compiling:ClassDecl? := null

    var compilationQueue := Array<ClassDecl>()

    @private
    def scans := HashMap<File, ListView<ClassDecl>>()

    @private
    def classes := HashMap<String, ClassDecl>()

    @private
    def currentClass := Stack<ClassDecl>()

    @private
    def currentMethod := Stack<MethodDecl>()

    @private
    var symbolTable:SymbolTable

    @private
    def codeGenerator:CodeGenerator

    @private
    def loops := Stack<String?>()

    @private
    var reusedValueCount:UInt64 := 0

    @private
    var errorCount := 0

    @private
    var reportErrors := true

    init(codeGenerator:CodeGenerator, settings:Settings) {
        self.settings := settings
        self.parser := Parser(self)
        self.scanner := Scanner(self)
        self.root := SymbolTable(self)
        self.symbolTable := root
        self.codeGenerator := codeGenerator
        codeGenerator.setCompiler(self)
        root.add(Type("builtin_bit", Type.Kind.BUILTIN_BIT, 1))
        root.add(Type("builtin_int8", Type.Kind.BUILTIN_INT, 8))
        root.add(Type("builtin_int16", Type.Kind.BUILTIN_INT, 16))
        root.add(Type("builtin_int32", Type.Kind.BUILTIN_INT, 32))
        root.add(Type("builtin_int64", Type.Kind.BUILTIN_INT, 64))
        root.add(Type("builtin_uint8", Type.Kind.BUILTIN_UINT, 8))
        root.add(Type("builtin_uint16", Type.Kind.BUILTIN_UINT, 16))
        root.add(Type("builtin_uint32", Type.Kind.BUILTIN_UINT, 32))
        root.add(Type("builtin_uint64", Type.Kind.BUILTIN_UINT, 64))
        root.add(Alias("Int", "panda.core.Int64", Position()))
        addAlias("panda.collections.Array")
        addAlias("panda.collections.Collection")
        addAlias("panda.collections.CollectionView")
        addAlias("panda.collections.CollectionWriter")
        addAlias("panda.collections.IdentityMap")
        addAlias("panda.collections.ImmutableArray")
        addAlias("panda.collections.Iterable")
        addAlias("panda.collections.Iterator")
        addAlias("panda.collections.Key")
        addAlias("panda.collections.List")
        addAlias("panda.collections.ListView")
        addAlias("panda.collections.ListWriter")
        addAlias("panda.collections.HashMap")
        addAlias("panda.collections.Map")
        addAlias("panda.collections.MapView")
        addAlias("panda.collections.MapWriter")
        addAlias("panda.collections.Set")
        addAlias("panda.collections.Stack")
        addAlias("panda.core.Class")
        addAlias("panda.core.Bit")
        addAlias("panda.core.Char8")
        addAlias("panda.core.Char16")
        addAlias("panda.core.Char32")
        addAlias("panda.core.Comparable")
        addAlias("panda.core.Equatable")
        addAlias("panda.core.Int8")
        addAlias("panda.core.Int16")
        addAlias("panda.core.Int32")
        addAlias("panda.core.Int64")
        addAlias("panda.core.Immutable")
        addAlias("panda.core.MutableString")
        addAlias("panda.core.Object")
        addAlias("panda.core.Panda")
        addAlias("panda.core.Range")
        addAlias("panda.core.SimpleRange")
        addAlias("panda.core.SteppedRange")
        addAlias("panda.core.String")
        addAlias("panda.core.System")
        addAlias("panda.core.UInt8")
        addAlias("panda.core.UInt16")
        addAlias("panda.core.UInt32")
        addAlias("panda.core.UInt64")
        addAlias("panda.core.Value")
        addAlias("panda.math.Random")
        addAlias("panda.math.XorShift128Plus")
        addAlias("panda.io.Console")
        addAlias("panda.io.File")
        addAlias("panda.io.IndentedOutputStream")
        addAlias("panda.io.InputStream")
        addAlias("panda.io.LineNumberInputStream")
        addAlias("panda.io.MemoryInputStream")
        addAlias("panda.io.MemoryOutputStream")
        addAlias("panda.io.OutputStream")
        addAlias("panda.io.PushbackInputStream")
        addAlias("panda.unsafe.Pointer")
    }

    @private
    method addAlias(name:String) {
        root.add(Alias(name[name.next(name.lastIndexOf("."))..], name, Position()))
    }

    ================================================================================================
    Attempts to locate a class with the given, possibly not-fully-qualified, class name. Returns
    null and does not report any errors on failure.
    ================================================================================================
    method tryResolveClass(name:String):ClassDecl? {
        if currentClass.get_count() > 0 {
            def alias := currentClass.peek().aliases[name]
            if alias != null {
                return getClass(alias)
            }
        }
        var result := getClass(name)
        if currentClass.get_count() > 0 {
            if result = null {
                def idx := currentClass.peek().name.lastIndexOf(".")
                if idx != null {
                    result := getClass(currentClass.peek().name[...idx] + name)
                }
            }
            if result = null {
                result := getClass(currentClass.peek().name + "." + name)
            }
            if result = null & currentClass.peek().owner != null {
                currentClass.push(currentClass.peek().owner)
                result := tryResolveClass(name)
                currentClass.pop()
            }
        }
        if result = null {
            def rootAlias := root[name]
            if rootAlias != null & rootAlias.kind = Symbol.Kind.ALIAS {
                result := getClass((rootAlias->Alias).fullName) -- FIXME parens
            }
        }
        if result = null {
            def index := name.lastIndexOf(".")
            if index != null {
                -- could be an inner class name; see if we can locate an enclosing class
                def parent := tryResolveClass(name[..index])
                if parent != null {
                    result := getClass(parent.name + name[index..])
                }
            }
        }
        return result
    }

    ================================================================================================
    Verifies that a type uses the correct number and kind of generic parameters for the class it
    refers to. Reports error(s) and returns false if the type is not valid.
    ================================================================================================
    method checkGenericParameters(position:Position, cl:ClassDecl, type:Type):Bit {
        resolve(cl)
        assert type.resolved
        def expectedCount := cl.parameters.get_count()
        def foundTypes := typeParameters(type)
        def foundCount := foundTypes.get_count()
        if expectedCount != foundCount {
            def s:String
            if expectedCount = 1 {
                s := ""
            }
            else {
                s := "s"
            }
            error(position, "'\{cl.name}' expected \{expectedCount} generic parameter\{s}, but " +
                    "found \{foundCount}")
            return false
        }
        def object := Type.Object()
        for i in 0 .. expectedCount {
            def bound := cl.parameters[i].bound
            if bound = object | (bound.typeKind = Type.Kind.NULLABLE & bound.subtypes[0] = object) {
                continue
            }
            if coercionCost(foundTypes[i], remapType(type, bound)) = null {
                error(position, "generic parameter '\{cl.name}.\{cl.parameters[i].name}' must be " +
                        "of type '\{cl.parameters[i].bound}', but found '\{foundTypes[i]}'")
                return false
            }
        }
        return true
    }

    method resolve(type:Type, checkParameters:Bit):Type? {
        if type.resolved {
            return type
        }
        match type.typeKind {
            when Type.Kind.CLASS:
                def resolved := tryResolveClass(type.name)
                if resolved != null {
                    def result := resolved.type()
                    if checkParameters {
                        if !checkGenericParameters(type.position, resolved, result) {
                            return null
                        }
                    }
                    return result
                }
                def s := symbolTable[type.name]
                if s != null {
                    match s.kind {
                        when Symbol.Kind.ALIAS:
                            return Type((s->Alias).fullName, Type.Kind.CLASS, type.position, true) -- FIXME parens
                        when Symbol.Kind.GENERIC_PARAMETER:
                            def gp := s->ClassDecl.GenericParameter
                            resolve(getClass(type.position, gp.owner))
                            return Type(gp)
                        when Symbol.Kind.TYPE:
                            return s->Type
                        when Symbol.Kind.CLASS:
                            return (s->ClassDecl).type() -- FIXME parens
                    }
                }
                error(type.position, "unknown type '\{type}'")
                return null
            when Type.Kind.NULLABLE:
                assert type.subtypes.get_count() = 1
                def subtypes := Array<Type>()
                def sub := resolve(type.subtypes[0])
                if sub = null {
                    return null
                }
                subtypes.add(sub)
                return Type(subtypes[0].name + "?", Type.Kind.NULLABLE, type.position, subtypes, true)
            when Type.Kind.GENERIC:
                assert type.subtypes.get_count() >= 2
                def subtypes := Array<Type>()
                def base := resolve(type.subtypes[0], false)
                if base = null {
                    return null
                }
                subtypes.add(base)
                def name := MutableString(subtypes[0].name)
                name.append("<")
                var separator := ""
                for i in 1 .. type.subtypes.get_count() {
                    def resolved := resolve(type.subtypes[i])
                    if resolved = null {
                        return null
                    }
                    subtypes.add(resolved)
                    name.append(separator)
                    name.append(resolved.name)
                    separator := ", "
                }
                name.append(">")
                def result := Type(name.finish(), Type.Kind.GENERIC, type.position, subtypes, true)
                if checkParameters {
                    if !checkGenericParameters(type.position, getClass(result.subtypes[0]),
                            result) {
                        return null
                    }
                }
                return result
            otherwise:
                assert false, "cannot resolve \{type}"
        }
    }

    method resolve(type:Type):Type? {
        return resolve(type, true)
    }

    method resolve(cl:ClassDecl) {
        if cl.resolved {
            return
        }
        cl.resolved := true
        currentClass.push(cl)
        def old := symbolTable
        symbolTable := cl.symbolTable
        for p in cl.parameters {
            def resolved := resolve(p.bound, false)
            if resolved != null {
                p.bound := resolved
            }
        }
        for rawS in cl.declaredSupers {
            def s := resolve(rawS, false)
            if s != null {
                def sClass := getClass(s)
                if sClass != null {
                    if sClass.classKind = ClassDecl.Kind.CLASS {
                        if cl.classKind = ClassDecl.Kind.INTERFACE {
                            error(s.position, "interface '\{cl.name}' cannot extend class " +
                                    "'\{s.name}'")
                        }
                        if cl.rawSuper = null {
                            cl.rawSuper := s
                            if cl.rawInterfaces.get_count() > 0 {
                                error(s.position, "superclass '\{s}' of class '\{cl.name}' must be " +
                                        "listed before any superinterfaces")
                            }
                        }
                        else {
                            error(s.position, "class '\{cl.name}' has more than one superclass")
                        }
                    }
                    else {
                        assert sClass.classKind = ClassDecl.Kind.INTERFACE
                        cl.rawInterfaces.add(s)
                    }
                }
            }
        }
        if cl.rawSuper = null & cl.name != "panda.core.Object" {
            cl.rawSuper := Type.Object()
        }
        if cl.rawSuper != null & !cl.annotations.isFinal() &
                cl.rawSuper.name = "panda.core.Value" {
            cl.annotations.flags ||= Annotations.Flag.FINAL
            for m in cl.methods {
                m.annotations.flags ||= Annotations.Flag.FINAL
                if scanner.shouldInline(m.annotations, m.body) {
                    m.annotations.flags ||= Annotations.Flag.INLINE
                }
            }
        }
        if cl.rawSuper != null {
            checkGenericParameters(cl.position, getClass(cl.rawSuper), cl.rawSuper)
        }
        for intf in cl.rawInterfaces {
            checkGenericParameters(cl.position, getClass(intf), intf)
        }
        for p in cl.parameters {
            def cl := getClass(p.bound)
            if cl != null {
                checkGenericParameters(cl.position, cl, p.bound)
            }
        }
        symbolTable := old
        currentClass.pop()
    }

    method resolve(m:MethodDecl) {
        if m.resolved {
            return
        }
        resolve(m.owner)
        currentClass.push(m.owner)
        def old := symbolTable
        symbolTable := m.owner.symbolTable
        for p in m.parameters {
            p.type := resolve(p.type)
        }
        m.returnType := resolve(m.returnType)
        m.resolved := true
        def overridden := getOverriddenMethod(m)
        if overridden != null {
            if !m.annotations.isOverride() {
                error(m.position, "\{m.declaration()} overrides \{overridden.declaration()}, but " +
                        "is not marked @override")
            }
            if m.methodKind = MethodDecl.Kind.METHOD &
                    overridden.methodKind = MethodDecl.Kind.FUNCTION {
                error(m.position, "\{m.declaration()} overrides \{overridden.declaration()}, but " +
                        "methods cannot override functions")
            }
        }
        else if m.annotations.isOverride() {
            error(m.position, "\{m.declaration()} is marked @override, but no matching method " +
                    "exists among its ancestors")
        }
        symbolTable := old
        currentClass.pop()
    }

    method resolve(f:FieldDecl) {
        if f.resolved {
            return
        }
        f.resolved := true
        currentClass.push(f.owner)
        def old := symbolTable
        symbolTable := f.owner.symbolTable
        if f.type != Type.Void() {
            def resolved := resolve(f.type)
            if resolved != null {
                f.type := resolved
                if f.rawValue != null {
                    f.value := coerce(compileExpression(f.rawValue), f.type)
                }
            }
            currentClass.pop()
            symbolTable := old
            return
        }
        if f.rawValue = null {
            error(f.position, "field has neither a type nor a value")
            currentClass.pop()
            symbolTable := old
            return
        }
        f.value := compileExpression(f.rawValue)
        if f.value = null {
            currentClass.pop()
            symbolTable := old
            return
        }
        f.type := variableType(f.value)
        f.value := coerce(f.value, f.type)
        currentClass.pop()
        symbolTable := old
    }

    method resolveMethodCall(expr:IRNode, target:Type?):IRNode? {
        assert expr.kind = IRNode.Kind.UNRESOLVED_METHOD_CALL
        def methods := expr.children[0].payload->ListView<MethodRef>
        def args := expr.children[1..]
        var best := Array<MethodRef>()
        var bestCost:Int? := null
        for m in methods {
            def cost := callCost(m, args, target)
            if cost = null {
                continue
            }
            if bestCost = null {
                best.add(m)
                bestCost := cost
                continue
            }
            if cost < bestCost {
                best.clear()
                bestCost := cost
            }
            if cost = bestCost {
                best.add(m)
            }
        }
        if best.get_count() = 1 {
            def callTarget:IRNode?
            if expr.children[0].children.get_count() > 0 {
                callTarget := expr.children[0].children[0]
            }
            else {
                callTarget := null
            }
            var result := call(expr.position, callTarget, best[0], args)
            if target != null {
                result := coerce(result, target)
            }
            return result
        }
        Console.printLine("no or ambiguous match on method call (\{expr.position}, \{methods[0].value.name}, \{best})")
        assert false
        return null
    }

    method resolve(expr:IRNode?):IRNode? {
        if expr = null {
            return null
        }
        match expr.kind {
            when IRNode.Kind.UNRESOLVED_IDENTIFIER:
                error(expr.position, "unknown identifier")
                return null
            when IRNode.Kind.UNRESOLVED_METHOD_CALL:
                return resolveMethodCall(expr, null)
            when IRNode.Kind.SUPER:
                error(expr.position, "'super' can only be used as part of a method call")
                return null
            otherwise:
                return coerce(expr, variableType(expr))
        }
    }

    method isValue(cl:ClassDecl):Bit {
        resolve(cl)
        return cl.rawSuper != null & cl.rawSuper.name = "panda.core.Value"
    }

    method instanceFields(cl:ClassDecl):ListView<FieldDecl> {
        resolve(cl)
        def result := Array<FieldDecl>()
        if !isValue(cl) & cl.rawSuper != null {
            def s := getClass(cl.rawSuper)
            if s != null {
                result.addAll(instanceFields(s))
            }
        }
        for f in cl.fields {
            if !f.annotations.isClass() {
                result.add(f)
            }
        }
        return result
    }

    ================================================================================================
    Attempts to load the class with the given fully-qualified name. Returns null on failure, without
    reporting an error.
    ================================================================================================
    method getClass(fullName:String):ClassDecl? {
        var result := classes[fullName]
        if result = null {
            def suffix := fullName.replace(".", "/") + ".panda"
            var found := false
            for dir in settings.importDirs {
                def f := dir.resolve(suffix)
                if f.exists() {
                    found := true
                    scan(f)
                    result := classes[fullName]
                }
            }
        }
        if result = null {
            def index := fullName.lastIndexOf(".")
            if index != null {
                def parent := getClass(fullName[..index])
                if parent != null {
                    result := classes[fullName]
                }
            }
        }
        return result
    }

    method getClass(position:Position, fullName:String):ClassDecl? {
        var result := classes[fullName]
        if result = null {
            def suffix := fullName.replace(".", "/") + ".panda"
            var found := false
            for dir in settings.importDirs {
                def f := dir.resolve(suffix)
                if f.exists() {
                    found := true
                    def oldErrorCount := errorCount
                    scan(f)
                    result := classes[fullName]
                    if result = null & errorCount = oldErrorCount {
                        error(f, Position(1, 1),
                                "expected file '\{f}' to contain a class named '\{fullName}'")
                    }
                }
            }
            if !found {
                error(position, "no file named \{suffix} in any import path (\{settings.importDirs})")
            }
        }
        return result
    }

    method specialize(cl:ClassDecl, rawType:Type):ClassDecl {
        resolve(cl)
        assert !rawType.name.contains("$int_literal")
        def type := resolve(rawType)
        if type.typeKind = Type.Kind.NULLABLE {
            return specialize(cl, type.subtypes[0])
        }
        if type.typeKind = Type.Kind.CLASS {
            return cl
        }
        assert type.typeKind = Type.Kind.GENERIC
        def result:ClassDecl? := classes[type.name]
        if result = null {
            currentClass.push(cl)
            def annotations := Annotations(cl.annotations.flags && !!Annotations.Flag.SPECIALIZE)
            def supertypes := Array<Type>()
            supertypes.add(remapType(type, cl.rawSuper))
            for intf in cl.rawInterfaces { -- FIXME use map
            supertypes.add(remapType(type, intf))
            }
            def aliases := HashMap<String, String>(cl.aliases)
            for i in 0 .. cl.parameters.get_count() {
                aliases[cl.parameters[i].name] := type.subtypes[i + 1].name
            }
            result := ClassDecl(cl.source, cl.position, aliases, cl.doccomment, annotations,
                    cl.classKind, type.name, supertypes, Array<ClassDecl.GenericParameter>(),
                    cl.symbolTable.parents[0])
            result.external := false
            for m in cl.methods {
                resolve(m)
                def parameters := Array<MethodDecl.Parameter>() -- FIXME use map
                for p in m.parameters {
                    parameters.add(MethodDecl.Parameter(p.name, remapType(type, p.type)))
                }
                def clone := MethodDecl(result, m.position, m.doccomment, m.annotations,
                        m.methodKind, m.name, parameters, m.returnType, m.body)
                result.methods.add(clone)
                result.symbolTable.add(clone)
            }
            for f in cl.fields {
                resolve(f)
                def clone := FieldDecl(result, f.position, f.doccomment, f.annotations, f.fieldKind,
                        f.name, remapType(type, f.type), f.rawValue)
                result.fields.add(clone)
                result.symbolTable.add(clone)
            }
            classes[result.name] := result
            compilationQueue.add(result)
            currentClass.pop()
        }
        return result
    }

    method getClass(type:Type):ClassDecl? {
        assert type.resolved, "unresolved type \{type}"
        var result:ClassDecl
        match type.typeKind {
            when Type.Kind.CLASS:
                result := getClass(type.position, type.name)
            when Type.Kind.NULLABLE, Type.Kind.GENERIC:
                result := getClass(type.subtypes[0])
            when Type.Kind.GENERIC_PARAMETER:
                return getClass(type.parameter.bound)
            otherwise:
                assert false, "unsupported type \{type}"
        }
        if result.annotations.isSpecialize() {
            result := specialize(result, type)
        }
        return result
    }

    method allInterfaces(t:Type):Set<Type> {
        def cl := getClass(t)
        assert cl != null
        resolve(cl)
        def result := Set<Type>()
        if cl.rawSuper != null {
            result.addAll(allInterfaces(remapType(t, cl.rawSuper)))
        }
        for intf in cl.rawInterfaces {
            result.addAll(allInterfaces(remapType(t, intf)))
        }
        if cl.classKind = ClassDecl.Kind.INTERFACE {
            result.add(t)
        }
        return result
    }

    function signatureMatch(t1:Type, t2:Type):Bit {
        assert t1.isMethod()
        assert t2.isMethod()
        if t1.subtypes.get_count() != t2.subtypes.get_count() {
            return false
        }
        for i in 0 .. t1.subtypes.get_count() {
            if t1.subtypes[i] != t2.subtypes[i] {
                return false
            }
        }
        return true
    }

    method findMethod(owner:Type, name:String, methodType:Type, checkInterfaces:Bit):MethodDecl? {
        def cl := getClass(owner)
        assert cl != null
        resolve(cl)
        for test in cl.methods {
            if test.name = name {
                resolve(test)
                if signatureMatch(remapType(owner, declaredType(test)), methodType) {
                    return test
                }
            }
        }
        if checkInterfaces | cl.classKind = ClassDecl.Kind.INTERFACE {
            for raw in cl.rawInterfaces {
                def result := findMethod(remapType(owner, raw), name, methodType, checkInterfaces)
                if result != null {
                    return result
                }
            }
        }
        if cl.rawSuper != null {
            return findMethod(remapType(owner, cl.rawSuper), name, methodType, checkInterfaces)
        }
        return null
    }

    function getOverriddenMethod(m:MethodDecl):MethodDecl? {
        if m.methodKind = MethodDecl.Kind.INIT {
            return null
        }
        resolve(m)
        def methodType := declaredType(m)
        def owner := m.owner.typeWithParameters()
        for raw in m.owner.rawInterfaces {
            def result := findMethod(remapType(owner, raw), m.name, methodType, true)
            if result != null {
                return result
            }
        }
        resolve(m.owner)
        if m.owner.rawSuper != null {
            return findMethod(remapType(owner, m.owner.rawSuper), m.name, methodType, true)
        }
        return null
    }

    method interfaceMethods(cl:ClassDecl, intf:Type):ListView<MethodDecl> {
        def intfClass := getClass(intf)
        assert intfClass != null
        def result := Array<MethodDecl>()
        for m in intfClass.methods {
            def found := findMethod(cl.type(), m.name, remapType(intf, inheritedType(m)), false)
            assert found != null, "internal error: interface \{m.signature()} not found in " +
                    "\{cl.name}"
            result.add(found)
        }
        return result
    }

    method getSymbolTable(cl:ClassDecl):SymbolTable {
        if !cl.symbolTableResolved {
            cl.symbolTableResolved := true
            resolve(cl)
            if cl.rawSuper != null {
                def superCl := getClass(cl.rawSuper)
                if superCl != null {
                    cl.symbolTable.parents.add(getSymbolTable(superCl))
                }
            }
            for rawIntf in cl.rawInterfaces {
                def intf := getClass(rawIntf)
                if intf != null {
                    cl.symbolTable.parents.add(getSymbolTable(intf))
                }
            }
        }
        return cl.symbolTable
    }

    method getVTable(cl:ClassDecl):ListView<MethodDecl> {
        if cl.virtualMethods.get_count() = 0 {
            resolve(cl)
            currentClass.push(cl) -- FIXME Auto
            if cl.rawSuper != null {
                def superCl := getClass(cl.rawSuper)
                if superCl = null {
                    currentClass.pop()
                    return cl.virtualMethods
                }
                cl.virtualMethods.addAll(getVTable(superCl))
            }
            for derived in cl.methods {
                resolve(derived)
                if derived.methodKind = MethodDecl.Kind.INIT | derived.annotations.isClass() {
                    continue
                }
                var found := false
                for i in 0 .. cl.virtualMethods.get_count() {
                    def base := cl.virtualMethods[i]
                    resolve(base)
                    if derived.matches(base) {
                        found := true
                        cl.virtualMethods[i] := derived
                        break
                    }
                }
                if !found {
                    cl.virtualMethods.add(derived)
                }
            }
            currentClass.pop()
        }
        return cl.virtualMethods
    }

    method addInheritedMethods(st:SymbolTable, name:String, result:Array<MethodRef>,
            types:ListView<Type>) {
    }

    method getMethodReference(st:SymbolTable, target:IRNode?, name:String, position:Position,
            types:ListView<Type>):IRNode {
        def methods := Array<MethodRef>()
        def s := st[name]
        assert s != null, "could not find method '\{name}'"
        if s.kind = Symbol.Kind.METHOD {
            resolve(s->MethodDecl)
            methods.add(MethodRef(s->MethodDecl, types))
        }
        else {
            assert s.kind = Symbol.Kind.METHODS
            for m in (s->Methods).methods { -- FIXME extra parens
                resolve(m)
                methods.add(MethodRef(m, types))
            }
        }
        for p in st.parents {
            addInheritedMethods(p, name, methods, types)
        }
        def children := Array<IRNode>()
        if target != null {
            children.add(target)
        }
        if methods.get_count() = 1 {
            return IRNode(IRNode.Kind.METHOD_REFERENCE, position, methods[0].type(), methods[0],
                    children)
        }
        else {
            assert methods.get_count() > 0
            def types := Array<Type>()
            for m in methods {
                types.add(m.type())
            }
            return IRNode(IRNode.Kind.UNRESOLVED_METHOD_REFERENCE, position, Type(types), methods,
                    children)
        }
    }

    method symbolRef(position:Position, target:IRNode?, s:Symbol, st:SymbolTable):IRNode? {
        match s.kind {
            when Symbol.Kind.ALIAS:
                assert target = null
                def cl := getClass(position, (s->Alias).fullName) -- FIXME remove extra parens
                if cl != null {
                    checkGenericParameters(position, cl, cl.type()) -- FIXME parens
                    return IRNode(IRNode.Kind.TYPE_REFERENCE, position, Type.Class(), cl.type())
                }
                return null
            when Symbol.Kind.CLASS:
                checkGenericParameters(position, s->ClassDecl, (s->ClassDecl).type()) -- FIXME parens
                return IRNode(IRNode.Kind.TYPE_REFERENCE, position, Type.Class(),
                        (s->ClassDecl).type()) -- FIXME parens
            when Symbol.Kind.METHOD, Symbol.Kind.METHODS:
                return getMethodReference(st, target, s.name, position, typeParameters(target))
            when Symbol.Kind.VARIABLE:
                return IRNode(IRNode.Kind.VARIABLE_REFERENCE, position, (s->Variable).type, -- FIXME parens
                        s->Variable)
            when Symbol.Kind.FIELD:
                def f := s->FieldDecl
                resolve(f)
                if f.type = Type.Void() {
                    return null
                }
                def children := Array<IRNode>()
                if target != null {
                    if target.kind = IRNode.Kind.SUPER {
                        error(target.position, "'super' can only be used as part of a method call")
                        return null
                    }
                    def effectiveType := remapType(target.type, f.type)
                    if f.annotations.isClass() {
                        children.add(target)
                    }
                    else {
                        children.add(coerce(target, f.owner.type()))
                    }
                    var result := IRNode(IRNode.Kind.FIELD_REFERENCE, position, f.type, s, children)
                    if effectiveType != result.type {
                        result := cast(result, position, false, effectiveType)
                    }
                    return result
                }
                else {
                    children.add(IRNode(IRNode.Kind.SELF, position, currentClass.peek().type()))
                    return IRNode(IRNode.Kind.FIELD_REFERENCE, position, f.type, s, children)
                }
            otherwise:
                assert false, "unsupported symbol kind: \{s.kind}"
        }
    }

    function remapType(context:Type, raw:Type):Type {
        match context.typeKind {
            when Type.Kind.CLASS:
                return raw
            when Type.Kind.NULLABLE:
                assert context.subtypes.get_count() = 1
                return remapType(context.subtypes[0], raw)
            when Type.Kind.GENERIC:
                assert context.subtypes.get_count() >= 2
                def typeMap := HashMap<String, Type>()
                def base := context.subtypes[0]
                def cl := tryResolveClass(base.name)
                assert cl != null
                for i in 1 .. context.subtypes.get_count() {
                    typeMap[cl.name + "." + cl.parameters[i - 1].name] := context.subtypes[i]
                }
                return raw.remap(typeMap)
            when Type.Kind.GENERIC_PARAMETER:
                return raw
            otherwise:
                assert false, "cannot remap type \{context}"
        }
    }

    function variableType(type:Type):Type {
        if type = Type.IntLiteral() {
            return Type.Int64()
        }
        if type = Type.BitLiteral() {
            return Type.Bit()
        }
        if type.typeKind = Type.Kind.NULL {
            return Type.Any()
        }
        return type
    }

    function variableType(expr:IRNode):Type {
        match expr.kind {
            when IRNode.Kind.UNRESOLVED_RANGE:
                if expr.children.get_count() = 2 {
                    if expr.children[0].kind = IRNode.Kind.NULL {
                        if expr.children[1].kind = IRNode.Kind.NULL {
                            return Type.RangeOf(Type.Int64().nullable())
                        }
                        return Type.RangeOf(variableType(expr.children[1].type).nullable())
                    }
                    if expr.children[1].kind = IRNode.Kind.NULL {
                        return Type.RangeOf(variableType(expr.children[0].type).nullable())
                    }
                    return Type.RangeOf(variableType(variableType(expr.children[0].type).union(
                            variableType(expr.children[1].type))))
                }
                def step := variableType(expr.children[2].type)
                if expr.children[0].kind = IRNode.Kind.NULL {
                    if expr.children[1].kind = IRNode.Kind.NULL {
                        return Type.SteppedRangeOf(Type.Int64().nullable(), step)
                    }
                    return Type.SteppedRangeOf(variableType(expr.children[1].type).nullable(), step)
                }
                if expr.children[1].kind = IRNode.Kind.NULL {
                    return Type.SteppedRangeOf(variableType(expr.children[0].type).nullable(), step)
                }
                return Type.SteppedRangeOf(variableType(variableType(expr.children[0].type).union(
                        variableType(expr.children[1].type))), step)
            when IRNode.Kind.UNRESOLVED_INDEX:
                def args := expr.children[1..]
                def c := call(expr.children[0], "[]", args)
                if c = null {
                    return Type.Any()
                }
                return c.type
        }
        return variableType(expr.type)
    }

    function coercionCost(type:Type, target:Type):Int? {
        assert type.resolved, "unresolved type '\{type}'"
        assert target.resolved, "unresolved type '\{target}'"
        if type = target {
            return 0
        }
        if type = Type.Void() {
            return null
        }
        if type.typeKind = Type.Kind.NULL {
            if target.typeKind = Type.Kind.NULLABLE {
                return 0
            }
            return null
        }
        if type.typeKind = Type.Kind.NULLABLE & target.typeKind != Type.Kind.NULLABLE {
            def result := coercionCost(type.subtypes[0], target)
            if result = null {
                return null
            }
            return result + NULLABLE_TO_NONNULLABLE_CAST_COST
        }
        match target.typeKind {
            when Type.Kind.NULLABLE:
                def result := coercionCost(type, target.subtypes[0])
                if result = null {
                    return null
                }
                return result + NONNULLABLE_TO_NULLABLE_CAST_COST
            when Type.Kind.GENERIC_PARAMETER:
                return null
            when Type.Kind.BUILTIN_INT, Type.Kind.BUILTIN_UINT:
                return null
            when Type.Kind.CLASS:
                if type.typeKind = Type.Kind.GENERIC {
                    return coercionCost(type.subtypes[0], target)
                }
        }
        match type.typeKind {
            when Type.Kind.BUILTIN_BIT:
                return coercionCost(Type.Bit(), target)
            when Type.Kind.UNRESOLVED:
                var best:Int? := null
                for t in type.subtypes {
                    def cost := coercionCost(t, target)
                    if cost != null & (best = null | cost < best) {
                        best := cost
                    }
                }
                return best
            when Type.Kind.GENERIC_PARAMETER:
                return coercionCost(type.parameter.bound, target)
        }
        if !target.isClass() {
            return null
        }
        if !type.isClass() {
            return null
        }
        def cl := getClass(type)
        assert cl != null
        resolve(cl)
        if cl.rawSuper != null {
            var cost := coercionCost(remapType(type, remapType(type, cl.rawSuper)), target)
            if cost != null {
                return cost + 1
            }
        }
        for intf in cl.rawInterfaces {
            var cost := coercionCost(remapType(type, remapType(type, intf)), target)
            if cost != null {
                return cost + 1
            }
        }
        return null
    }

    function requiredSize(value:Int64):Int {
        if value >= -128 & value <= 127 {
            return 8
        }
        if value >= -32768 & value <= 32767 {
            return 16
        }
        if value >= -2147483648 & value <= 2147483647 {
            return 32
        }
        return 64
    }

    function requiredSize(value:UInt64):Int {
        if value <= 255 {
            return 8
        }
        if value <= 65535 {
            return 16
        }
        if value <= 4294967295 {
            return 32
        }
        return 64
    }

    function coercionCost(expr:IRNode, target:Type):Int? {
        if expr.type = target {
            return 0
        }
        match target.typeKind {
            when Type.Kind.NULLABLE:
                if expr.kind = IRNode.Kind.NULL {
                    return 0
                }
                def cost := coercionCost(expr, target.subtypes[0])
                if cost = null {
                    return null
                }
                if expr.type.typeKind = Type.Kind.NULLABLE {
                    return cost
                }
                return cost + NONNULLABLE_TO_NULLABLE_CAST_COST
            when Type.Kind.GENERIC_PARAMETER:
                return coercionCost(expr, target.parameter.bound)
        }
        match expr.kind {
            when IRNode.Kind.BIT:
                if target.typeKind = Type.Kind.BUILTIN_BIT {
                    return 0
                }
                if target.isClass() {
                    return coercionCost(Type.Bit(), target)
                }
            when IRNode.Kind.INT:
                if (target.typeKind = Type.Kind.BUILTIN_INT &
                        requiredSize((expr.payload->UInt64).convert()->Int64) <= target.size()) |
                        (target.typeKind = Type.Kind.BUILTIN_UINT &
                        requiredSize(expr.payload->UInt64) <= target.size()) {
                    return 0
                }
                if !target.isNumber() {
                    return coercionCost(variableType(expr), target)
                }
            when IRNode.Kind.NEGATED_INT:
                if (target.typeKind = Type.Kind.BUILTIN_INT &
                        requiredSize(-(expr.payload->UInt64).convert()->Int64) <= target.size()) |
                        (target.typeKind = Type.Kind.BUILTIN_UINT &
                        requiredSize(-(expr.payload->UInt64).convert()->Int64) <= target.size()) {
                    return 0
                }
                if !target.isNumber() {
                    return coercionCost(variableType(expr), target)
                }
            when IRNode.Kind.UNRESOLVED_RANGE:
                if target.isRange() {
                    if expr.children.get_count() != 2 {
                        return null
                    }
                    if expr.children[0].kind = IRNode.Kind.NULL &
                            expr.children[1].kind = IRNode.Kind.NULL {
                        if target.subtypes[1].typeKind = Type.Kind.NULLABLE {
                            if target.subtypes[1].subtypes[0].isNumber() {
                                return 0
                            }
                            return 1
                        }
                        return null
                    }
                    assert target.typeKind = Type.Kind.GENERIC
                    def cost1 := coercionCost(expr.children[0], target.subtypes[1])
                    if cost1 = null {
                        return null
                    }
                    def cost2 := coercionCost(expr.children[1], target.subtypes[1])
                    if cost2 = null {
                        return null
                    }
                    return cost1 + cost2
                }
                if target.isSteppedRange() {
                    if expr.children.get_count() != 3 {
                        return null
                    }
                    var cost:Int
                    if expr.children[0].kind = IRNode.Kind.NULL &
                            expr.children[1].kind = IRNode.Kind.NULL {
                        if target.subtypes[1].typeKind = Type.Kind.NULLABLE {
                            if target.subtypes[1].subtypes[0].isNumber() {
                                cost := 0
                            }
                            else {
                                cost := 1
                            }
                        }
                        else {
                            return null
                        }
                    }
                    else {
                        assert target.typeKind = Type.Kind.GENERIC
                        def cost1 := coercionCost(expr.children[0], target.subtypes[1])
                        if cost1 = null {
                            return null
                        }
                        def cost2 := coercionCost(expr.children[1], target.subtypes[1])
                        if cost2 = null {
                            return null
                        }
                        cost := cost1 + cost2
                    }
                    def cost3 := coercionCost(expr.children[2], target.subtypes[2])
                    if cost3 = null {
                        return null
                    }
                    return cost + cost3
                }
                return coercionCost(variableType(expr), target)
            when IRNode.Kind.UNRESOLVED_INDEX:
                def args := Array<IRNode>() -- FIXME literal
                args.add(expr.children[1])
                return coercionCost(call(expr.children[0], "[]", args), target)
        }
        if !target.isClass() {
            return null
        }
        def targetClass := getClass(target)
        if targetClass = null {
            return null
        }
        for m in targetClass.methods {
            if m.annotations.isImplicit() {
                -- Internal use feature, sharp edges! We currently assume there's only one implicit
                -- method and it's a single-argument init.
                resolve(m)
                assert m.methodKind = MethodDecl.Kind.INIT
                assert m.parameters.get_count() = 1
                def cost := coercionCost(expr, m.parameters[0].type)
                if cost != null {
                    return cost
                }
            }
        }
        assert expr.type != null
        return coercionCost(expr.type, target)
    }

    function doCoerce(expr:IRNode?, target:Type):IRNode? {
        if expr = null {
            return null
        }
        assert expr.type.resolved, "unresolved type '\{expr.type}'"
        assert target.resolved, "unresolved type '\{target}'"
        if expr.type = target {
            return expr
        }
        if expr.type.typeKind = Type.Kind.NULLABLE & target.typeKind != Type.Kind.NULLABLE {
            if expr.type.subtypes[0] = target {
                def children := Array<IRNode>() -- FIXME literal
                children.add(expr)
                return IRNode(IRNode.Kind.CAST, expr.position, target, false, children)
            }
            def intermediate := coerce(expr, expr.type.subtypes[0])
            return coerce(intermediate, target)
        }
        match expr.kind {
            when IRNode.Kind.INT:
                if target.typeKind = Type.Kind.BUILTIN_INT &
                        requiredSize(expr.payload->UInt64) <= target.size() {
                    return IRNode(IRNode.Kind.INT, expr.position, target, expr.payload->UInt64)
                }
                else if target.typeKind = Type.Kind.BUILTIN_UINT &
                        requiredSize(expr.payload->UInt64) <= target.size() {
                    return IRNode(IRNode.Kind.INT, expr.position, target, expr.payload->UInt64)
                }
                if target.typeKind = Type.Kind.CLASS & !target.isNumber() {
                    def coerced := coerce(expr, variableType(expr))
                    if coerced = null {
                        return null
                    }
                    return coerce(coerced, target)
                }
            when IRNode.Kind.NEGATED_INT:
                if target.typeKind = Type.Kind.BUILTIN_INT &
                        requiredSize(-((expr.payload->UInt64).convert()->Int64)) <= target.size() { -- FIXME parens
                    return IRNode(IRNode.Kind.NEGATED_INT, expr.position, target,
                            expr.payload->UInt64)
                }
                if target.typeKind = Type.Kind.CLASS & !target.isNumber() {
                    def coerced := coerce(expr, variableType(expr))
                    if coerced = null {
                        return null
                    }
                    return coerce(coerced, target)
                }
            when IRNode.Kind.BIT:
                if target = Type.BuiltinBit() {
                    return IRNode(IRNode.Kind.BIT, expr.position, target, expr.payload->Bit)
                }
                if target.isClass() & target != Type.Bit() {
                    def varType := coerce(expr, variableType(expr))
                    if varType != null {
                        return coerce(varType, target)
                    }
                }
            when IRNode.Kind.UNRESOLVED_RANGE:
                if target.isRange() {
                    if expr.children.get_count() != 2 {
                        error(expr.position, "expected '\{target}', but found '\{expr}'")
                        return null
                    }
                    assert target.typeKind = Type.Kind.GENERIC
                    def param := target.subtypes[1]
                    def start := coerce(expr.children[0], param)
                    if start = null {
                        return null
                    }
                    def end := coerce(expr.children[1], param)
                    if end = null {
                        return null
                    }
                    def args := Array<IRNode>()
                    args.add(start)
                    args.add(end)
                    args.add(IRNode(IRNode.Kind.BIT, expr.position, Type.BuiltinBit(),
                            expr.payload->Bit))
                    def target := IRNode(IRNode.Kind.TYPE_REFERENCE, expr.position, Type.Class(),
                            target)
                    return call(target, args)
                }
                else if target.isSteppedRange() {
                    if expr.children.get_count() != 3 {
                        error(expr.position, "expected '\{target}', but found '\{expr}'")
                        return null
                    }
                    assert target.typeKind = Type.Kind.GENERIC
                    def endPoint := target.subtypes[1]
                    def start := coerce(expr.children[0], endPoint)
                    if start = null {
                        return null
                    }
                    def end := coerce(expr.children[1], endPoint)
                    def step := coerce(expr.children[2], target.subtypes[2])
                    def args := Array<IRNode>()
                    args.add(start)
                    args.add(end)
                    args.add(step)
                    args.add(IRNode(IRNode.Kind.BIT, expr.position, Type.BuiltinBit(),
                            expr.payload->Bit))
                    def target := IRNode(IRNode.Kind.TYPE_REFERENCE, expr.position, Type.Class(),
                            target)
                    return call(target, args)
                }
                else {
                    return coerce(resolve(expr), target)
                }
            when IRNode.Kind.UNRESOLVED_METHOD_CALL:
                return resolveMethodCall(expr, target)
            when IRNode.Kind.UNRESOLVED_INDEX:
                def args := expr.children[1..]
                return coerce(call(expr.children[0], "[]", args, target), target)
        }
        if target.typeKind = Type.Kind.NULLABLE {
            if expr.kind = IRNode.Kind.NULL {
                return IRNode(IRNode.Kind.NULL, expr.position, target)
            }
            if expr.type = target.subtypes[0] {
                def children := Array<IRNode>() -- FIXME literal
                children.add(expr)
                return IRNode(IRNode.Kind.CAST, expr.position, target, false, children)
            }
            if expr.type.typeKind != Type.Kind.NULLABLE {
                def intermediate := coerce(expr, target.subtypes[0])
                return coerce(intermediate, target)
            }
        }
        if coercionCost(expr, target) != null {
            def cl := getClass(target)
            if cl != null {
                for m in cl.methods {
                    if m.annotations.isImplicit() {
                        -- Internal use feature, sharp edges! We currently assume there's only one
                        -- implicit method and it's a single-argument init.
                        resolve(m)
                        assert m.methodKind = MethodDecl.Kind.INIT
                        assert m.parameters.get_count() = 1
                        if coercionCost(expr, m.parameters[0].type) != null {
                            def type := IRNode(IRNode.Kind.TYPE_REFERENCE, expr.position,
                                    Type.Class(), cl.type())
                            def args := Array<IRNode>(1) -- FIXME literal
                            args.add(expr)
                            return call(type, args)
                        }
                    }
                }
            }
            def children := Array<IRNode>(1) -- FIXME literal
            children.add(expr)
            return IRNode(IRNode.Kind.CAST, expr.position, target, false, children)
        }
        error(expr.position, "expected '\{target}', but found '\{expr.type}'")
        return null
    }

    -- FIXME use postcondition
    method coerce(expr:IRNode?, target:Type):IRNode? {
        def result := doCoerce(expr, target)
        assert result = null | result.type = target,
                "coerce returned wrong type: \{expr}->\{target} yields \{result.type}"
        return result
    }

    method canCast(type:Type, target:Type):Bit {
        if type.isPointer() & target.isPointer() {
            return true
        }
        if coercionCost(type, target) != null {
            return true
        }
        if type.isBuiltinNumber() & target.isBuiltinNumber() {
            return true
        }
        if type.typeKind = Type.Kind.INVALID {
            return false
        }
        return coercionCost(target, type) != null
    }

    method canCast(node:IRNode, target:Type):Bit {
        if coercionCost(node, target) != null {
            return true
        }
        var result := canCast(node.type, target)
        if !result & node.type.typeKind = Type.Kind.UNRESOLVED {
            def resolved := resolve(node)
            if resolved != null {
                result := canCast(resolved, target)
            }
        }
        return result
    }

    method cast(node:IRNode, position:Position, isExplicit:Bit, target:Type):IRNode {
        if node.type = target {
            return node
        }
        assert target != Type.Void()
        if isExplicit & !canCast(node, target) {
            error(position, "value of type '\{node.type}' cannot possibly be an instance of " +
                    "'\{target}'")
        }
        match node.kind {
            when IRNode.Kind.INT, IRNode.Kind.NEGATED_INT, IRNode.Kind.BIT:
                return coerce(node, target)
            when IRNode.Kind.UNRESOLVED_METHOD_CALL, IRNode.Kind.UNRESOLVED_INDEX:
                if coercionCost(node, target) != null {
                    return coerce(node, target)
                }
                def resolved := resolve(node)
                if resolved != null {
                    return cast(resolved, position, isExplicit, target)
                }
        }
        def children := Array<IRNode>() -- FIXME literal
        children.add(node)
        return IRNode(IRNode.Kind.CAST, position, target, isExplicit, children)
    }

    method callCost(m:MethodRef, args:ListView<IRNode>, expectedReturn:Type?):Int? {
        assert m.value.resolved
        if m.parameterCount() != args.get_count() {
            return null
        }
        var result := 0
        for i in 0 .. m.parameterCount() {
            def cost := coercionCost(args[i], m.parameter(i))
            if cost = null {
                return null
            }
            result += cost
        }
        if expectedReturn != null {
            def cost := coercionCost(m.returnType(), expectedReturn)
            if cost = null {
                return null
            }
            result += cost
        }
        -- numbers prefer to operate on their own sizes, i.e. we should treat Int8 + 10 as
        -- Int8 + Int8 rather than complain about it being ambiguous
        if m.value.owner.type().isNumber() & args.get_count() = 1 &
                m.value.parameters[0].type != m.value.owner.type() {
            result += 1
        }
        return result
    }

    method matchMethods(methods:Array<MethodRef>, args:ListView<IRNode>,
            expectedReturn:Type?):Int? {
        def result := Array<MethodRef>()
        var best:Int? := null
        for m in methods {
            def cost := callCost(m, args, expectedReturn)
            if cost = null {
                continue
            }
            if best = null | cost < best {
                result.clear()
                best := cost
            }
            if cost = best {
                result.add(m)
            }
        }
        methods.clear()
        methods.addAll(result)
        return best
    }

    method call(position:Position, target:IRNode?, m:MethodRef, args:ListView<IRNode>):IRNode? {
        assert m.value.resolved
        if m.parameterCount() != args.get_count() {
            def s:String
            if m.parameterCount() = 1 {
                s := ""
            }
            else {
                s := "s"
            }
            error(position, "\{m.value.declaration()} expected \{m.parameterCount()} argument\{s}, " +
                    "but received \{args.get_count()}")
            return null
        }
        def finalArgs := Array<IRNode>()
        if target != null & target.kind != IRNode.Kind.CONSTRUCTED_OBJECT &
                !m.value.annotations.isClass() {
            finalArgs.add(cast(target, position, false, m.owner()))
        }
        if m.value.methodKind = MethodDecl.Kind.INIT {
            if target = null {
                if currentMethod.peek().methodKind = MethodDecl.Kind.INIT {
                    finalArgs.add(IRNode(IRNode.Kind.SELF, position, currentClass.peek().type()))
                }
                else {
                    error(position, "cannot directly call 'init' outside of an init method")
                }
            }
            else if target.kind != IRNode.Kind.SELF & target.kind != IRNode.Kind.SUPER &
                    target.kind != IRNode.Kind.CONSTRUCTED_OBJECT {
                error(position, "'init' may only be called on 'self' or 'super'")
            }
        }
        else if m.value.isInstance() & target = null {
            var selfNode := IRNode(IRNode.Kind.SELF, position, currentClass.peek().type())
            selfNode := coerce(selfNode, m.value.owner.type())
            assert selfNode != null
            finalArgs.add(selfNode)
            if !currentMethod.peek().isInstance() {
                error(position, "cannot call instance \{m.value.declaration()} from a @class context")
            }
        }
        else if !m.value.isInstance() & target != null & target.kind != IRNode.Kind.TYPE_REFERENCE {
            error(position, "cannot call class \{m.value.declaration()} on an instance")
        }
        for i in 0 .. args.get_count() {
            var coerced := coerce(args[i], m.parameter(i))
            if coerced = null {
                return null
            }
            coerced := cast(coerced, position, false, m.value.parameters[i].type)
            if coerced = null {
                return null
            }
            finalArgs.add(coerced)
        }
        var result:IRNode
        if m.value.owner.name = "panda.unsafe.Pointer" {
            result := IRNode(IRNode.Kind.CALL, position, m.returnType(), m, finalArgs)
        }
        else {
            result := IRNode(IRNode.Kind.CALL, position, m.value.returnType, m, finalArgs)
            result := cast(result, position, false, m.returnType())
        }
        return result
    }

    method call(target:IRNode, name:String, args:ListView<IRNode>):IRNode? {
        return call(target, name, args, null)
    }

    method call(target:IRNode, name:String, args:ListView<IRNode>, expectedType:Type?):IRNode? {
        def resolved := resolve(target)
        if resolved = null {
            return null
        }
        def cl:ClassDecl?
        if resolved.kind = IRNode.Kind.TYPE_REFERENCE {
            cl := getClass(resolved.payload->Type)
        }
        else {
            cl := getClass(resolved.type)
        }
        if cl = null {
            return null
        }
        def s := getSymbolTable(cl)[name]
        if s = null {
            error(target.position, "class '\{cl.name}' does not have a member named '\{name}'")
            return null
        }
        if s.kind != Symbol.Kind.METHOD & s.kind != Symbol.Kind.METHODS {
            error(target.position, "'\{cl.name}.\{name}' is not a method")
            return null
        }
        def ref := symbolRef(target.position, target, s, getSymbolTable(cl))
        if ref = null {
            return null
        }
        return call(ref, args, expectedType)
    }

    method call(m:IRNode, args:ListView<IRNode>):IRNode? {
        return call(m, args, null)
    }

    method call(m:IRNode, args:ListView<IRNode>, expectedType:Type?):IRNode? {
        match m.kind {
            when IRNode.Kind.METHOD_REFERENCE:
                def target:IRNode?
                if m.children.get_count() = 0 {
                    target := null
                }
                else {
                    assert m.children.get_count() = 1
                    target := m.children[0]
                }
                return call(m.position, target, m.payload->MethodRef, args)
            when IRNode.Kind.UNRESOLVED_METHOD_REFERENCE:
                def methods := Array<MethodRef>(m.payload->ListView<MethodRef>)
                matchMethods(methods, args, expectedType)
                if methods.get_count() = 0 {
                    def first := m.payload->ListView<MethodRef>[0].value
                    def msg := MutableString("no match for call to '\{first.owner.name}." +
                            "\{first.name}(")
                    var separator := ""
                    for a in args {
                        msg.append(separator)
                        msg.append(a.type)
                        separator := ", "
                    }
                    msg.append(")'")
                    if expectedType != null {
                        msg.append(" with return type '\{expectedType}'")
                    }
                    error(m.position, msg.finish())
                    return null
                }
                if methods.get_count() = 1 {
                    def target:IRNode?
                    if m.children.get_count() = 1 {
                        target := m.children[0]
                    }
                    else {
                        assert m.children.get_count() = 0
                        target := null
                    }
                    return call(m.position, target, methods[0], args)
                }
                def children := Array<IRNode>()
                children.add(IRNode(IRNode.Kind.UNRESOLVED_METHOD_REFERENCE, m.position,
                        Type.Invalid(), methods, m.children))
                children.addAll(args)
                def types := Array<Type>()
                for m in methods {
                    types.add(m.returnType())
                }
                return IRNode(IRNode.Kind.UNRESOLVED_METHOD_CALL, m.position, Type(types), children)
            when IRNode.Kind.TYPE_REFERENCE:
                def target := IRNode(IRNode.Kind.CONSTRUCTED_OBJECT, m.position, m.payload->Type)
                def initCall := resolve(call(target, "init", args))
                if initCall = null {
                    return null
                }
                def children := Array<IRNode>() -- FIXME literal
                children.add(initCall)
                return IRNode(IRNode.Kind.CONSTRUCT, m.position, m.payload->Type, children)
            otherwise:
                def resolved := resolve(m)
                if resolved = null {
                    return null
                }
                error(resolved.position, "value of type '\{resolved.type}' is not a method")
        }
    }

    function declaredType(m:MethodDecl):Type {
        resolve(m)
        def subtypes := Array<Type>()
        def typeName := MutableString("(")
        var separator := ""
        for p in m.parameters {
            typeName.append(separator)
            typeName.append(p.type.name)
            subtypes.add(p.type)
            separator := ", "
        }
        def kind:Int
        if m.methodKind = MethodDecl.Kind.FUNCTION {
            typeName.append(")=>(")
            kind := Type.Kind.FUNCTION
        }
        else {
            typeName.append(")=&>(")
            kind := Type.Kind.METHOD
        }
        subtypes.add(m.returnType)
        if m.returnType != Type.Void() {
            typeName.append(m.returnType.name)
        }
        typeName.append(")")
        return Type(typeName.finish(), kind, m.position, subtypes, true)
    }

    function declaredTypeWithSelf(m:MethodDecl, selfType:Type):Type {
        resolve(m)
        def subtypes := Array<Type>()
        def typeName := MutableString("(")
        typeName.append(selfType.name)
        subtypes.add(selfType)
        for p in m.parameters {
            typeName.append(", ")
            typeName.append(p.type.name)
            subtypes.add(p.type)
        }
        def kind:Int
        if m.methodKind = MethodDecl.Kind.FUNCTION {
            typeName.append(")=>(")
            kind := Type.Kind.FUNCTION
        }
        else {
            typeName.append(")=&>(")
            kind := Type.Kind.METHOD
        }
        subtypes.add(m.returnType)
        if m.returnType != Type.Void() {
            typeName.append(m.returnType.name)
        }
        typeName.append(")")
        return Type(typeName.finish(), kind, m.position, subtypes, true)
    }

    function inheritedType(m:MethodDecl):Type {
        def inherited := getOverriddenMethod(m)
        if inherited = null {
            return declaredType(m)
        }
        return inheritedType(inherited)
    }

    function inheritedTypeWithSelf(m:MethodDecl):Type {
        return inheritedTypeWithSelf(m, m.owner.type())
    }

    function inheritedTypeWithSelf(m:MethodDecl, selfType:Type):Type {
        def inherited := getOverriddenMethod(m)
        if inherited = null {
            return declaredTypeWithSelf(m, selfType)
        }
        return inheritedTypeWithSelf(inherited, selfType)
    }

    @class
    function operatorName(op:Int):String {
        match op {
            when Token.Kind.ADD: return "+"
            when Token.Kind.SUB: return "-"
            when Token.Kind.MUL: return "*"
            when Token.Kind.DIV: return "/"
            when Token.Kind.INTDIV: return "//"
            when Token.Kind.REM: return "%"
            when Token.Kind.POW: return "^"
            when Token.Kind.EQ: return "="
            when Token.Kind.NEQ: return "!="
            when Token.Kind.GT: return ">"
            when Token.Kind.LT: return "<"
            when Token.Kind.GTEQ: return ">="
            when Token.Kind.LTEQ: return "<="
            when Token.Kind.OR: return "|"
            when Token.Kind.BITWISEOR: return "||"
            when Token.Kind.AND: return "&"
            when Token.Kind.BITWISEAND: return "&&"
            when Token.Kind.XOR: return "~"
            when Token.Kind.BITWISEXOR: return "~~"
            when Token.Kind.NOT: return "!"
            when Token.Kind.BITWISENOT: return "!!"
            when Token.Kind.SHIFTLEFT: return "<<"
            when Token.Kind.SHIFTRIGHT: return ">>"
            when Token.Kind.LBRACKET: return "[]"
            when Token.Kind.ASSIGNMENT: return ":="
            when Token.Kind.IDENTITY: return "=="
            when Token.Kind.NIDENTITY: return "!=="
            otherwise: assert false, "not an operator: \{op}"
        }
    }

    @class
    function isAssignment(op:Int):Bit {
        match op {
            when Token.Kind.ADDEQ, Token.Kind.SUBEQ, Token.Kind.MULEQ, Token.Kind.DIVEQ,
                    Token.Kind.INTDIVEQ, Token.Kind.REMEQ, Token.Kind.POWEQ, Token.Kind.OREQ,
                    Token.Kind.BITWISEOREQ, Token.Kind.ANDEQ, Token.Kind.BITWISEANDEQ,
                    Token.Kind.XOREQ, Token.Kind.BITWISEXOREQ, Token.Kind.SHIFTLEFTEQ,
                    Token.Kind.SHIFTRIGHTEQ:
                return true
            otherwise:
                return false
        }
    }

    @class
    function removeAssignment(op:Int):Int {
        match op {
            when Token.Kind.ADDEQ:        return Token.Kind.ADD
            when Token.Kind.SUBEQ:        return Token.Kind.SUB
            when Token.Kind.MULEQ:        return Token.Kind.MUL
            when Token.Kind.DIVEQ:        return Token.Kind.DIV
            when Token.Kind.INTDIVEQ:     return Token.Kind.INTDIV
            when Token.Kind.REMEQ:        return Token.Kind.REM
            when Token.Kind.POWEQ:        return Token.Kind.POW
            when Token.Kind.OREQ:         return Token.Kind.OR
            when Token.Kind.BITWISEOREQ:  return Token.Kind.BITWISEOR
            when Token.Kind.ANDEQ:        return Token.Kind.AND
            when Token.Kind.BITWISEANDEQ: return Token.Kind.BITWISEAND
            when Token.Kind.XOREQ:        return Token.Kind.XOR
            when Token.Kind.BITWISEXOREQ: return Token.Kind.BITWISEXOR
            when Token.Kind.SHIFTLEFTEQ:  return Token.Kind.SHIFTLEFT
            when Token.Kind.SHIFTRIGHTEQ: return Token.Kind.SHIFTRIGHT
            otherwise:
                assert false
        }
    }

    function isLValue(expr:IRNode):Bit {
        match expr.kind {
            when IRNode.Kind.CAST:
                assert expr.children.get_count() = 1
                if !expr.payload->Bit {
                    return isLValue(expr.children[0])
                }
                return false
            when IRNode.Kind.FIELD_REFERENCE, IRNode.Kind.VARIABLE_REFERENCE:
                return true
            when IRNode.Kind.REUSED_VALUE_DEFINITION:
                return isLValue(expr.children[0])
            otherwise:
                return false
        }
    }

    method foldInts(position:Position, left:IRNode, op:Int, right:IRNode):IRNode? {
        assert left.kind = IRNode.Kind.INT | left.kind = IRNode.Kind.NEGATED_INT
        assert right.kind = IRNode.Kind.INT | right.kind = IRNode.Kind.NEGATED_INT
        if left.kind = IRNode.Kind.NEGATED_INT | left.payload->UInt64 < Int64.MAX.convert() &
                right.kind = IRNode.Kind.NEGATED_INT | right.payload->UInt64 < Int64.MAX.convert() {
            -- both values fit into a signed Int64
            def l:Int64 := (left.payload->UInt64).convert() -- FIXME parens
            def r:Int64 := (right.payload->UInt64).convert() -- FIXME parens
            match op {
                when Token.Kind.ADD:
                    return IRNode(IRNode.Kind.INT, position, Type.IntLiteral(),
                        (l + r).convert()->UInt64)
                when Token.Kind.SUB:
                    return IRNode(IRNode.Kind.INT, position, Type.IntLiteral(),
                        (l - r).convert()->UInt64)
                when Token.Kind.MUL:
                    return IRNode(IRNode.Kind.INT, position, Type.IntLiteral(),
                        (l * r).convert()->UInt64)
                when Token.Kind.INTDIV:
                    return IRNode(IRNode.Kind.INT, position, Type.IntLiteral(),
                        (l // r).convert()->UInt64)
                when Token.Kind.REM:
                    return IRNode(IRNode.Kind.INT, position, Type.IntLiteral(),
                        (l % r).convert()->UInt64)
                when Token.Kind.EQ:
                    return IRNode(IRNode.Kind.BIT, position, Type.BitLiteral(), l = r)
                when Token.Kind.NEQ:
                    return IRNode(IRNode.Kind.BIT, position, Type.BitLiteral(), l != r)
                when Token.Kind.LT:
                    return IRNode(IRNode.Kind.BIT, position, Type.BitLiteral(), l < r)
                when Token.Kind.GT:
                    return IRNode(IRNode.Kind.BIT, position, Type.BitLiteral(), l > r)
                when Token.Kind.LTEQ:
                    return IRNode(IRNode.Kind.BIT, position, Type.BitLiteral(), l <= r)
                when Token.Kind.GTEQ:
                    return IRNode(IRNode.Kind.BIT, position, Type.BitLiteral(), l >= r)
                when Token.Kind.BITWISEAND:
                    return IRNode(IRNode.Kind.INT, position, Type.IntLiteral(),
                        (l && r).convert()->UInt64)
                when Token.Kind.BITWISEOR:
                    return IRNode(IRNode.Kind.INT, position, Type.IntLiteral(),
                        (l || r).convert()->UInt64)
                when Token.Kind.BITWISEXOR:
                    return IRNode(IRNode.Kind.INT, position, Type.IntLiteral(),
                        (l ~~ r).convert()->UInt64)
                when Token.Kind.SHIFTLEFT:
                    return IRNode(IRNode.Kind.INT, position, Type.IntLiteral(),
                        (l << r).convert()->UInt64)
                when Token.Kind.SHIFTRIGHT:
                    return IRNode(IRNode.Kind.INT, position, Type.IntLiteral(),
                        (l >> r).convert()->UInt64)
            }
        }
        error(position, "invalid numeric operation")
        return null
    }

    function unwrapCast(expr:IRNode):IRNode {
        if expr.kind = IRNode.Kind.CAST {
            return expr.children[0]
        }
        return expr
    }

    method compileIndexedAssignment(position:Position, left:IRNode, op:Int, right:IRNode):IRNode? {
        assert left.kind = IRNode.Kind.UNRESOLVED_INDEX
        assert left.children.get_count() = 2
        if op = Token.Kind.ASSIGNMENT {
            def args := Array<IRNode>() -- FIXME literal
            args.add(left.children[1])
            args.add(right)
            return call(left.children[0], "[]:=", args)
        }
        assert isAssignment(op)
        -- compound indexed assignment (e.g. foo[bar] += 1), which needs to get converted to
        -- foo.[]:=(bar, foo.[](bar) + 1). We need to reuse both the base and the index so they're
        -- only evaluated once.
        var resolved := resolve(left)
        if resolved = null {
            return null
        }
        resolved := unwrapCast(resolved)
        assert resolved.children.get_count() = 2
        def children := Array<IRNode>()
        children.add(unwrapCast(resolved.children[0]))
        reusedValueCount += 1
        def baseId := reusedValueCount
        def base := IRNode(IRNode.Kind.REUSED_VALUE_DEFINITION, children[0].position,
                children[0].type, baseId, children)
        children.clear()

        children.add(resolved.children[1])
        reusedValueCount += 1
        def indexId := reusedValueCount
        def index := IRNode(IRNode.Kind.REUSED_VALUE_DEFINITION, children[0].position,
                children[0].type, indexId, children)
        def baseRef := IRNode(IRNode.Kind.REUSED_VALUE, base.position, base.type, baseId)
        def indexRef := IRNode(IRNode.Kind.REUSED_VALUE, index.position, index.type, indexId)
        -- in our example, foo.[](bar)
        def rhsIndex := compileBinary(position, baseRef, Token.Kind.LBRACKET, indexRef)
        if rhsIndex = null {
            return null
        }
        -- in our example, foo.[](bar) + 1
        var value := compileBinary(position, rhsIndex, removeAssignment(op), right)
        if value = null {
            return null
        }
        -- 32 bit promotion means that e.g. int8 += int8 will result in a 32 bit value that can't be
        -- stored back into the original lvalue. Special case this and convert it back to its
        -- original size.
        if rhsIndex.type.isNumber() & right.type.isNumber() & rhsIndex.type != value.type {
            value := call(value, "convert", Array<IRNode>(), resolved.type) -- FIXME literal
            if value = null {
                return null
            }
        }
        children.clear()
        children.add(index)
        children.add(value)
        return call(base, "[]:=", children)
    }

    method compileBinary(position:Position, rawLeft:IRNode, op:Int, rawRight:IRNode):IRNode? {
        -- FIXME use var parameters
        var left := rawLeft
        var right := rawRight
        if left.type.typeKind = Type.Kind.INT_LITERAL {
            right := resolve(right)
            if right = null {
                return null
            }
            if coercionCost(left, right.type) != null {
                left := coerce(left, right.type)
            }
        }
        if right.type.typeKind = Type.Kind.INT_LITERAL &
                coercionCost(right, left.type) != null {
            right := coerce(right, left.type)
        }
        if op = Token.Kind.EQ | op = Token.Kind.NEQ | op = Token.Kind.IDENTITY |
                op = Token.Kind.NIDENTITY {
            def kind:Int
            if op = Token.Kind.EQ | op = Token.Kind.IDENTITY {
                kind := IRNode.Kind.IS_NULL
            }
            else {
                kind := IRNode.Kind.IS_NONNULL
            }
            if left.kind = IRNode.Kind.NULL {
                def resolved := resolve(right)
                if resolved = null {
                    return null
                }
                def children := Array<IRNode>() -- FIXME literal
                children.add(resolved)
                return IRNode(kind, position, Type.Bit(), children)
            }
            if right.kind = IRNode.Kind.NULL {
                def resolved := resolve(left)
                if resolved = null {
                    return null
                }
                def children := Array<IRNode>() -- FIXME literal
                children.add(resolved)
                return IRNode(kind, position, Type.Bit(), children)
            }
        }
        if op = Token.Kind.IDENTITY | op = Token.Kind.NIDENTITY {
            if left.type.isClass() {
                def cl := getClass(left.type)
                if cl = null {
                    return null
                }
                if isValue(cl) {
                    error(position, "'\{operatorName(op)}' cannot operate on '\{left.type}', " +
                            "'\{right.type}'")
                }
            }
            if right.type.isClass() {
                def cl := getClass(right.type)
                if cl = null {
                    return null
                }
                if isValue(cl) {
                    error(position, "'\{operatorName(op)}' cannot operate on '\{left.type}', " +
                            "'\{right.type}'")
                }
            }
            def finalLeft := coerce(left, Type.Object())
            if finalLeft = null {
                return null
            }
            def finalRight := coerce(right, Type.Object())
            if finalRight = null {
                return null
            }
            def children := Array<IRNode>() -- FIXME literal
            children.add(finalLeft)
            children.add(finalRight)
            return IRNode(IRNode.Kind.BINARY, position, Type.Bit(), op, children)
        }
        if op = Token.Kind.ASSIGNMENT {
            if left.kind = IRNode.Kind.UNRESOLVED_INDEX {
                return compileIndexedAssignment(position, left, op, right)
            }
            left := resolve(left)
            if left = null {
                return null
            }
            right := coerce(right, left.type)
            if right = null {
                return null
            }
            if !isLValue(left) {
                error(left.position, "cannot assign to this expression")
                return null
            }
            def children := Array<IRNode>() -- FIXME literal
            children.add(left)
            children.add(right)
            return IRNode(IRNode.Kind.BINARY, position, Token.Kind.ASSIGNMENT, children)
        }
        if isAssignment(op) {
            -- compound assignment
            if left.kind = IRNode.Kind.UNRESOLVED_INDEX {
                return compileIndexedAssignment(position, left, op, right)
            }
            left := resolve(left)
            if left = null {
                return null
            }
            if !isLValue(left) {
                error(left.position, "cannot assign to this expression")
                return null
            }
            def children := Array<IRNode>() -- FIXME literal
            children.add(left)
            reusedValueCount += 1
            left := IRNode(IRNode.Kind.REUSED_VALUE_DEFINITION, left.position, left.type,
                    reusedValueCount, children)
            def reusedLeft := IRNode(IRNode.Kind.REUSED_VALUE, left.position, left.type,
                    reusedValueCount)
            right := compileBinary(position, reusedLeft, removeAssignment(op), right)
            if right = null {
                return null
            }
            -- 32 bit promotion means that e.g. int8 += int8 will result in a 32 bit value that can't be
            -- stored back into the original lvalue. Special case this and convert it back to its
            -- original size.
            if left.type.isNumber() & left.type != right.type {
                right := call(right, "convert", Array<IRNode>(), left.type)
                if right = null {
                    return null
                }
            }
            return compileBinary(position, left, Token.Kind.ASSIGNMENT, right)
        }
        if op = Token.Kind.LBRACKET {
            left := resolve(left)
            if left = null {
                return null
            }
            def cl := getClass(left.type)
            if cl = null {
                return null
            }
            def parameters := typeParameters(left.type)
            def methods := getSymbolTable(cl)["[]"]
            def type:Type
            if methods != null {
                def types := Array<Type>()
                if methods.kind = Symbol.Kind.METHOD {
                    def m := methods->MethodDecl
                    resolve(m)
                    types.add(MethodRef(m, parameters).returnType())
                }
                else {
                    assert methods.kind = Symbol.Kind.METHODS
                    for m in (methods->Methods).methods { -- FIXME parens
                        resolve(m)
                        types.add(MethodRef(m, parameters).returnType())
                    }
                }
                type := Type(types)
            }
            else {
                type := Type.Invalid()
            }
            def children := Array<IRNode>()
            children.add(left)
            children.add(right)
            return IRNode(IRNode.Kind.UNRESOLVED_INDEX, position, type, children)
        }
        if left.type = Type.BuiltinBit() {
            if right.type = Type.BuiltinBit() & (op = Token.Kind.AND | op = Token.Kind.OR |
                    op = Token.Kind.XOR | op = Token.Kind.EQ | op = Token.Kind.NEQ) {
                def children := Array<IRNode>() -- FIXME literal
                children.add(left)
                children.add(right)
                return IRNode(IRNode.Kind.BINARY, position, left.type, op, children)
            }
            error(position, "'\{operatorName(op)}' cannot operate on '\{left.type}', '\{right.type}'")
            return null
        }
        def children := Array<IRNode>()
        if (left.kind = IRNode.Kind.INT | left.kind = IRNode.Kind.NEGATED_INT) &
                (right.kind = IRNode.Kind.INT | right.kind = IRNode.Kind.NEGATED_INT) {
            return foldInts(position, left, op, right)
        }
        if left.type.isBuiltinNumber() & coercionCost(right, left.type) != null {
            right := coerce(right, left.type)
            assert right != null
            children.add(left)
            children.add(right)
            def resultType:Type
            match op {
                when Token.Kind.EQ, Token.Kind.NEQ, Token.Kind.GT, Token.Kind.GTEQ, Token.Kind.LT,
                        Token.Kind.LTEQ:
                    resultType := Type.BuiltinBit()
                otherwise:
                    resultType := left.type
            }
            return IRNode(IRNode.Kind.BINARY, position, resultType, op, children)
        }
        children.add(right)
        assert reportErrors
        reportErrors := false
        var result := call(left, operatorName(op), children)
        reportErrors := true
        if result = null {
            children.clear()
            children.add(left)
            def resolved := resolve(right)
            if resolved != null & resolved.type.isClass() {
                children.add(resolved)
                def target := IRNode(IRNode.Kind.TYPE_REFERENCE, resolved.position, Type.Class(),
                        resolved.type)
                result := call(target, operatorName(op), children)
            }
        }
        return result
    }

    method compileBinary(b:ASTNode):IRNode? {
        def left := compileExpression(b.children[0])
        if left = null {
            return null
        }
        def right := compileExpression(b.children[1])
        if right = null {
            return null
        }
        return compileBinary(b.position, left, b.payload->Int, right)
    }

    function typeParameters(type:Type):ListView<Type> {
        match type.typeKind {
            when Type.Kind.GENERIC_PARAMETER:
                return typeParameters(type.parameter.bound)
            when Type.Kind.GENERIC:
                assert type.subtypes.get_count() >= 2
                return type.subtypes[1..]
            when Type.Kind.NULLABLE:
                return typeParameters(type.subtypes[0])
            otherwise:
                return Array<Type>()
        }
    }

    function typeParameters(target:IRNode?):ListView<Type> {
        if target != null {
            if target.kind = IRNode.Kind.TYPE_REFERENCE {
                return typeParameters(target.payload->Type)
            }
            return typeParameters(target.type)
        }
        return Array<Type>()
    }

    method compilePrefix(op:Int, base:IRNode, position:Position):IRNode? {
        if base.type.isClass() {
            def name := operatorName(op)
            def cl := getClass(base.type)
            if cl = null {
                return null
            }
            def s := getSymbolTable(cl)[name]
            if s != null {
                def m:MethodDecl? := null
                match s.kind {
                    when Symbol.Kind.METHOD:
                        m := s->MethodDecl
                        assert m.parameters.get_count() = 0
                        assert !m.annotations.isClass()
                    when Symbol.Kind.METHODS:
                        for test in (s->Methods).methods { -- FIXME ()s
                            if !test.annotations.isClass() & test.parameters.get_count() = 0 {
                                m := test
                                break
                            }
                        }
                    otherwise:
                        assert false
                }
                if m != null {
                    resolve(m)
                    def ref := MethodRef(m, typeParameters(base))
                    def children := Array<IRNode>() -- FIXME literal
                    children.add(base)
                    def methodRef := IRNode(IRNode.Kind.METHOD_REFERENCE, position,
                            Type("<method>", Type.Kind.INVALID, Position(), true), ref, children)
                    def args := Array<IRNode>() -- FIXME literal
                    return call(methodRef, args)
                }
            }
        }
        match op {
            when Token.Kind.SUB:
                match base.kind {
                    when IRNode.Kind.INT:
                        return IRNode(IRNode.Kind.NEGATED_INT, position, base.type,
                                base.payload->UInt64)
                    when IRNode.Kind.NEGATED_INT:
                        return IRNode(IRNode.Kind.INT, position, base.type, base.payload->UInt64)
                    otherwise:
                        if base.type.isBuiltinNumber() {
                            def children := Array<IRNode>() -- FIXME literal
                            children.add(base)
                            return IRNode(IRNode.Kind.PREFIX, base.position, base.type,
                                    Token.Kind.SUB, children)
                        }
                }
                error(base.position, "expected a number, but found '\{base.type}'")
                return null
            when Token.Kind.BITWISENOT:
                if base.type.isBuiltinNumber() {
                    def children := Array<IRNode>() -- FIXME literal
                    children.add(base)
                    return IRNode(IRNode.Kind.PREFIX, base.position, base.type,
                            Token.Kind.BITWISENOT, children)
                }
                else {
                    error(base.position, "expected a number, but found '\{base.type.name}'")
                    return null
                }
            when Token.Kind.NOT:
                def coerced := coerce(base, Type.BuiltinBit())
                if coerced = null {
                    return null
                }
                def children := Array<IRNode>() -- FIXME literal
                children.add(coerced)
                return IRNode(IRNode.Kind.PREFIX, base.position, base.type, Token.Kind.NOT, children)
            otherwise:
                assert false
        }
        assert false
    }

    method compilePrefix(p:ASTNode):IRNode? {
        assert p.kind = ASTNode.Kind.PREFIX
        assert p.children.get_count() = 1
        def base := compileExpression(p.children[0])
        if base = null {
            return null
        }
        return compilePrefix(p.payload->Int, base, p.position)
    }

    method compileCall(c:ASTNode):IRNode? {
        assert c.kind = ASTNode.Kind.CALL
        var m := compileExpression(c.children[0])
        if m != null {
            def args := Array<IRNode>()
            for i in 1 .. c.children.get_count() {
                def arg := compileExpression(c.children[i])
                if arg = null {
                    return null
                }
                args.add(arg)
            }
            return call(m, args)
        }
        return null
    }

    method compileDot(d:ASTNode):IRNode? {
        assert d.kind = ASTNode.Kind.DOT
        assert d.children.get_count() = 1
        var base := compileExpression(d.children[0])
        if base = null {
            return null
        }
        if base.kind != IRNode.Kind.UNRESOLVED_IDENTIFIER & base.kind != IRNode.Kind.SUPER {
            base := resolve(base)
        }
        if base = null {
            return null
        }
        def cl:ClassDecl?
        match base.kind {
            when IRNode.Kind.TYPE_REFERENCE:
                cl := getClass(base.payload->Type)
            when IRNode.Kind.UNRESOLVED_IDENTIFIER:
                def name := "\{base.payload}.\{d.payload}"
                def cl := tryResolveClass(name)
                if cl != null {
                    return IRNode(IRNode.Kind.TYPE_REFERENCE, d.position, Type.Class(), cl.type())
                }
                return IRNode(IRNode.Kind.UNRESOLVED_IDENTIFIER, d.position, Type.Invalid(), name)
            when IRNode.Kind.SUPER:
                resolve(currentClass.peek())
                cl := getClass(currentClass.peek().rawSuper)
            otherwise:
                cl := getClass(base.type)
        }
        if cl = null {
            return null
        }
        def s := getSymbolTable(cl)[d.payload->String]
        if s = null {
            error(d.position, "class '\{base.type}' does not have a member named " +
                    "'\{d.payload}'")
            return null
        }
        return symbolRef(d.position, base, s, getSymbolTable(cl))
    }

    method compileIdentifier(i:ASTNode):IRNode? {
        assert i.kind = ASTNode.Kind.IDENTIFIER
        var s := symbolTable[i.payload->String]
        if s = null {
            s := tryResolveClass(i.payload->String)
        }
        if s != null {
            return symbolRef(i.position, null, s, symbolTable)
        }
        return IRNode(IRNode.Kind.UNRESOLVED_IDENTIFIER, i.position, Type.Invalid(),
                i.payload->String)
    }

    method compileType(t:ASTNode):IRNode? {
        def resolved := resolve(scanner.convertType(t))
        if resolved = null {
            return null
        }
        return IRNode(IRNode.Kind.TYPE_REFERENCE, t.position, Type.Class(), resolved)
    }

    method compileRange(r:ASTNode):IRNode? {
        assert r.kind = ASTNode.Kind.RANGE_EXCLUSIVE | r.kind = ASTNode.Kind.RANGE_INCLUSIVE
        assert r.children.get_count() = 3
        def start:IRNode?
        if r.children[0].kind = ASTNode.Kind.VOID {
            start := IRNode(IRNode.Kind.NULL, r.position, Type.Null())
        }
        else {
            start := compileExpression(r.children[0])
            if start = null {
                return null
            }
        }
        def end:IRNode?
        if r.children[1].kind = ASTNode.Kind.VOID {
            end := IRNode(IRNode.Kind.NULL, r.position, Type.Null())
        }
        else {
            end := compileExpression(r.children[1])
            if end = null {
                return null
            }
        }
        def step:IRNode?
        if r.children[2].kind = ASTNode.Kind.VOID {
            step := null
        }
        else {
            step := coerce(compileExpression(r.children[2]), Type.Int64())
            if step = null {
                return null
            }
        }
        def children := Array<IRNode>() -- FIXME literal
        children.add(start)
        children.add(end)
        if step != null {
            children.add(step)
        }
        return IRNode(IRNode.Kind.UNRESOLVED_RANGE,
                r.position,
                Type("<unresolved range>", Type.Kind.UNRESOLVED, Position(), true),
                r.kind = ASTNode.Kind.RANGE_INCLUSIVE,
                children)
    }

    method compileString(s:ASTNode):IRNode? {
        return IRNode(IRNode.Kind.STRING, s.position, Type.StringType(), s.payload->String)
    }

    method compileSelf(s:ASTNode):IRNode? {
        assert s.kind = ASTNode.Kind.SELF
        if currentMethod.peek().annotations.isClass() {
            error(s.position, "cannot reference 'self' from a @class method")
            return null
        }
        def type:Type
        def cl := currentClass.peek()
        if cl.parameters.get_count() > 0 {
            def subtypes := Array<Type>()
            subtypes.add(cl.type())
            def name := MutableString(cl.name)
            name.append("<")
            var separator := ""
            for p in cl.parameters {
                def pType := Array<Type>() -- FIXME literal
                pType.add(p.bound)
                def pName := "\{cl.name}.\{p.name}"
                name.append(separator)
                name.append(pName)
                subtypes.add(Type(p))
                separator := ", "
            }
            name.append(">")
            type := Type(name.finish(), Type.Kind.GENERIC, s.position, subtypes, true)
        }
        else {
            type := cl.type()
        }
        return IRNode(IRNode.Kind.SELF, s.position, type)
    }

    method compileSuper(s:ASTNode):IRNode? {
        assert s.kind = ASTNode.Kind.SUPER
        if currentMethod.peek().annotations.isClass() {
            error(s.position, "cannot reference 'super' from a @class method")
            return null
        }
        def cl := currentClass.peek()
        assert cl.resolved
        return IRNode(IRNode.Kind.SUPER, s.position, cl.rawSuper)
    }

    method compileCast(c:ASTNode):IRNode? {
        assert c.kind = ASTNode.Kind.CAST
        assert c.children.get_count() = 2
        def value := compileExpression(c.children[0])
        if value = null {
            return null
        }
        def type := resolve(scanner.convertType(c.children[1]))
        if type = null {
            return null
        }
        if coercionCost(value, type) != null {
            return coerce(value, type)
        }
        if canCast(value, type) {
            return cast(value, c.position, true, type)
        }
        else {
            error(c.position, "value of type '\{value.type}' cannot possibly be an " +
                    "instance of '\{type}'")
            return null
        }
    }

    method compileNull(n:ASTNode):IRNode {
        assert n.kind = ASTNode.Kind.NULL
        return IRNode(IRNode.Kind.NULL, n.position, Type.Null())
    }

    method compileExpression(e:ASTNode):IRNode? {
        match e.kind {
            when ASTNode.Kind.BINARY:
                return compileBinary(e)
            when ASTNode.Kind.BIT:
                return IRNode(IRNode.Kind.BIT, e.position, Type.BitLiteral(), e.payload->Bit)
            when ASTNode.Kind.CALL:
                def result := compileCall(e)
                if result != null & result.type = Type.Void() {
                    assert result.kind = IRNode.Kind.CALL
                    error(result.position, (result.payload->MethodRef).value.declaration() + -- FIXME parens
                            " does not return a value")
                    return null
                }
                return result
            when ASTNode.Kind.DOT:
                return compileDot(e)
            when ASTNode.Kind.IDENTIFIER:
                return compileIdentifier(e)
            when ASTNode.Kind.INT:
                return IRNode(IRNode.Kind.INT, e.position, Type.IntLiteral(), e.payload->UInt64)
            when ASTNode.Kind.PREFIX:
                return compilePrefix(e)
            when ASTNode.Kind.RANGE_INCLUSIVE, ASTNode.Kind.RANGE_EXCLUSIVE:
                return compileRange(e)
            when ASTNode.Kind.STRING:
                return compileString(e)
            when ASTNode.Kind.TYPE, ASTNode.Kind.GENERIC_TYPE, ASTNode.Kind.NULLABLE_TYPE:
                return compileType(e)
            when ASTNode.Kind.SELF:
                return compileSelf(e)
            when ASTNode.Kind.SUPER:
                return compileSuper(e)
            when ASTNode.Kind.CAST:
                return compileCast(e)
            when ASTNode.Kind.NULL:
                return compileNull(e)
        }
        assert false, "unsupported expression: \{e} (\{e.kind})"
    }

    method compileBlock(b:ASTNode):IRNode? {
        assert b.kind = ASTNode.Kind.BLOCK
        def symbols := SymbolTable(symbolTable) -- FIXME auto
        symbolTable := symbols
        def result := Array<IRNode>()
        for stmt in b.children {
            def compiled := compileStatement(stmt)
            if compiled = null {
                symbolTable := symbols.parents[0]
                return null
            }
            assert compiled.kind != IRNode.Kind.UNRESOLVED_METHOD_CALL
            result.add(compiled)
        }
        symbolTable := symbols.parents[0]
        return IRNode(IRNode.Kind.BLOCK, b.position, result)
    }

    method compileIf(i:ASTNode):IRNode? {
        assert i.kind = ASTNode.Kind.IF
        assert i.children.get_count() = 2 | i.children.get_count() = 3
        def test := coerce(compileExpression(i.children[0]), Type.Bit())
        if test = null {
            return null
        }
        def ifTrue := compileStatement(i.children[1])
        if ifTrue = null {
            return null
        }
        def children := Array<IRNode>()
        children.add(test)
        children.add(ifTrue)
        if i.children.get_count() = 3 {
            def ifFalse := compileStatement(i.children[2])
            if ifFalse = null {
                return null
            }
            children.add(ifFalse)
        }
        return IRNode(IRNode.Kind.IF, i.position, children)
    }

    method compileRangeFor(position:Position, label:String?, astTarget:ASTNode, rawList:IRNode,
            body:ASTNode):IRNode? {
        def elementType:Type
        def list:IRNode?
        if astTarget.kind = ASTNode.Kind.IDENTIFIER & astTarget.children.get_count() = 1 {
            def t := resolve(scanner.convertType(astTarget.children[0]))
            if rawList.kind = IRNode.Kind.UNRESOLVED_RANGE {
                if rawList.children.get_count() = 2 {
                    list := coerce(rawList, Type.RangeOf(t))
                }
                else {
                    assert rawList.children.get_count() = 3
                    list := coerce(rawList, Type.SteppedRangeOf(t, Type.Int64()))
                }
            }
            else if rawList.type.isSteppedRange() {
                list := coerce(rawList, Type.SteppedRangeOf(t, rawList.type.subtypes[2]))
            }
            else if coercionCost(rawList, Type.RangeOf(t)) != null {
                list := coerce(rawList, Type.RangeOf(t))
            }
            else {
                list := coerce(rawList, Type.SteppedRangeOf(t, Type.Int64()))
            }
        }
        else {
            list := resolve(rawList)
        }
        if list = null {
            return null
        }
        if list.type.typeKind = Type.Kind.NULLABLE {
            assert list.type.subtypes[0].typeKind = Type.Kind.GENERIC
            elementType := list.type.subtypes[0].subtypes[1]
        }
        else {
            assert list.type.typeKind = Type.Kind.GENERIC
            elementType := list.type.subtypes[1]
        }
        def target := compileTarget(astTarget, Variable.Kind.DEF, null, elementType)
        if target = null {
            return null
        }
        assert target.value = null
        def body := compileStatement(body)
        if body = null {
            return null
        }
        def children := Array<IRNode>() -- FIXME literal
        children.add(target.target)
        children.add(list)
        children.add(body)
        return IRNode(IRNode.Kind.RANGE_FOR, position, label, children)
    }

    method compileIteratorFor(position:Position, label:String?, astTarget:ASTNode, iterator:IRNode,
            body:ASTNode):IRNode? {
        -- We rewrite 'for v in <iterator> { <statements> }' to:
        -- def v$Iter := <iterator>
        -- while !v$Iter.done() {
        --     def v := v$Iter.next()
        --     <statements>
        -- }
        assert iterator.type.typeKind = Type.Kind.GENERIC &
                iterator.type.subtypes[0] = Type.Iterator()
        def target := compileTarget(astTarget, Variable.Kind.DEF, null, iterator.type.subtypes[1])
        if target = null {
            return null
        }
        assert target.target.kind = IRNode.Kind.VARIABLE_REFERENCE
        def targetVar := target.target.payload->Variable
        def subtypes := Array<Type>() -- FIXME literal
        subtypes.add(Type.Iterator())
        subtypes.add(target.target.type)
        def iterType := Type("\{subtypes[0]}<\{subtypes[1]}>", Type.Kind.GENERIC, position, subtypes,
                true)
        def iter := Variable(iterator.position, Variable.Kind.DEF, targetVar.name + "$Iter",
                iterType)
        symbolTable.add(iter)
        def statements := Array<IRNode>()
        def declChildren := Array<IRNode>() -- FIXME literal
        declChildren.add(IRNode(IRNode.Kind.VARIABLE_REFERENCE, iterator.position, iter.type, iter))
        declChildren.add(iterator)
        def varChildren := Array<IRNode>()
        varChildren.add(IRNode(IRNode.Kind.DECLARATION, iter.position, declChildren))
        statements.add(IRNode(IRNode.Kind.DEF, iter.position, varChildren))
        def whileChildren := Array<IRNode>()
        def done := call(IRNode(IRNode.Kind.VARIABLE_REFERENCE, iter.position, iter.type, iter),
                "get_done", Array<IRNode>(), null)
        if done = null {
            return null
        }
        def notCall := call(done, "!", Array<IRNode>(), null)
        if notCall = null {
            return null
        }
        whileChildren.add(notCall)
        def valueDeclChildren := Array<IRNode>() -- FIXME literal
        valueDeclChildren.add(IRNode(IRNode.Kind.VARIABLE_REFERENCE, iterator.position,
                targetVar.type, targetVar))
        def next := call(IRNode(IRNode.Kind.VARIABLE_REFERENCE, iterator.position, iter.type, iter),
                "next", Array<IRNode>(), null)
        assert next != null
        valueDeclChildren.add(next)
        def valueVarChildren := Array<IRNode>() -- FIXME literal
        valueVarChildren.add(IRNode(IRNode.Kind.DECLARATION, iterator.position, valueDeclChildren))
        var block := compileStatement(body)
        if block = null {
            return null
        }
        def blockChildren := Array<IRNode>()
        blockChildren.add(IRNode(IRNode.Kind.DEF, iterator.position, valueVarChildren))
        blockChildren.addAll(block.children)
        block := IRNode(IRNode.Kind.BLOCK, block.position, blockChildren)
        whileChildren.add(block)
        statements.add(IRNode(IRNode.Kind.WHILE, iterator.position, label, whileChildren))
        return IRNode(IRNode.Kind.BLOCK, iterator.position, statements)
    }

    method compileFor(f:ASTNode):IRNode? {
        assert f.kind = ASTNode.Kind.FOR
        assert f.children.get_count() = 3
        loops.push(f.payload->String?) -- FIXME use AutoLoop
        var list := compileExpression(f.children[1])
        if list = null {
            loops.pop()
            return null
        }
        def symbols := SymbolTable(symbolTable) -- FIXME auto
        symbolTable := symbols
        def result:IRNode?
        if list.kind = IRNode.Kind.UNRESOLVED_RANGE | list.type.isRange() |
                list.type.isSteppedRange() {
            result := compileRangeFor(f.position, f.payload->String?, f.children[0], list,
                    f.children[2])
        }
        else {
            list := resolve(list)
            if list = null {
                return null
            }
            var found := false
            for intf in allInterfaces(list.type) {
                if intf.typeKind = Type.Kind.GENERIC & intf.subtypes[0] = Type.Iterator() {
                    def iterator := coerce(list, intf)
                    result := compileIteratorFor(f.position, f.payload->String?, f.children[0],
                            iterator, f.children[2])
                    found := true
                    break
                }
                if intf.typeKind = Type.Kind.GENERIC & intf.subtypes[0] = Type.Iterable() {
                    def iterable := coerce(list, intf)
                    def iterator := call(iterable, "iterator", Array<IRNode>())
                    result := compileIteratorFor(f.position, f.payload->String?, f.children[0],
                            iterator, f.children[2])
                    found := true
                    break
                }
            }
            if !found {
                error(list.position, "expected an Iterable or Iterator, but found '\{list.type}'")
                return null
            }
        }
        symbolTable := symbols.parents[0]
        loops.pop()
        return result
    }

    method compileWhile(w:ASTNode):IRNode? {
        assert w.kind = ASTNode.Kind.WHILE
        assert w.children.get_count() = 2
        loops.push(w.payload->String?) -- FIXME use AutoLoop
        def test := coerce(compileExpression(w.children[0]), Type.Bit())
        if test = null {
            loops.pop()
            return null
        }
        def stmt := compileStatement(w.children[1])
        if stmt = null {
            loops.pop()
            return null
        }
        def children := Array<IRNode>(2) -- FIXME literal
        children.add(test)
        children.add(stmt)
        loops.pop()
        return IRNode(IRNode.Kind.WHILE, w.position, w.payload, children)
    }

    method compileDo(d:ASTNode):IRNode? {
        assert d.kind = ASTNode.Kind.DO
        assert d.children.get_count() = 2
        loops.push(d.payload->String?) -- FIXME use AutoLoop
        def stmt := compileStatement(d.children[0])
        if stmt = null {
            loops.pop()
            return null
        }
        def test := coerce(compileExpression(d.children[1]), Type.Bit())
        if test = null {
            loops.pop()
            return null
        }
        def children := Array<IRNode>(2) -- FIXME literal
        children.add(stmt)
        children.add(test)
        loops.pop()
        return IRNode(IRNode.Kind.DO, d.position, d.payload, children)
    }

    method compileLoop(l:ASTNode):IRNode? {
        assert l.kind = ASTNode.Kind.LOOP
        assert l.children.get_count() = 1
        loops.push(l.payload->String?) -- FIXME use AutoLoop
        def stmt := compileStatement(l.children[0])
        if stmt = null {
            loops.pop()
            return null
        }
        def children := Array<IRNode>(1) -- FIXME literal
        children.add(stmt)
        loops.pop()
        return IRNode(IRNode.Kind.LOOP, l.position, l.payload, children)
    }

    -- FIXME use tuple
    class CompileTargetResult {
        def target:org.pandalanguage.pandac.IRNode
        def value:org.pandalanguage.pandac.IRNode?

        init(target:org.pandalanguage.pandac.IRNode, value:org.pandalanguage.pandac.IRNode?) {
            self.target := target
            self.value := value
        }
    }

    method compileTarget(t:ASTNode, kind:Int-*Variable.Kind*-, rawValue:IRNode?,
            valueType:Type?):CompileTargetResult? {
        var value:IRNode? := rawValue -- FIXME use var on parameter
        assert value = null | valueType = null
        match t.kind {
            when ASTNode.Kind.IDENTIFIER:
                def type:Type
                if t.children.get_count() = 1 {
                    type := resolve(scanner.convertType(t.children[0]))
                }
                else if value != null {
                    value := resolve(value)
                    if value = null {
                        return null
                    }
                    type := variableType(value)
                }
                else if valueType != null {
                    type := valueType
                }
                else {
                    error(t.position, "declaration has neither a type nor a value")
                    return null
                }
                if value != null {
                    value := coerce(value, type)
                    if value = null {
                        return null
                    }
                    assert value.type = type
                }
                def v := Variable(t.position, kind, t.payload->String, type)
                symbolTable.add(v)
                return CompileTargetResult(IRNode(IRNode.Kind.VARIABLE_REFERENCE, v.position, v.type,
                        v), value)
            when ASTNode.Kind.TUPLE_TARGET:
                assert false
            otherwise:
                assert false
        }
    }

    method compileDeclaration(d:ASTNode, varKind:Int):IRNode? {
        assert d.kind = ASTNode.Kind.DECLARATION
        assert d.children.get_count() = 1 | d.children.get_count() = 2
        def value:IRNode?
        if d.children.get_count() = 2 {
            value := compileExpression(d.children[1])
            if value = null {
                return null
            }
        }
        else {
            value := null
        }
        def target := compileTarget(d.children[0], varKind, value, null)
        if target = null {
            return null
        }
        def children := Array<IRNode>()
        children.add(target.target)
        if target.value != null {
            assert target.target.kind = IRNode.Kind.VARIABLE_REFERENCE
            def v := target.target.payload->Variable
            v.initialValue := target.value -- FIXME parens
            children.add(target.value)
        }
        return IRNode(IRNode.Kind.DECLARATION, d.position, children)
    }

    method compileBreak(b:ASTNode):IRNode? {
        assert b.kind = ASTNode.Kind.BREAK
        if b.payload != null {
            var found := false
            for label in loops {
                if label != null & label = b.payload->String { -- FIXME shouldn't need null check
                    found := true
                    break
                }
            }
            if !found {
                error(b.position, "'break \{b.payload}' must be inside a loop labelled " +
                        "'\{b.payload}:'")
            }
        }
        else if loops.get_count() = 0 {
            error(b.position, "'break' must be inside a loop")
        }
        return IRNode(IRNode.Kind.BREAK, b.position, b.payload->String)
    }

    method compileContinue(c:ASTNode):IRNode? {
        assert c.kind = ASTNode.Kind.CONTINUE
        if c.payload != null {
            var found := false
            for label in loops {
                if label != null & label = c.payload->String { -- FIXME shouldn't need null check
                    found := true
                    break
                }
            }
            if !found {
                error(c.position, "'continue \{c.payload}' must be inside a loop labelled " +
                        "'\{c.payload}:'")
            }
        }
        else if loops.get_count() = 0 {
            error(c.position, "'continue' must be inside a loop")
        }
        return IRNode(IRNode.Kind.CONTINUE, c.position, c.payload->String)
    }

    method compileReturn(r:ASTNode):IRNode? {
        assert r.kind = ASTNode.Kind.RETURN
        if r.children.get_count() = 1 {
            if currentMethod.peek().returnType = Type.Void() {
                error(r.position, "cannot return a value from a method with no return type")
                return null
            }
            def value := coerce(compileExpression(r.children[0]), currentMethod.peek().returnType)
            if value = null {
                return null
            }
            def children := Array<IRNode>() -- FIXME literal
            children.add(value)
            return IRNode(IRNode.Kind.RETURN, r.position, children)
        }
        assert r.children.get_count() = 0
        if currentMethod.peek().returnType != Type.Void() {
            error(r.position, "expected a return value")
            return null
        }
        return IRNode(IRNode.Kind.RETURN, r.position)
    }

    method compileAssert(a:ASTNode):IRNode? {
        assert(a.kind = ASTNode.Kind.ASSERT)
        assert(a.children.get_count() = 1 | a.children.get_count() = 2)
        var test := compileExpression(a.children[0])
        if test = null {
            return null
        }
        test := coerce(test, Type.Bit())
        if test = null {
            return null
        }
        def bit := getClass(Type.Bit())
        assert bit != null
        def value := bit.symbolTable["value"]
        resolve(value->FieldDecl)
        def fieldChildren := Array<IRNode>() -- FIXME literal
        fieldChildren.add(test)
        test := IRNode(IRNode.Kind.FIELD_REFERENCE, a.position, Type.BuiltinBit(), value,
                fieldChildren)
        def children := Array<IRNode>() -- FIXME literal
        children.add(test)
        if a.children.get_count() = 2 {
            var msg := compileExpression(a.children[1])
            if msg = null {
                return null
            }
            msg := coerce(msg, Type.StringType())
            if msg = null {
                return null
            }
            children.add(msg)
        }
        return IRNode(IRNode.Kind.ASSERT, a.position, children)
    }

    method compileVar(v:ASTNode):IRNode? {
        assert v.kind = ASTNode.Kind.VAR |
               v.kind = ASTNode.Kind.DEF |
               v.kind = ASTNode.Kind.PROPERTY |
               v.kind = ASTNode.Kind.CONSTANT
        def nodeKind:Int
        def varKind:Int
        match v.kind {
            when ASTNode.Kind.VAR:
                nodeKind := IRNode.Kind.VAR
                varKind := Variable.Kind.VAR
            when ASTNode.Kind.DEF:
                nodeKind := IRNode.Kind.DEF
                varKind := Variable.Kind.DEF
            when ASTNode.Kind.CONSTANT:
                nodeKind := IRNode.Kind.CONSTANT
                varKind := Variable.Kind.CONSTANT
            when ASTNode.Kind.PROPERTY:
                nodeKind := IRNode.Kind.PROPERTY
                varKind := Variable.Kind.PROPERTY
            otherwise: assert false
        }
        def decls := Array<IRNode>()
        for astDecl in v.children {
            def decl := compileDeclaration(astDecl, varKind)
            if decl = null {
                return null
            }
            decls.add(decl)
        }
        return IRNode(nodeKind, v.position, decls)
    }

    method compileWhenTest(value:Variable, test:ASTNode):IRNode? {
        def target := IRNode(IRNode.Kind.VARIABLE_REFERENCE, test.position, value.type, value)
        def callChildren := Array<IRNode>()
        def testValue := compileExpression(test)
        if testValue = null {
            return null
        }
        callChildren.add(testValue)
        return call(target, "=", callChildren)
    }

    method compileChainedIfWhen(value:Variable, w:ASTNode):IRNode? {
        assert w.kind = ASTNode.Kind.WHEN
        assert w.children.get_count() >= 1
        assert w.children[0].kind = ASTNode.Kind.EXPRESSIONS
        assert w.children[0].children.get_count() >= 1
        var test := compileWhenTest(value, w.children[0].children[0])
        if test = null {
            return null
        }
        for i in 1 .. w.children[0].children.get_count() {
            def nextTest := compileWhenTest(value, w.children[0].children[i])
            if nextTest = null {
                return null
            }
            def callChildren := Array<IRNode>() -- FIXME literal
            callChildren.add(nextTest)
            test := call(test, "|", callChildren)
            if test = null {
                return null
            }
        }
        symbolTable := SymbolTable(symbolTable)
        def statements := Array<IRNode>()
        for i in 1 .. w.children.get_count() {
            def statement := compileStatement(w.children[i])
            if statement = null {
                return null
            }
            statements.add(statement)
        }
        symbolTable := symbolTable.parents[0]
        def children := Array<IRNode>() -- FIXME literal
        children.add(test)
        children.add(IRNode(IRNode.Kind.BLOCK, w.position, statements))
        return IRNode(IRNode.Kind.IF, w.position, children)
    }

    method compileChainedIfMatch(m:ASTNode, value:IRNode):IRNode? {
        def children := Array<IRNode>()
        def valueVar := Variable(m.position, Variable.Kind.DEF,
                "$match$\{m.position.line}_\{m.position.column}", value.type)
        def declChildren := Array<IRNode>() -- FIXME literal
        declChildren.add(IRNode(IRNode.Kind.VARIABLE_REFERENCE, value.position, valueVar.type,
                valueVar))
        declChildren.add(value)
        def varChildren := Array<IRNode>()
        varChildren.add(IRNode(IRNode.Kind.DECLARATION, valueVar.position, declChildren))
        children.add(IRNode(IRNode.Kind.DEF, valueVar.position, varChildren))
        for i in 1 .. m.children.get_count() {
            def c := m.children[i]
            match c.kind {
                when ASTNode.Kind.WHEN:
                    def w := compileChainedIfWhen(valueVar, c)
                    if w = null {
                        return null
                    }
                    children.add(w)
                when ASTNode.Kind.OTHERWISE:
                    def statements := Array<IRNode>()
                    for astStatement in c.children {
                        def stmt := compileStatement(astStatement)
                        if stmt = null {
                            return null
                        }
                        statements.add(stmt)
                    }
                    children.add(IRNode(IRNode.Kind.BLOCK, c.position, statements))
                otherwise:
                    assert false
            }
        }
        for i in children.get_count() - 1 .. 1 by -1 {
            assert children[i - 1].kind = IRNode.Kind.IF
            assert children[i - 1].children.get_count() = 2
            children[i - 1].children.add(children[i])
            children.removeIndex(children.get_count() - 1)
        }
        return IRNode(IRNode.Kind.BLOCK, m.position, children)
    }

    method compileWhen(type:Type, w:ASTNode):IRNode? {
        assert w.kind = ASTNode.Kind.WHEN
        assert w.children.get_count() >= 1
        assert w.children[0].kind = ASTNode.Kind.EXPRESSIONS
        assert w.children[0].children.get_count() >= 1
        def children := Array<IRNode>()
        for expr in w.children[0].children {
            def compiled := coerce(compileExpression(expr), type)
            if compiled = null {
                return null
            }
            children.add(compiled)
        }
        symbolTable := SymbolTable(symbolTable)
        def statements := Array<IRNode>()
        for i in 1 .. w.children.get_count() {
            def statement := compileStatement(w.children[i])
            if statement = null {
                return null
            }
            statements.add(statement)
        }
        symbolTable := symbolTable.parents[0]
        children.add(IRNode(IRNode.Kind.BLOCK, w.position, statements))
        return IRNode(IRNode.Kind.WHEN, w.position, children)
    }

    method compileOtherwise(o:ASTNode):IRNode? {
        assert o.kind = ASTNode.Kind.OTHERWISE
        def children := Array<IRNode>()
        symbolTable := SymbolTable(symbolTable)
        def statements := Array<IRNode>()
        for s in o.children {
            def statement := compileStatement(s)
            if statement = null {
                return null
            }
            statements.add(statement)
        }
        symbolTable := symbolTable.parents[0]
        children.add(IRNode(IRNode.Kind.BLOCK, o.position, statements))
        return IRNode(IRNode.Kind.OTHERWISE, o.position, children)
    }

    function isConstantInt(expr:IRNode):Bit {
        match expr.kind {
            when IRNode.Kind.INT:
                return true
            when IRNode.Kind.CONSTRUCT:
                return expr.type.isNumber() & isConstantInt(expr.children[0].children[0])
            when IRNode.Kind.FIELD_REFERENCE:
                def f := expr.payload->FieldDecl
                assert f.resolved
                return f.fieldKind = FieldDecl.Kind.CONSTANT & f.value != null &
                        isConstantInt(f.value)
            when IRNode.Kind.VARIABLE_REFERENCE:
                def v := expr.payload->Variable
                return v.varKind = Variable.Kind.DEF | v.varKind = Variable.Kind.CONSTANT &
                        v.initialValue != null & isConstantInt(v.initialValue)
            otherwise:
                return false
        }
    }

    function getConstantInt(expr:IRNode):UInt64 {
        assert isConstantInt(expr)
        match expr.kind {
            when IRNode.Kind.INT:
                return expr.payload->UInt64
            when IRNode.Kind.CONSTRUCT:
                return getConstantInt(expr.children[0].children[0])
            when IRNode.Kind.FIELD_REFERENCE:
                def f := expr.payload->FieldDecl
                return getConstantInt(f.value)
            when IRNode.Kind.VARIABLE_REFERENCE:
                def v := expr.payload->Variable
                return getConstantInt(v.initialValue)
            otherwise:
               assert false
        }
    }

    method compileMatch(m:ASTNode):IRNode? {
        assert m.kind = ASTNode.Kind.MATCH
        assert m.children.get_count() >= 1
        def value := resolve(compileExpression(m.children[0]))
        if value = null {
            return null
        }
        if !value.type.isNumber() {
            return compileChainedIfMatch(m, value)
        }
        def children := Array<IRNode>()
        children.add(value)
        for rawWhen in m.children[1..] {
            if rawWhen.kind = ASTNode.Kind.OTHERWISE {
                def o := compileOtherwise(rawWhen)
                if o = null {
                    return null
                }
                children.add(o)
                continue
            }
            def w := compileWhen(value.type, rawWhen)
            if w = null {
                return null
            }
            if !isConstantInt(w.children[0]) {
                return compileChainedIfMatch(m, value)
            }
            children.add(w)
        }
        return IRNode(IRNode.Kind.MATCH, m.position, children)
    }

    method compileStatement(s:ASTNode):IRNode? {
        match s.kind {
            when ASTNode.Kind.ASSERT:   return compileAssert(s)
            when ASTNode.Kind.BINARY:   return resolve(compileBinary(s))
            when ASTNode.Kind.BLOCK:    return compileBlock(s)
            when ASTNode.Kind.IF:       return compileIf(s)
            when ASTNode.Kind.FOR:      return compileFor(s)
            when ASTNode.Kind.WHILE:    return compileWhile(s)
            when ASTNode.Kind.DO:       return compileDo(s)
            when ASTNode.Kind.LOOP:     return compileLoop(s)
            when ASTNode.Kind.MATCH:    return compileMatch(s)
            when ASTNode.Kind.BREAK:    return compileBreak(s)
            when ASTNode.Kind.CONTINUE: return compileContinue(s)
            when ASTNode.Kind.RETURN:   return compileReturn(s)
            when ASTNode.Kind.CALL:
                var result := resolve(compileCall(s))
                if result != null {
                    result := unwrapCast(result)
                }
                return result
            when ASTNode.Kind.VAR, ASTNode.Kind.DEF, ASTNode.Kind.CONSTANT, ASTNode.Kind.PROPERTY:
                return compileVar(s)
        }
        assert false, "unsupported statement kind: \{s.kind}"
    }

    method compileBody(m:MethodDecl):IRNode? {
        if m.compiledBody != null {
            return m.compiledBody
        }
        currentClass.push(m.owner)
        def old := symbolTable
        symbolTable := getSymbolTable(m.owner)
        currentMethod.push(m)
        resolve(m)
        assert m.body != null
        def symbols := SymbolTable(symbolTable)
        for p in m.parameters {
            symbols.add(Variable(m.position, Variable.Kind.DEF, p.name, p.type,
                    Variable.Storage.PARAMETER))
        }
        symbolTable := symbols
        def fieldInitializers := Array<IRNode>()
        if m.methodKind = MethodDecl.Kind.INIT {
            for f in currentClass.peek().fields {
                resolve(f)
                if !f.annotations.isClass() & f.value != null {
                    def children := Array<IRNode>()
                    children.add(IRNode(IRNode.Kind.SELF, m.position, currentClass.peek().type()))
                    def fieldRef := IRNode(IRNode.Kind.FIELD_REFERENCE, m.position, f.type, f,
                            children)
                    children.clear()
                    children.add(fieldRef)
                    children.add(f.value)
                    fieldInitializers.add(IRNode(IRNode.Kind.BINARY, f.position,
                            Token.Kind.ASSIGNMENT, children))
                }
            }
        }
        var compiled := compileBlock(m.body)
        if compiled != null {
            if fieldInitializers.get_count() != 0 {
                def children := Array<IRNode>(fieldInitializers)
                children.addAll(compiled.children)
                compiled := IRNode(IRNode.Kind.BLOCK, m.body.position, children)
            }
        }
        assert symbolTable == symbols
        symbolTable := old
        currentMethod.pop()
        currentClass.pop()
        if m.annotations.isInline() {
            m.compiledBody := compiled
        }
        return compiled
    }

    method compile(m:MethodDecl) {
        if m.body != null {
            def compiled := compileBody(m)
            if compiled != null {
                codeGenerator.write(m, compiled)
            }
        }
        else {
            resolve(m)
            codeGenerator.writeDeclaration(m)
        }
    }

    method markNonExternal(cl:ClassDecl) {
        cl.external := false
        for inner in cl.classes {
            markNonExternal(inner)
        }
    }

    method compile(cl:ClassDecl) {
        assert compiling = null,
                "starting compilation of \{cl.name} while already compiling \{compiling.name}"
        compiling := cl
        currentClass.push(cl)
        markNonExternal(cl)
        if cl.annotations.isSpecialize() {
            codeGenerator.start(cl)
            codeGenerator.end(cl)
            currentClass.pop()
            return
        }
        def old := symbolTable
        symbolTable := getSymbolTable(cl)
        codeGenerator.start(cl)
        for m in cl.methods {
            compile(m)
        }
        codeGenerator.end(cl)
        symbolTable := old
        currentClass.pop()
        compiling := null

        if compilationQueue.get_count() > 0 {
            def next := compilationQueue[0]
            compilationQueue.removeIndex(0)
            compile(next)
        }
        assert compilationQueue.get_count() = 0
    }

    method scan(file:File):ListView<ClassDecl> {
        var result := scans[file]
        if result = null {
            parser.start(file, file.readFully())
            def parsed := parser.file()
            if parsed != null {
                result := scanner.scan(file, parsed)
                for cl in result {
                    classes[cl.name] := cl
                }
            }
            else {
                result := Array<ClassDecl>()
            }
            scans[file] := result
        }
        return result
    }

    method compile(file:File) {
        def classes := scan(file)
        for cl in classes {
            compile(cl)
        }
    }

    method error(position:Position, msg:String) {
        error(currentClass.peek().source, position, msg)
    }

    @override
    method error(file:File, pos:Position, msg:String) {
        if reportErrors {
            errorCount += 1
            Console.printLine("\{file.name()}:\{pos}: error: \{msg}")
        }
    }

    method finish() {
        codeGenerator.finish()
    }
}