package org.pandalanguage.pandac

uses org.pandalanguage.pandac.parser.Parser
uses org.pandalanguage.pandac.parser.Token

class Compiler (ErrorReporter) {
    def importDirs:ListView<File>

    def parser:Parser

    def scanner:Scanner

    def root:SymbolTable

    @private
    def scans := HashMap<File, ListView<ClassDecl>>()

    @private
    def classes := HashMap<String, ClassDecl>()

    @private
    def currentFile := Stack<File>()

    @private
    def currentClass := Stack<ClassDecl>()

    @private
    def currentMethod := Stack<MethodDecl>()

    @private
    var symbolTable:SymbolTable

    @private
    def codeGenerator:CodeGenerator

    @private
    def loops := Stack<String?>()

    @private
    var errorCount := 0

    init(importDirs:ListView<File>) {
        self.importDirs := importDirs
        self.parser := Parser(self)
        self.scanner := Scanner(self)
        self.root := SymbolTable(self)
        self.symbolTable := root
        self.codeGenerator := LLVMCodeGenerator(self)
        codeGenerator.start(File("/tmp/output.ll").openOutputStream())
        root.add(Type("builtin_bit", Type.Kind.BUILTIN_BIT, -1, true))
        root.add(Type("builtin_int8", Type.Kind.BUILTIN_INT, -1, true))
        root.add(Type("builtin_int16", Type.Kind.BUILTIN_INT, -1, true))
        root.add(Type("builtin_int32", Type.Kind.BUILTIN_INT, -1, true))
        root.add(Type("builtin_int64", Type.Kind.BUILTIN_INT, -1, true))
        root.add(Alias("Int", "panda.core.Int64", -1))
        addAlias("panda.core.Class")
        addAlias("panda.core.Bit")
        addAlias("panda.core.Int8")
        addAlias("panda.core.Int16")
        addAlias("panda.core.Int32")
        addAlias("panda.core.Int64")
        addAlias("panda.core.Immutable")
        addAlias("panda.core.Object")
        addAlias("panda.core.Range")
        addAlias("panda.core.Value")
        addAlias("panda.io.Console")
    }

    @private
    method addAlias(name:String) {
        root.add(Alias(name[name.next(name.lastIndexOf("."))..], name, -1))
    }

    function resolve(type:Type):Type {
        if type.resolved {
            return type
        }
        match type.typeKind {
            when Type.Kind.CLASS:
                def resolved := currentClass.peek().aliases[type.name]
                if resolved != null {
                    return Type(resolved, Type.Kind.CLASS, type.offset, true)
                }
                def s := symbolTable[type.name]
                if s != null {
                    match s.kind {
                        when Symbol.Kind.ALIAS:
                            return Type((s->Alias).fullName, Type.Kind.CLASS, type.offset, true) -- FIXME parens
                        when Symbol.Kind.GENERIC_PARAMETER:
                            def gp := s->ClassDecl.GenericParameter
                            resolve(getClass(type.offset, gp.owner))
                            def subtypes := Array<Type>() -- FIXME literal
                            subtypes.add(gp.bound)
                            return Type(gp.owner + "." + gp.name, Type.Kind.GENERIC_PARAMETER,
                                    type.offset, subtypes, true)
                        when Symbol.Kind.TYPE:
                            return s->Type
                    }
                }
                error(position(type.offset), "unknown type '\{type}'")
                return Type.Invalid()
            when Type.Kind.NULLABLE:
                assert type.subtypes.get_count() = 1
                def subtypes := Array<Type>()
                subtypes.add(resolve(type.subtypes[0]))
                return Type(subtypes[0].name + "?", Type.Kind.NULLABLE, type.offset, subtypes, true)
            when Type.Kind.GENERIC:
                assert type.subtypes.get_count() >= 2
                def subtypes := Array<Type>()
                subtypes.add(resolve(type.subtypes[0]))
                def name := MutableString(subtypes[0].name)
                name.append("<")
                var separator := ""
                for i in 1 .. type.subtypes.get_count() {
                    def resolved := resolve(type.subtypes[i])
                    subtypes.add(resolved)
                    name.append(separator)
                    name.append(resolved.name)
                    separator := ", "
                }
                name.append(">")
                return Type(name.convert(), Type.Kind.GENERIC, type.offset, subtypes, true)
            otherwise:
                assert false, "cannot resolve \{type}"
        }
    }

    method resolve(cl:ClassDecl) {
        if cl.resolved {
            return
        }
        currentFile.push(cl.source)
        if cl.rawSuper != null {
            cl.rawSuper := resolve(cl.rawSuper)
        }
        for i in 0 .. cl.rawInterfaces.get_count() {
            cl.rawInterfaces[i] := resolve(cl.rawInterfaces[i])
        }
        cl.resolved := true
        currentFile.pop()
    }

    method resolve(m:MethodDecl) {
        if m.resolved {
            return
        }
        currentFile.push(m.owner.source) -- FIXME use init / cleanup
        def old := symbolTable
        symbolTable := m.owner.symbolTable
        for p in m.parameters {
            p.type := resolve(p.type)
        }
        m.returnType := resolve(m.returnType)
        m.resolved := true
        symbolTable := old
        currentFile.pop()
    }

    method resolve(f:FieldDecl) {
        if f.resolved {
            return
        }
        f.resolved := true
        currentFile.push(f.owner.source) -- FIXME use init / cleanup
        def old := symbolTable
        symbolTable := f.owner.symbolTable
        if f.type != Type.Void() {
            f.type := resolve(f.type)
            currentFile.pop()
            symbolTable := old
            return
        }
        if f.rawValue = null {
            error(f.offset, "field has neither a type nor a value")
            currentFile.pop()
            symbolTable := old
            return
        }
        f.value := compileExpression(f.rawValue)
        if f.value = null {
            currentFile.pop()
            symbolTable := old
            return
        }
        f.type := variableType(f.value)
        f.value := coerce(f.value, f.type)
        currentFile.pop()
        symbolTable := old
    }

    method resolve(expr:IRNode?):IRNode? {
        if expr = null {
            return null
        }
        return coerce(expr, variableType(expr))
    }

    method isValue(cl:ClassDecl):Bit {
        return coercionCost(cl.type(), Type.Value()) != null
    }

    method instanceFields(cl:ClassDecl):ListView<FieldDecl> {
        resolve(cl)
        def result := Array<FieldDecl>()
        if !isValue(cl) & cl.rawSuper != null {
            def s := getClass(cl.rawSuper)
            if s != null {
                result.addAll(instanceFields(s))
            }
        }
        for f in cl.fields {
            if !f.annotations.isClass() {
                result.add(f)
            }
        }
        return result
    }

    method getClass(offset:Int, fullName:String):ClassDecl? {
        var result := classes[fullName]
        if result = null {
            def suffix := fullName.replace(".", "/") + ".panda"
            var found := false
            for dir in importDirs {
                def f := dir.resolve(suffix)
                if f.exists() {
                    found := true
                    def oldErrorCount := errorCount
                    scan(f)
                    result := classes[fullName]
                    if result = null & errorCount = oldErrorCount {
                        error(Position(f.name(), 1, 1),
                                "expected file '\{f}' to contain a class named '\{fullName}'")
                    }
                }
            }
            if !found {
                error(offset, "no file named \{suffix} in any import path (\{importDirs})")
            }
        }
        return result
    }

    method getClass(type:Type):ClassDecl? {
        assert type.resolved, "unresolved type \{type}"
        match type.typeKind {
            when Type.Kind.CLASS:
                return getClass(type.offset, type.name)
            when Type.Kind.NULLABLE, Type.Kind.GENERIC, Type.Kind.GENERIC_PARAMETER:
                return getClass(type.subtypes[0])
            otherwise:
                assert false
        }
    }

    method addInheritedMethods(st:SymbolTable, name:String, result:Array<MethodRef>,
            types:Array<Type>) {
    }

    method getMethodReference(st:SymbolTable, target:IRNode?, name:String, offset:Int,
            types:Array<Type>):IRNode {
        def methods := Array<MethodRef>()
        def s := st[name]
        if s.kind = Symbol.Kind.METHOD {
            resolve(s->MethodDecl)
            methods.add(MethodRef(s->MethodDecl, types))
        }
        else {
            assert s.kind = Symbol.Kind.METHODS
            for m in (s->Methods).methods { -- FIXME extra parens
                resolve(m)
                methods.add(MethodRef(m, types))
            }
        }
        for p in st.parents {
            addInheritedMethods(p, name, methods, types)
        }
        def children := Array<IRNode>()
        if target != null {
            children.add(target)
        }
        if methods.get_count() = 1 {
            return IRNode(IRNode.Kind.METHOD_REFERENCE, offset, methods[0].type(), methods[0],
                    children)
        }
        else {
            def types := Array<Type>()
            for m in methods {
                types.add(m.type())
            }
            return IRNode(IRNode.Kind.UNRESOLVED_METHOD_REFERENCE, offset, Type(types), methods,
                    children)
        }
    }

    method symbolRef(offset:Int, target:IRNode?, s:Symbol, st:SymbolTable):IRNode? {
        match s.kind {
            when Symbol.Kind.ALIAS:
                assert target = null
                def cl := getClass(offset, (s->Alias).fullName) -- FIXME remove extra parens
                if cl != null {
                    return IRNode(IRNode.Kind.TYPE_REFERENCE, offset, Type.Class(), cl.type())
                }
                return null
            when Symbol.Kind.METHOD, Symbol.Kind.METHODS:
                return getMethodReference(st, target, s.name, offset, Array<Type>())
            when Symbol.Kind.VARIABLE:
                return IRNode(IRNode.Kind.VARIABLE_REFERENCE, offset, (s->Variable).type, -- FIXME parens
                        s->Variable)
            when Symbol.Kind.FIELD:
                def f := s->FieldDecl
                resolve(f)
                if f.type = Type.Void() {
                    return null
                }
                def children := Array<IRNode>()
                if target != null {
                    if target.kind == IRNode.Kind.SUPER {
                        error(target.offset, "'super' can only be used as part of a method call")
                        return null
                    }
                    def effectiveType := remapType(target.type, f.type)
                    children.add(target)
                    var result := IRNode(IRNode.Kind.FIELD_REFERENCE, offset, f.type, s, children)
                    if effectiveType != result.type {
                        result := cast(result, offset, false, effectiveType)
                    }
                    return result
                }
                else {
                    children.add(IRNode(IRNode.Kind.SELF, offset, currentClass.peek().type()))
                    return IRNode(IRNode.Kind.FIELD_REFERENCE, offset, f.type, s, children)
                }
            otherwise:
                assert false, "unsupported symbol kind: \{s.kind}"
        }
    }

    function remapType(context:Type, type:Type):Type {
        return type
    }

    function variableType(type:Type):Type {
        if type = Type.IntLiteral() {
            return Type.Int64()
        }
        if type = Type.BitLiteral() {
            return Type.Bit()
        }
        return type
    }

    function variableType(expr:IRNode):Type {
        return variableType(expr.type)
    }

    function coercionCost(type:Type, target:Type):Int? {
        assert type.resolved
        assert target.resolved
        if type = target {
            return 0
        }
        match target.typeKind {
            when Type.Kind.NULLABLE, Type.Kind.GENERIC_PARAMETER:
                return coercionCost(type, target.subtypes[0])
        }
        def targetClass := getClass(target)
        if targetClass = null {
            return null
        }
        for m in targetClass.methods {
            if m.annotations.isImplicit() {
                -- Internal use feature, sharp edges! We currently assume there's only one implicit
                -- method and it's a single-argument init.
                resolve(m)
                assert m.methodKind = MethodDecl.Kind.INIT
                assert m.parameters.get_count() = 1
                def cost := coercionCost(type, m.parameters[0].type)
                if cost != null {
                    return cost
                }
            }
        }

        def cl := getClass(type)
        assert cl != null
        resolve(cl)
        if cl.rawSuper != null {
            var cost := coercionCost(remapType(type, cl.rawSuper), target)
            if cost != null {
                return cost + 1
            }
        }
        for intf in cl.rawInterfaces {
            var cost := coercionCost(remapType(type, intf), target)
            if cost != null {
                return cost + 1
            }
        }
        return null
    }

    function coercionCost(expr:IRNode, target:Type):Int? {
        if expr.type = target {
            return 0
        }
        match target.typeKind {
            when Type.Kind.NULLABLE, Type.Kind.GENERIC_PARAMETER:
                return coercionCost(expr, target.subtypes[0])
        }
        match expr.kind {
            when IRNode.Kind.BIT:
                if target.typeKind = Type.Kind.BUILTIN_BIT {
                    return 0
                }
                if target.isClass() {
                    return coercionCost(Type.Bit(), target)
                }
            when IRNode.Kind.INT:
                if target.typeKind = Type.Kind.BUILTIN_INT {
                    return 0
                }
                if target = Type.Int64() {
                    return 0
                }
                if target.isNumber() {
                    return 1
                }
                if !target.isNumber() {
                    return coercionCost(variableType(expr), target)
                }
        }
        assert expr.type != null
        return coercionCost(expr.type, target)
    }

    function coerce(expr:IRNode?, target:Type):IRNode? {
        if expr = null {
            return null
        }
        assert expr.type.resolved
        assert target.resolved
        if expr.type = target {
            return expr
        }
        match target.typeKind {
            when Type.Kind.GENERIC_PARAMETER:
                return coerce(expr, target.subtypes[0])
            when Type.Kind.NULLABLE:
                if expr.type = target.subtypes[0] {
                    def children := Array<IRNode>() -- FIXME literal
                    children.add(expr)
                    return IRNode(IRNode.Kind.CAST, expr.offset, target, false, children)
                }
                if expr.type.kind != Type.Kind.NULLABLE {
                    def intermediate := coerce(expr, target.subtypes[0])
                    return coerce(intermediate, target)
                }
        }
        if expr.kind = IRNode.Kind.INT {
            if target.isBuiltinNumber() {
                return IRNode(IRNode.Kind.INT, expr.offset, target, expr.payload->UInt64)
            }
            if target.isClass() & !target.isNumber() {
                def varType := coerce(expr, variableType(expr))
                if varType != null {
                    return coerce(varType, target)
                }
            }
        }
        if expr.kind = IRNode.Kind.BIT {
            if target = Type.BuiltinBit() {
                return IRNode(IRNode.Kind.BIT, expr.offset, target, expr.payload->Bit)
            }
            if target.isClass() & target != Type.Bit() {
                def varType := coerce(expr, variableType(expr))
                if varType != null {
                    return coerce(varType, target)
                }
            }
        }
        if coercionCost(expr, target) != null {
            def cl := getClass(target)
            if cl != null {
                for m in cl.methods {
                    if m.annotations.isImplicit() {
                        -- Internal use feature, sharp edges! We currently assume there's only one
                        -- implicit method and it's a single-argument init.
                        resolve(m)
                        assert m.methodKind = MethodDecl.Kind.INIT
                        assert m.parameters.get_count() = 1
                        if coercionCost(expr, m.parameters[0].type) != null {
                            def type := IRNode(IRNode.Kind.TYPE_REFERENCE, expr.offset,
                                    Type.Class(), cl.type())
                            def args := Array<IRNode>(1) -- FIXME literal
                            args.add(expr)
                            return call(type, args)
                        }
                    }
                }
            }
            def children := Array<IRNode>(1) -- FIXME literal
            children.add(expr)
            return IRNode(IRNode.Kind.CAST, expr.offset, target, false, children)
        }
        assert false, "need to coerce \{expr} to \{target}"
    }

    method canCast(node:IRNode, target:Type):Bit {
        if node.type.isPointer() & target.isPointer() {
            return true
        }
        if coercionCost(node, target) != null {
            return true
        }
        if node.type.isBuiltinNumber() & target.isBuiltinNumber() {
            return true
        }
        return coercionCost(target, node.type) != null
    }

    method cast(node:IRNode, offset:Int, isExplicit:Bit, target:Type):IRNode {
        assert target != Type.Void()
        if node.type = target {
            return node
        }
        if isExplicit & !canCast(node, target) {
            error(offset, "value of type '\{node.type}' cannot possibly be an instance of " +
                    "'\{target}'")
        }
        def children := Array<IRNode>() -- FIXME literal
        children.add(node)
        return IRNode(IRNode.Kind.CAST, offset, target, isExplicit, children)
    }

    method callCost(m:MethodRef, args:ListView<IRNode>, expectedReturn:Type?):Int? {
        if m.parameterCount() != args.get_count() {
            return null
        }
        var result := 0
        for i in 0 .. m.parameterCount() {
            def cost := coercionCost(args[i], m.parameter(i))
            if cost = null {
                return null
            }
            result += cost
        }
        if expectedReturn != null {
            def cost := coercionCost(m.returnType(), expectedReturn)
            if cost = null {
                return null
            }
            result += cost
        }
        return result
    }

    method matchMethods(methods:Array<MethodRef>, args:ListView<IRNode>,
            expectedReturn:Type?):Int? {
        def result := Array<MethodRef>()
        var best:Int? := null
        for m in methods {
            def cost := callCost(m, args, expectedReturn)
            if cost = null {
                continue
            }
            if best = null | cost < best {
                result.clear()
                best := cost
            }
            if cost = best {
                result.add(m)
            }
        }
        methods.clear()
        methods.addAll(result)
        return best
    }

    method call(target:IRNode?, m:MethodRef, args:ListView<IRNode>):IRNode? {
        assert m.value.resolved
        assert m.parameterCount() = args.get_count(), "invalid call: \{m} with args: \{args}"
        def finalArgs := Array<IRNode>()
        if target != null & !m.value.annotations.isClass() {
            finalArgs.add(coerce(target, m.value.owner.type()))
        }
        for i in 0 .. args.get_count() {
            def coerced := coerce(args[i], m.parameter(i))
            if coerced = null {
                return null
            }
            finalArgs.add(coerced)
        }
        return IRNode(IRNode.Kind.CALL, m.value.offset, m.returnType(), m, finalArgs)
    }

    method call(target:IRNode, name:String, args:ListView<IRNode>):IRNode? {
        def resolved := resolve(target)
        if resolved = null {
            return null
        }
        def cl := getClass(resolved.type)
        if cl = null {
            return null
        }
        def s := cl.symbolTable[name]
        if s = null {
            error(target.offset, "class '\{cl.name}' does not have a member named '\{name}'")
            return null
        }
        if s.kind != Symbol.Kind.METHOD & s.kind != Symbol.Kind.METHODS {
            error(target.offset, "'\{cl.name}.\{name}' is not a method")
            return null
        }
        def ref := symbolRef(target.offset, target, s, cl.symbolTable)
        if ref = null {
            return null
        }
        return call(ref, args)
    }

    method call(m:IRNode, args:ListView<IRNode>):IRNode? {
        match m.kind {
            when IRNode.Kind.METHOD_REFERENCE:
                def target:IRNode?
                return call(m.children[0], m.payload->MethodRef, args)
            when IRNode.Kind.UNRESOLVED_METHOD_REFERENCE:
                def methods := Array<MethodRef>(m.payload->ListView<MethodRef>)
                matchMethods(methods, args, null)
                if methods.get_count() = 1 {
                    def target:IRNode?
                    if m.children.get_count() = 1 {
                        target := m.children[0]
                    }
                    else {
                        assert m.children.get_count() = 0
                        target := null
                    }
                    return call(target, methods[0], args)
                }
                assert false
            when IRNode.Kind.TYPE_REFERENCE:
                def cl := getClass(m.payload->Type)
                assert cl != null
                def methods := getMethodReference(cl.symbolTable, null, "init", m.offset,
                        Array<Type>())
                def initCall := resolve(call(methods, args))
                if initCall = null {
                    return null
                }
                def children := Array<IRNode>() -- FIXME literal
                children.add(initCall)
                return IRNode(IRNode.Kind.CONSTRUCT, m.offset, m.payload->Type, children)
        }
        assert false
    }

    function operatorName(op:Int):String {
        match op {
            when Token.Kind.ADD: return "+"
            when Token.Kind.SUB: return "-"
            when Token.Kind.MUL: return "*"
            when Token.Kind.DIV: return "/"
            when Token.Kind.INTDIV: return "//"
            when Token.Kind.REM: return "%"
            when Token.Kind.POW: return "^"
            when Token.Kind.EQ: return "="
            when Token.Kind.NEQ: return "!="
            when Token.Kind.GT: return ">"
            when Token.Kind.LT: return "<"
            when Token.Kind.GTEQ: return ">="
            when Token.Kind.LTEQ: return "<="
            when Token.Kind.OR: return "|"
            when Token.Kind.BITWISEOR: return "||"
            when Token.Kind.AND: return "&"
            when Token.Kind.BITWISEAND: return "&&"
            when Token.Kind.XOR: return "~"
            when Token.Kind.BITWISEXOR: return "~~"
            when Token.Kind.NOT: return "!"
            when Token.Kind.BITWISENOT: return "!!"
            when Token.Kind.SHIFTLEFT: return "<<"
            when Token.Kind.SHIFTRIGHT: return ">>"
            otherwise: assert false
        }
    }

    function isLValue(expr:IRNode):Bit {
        match expr.kind {
            when IRNode.Kind.CAST:
                assert expr.children.get_count() = 1
                if !expr.payload->Bit {
                    return isLValue(expr.children[0])
                }
                return false
            when IRNode.Kind.FIELD_REFERENCE, IRNode.Kind.VARIABLE_REFERENCE:
                return true
            when IRNode.Kind.REUSED_VALUE_DEFINITION:
                return isLValue(expr.children[0])
            otherwise:
                return false
        }
    }

    method compileBinary(b:ASTNode):IRNode? {
        var left := compileExpression(b.children[0])
        if left = null {
            return null
        }
        var right := compileExpression(b.children[1])
        if right = null {
            return null
        }
        if b.payload->Int = Token.Kind.ASSIGNMENT {
            left := resolve(left)
            if left = null {
                return null
            }
            right := coerce(right, left.type)
            if right = null {
                return null
            }
            if !isLValue(left) {
                error(left.offset, "cannot assign to this expression")
                return null
            }
            def children := Array<IRNode>()
            children.add(left)
            children.add(right)
            return IRNode(IRNode.Kind.BINARY, b.offset, Token.Kind.ASSIGNMENT, children)
        }
        def children := Array<IRNode>()
        if left.type.isBuiltinNumber() & coercionCost(right, left.type) != null {
            right := coerce(right, left.type)
            assert right != null
            children.add(left)
            children.add(right)
            def resultType:Type
            match b.payload->Int {
                when Token.Kind.EQ, Token.Kind.NEQ, Token.Kind.GT, Token.Kind.GTEQ, Token.Kind.LT,
                        Token.Kind.LTEQ:
                    resultType := Type.BuiltinBit()
                otherwise:
                    resultType := left.type
            }
            return IRNode(IRNode.Kind.BINARY, b.offset, resultType, b.payload->Int, children)
        }
        children.add(right)
        return call(left, operatorName(b.payload->Int), children)
    }

    method compileCall(c:ASTNode):IRNode? {
        assert c.kind = ASTNode.Kind.CALL
        var m := compileExpression(c.children[0])
        if m != null {
            def args := Array<IRNode>()
            for i in 1 .. c.children.get_count() {
                def arg := compileExpression(c.children[i])
                if arg = null {
                    return null
                }
                args.add(arg)
            }
            return call(m, args)
        }
        return null
    }

    method compileDot(d:ASTNode):IRNode? {
        assert d.kind = ASTNode.Kind.DOT
        assert d.children.get_count() = 1
        def base := resolve(compileExpression(d.children[0]))
        if base = null {
            return null
        }
        def cl:ClassDecl?
        if base.kind = IRNode.Kind.TYPE_REFERENCE {
            cl := getClass(base.payload->Type)
        }
        else {
            cl := getClass(base.type)
        }
        if cl = null {
            return null
        }
        def s := cl.symbolTable[d.payload->String]
        if s = null {
            error(d.offset, "value of type '\{base}' does not have a member named '\{d.payload}'")
            return null
        }
        return symbolRef(d.offset, base, s, cl.symbolTable)
    }

    method compileIdentifier(i:ASTNode):IRNode? {
        assert i.kind = ASTNode.Kind.IDENTIFIER
        def s := symbolTable[i.payload->String]
        if s != null {
            return symbolRef(i.offset, null, s, symbolTable)
        }
        else {
            error(i.offset, "unknown identifier '\{i.payload}'")
            return null
        }
    }

    method compileType(t:ASTNode):IRNode? {
        return IRNode(IRNode.Kind.TYPE_REFERENCE, t.offset, Type.Class(),
                resolve(scanner.convertType(t)))
    }

    method compileExpression(e:ASTNode):IRNode? {
        match e.kind {
            when ASTNode.Kind.BINARY:
                return compileBinary(e)
            when ASTNode.Kind.BIT:
                return IRNode(IRNode.Kind.BIT, e.offset, Type.BitLiteral(), e.payload->Bit)
            when ASTNode.Kind.CALL:
                return compileCall(e)
            when ASTNode.Kind.DOT:
                return compileDot(e)
            when ASTNode.Kind.IDENTIFIER:
                return compileIdentifier(e)
            when ASTNode.Kind.INT:
                return IRNode(IRNode.Kind.INT, e.offset, Type.IntLiteral(), e.payload->UInt64)
            when ASTNode.Kind.TYPE, ASTNode.Kind.GENERIC_TYPE, ASTNode.Kind.NULLABLE_TYPE:
                return compileType(e)
        }
        assert false, "unsupported expression: \{e} (\{e.kind})"
    }

    method compileBlock(b:ASTNode):IRNode? {
        assert b.kind = ASTNode.Kind.BLOCK
        def result := Array<IRNode>()
        for stmt in b.children {
            def compiled := compileStatement(stmt)
            if compiled = null {
                return null
            }
            result.add(compiled)
        }
        return IRNode(IRNode.Kind.BLOCK, b.offset, result)
    }

    method compileIf(i:ASTNode):IRNode? {
        assert i.kind = ASTNode.Kind.IF
        assert i.children.get_count() = 2 | i.children.get_count() = 3
        def test := coerce(compileExpression(i.children[0]), Type.Bit())
        if test = null {
            return null
        }
        def ifTrue := compileStatement(i.children[1])
        def children := Array<IRNode>()
        children.add(test)
        children.add(ifTrue)
        if i.children.get_count() = 3 {
            def ifFalse := compileStatement(i.children[2])
            if ifFalse = null {
                return null
            }
            children.add(ifFalse)
        }
        return IRNode(IRNode.Kind.IF, i.offset, children)
    }

    method compileWhile(w:ASTNode):IRNode? {
        assert w.kind = ASTNode.Kind.WHILE
        assert w.children.get_count() = 2
        loops.push(w.payload->String?) -- FIXME use AutoLoop
        def test := coerce(compileExpression(w.children[0]), Type.Bit())
        if test = null {
            loops.pop()
            return null
        }
        def stmt := compileStatement(w.children[1])
        if stmt = null {
            loops.pop()
            return null
        }
        def children := Array<IRNode>(2) -- FIXME literal
        children.add(test)
        children.add(stmt)
        loops.pop()
        return IRNode(IRNode.Kind.WHILE, w.offset, w.payload, children)
    }

    method compileDo(d:ASTNode):IRNode? {
        assert d.kind = ASTNode.Kind.DO
        assert d.children.get_count() = 2
        loops.push(d.payload->String?) -- FIXME use AutoLoop
        def stmt := compileStatement(d.children[0])
        if stmt = null {
            loops.pop()
            return null
        }
        def test := coerce(compileExpression(d.children[1]), Type.Bit())
        if test = null {
            loops.pop()
            return null
        }
        def children := Array<IRNode>(2) -- FIXME literal
        children.add(stmt)
        children.add(test)
        loops.pop()
        return IRNode(IRNode.Kind.DO, d.offset, d.payload, children)
    }

    method compileLoop(l:ASTNode):IRNode? {
        assert l.kind = ASTNode.Kind.LOOP
        assert l.children.get_count() = 1
        loops.push(l.payload->String?) -- FIXME use AutoLoop
        def stmt := compileStatement(l.children[0])
        if stmt = null {
            loops.pop()
            return null
        }
        def children := Array<IRNode>(1) -- FIXME literal
        children.add(stmt)
        loops.pop()
        return IRNode(IRNode.Kind.LOOP, l.offset, l.payload, children)
    }

    -- FIXME use tuple
    class CompileTargetResult {
        def target:org.pandalanguage.pandac.IRNode
        def value:org.pandalanguage.pandac.IRNode?

        init(target:org.pandalanguage.pandac.IRNode, value:org.pandalanguage.pandac.IRNode?) {
            self.target := target
            self.value := value
        }
    }

    method compileTarget(t:ASTNode, rawValue:IRNode?, valueType:Type?):CompileTargetResult? {
        var value:IRNode? := rawValue -- FIXME use var on parameter
        assert value = null | valueType = null
        match t.kind {
            when ASTNode.Kind.IDENTIFIER:
                def type:Type
                if t.children.get_count() = 1 {
                    type := resolve(scanner.convertType(t.children[0]))
                }
                else if value != null {
                    value := resolve(value)
                    if value = null {
                        return null
                    }
                    type := variableType(value)
                }
                else if valueType != null {
                    type := valueType
                }
                else {
                    error(t.offset, "declaration has neither a type nor a value")
                    return null
                }
                if value != null {
                    value := coerce(value, type)
                    assert value.type = type
                    if value = null {
                        return null
                    }
                }
                def v := Variable(t.offset, t.payload->String, type)
                symbolTable.add(v)
                return CompileTargetResult(IRNode(IRNode.Kind.VARIABLE_REFERENCE, v.offset, v.type, v), value)
            when ASTNode.Kind.TUPLE_TARGET:
                assert false
            otherwise:
                assert false
        }
    }

    method compileDeclaration(d:ASTNode):IRNode? {
        assert d.kind = ASTNode.Kind.DECLARATION
        assert d.children.get_count() = 1 | d.children.get_count() = 2
        def value:IRNode?
        if d.children.get_count() = 2 {
            value := compileExpression(d.children[1])
            if value = null {
                return null
            }
        }
        else {
            value := null
        }
        def target := compileTarget(d.children[0], value, null)
        if target = null {
            return null
        }
        def children := Array<IRNode>()
        children.add(target.target)
        if target.value != null {
            children.add(target.value)
        }
        return IRNode(IRNode.Kind.DECLARATION, d.offset, children)
    }

    method compileReturn(r:ASTNode):IRNode? {
        assert r.kind = ASTNode.Kind.RETURN
        if r.children.get_count() = 1 {
            if currentMethod.peek().returnType = Type.Void() {
                error(r.offset, "cannot return a value from a method with no return type")
                return null
            }
            def value := coerce(compileExpression(r.children[0]), currentMethod.peek().returnType)
            if value = null {
                return null
            }
            def children := Array<IRNode>() -- FIXME literal
            children.add(value)
            return IRNode(IRNode.Kind.RETURN, r.offset, children)
        }
        assert r.children.get_count() = 0
        if currentMethod.peek().returnType != Type.Void() {
            error(r.offset, "expected a return value")
            return null
        }
        return IRNode(IRNode.Kind.RETURN, r.offset)
    }

    method compileVar(v:ASTNode):IRNode? {
        assert v.kind = ASTNode.Kind.VAR |
               v.kind = ASTNode.Kind.DEF |
               v.kind = ASTNode.Kind.PROPERTY |
               v.kind = ASTNode.Kind.CONSTANT
        def decls := Array<IRNode>()
        for astDecl in v.children {
            def decl := compileDeclaration(astDecl)
            if decl = null {
                return null
            }
            decls.add(decl)
        }
        def kind:Int
        match v.kind {
            when ASTNode.Kind.VAR:      kind := IRNode.Kind.VAR
            when ASTNode.Kind.DEF:      kind := IRNode.Kind.DEF
            when ASTNode.Kind.PROPERTY: kind := IRNode.Kind.PROPERTY
            when ASTNode.Kind.CONSTANT: kind := IRNode.Kind.CONSTANT
            otherwise: assert false
        }
        return IRNode(kind, v.offset, decls)
    }

    method compileStatement(s:ASTNode):IRNode? {
        match s.kind {
            when ASTNode.Kind.BINARY: return compileBinary(s)
            when ASTNode.Kind.BLOCK:  return compileBlock(s)
            when ASTNode.Kind.CALL:   return compileCall(s)
            when ASTNode.Kind.IF:     return compileIf(s)
            when ASTNode.Kind.WHILE:  return compileWhile(s)
            when ASTNode.Kind.DO:     return compileDo(s)
            when ASTNode.Kind.LOOP:   return compileLoop(s)
            when ASTNode.Kind.RETURN: return compileReturn(s)
            when ASTNode.Kind.VAR, ASTNode.Kind.DEF, ASTNode.Kind.CONSTANT, ASTNode.Kind.PROPERTY:
                return compileVar(s)
        }
        assert false, "unsupported statement kind: \{s.kind}"
    }

    method compile(m:MethodDecl) {
        assert currentClass.peek() == m.owner
        assert symbolTable == m.owner.symbolTable
        currentMethod.push(m)
        resolve(m)
        if m.body != null {
            def symbols := SymbolTable(symbolTable)
            for p in m.parameters {
                symbols.add(Variable(m.offset, p.name, p.type, Variable.Storage.PARAMETER))
            }
            symbolTable := symbols
            def compiled := compileBlock(m.body)
            if compiled != null {
                codeGenerator.write(m, compiled)
            }
            assert symbolTable == symbols
            symbolTable := m.owner.symbolTable
        }
        currentMethod.pop()
    }

    method compile(cl:ClassDecl) {
        cl.external := false
        currentClass.push(cl)
        currentFile.push(cl.source)
        symbolTable := cl.symbolTable
        for m in cl.methods {
            compile(m)
        }
        currentFile.pop()
        currentClass.pop()
    }

    method scan(file:File):ListView<ClassDecl> {
        var result := scans[file]
        if result = null {
            currentFile.push(file)
            parser.start(file.name(), file.readFully())
            def parsed := parser.file()
            if parsed != null {
                result := scanner.scan(file, parsed)
                for cl in result {
                    classes[cl.name] := cl
                }
            }
            else {
                result := Array<ClassDecl>()
            }
            scans[file] := result
            currentFile.pop()
        }
        return result
    }

    method compile(file:File) {
        def classes := scan(file)
        for cl in classes {
            compile(cl)
        }
    }

    function position(offset:Int):Position {
        def source := currentFile.peek().openInputStream()
        var line := 1
        var column := 1
        for i in 0 .. offset {
            match source.read()->Char8 { -- FIXME char literals
                when Char8(10):
                    line += 1
                    column := 1
                when Char8(9):
                    column += 4 - column % 4
                otherwise:
                    column += 1
            }
        }
        return Position(currentFile.peek().name(), line, column)
    }

    method error(offset:Int, msg:String) {
        error(position(offset), msg)
    }

    @override
    method error(pos:Position, msg:String) {
        errorCount += 1
        Console.printLine("\{pos}: \{msg}")
        assert false
    }
}