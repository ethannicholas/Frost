package org.pandalanguage.pandac

class Scanner {
    @private
    def compiler:Compiler

    init(compiler:Compiler) {
        self.compiler := compiler
    }

    method convertType(type:ASTNode):Type {
        match type.kind {
            when ASTNode.Kind.VOID:
                return Type.Void()
            when ASTNode.Kind.TYPE:
                assert type.children.get_count() = 0
                return Type(type.payload->String, Type.Kind.CLASS, type.offset)
            when ASTNode.Kind.NULLABLE_TYPE:
                assert type.children.get_count() = 1
                def children := Array<Type>()
                children.add(convertType(type.children[0]))
                return Type(children[0].name + "?", Type.Kind.NULLABLE, type.offset, children,
                        false)
            when ASTNode.Kind.GENERIC_TYPE:
                assert type.children.get_count() >= 2
                def children := Array<Type>()
                for c in type.children {
                    children.add(convertType(c))
                }
                return Type(type.payload->String, Type.Kind.GENERIC, type.offset, children, false)
            otherwise:
                assert false, "\{type} (\{type.kind})"
        }
    }

    method convertAnnotations(a:ASTNode):Annotations {
        assert a.kind = ASTNode.Kind.ANNOTATIONS
        var flags := 0
        for c in a.children {
            assert c.kind = ASTNode.Kind.ANNOTATION
            match c.payload->String {
                when "@private":   flags ||= Annotations.Flag.PRIVATE
                when "@protected": flags ||= Annotations.Flag.PROTECTED
                when "@package":   flags ||= Annotations.Flag.PACKAGE
                when "@class":     flags ||= Annotations.Flag.CLASS
                when "@override":  flags ||= Annotations.Flag.OVERRIDE
                when "@external":  flags ||= Annotations.Flag.EXTERNAL
                when "@$implicit": flags ||= Annotations.Flag.IMPLICIT
                when "@final":     flags ||= Annotations.Flag.FINAL
                when "@abstract":  flags ||= Annotations.Flag.ABSTRACT
                when "@inline":    flags ||= Annotations.Flag.INLINE
                otherwise:
                    compiler.error(c.offset, "unrecognized annotation '\{c.payload}'")
            }
        }
        return Annotations(flags)
    }

    method scanFields(owner:ClassDecl, f:ASTNode) {
        assert f.children.get_count() = 3
        def doccomment:String?
        if f.children[0].kind != ASTNode.Kind.VOID {
            assert f.children[0].kind = ASTNode.Kind.DOC_COMMENT
            doccomment := f.children[0].payload->String
        }
        else {
            doccomment := null
        }
        def annotations := convertAnnotations(f.children[1])
        def kind:Int
        match f.children[2].kind {
            when ASTNode.Kind.VAR:
                kind := FieldDecl.Kind.VAR
            when ASTNode.Kind.DEF:
                kind := FieldDecl.Kind.DEF
            when ASTNode.Kind.CONSTANT:
                kind := FieldDecl.Kind.CONSTANT
                annotations.flags ||= Annotations.Flag.CLASS
            when ASTNode.Kind.PROPERTY:
                kind := FieldDecl.Kind.PROPERTY
        }
        for decl in f.children[2].children {
            assert decl.children[0].kind = ASTNode.Kind.IDENTIFIER
            assert decl.children[0].children.get_count() = 1
            def value:ASTNode?
            if decl.children.get_count() = 2 {
                value := decl.children[1]
            }
            else {
                assert decl.children.get_count() = 1
                value := null
            }
            def field := FieldDecl(owner, decl.offset, doccomment, annotations, kind,
                    decl.children[0].payload->String, convertType(decl.children[0].children[0]),
                    value)
            owner.symbolTable.add(field)
            owner.fields.add(field)
        }
    }

    method scanInit(owner:ClassDecl, i:ASTNode):MethodDecl? {
        assert i.children.get_count() = 5
        def doccomment:String?
        if i.children[0].kind != ASTNode.Kind.VOID {
            assert i.children[0].kind = ASTNode.Kind.DOC_COMMENT
            doccomment := i.children[0].payload->String
        }
        else {
            doccomment := null
        }
        assert i.children[1].kind = ASTNode.Kind.ANNOTATIONS
        def annotations := convertAnnotations(i.children[1])
        assert i.children[2].kind = ASTNode.Kind.PARAMETERS
        def parameters := Array<MethodDecl.Parameter>()
        for p in i.children[2].children {
            assert p.kind = ASTNode.Kind.PARAMETER
            assert p.children.get_count() = 1
            parameters.add(MethodDecl.Parameter(p.payload->String, convertType(p.children[0])))
        }
        return MethodDecl(owner, i.offset, doccomment, annotations, MethodDecl.Kind.INIT, "init",
                parameters, Type.Void(), i.children[3])
    }

    method scanMethod(owner:ClassDecl, m:ASTNode):MethodDecl? {
        assert m.children.get_count() = 6
        def kind:Int
        match m.kind {
            when ASTNode.Kind.METHOD:   kind := MethodDecl.Kind.METHOD
            when ASTNode.Kind.FUNCTION: kind := MethodDecl.Kind.FUNCTION
            otherwise: assert false
        }
        def name := m.payload->String
        def doccomment:String?
        if m.children[0].kind != ASTNode.Kind.VOID {
            assert m.children[0].kind = ASTNode.Kind.DOC_COMMENT
            doccomment := m.children[0].payload->String
        }
        else {
            doccomment := null
        }
        assert m.children[1].kind = ASTNode.Kind.ANNOTATIONS
        def annotations := convertAnnotations(m.children[1])
        assert m.children[2].kind = ASTNode.Kind.PARAMETERS
        def parameters := Array<MethodDecl.Parameter>()
        for p in m.children[2].children {
            assert p.kind = ASTNode.Kind.PARAMETER
            assert p.children.get_count() = 1
            parameters.add(MethodDecl.Parameter(p.payload->String, convertType(p.children[0])))
        }
        def returnType := convertType(m.children[3])
        if m.children[4].kind = ASTNode.Kind.BLOCK {
            return MethodDecl(owner, m.offset, doccomment, annotations, kind, name, parameters,
                    returnType, m.children[4])
        }
        else {
            return MethodDecl(owner, m.offset, doccomment, annotations, kind, name, parameters,
                    returnType, null)
        }
    }

    method scanClass(source:File, aliases:MapView<String, String>, pkg:String,
            cl:ASTNode):ClassDecl? {
        def fullName:String
        if pkg != "" {
            fullName := "\{pkg}.\{cl.payload}"
        }
        else {
            fullName := cl.payload->String
        }
        assert cl.children.get_count() = 6
        def doccomment:String?
        if cl.children[0].kind != ASTNode.Kind.VOID {
            assert cl.children[0].kind = ASTNode.Kind.DOC_COMMENT
            doccomment := cl.children[0].payload->String
        }
        else {
            doccomment := null
        }
        assert cl.children[1].kind = ASTNode.Kind.ANNOTATIONS
        def annotations := convertAnnotations(cl.children[1])
        def parameters := Array<ClassDecl.GenericParameter>()
        if cl.children[2].kind = ASTNode.Kind.GENERICS {
            for p in cl.children[2].children {
                assert p.kind = ASTNode.Kind.IDENTIFIER
                def bound:Type
                if p.children.get_count() = 1 {
                    bound := convertType(p.children[0])
                }
                else {
                    assert p.children.get_count() = 0
                    bound := Type.Any()
                }
                parameters.add(ClassDecl.GenericParameter(p.offset, fullName, p.payload->String,
                        bound))
            }
        }
        else {
            assert cl.children[2].kind = ASTNode.Kind.VOID
        }
        def supertype:Type?
        if cl.children[3].kind != ASTNode.Kind.VOID {
            supertype := convertType(cl.children[3])
        }
        else if fullName != "panda.core.Object" {
            supertype := Type.Object()
        }
        else {
            supertype := null
        }
        def interfaces := Array<Type>()
        def result := ClassDecl(source, cl.offset, aliases, doccomment, annotations, fullName,
                supertype, interfaces, parameters, compiler.root)
        for c in cl.children[5].children {
            match c.kind {
                when ASTNode.Kind.FIELD:
                    scanFields(result, c)
                when ASTNode.Kind.INIT:
                    def i := scanInit(result, c)
                    if i != null {
                        result.symbolTable.add(i)
                        result.methods.add(i)
                    }
                when ASTNode.Kind.METHOD, ASTNode.Kind.FUNCTION:
                    def m := scanMethod(result, c)
                    if m != null {
                        result.symbolTable.add(m)
                        result.methods.add(m)
                    }
                otherwise:
                    assert false, "unsupported class child: \{c.kind}"
            }
        }
        return result
    }

    method scan(source:File, file:ASTNode):ListView<ClassDecl> {
        def result := Array<ClassDecl>()
        var currentPackage := ""
        def aliases := HashMap<String, String>()
        assert file.kind = ASTNode.Kind.FILE
        for c in file.children {
            match c.kind {
                when ASTNode.Kind.PACKAGE:
                    currentPackage := c.payload->String
                when ASTNode.Kind.USES:
                    def fullName := c.payload->String
                    def idx := fullName.lastIndexOf(".")
                    def alias:String
                    if idx != null {
                        alias := fullName[fullName.next(idx)..]
                    }
                    else {
                        alias := fullName
                    }
                    aliases[alias] := fullName
                when ASTNode.Kind.CLASS:
                    def cl := scanClass(source, aliases, currentPackage, c)
                    result.add(cl)
                otherwise:
                    assert false, "unsupported: \{c.kind}"
            }
        }
        return result
    }
}