package org.pandalanguage.pandac

@final
class Scanner {
    @private
    constant INLINE_THRESHOLD := 50

    @private
    def compiler:Compiler

    init(compiler:Compiler) {
        self.compiler := compiler
    }

    method convertType(type:ASTNode):Type {
        match type.kind {
            when ASTNode.Kind.VOID:
                return Type.Void()
            when ASTNode.Kind.TYPE:
                assert type.children.get_count() = 0
                return Type(type.payload->String, Type.Kind.CLASS, type.position)
            when ASTNode.Kind.NULLABLE_TYPE:
                assert type.children.get_count() = 1
                def children := Array<Type>()
                children.add(convertType(type.children[0]))
                return Type(children[0].name + "?", Type.Kind.NULLABLE, type.position, children,
                        false)
            when ASTNode.Kind.GENERIC_TYPE:
                assert type.children.get_count() >= 2
                def children := Array<Type>()
                for c in type.children {
                    def child := convertType(c)
                    children.add(child)
                }
                return Type(type.payload->String, Type.Kind.GENERIC, type.position, children, false)
            otherwise:
                assert false, "\{type} (\{type.kind})"
        }
    }

    method convertAnnotations(a:ASTNode):Annotations {
        assert a.kind = ASTNode.Kind.ANNOTATIONS
        var flags := 0
        for c in a.children {
            assert c.kind = ASTNode.Kind.ANNOTATION
            match c.payload->String {
                when "@private":    flags ||= Annotations.Flag.PRIVATE
                when "@protected":  flags ||= Annotations.Flag.PROTECTED
                when "@package":    flags ||= Annotations.Flag.PACKAGE
                when "@class":      flags ||= Annotations.Flag.CLASS
                when "@override":   flags ||= Annotations.Flag.OVERRIDE
                when "@external":   flags ||= Annotations.Flag.EXTERNAL
                when "@$implicit":  flags ||= Annotations.Flag.IMPLICIT
                when "@final":      flags ||= Annotations.Flag.FINAL
                when "@abstract":   flags ||= Annotations.Flag.ABSTRACT
                when "@inline":     flags ||= Annotations.Flag.INLINE
                when "@specialize": flags ||= Annotations.Flag.SPECIALIZE
                otherwise:
                    compiler.error(c.position, "unrecognized annotation '\{c.payload}'")
            }
        }
        return Annotations(flags)
    }

    method scanFields(owner:ClassDecl, f:ASTNode) {
        assert f.children.get_count() = 3
        def doccomment:String?
        if f.children[0].kind != ASTNode.Kind.VOID {
            assert f.children[0].kind = ASTNode.Kind.DOC_COMMENT
            doccomment := f.children[0].payload->String
        }
        else {
            doccomment := null
        }
        def annotations := convertAnnotations(f.children[1])
        def kind:Int
        match f.children[2].kind {
            when ASTNode.Kind.VAR:
                kind := FieldDecl.Kind.VAR
            when ASTNode.Kind.DEF:
                kind := FieldDecl.Kind.DEF
            when ASTNode.Kind.CONSTANT:
                kind := FieldDecl.Kind.CONSTANT
                annotations.flags ||= Annotations.Flag.CLASS
            when ASTNode.Kind.PROPERTY:
                kind := FieldDecl.Kind.PROPERTY
        }
        for decl in f.children[2].children {
            assert decl.children[0].kind = ASTNode.Kind.IDENTIFIER
            def value:ASTNode?
            if decl.children.get_count() = 2 {
                value := decl.children[1]
            }
            else {
                assert decl.children.get_count() = 1
                value := null
            }
            def type:Type
            if decl.children[0].children.get_count() = 1 {
                type := convertType(decl.children[0].children[0])
            }
            else {
                assert decl.children[0].children.get_count() = 0
                type := Type.Void()
            }
            def field := FieldDecl(owner, decl.position, doccomment, annotations, kind,
                    decl.children[0].payload->String, type, value)
            owner.symbolTable.add(field)
            owner.fields.add(field)
        }
    }

    method scanInit(owner:ClassDecl, i:ASTNode):MethodDecl? {
        assert i.children.get_count() = 5
        def doccomment:String?
        if i.children[0].kind != ASTNode.Kind.VOID {
            assert i.children[0].kind = ASTNode.Kind.DOC_COMMENT
            doccomment := i.children[0].payload->String
        }
        else {
            doccomment := null
        }
        assert i.children[1].kind = ASTNode.Kind.ANNOTATIONS
        def annotations := convertAnnotations(i.children[1])
        assert i.children[2].kind = ASTNode.Kind.PARAMETERS
        def parameters := Array<MethodDecl.Parameter>()
        for p in i.children[2].children {
            assert p.kind = ASTNode.Kind.PARAMETER
            assert p.children.get_count() = 1
            parameters.add(MethodDecl.Parameter(p.payload->String, convertType(p.children[0])))
        }
        return MethodDecl(owner, i.position, doccomment, annotations, MethodDecl.Kind.INIT, "init",
                parameters, Type.Void(), i.children[3])
    }

    function complexity(node:ASTNode):Int {
        var result := 1
        for child in node.children {
            result += complexity(child)
            if result > INLINE_THRESHOLD {
                break
            }
        }
        return result
    }

    function shouldInline(annotations:Annotations, body:ASTNode?):Bit {
        return body != null & !annotations.isInline() & annotations.isFinal() &
                complexity(body) <= INLINE_THRESHOLD
    }

    method scanMethod(owner:ClassDecl, m:ASTNode):MethodDecl? {
        assert m.children.get_count() = 6
        def kind:Int
        match m.kind {
            when ASTNode.Kind.METHOD:   kind := MethodDecl.Kind.METHOD
            when ASTNode.Kind.FUNCTION: kind := MethodDecl.Kind.FUNCTION
            otherwise: assert false
        }
        def name := m.payload->String
        def doccomment:String?
        if m.children[0].kind != ASTNode.Kind.VOID {
            assert m.children[0].kind = ASTNode.Kind.DOC_COMMENT
            doccomment := m.children[0].payload->String
        }
        else {
            doccomment := null
        }
        assert m.children[1].kind = ASTNode.Kind.ANNOTATIONS
        def annotations := convertAnnotations(m.children[1])
        if owner.classKind = ClassDecl.Kind.INTERFACE {
            annotations.flags ||= Annotations.Flag.ABSTRACT
        }
        if owner.annotations.isFinal() | annotations.isPrivate() {
            annotations.flags ||= Annotations.Flag.FINAL
        }
        assert m.children[2].kind = ASTNode.Kind.PARAMETERS
        def parameters := Array<MethodDecl.Parameter>()
        for p in m.children[2].children {
            assert p.kind = ASTNode.Kind.PARAMETER
            assert p.children.get_count() = 1
            parameters.add(MethodDecl.Parameter(p.payload->String, convertType(p.children[0])))
        }
        def returnType := convertType(m.children[3])
        if kind = MethodDecl.Kind.FUNCTION & returnType = Type.Void() {
            compiler.error(m.position, "functions must have a return type")
        }
        if m.children[4].kind = ASTNode.Kind.BLOCK {
            if shouldInline(annotations, m.children[4]) {
                annotations.flags ||= Annotations.Flag.INLINE
            }
            return MethodDecl(owner, m.position, doccomment, annotations, kind, name, parameters,
                    returnType, m.children[4])
        }
        else {
            return MethodDecl(owner, m.position, doccomment, annotations, kind, name, parameters,
                    returnType, null)
        }
    }

    method scanClass(source:File, aliases:MapView<String, String>, contextName:String,
            cl:ASTNode):ClassDecl? {
        def fullName:String
        if contextName != "" {
            fullName := "\{contextName}.\{cl.payload}"
        }
        else {
            fullName := cl.payload->String
        }
        assert cl.children.get_count() = 5
        def doccomment:String?
        if cl.children[0].kind != ASTNode.Kind.VOID {
            assert cl.children[0].kind = ASTNode.Kind.DOC_COMMENT
            doccomment := cl.children[0].payload->String
        }
        else {
            doccomment := null
        }
        assert cl.children[1].kind = ASTNode.Kind.ANNOTATIONS
        def annotations := convertAnnotations(cl.children[1])
        def parameters := Array<ClassDecl.GenericParameter>()
        if cl.children[2].kind = ASTNode.Kind.GENERICS {
            for p in cl.children[2].children {
                assert p.kind = ASTNode.Kind.IDENTIFIER
                def bound:Type
                if p.children.get_count() = 1 {
                    bound := convertType(p.children[0])
                }
                else {
                    assert p.children.get_count() = 0
                    bound := Type.Any()
                }
                parameters.add(ClassDecl.GenericParameter(p.position, fullName, p.payload->String,
                        bound))
            }
        }
        else {
            assert cl.children[2].kind = ASTNode.Kind.VOID
        }
        def supertypes := Array<Type>()
        assert cl.children[3].kind = ASTNode.Kind.TYPES
        for intf in cl.children[3].children {
            supertypes.add(convertType(intf))
        }
        def result := ClassDecl(source, cl.position, aliases, doccomment, annotations,
                ClassDecl.Kind.CLASS, fullName, supertypes, parameters, compiler.root)
        compiler.currentClass.push(result)
        var foundInit := false
        for c in cl.children[4].children {
            match c.kind {
                when ASTNode.Kind.FIELD:
                    scanFields(result, c)
                when ASTNode.Kind.INIT:
                    def i := scanInit(result, c)
                    if i != null {
                        result.symbolTable.add(i)
                        result.methods.add(i)
                    }
                    foundInit := true
                when ASTNode.Kind.METHOD, ASTNode.Kind.FUNCTION:
                    def m := scanMethod(result, c)
                    if m != null {
                        result.symbolTable.add(m)
                        result.methods.add(m)
                    }
                when ASTNode.Kind.CLASS:
                    def inner := scanClass(source, aliases, fullName, c)
                    if inner != null {
                        inner.owner := result
                        result.classes.add(inner)
                        assert inner.name.startsWith(fullName + ".")
                        result.symbolTable.add(inner, inner.name[fullName.length() + 1..])
                        inner.symbolTable.parents.add(result.symbolTable)
                        inner.symbolTable.add(result, cl.payload->String)
                    }
                when ASTNode.Kind.INTERFACE:
                    def cl := scanInterface(source, aliases, fullName, c)
                    if cl != null {
                        result.classes.add(cl)
                        assert cl.name.startsWith(fullName + ".")
                        result.symbolTable.add(cl, cl.name[fullName.length() + 1..])
                    }
                otherwise:
                    assert false, "unsupported class child: \{c.kind}"
            }
        }
        if !foundInit & result.name != "panda.unsafe.Pointer" {
            def defaultInit := MethodDecl(result, cl.position, null, Annotations(),
                    MethodDecl.Kind.INIT, "init", Array<MethodDecl.Parameter>(), Type.Void(),
                    ASTNode(ASTNode.Kind.BLOCK, cl.position))
            result.methods.add(defaultInit)
            result.symbolTable.add(defaultInit)
        }
        compiler.currentClass.pop()
        return result
    }

    method scanInterface(source:File, aliases:MapView<String, String>, contextName:String,
            intf:ASTNode):ClassDecl? {
        def fullName:String
        if contextName != "" {
            fullName := "\{contextName}.\{intf.payload}"
        }
        else {
            fullName := intf.payload->String
        }
        assert intf.children.get_count() = 5
        def doccomment:String?
        if intf.children[0].kind != ASTNode.Kind.VOID {
            assert intf.children[0].kind = ASTNode.Kind.DOC_COMMENT
            doccomment := intf.children[0].payload->String
        }
        else {
            doccomment := null
        }
        assert intf.children[1].kind = ASTNode.Kind.ANNOTATIONS
        def annotations := convertAnnotations(intf.children[1])
        def parameters := Array<ClassDecl.GenericParameter>()
        if intf.children[2].kind = ASTNode.Kind.GENERICS {
            for p in intf.children[2].children {
                assert p.kind = ASTNode.Kind.IDENTIFIER
                def bound:Type
                if p.children.get_count() = 1 {
                    bound := convertType(p.children[0])
                }
                else {
                    assert p.children.get_count() = 0
                    bound := Type.Any()
                }
                parameters.add(ClassDecl.GenericParameter(p.position, fullName, p.payload->String,
                        bound))
            }
        }
        else {
            assert intf.children[2].kind = ASTNode.Kind.VOID
        }
        def supertypes := Array<Type>()
        assert intf.children[3].kind = ASTNode.Kind.TYPES
        for s in intf.children[3].children {
            supertypes.add(convertType(s))
        }
        def result := ClassDecl(source, intf.position, aliases, doccomment, annotations,
                ClassDecl.Kind.INTERFACE, fullName, supertypes, parameters, compiler.root)
        for c in intf.children[4].children {
            match c.kind {
                when ASTNode.Kind.FIELD:
                    scanFields(result, c)
                when ASTNode.Kind.INIT:
                    def i := scanInit(result, c)
                    if i != null {
                        result.symbolTable.add(i)
                        result.methods.add(i)
                    }
                when ASTNode.Kind.METHOD, ASTNode.Kind.FUNCTION:
                    def m := scanMethod(result, c)
                    if m != null {
                        if m.body = null {
                            m.annotations.flags ||= Annotations.Flag.ABSTRACT
                        }
                        result.symbolTable.add(m)
                        result.methods.add(m)
                    }
                when ASTNode.Kind.CLASS:
                    def cl := scanClass(source, aliases, fullName, c)
                    if cl != null {
                        result.classes.add(cl)
                        assert cl.name.startsWith(fullName + ".")
                        result.symbolTable.add(cl, cl.name[fullName.length() + 1..])
                    }
                when ASTNode.Kind.INTERFACE:
                    def cl := scanInterface(source, aliases, fullName, c)
                    if cl != null {
                        result.classes.add(cl)
                        assert cl.name.startsWith(fullName + ".")
                        result.symbolTable.add(cl, cl.name[fullName.length() + 1..])
                    }
                otherwise:
                    assert false, "unsupported class child: \{c.kind}"
            }
        }
        return result
    }

    method addClass(cl:ClassDecl, arr:Array<ClassDecl>) {
        arr.add(cl)
        for inner in cl.classes {
            addClass(inner, arr)
        }
    }

    method scan(source:File, file:ASTNode):ListView<ClassDecl> {
        def result := Array<ClassDecl>()
        var currentPackage := "anonymous"
        def aliases := HashMap<String, String>()
        assert file.kind = ASTNode.Kind.FILE
        for c in file.children {
            match c.kind {
                when ASTNode.Kind.PACKAGE:
                    currentPackage := c.payload->String
                when ASTNode.Kind.USES:
                    def fullName := c.payload->String
                    def idx := fullName.lastIndexOf(".")
                    def alias:String
                    if idx != null {
                        alias := fullName[fullName.next(idx)..]
                    }
                    else {
                        alias := fullName
                    }
                    aliases[alias] := fullName
                when ASTNode.Kind.CLASS:
                    def cl := scanClass(source, aliases, currentPackage, c)
                    if cl != null {
                        addClass(cl, result)
                    }
                when ASTNode.Kind.INTERFACE:
                    def cl := scanInterface(source, aliases, currentPackage, c)
                    if cl != null {
                        addClass(cl, result)
                    }
                otherwise:
                    assert false, "unsupported: \{c.kind}"
            }
        }
        return result
    }
}