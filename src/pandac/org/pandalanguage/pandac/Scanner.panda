package org.pandalanguage.pandac

uses org.pandalanguage.pandac.parser.Token

@final
class Scanner {
    @private
    constant INLINE_THRESHOLD := 10

    @private
    @weak
    def compiler:Compiler

    init(compiler:Compiler) {
        self.compiler := compiler
    }

    method convertType(type:ASTNode):Type {
        match type {
            when ASTNode.TYPE(position, name):
                return Type(name, Type.Kind.CLASS, position)
            when ASTNode.NULLABLE_TYPE(position, base):
                def subtypes := Array<Type>()
                subtypes.add(convertType(base))
                return Type(subtypes[0].name + "?", Type.Kind.NULLABLE, position, subtypes, false)
            when ASTNode.GENERIC_TYPE(position, base, args):
                def subtypes := Array<Type>()
                def name := MutableString(base)
                name.append("<")
                var separator := ""
                for arg in args {
                    def subtype := convertType(arg)
                    subtypes.add(subtype)
                    name.append(separator)
                    name.append(subtype.name)
                    separator := ", "
                }
                name.append(">")
                return Type(name.finish(), Type.Kind.GENERIC, position, subtypes, false)
            otherwise:
                assert false, "unsupported type \{type}"
        }
    }

    method convertAnnotations(a:ImmutableArray<ASTNode>):Annotations {
        var flags := 0
        for c in a {
            match c {
                when ASTNode.ANNOTATION(position, text):
                    match text {
                        when "@private":    flags ||= Annotations.Flag.PRIVATE
                        when "@protected":  flags ||= Annotations.Flag.PROTECTED
                        when "@package":    flags ||= Annotations.Flag.PACKAGE
                        when "@class":      flags ||= Annotations.Flag.CLASS
                        when "@override":   flags ||= Annotations.Flag.OVERRIDE
                        when "@external":   flags ||= Annotations.Flag.EXTERNAL
                        when "@implicit":   flags ||= Annotations.Flag.IMPLICIT
                        when "@final":      flags ||= Annotations.Flag.FINAL
                        when "@abstract":   flags ||= Annotations.Flag.ABSTRACT
                        when "@inline":     flags ||= Annotations.Flag.INLINE
                        when "@specialize": flags ||= Annotations.Flag.SPECIALIZE
                        when "@weak":       flags ||= Annotations.Flag.WEAK
                        otherwise:
                            compiler.error(position, "unrecognized annotation '\{text}'")
                    }
                otherwise:
                    assert false
            }
        }
        return Annotations(flags)
    }

    method scanFields(owner:ClassDecl, position:Position, rawDoccomment:ASTNode?,
                rawAnnotations:ImmutableArray<ASTNode>, varDecl:ASTNode) {
        def doccomment:String?
        -- FIXME should be able to match against null too
        if rawDoccomment = null {
            doccomment := null
        }
        else {
            match rawDoccomment {
                when ASTNode.STRING(position, text):
                    doccomment := text
                otherwise:
                    assert false
            }
        }
        def annotations := convertAnnotations(rawAnnotations)
        def fieldKind:FieldDecl.Kind
        match varDecl {
            when ASTNode.VAR(_, kind, decls):
                match kind {
                    when Variable.Kind.VAR:
                        fieldKind := FieldDecl.Kind.VAR
                    when Variable.Kind.DEF:
                        fieldKind := FieldDecl.Kind.DEF
                    when Variable.Kind.CONSTANT:
                        fieldKind := FieldDecl.Kind.CONSTANT
                        annotations.flags ||= Annotations.Flag.CLASS
                    when Variable.Kind.PROPERTY:
                        fieldKind := FieldDecl.Kind.PROPERTY
                }
                for decl in decls {
                    match decl {
                        when ASTNode.DECLARATION(declPosition, target, value):
                            def name:String
                            def type:Type
                            match target {
                                when ASTNode.IDENTIFIER(_, id):
                                    name := id
                                    type := Type.Void()
                                when ASTNode.TYPED_IDENTIFIER(_, id, idType):
                                    name := id
                                    type := convertType(idType)
                                otherwise:
                                    assert false
                            }
                            def field := FieldDecl(owner, declPosition, doccomment, annotations,
                                    fieldKind, name, type, value)
                            owner.symbolTable.add(field)
                            owner.fields.add(field)
                        otherwise:
                            assert false
                    }
                }
            otherwise:
                assert false
        }
    }

    function complexity(node:ASTNode):Int {
        -- FIXME provide a visitor in ASTNode when lambdas are in so I can eliminate this mess
        match node {
            when ASTNode.ASSERT(_, test, _):
                return complexity(test)
            when ASTNode.BINARY(_, left, _, right):
                return 1 + complexity(left) + complexity(right)
            when ASTNode.BIT:
                return 1
            when ASTNode.BLOCK(_, statements):
                var result := 0
                for s in statements {
                    result += complexity(s)
                }
                return result
            when ASTNode.BREAK:
                return 1
            when ASTNode.CALL(_, target, args):
                var result := complexity(target)
                for a in args {
                    result += complexity(a)
                }
                return result
            when ASTNode.CHOICE_FIELD_REFERENCE(_, base, _, _):
                return complexity(base)
            when ASTNode.CONTINUE:
                return 1
            when ASTNode.DECLARATION(_, _, value):
                if value = null {
                    return 0
                }
                return complexity(value)
            when ASTNode.DO(_, _, statements, test):
                var result := complexity(test)
                for s in statements {
                    result += complexity(s)
                }
                return result
            when ASTNode.DOT(_, base, _):
                return complexity(base)
            when ASTNode.FOR(_, _, _, list, statements):
                var result := complexity(list)
                for s in statements {
                    result += complexity(s)
                }
                return result
            when ASTNode.GENERIC_TYPE:
                return 0
            when ASTNode.IDENTIFIER:
                return 1
            when ASTNode.IF(_, test, ifTrue, ifFalse):
                var result := complexity(test)
                for s in ifTrue {
                    result += complexity(s)
                }
                if ifFalse != null {
                    result += complexity(ifFalse)
                }
                return result
            when ASTNode.INT:
                return 1
            when ASTNode.LOOP(_, _, statements):
                var result := 0
                for s in statements {
                    result += complexity(s)
                }
                return result
            when ASTNode.MATCH(_, value, whens, other):
                var result := complexity(value)
                for w in whens {
                    result += complexity(w)
                }
                if other != null {
                    for s in other {
                        result += complexity(s)
                    }
                }
                return result
            when ASTNode.NULL:
                return 1
            when ASTNode.NULLABLE_TYPE:
                return 0
            when ASTNode.PREFIX(_, _, base):
                return 1 + complexity(base)
            when ASTNode.RANGE:
                return 1
            when ASTNode.REAL:
                return 1
            when ASTNode.RETURN(_, value):
                if value = null {
                    return 0
                }
                return complexity(value)
            when ASTNode.SELF:
                return 1
            when ASTNode.STRING:
                return 1
            when ASTNode.SUPER:
                return 1
            when ASTNode.TYPE:
                return 0
            when ASTNode.VAR(_, _, decls):
                var result := 0
                for decl in decls {
                    result += complexity(decl)
                }
                return result
            when ASTNode.WHEN(_, tests, statements):
                var result := 0
                for test in tests {
                    result += complexity(test)
                }
                for s in statements {
                    result += complexity(s)
                }
                return result
            when ASTNode.WHILE(_, _, test, statements):
                var result := complexity(test)
                for s in statements {
                    result += complexity(s)
                }
                return result
            otherwise:
                assert false, "unsupported node: \{node}"
        }
    }

    function shouldInline(annotations:Annotations, statements:ImmutableArray<ASTNode>):Bit {
        if compiler.settings.optimizationLevel > 0 & !annotations.isInline() &
                annotations.isFinal() {
            var c := 0
            for s in statements {
                c += complexity(s)
                if c > INLINE_THRESHOLD {
                    return false
                }
            }
            return true
        }
        return false
    }

    method scanMethod(owner:ClassDecl, position:Position, rawDoccomment:ASTNode?,
            rawAnnotations:ImmutableArray<ASTNode>, kind:MethodDecl.Kind, name:String,
            rawParameters:ImmutableArray<ASTNode>, rawReturnType:ASTNode?,
            statements:ImmutableArray<ASTNode>?):MethodDecl? {
        def doccomment:String?
        -- FIXME should be able to match against null too
        if rawDoccomment = null {
            doccomment := null
        }
        else {
            match rawDoccomment {
                when ASTNode.STRING(position, text):
                    doccomment := text
                otherwise:
                    assert false
            }
        }
        def annotations := convertAnnotations(rawAnnotations)
        if kind != MethodDecl.Kind.INIT & owner.annotations.isFinal() | annotations.isPrivate() {
            annotations.flags ||= Annotations.Flag.FINAL
        }
        def parameters := Array<MethodDecl.Parameter>()
        for p in rawParameters {
            match p {
                when ASTNode.PARAMETER(_, name, type):
                    parameters.add(MethodDecl.Parameter(name, convertType(type)))
                otherwise:
                    assert false
            }
        }
        def returnType:Type
        if rawReturnType != null{
            returnType := convertType(rawReturnType)
        }
        else {
            returnType := Type.Void()
        }
        if kind = MethodDecl.Kind.FUNCTION & returnType = Type.Void() {
            compiler.error(position, "functions must have a return type")
        }
        if statements != null & shouldInline(annotations, statements) {
            annotations.flags ||= Annotations.Flag.INLINE
        }
        if statements = null {
            if owner.classKind = ClassDecl.Kind.INTERFACE {
                annotations.flags ||= Annotations.Flag.ABSTRACT
            }
            else if annotations.flags || Annotations.Flag.ABSTRACT = 0 {
                compiler.error(position, "expected non-abstract method '\{name}' to have a body")
            }
        }
        return MethodDecl(owner, position, doccomment, annotations, kind, name, parameters,
                returnType, statements)
    }

    method scanClassChild(cl:ClassDecl, node:ASTNode) {
        match node {
            when ASTNode.FIELD(position, dc, annotations, varDecl):
                scanFields(cl, position, dc, annotations, varDecl)
            when ASTNode.METHOD(position, dc, annotations, kind, name, parameters, rawReturnType,
                    statements):
                def m := scanMethod(cl, position, dc, annotations, kind, name, parameters,
                        rawReturnType, statements)
                if m != null {
                    cl.symbolTable.add(m)
                    cl.methods.add(m)
                }
            when ASTNode.CLASS(position, dc, annotations, kind, name, generics, supertypes,
                    members):
                def inner := scanClass(cl.source, cl.aliases, cl.name, position, dc, annotations,
                        kind, name, generics, supertypes, members)
                if inner != null {
                    inner.owner := cl
                    cl.classes.add(inner)
                    assert inner.name.startsWith(cl.name + ".")
                    cl.symbolTable.add(Alias(inner.name[cl.name.length() + 1..], inner.name,
                            Position()))
                    inner.symbolTable.add(Alias(cl.simpleName(), cl.name, Position()))
                }
            when ASTNode.CHOICE_ENTRY(position, dc, name, fields):
                scanChoiceEntry(cl, position, dc, name, fields)
            otherwise:
                assert false, "unsupported class child: \{node}"
        }
    }

    method scanChoiceEntry(cl:ClassDecl, position:Position, rawDoccomment:ASTNode?, name:String,
            rawFields:ImmutableArray<ASTNode>?) {
        def doccomment:String?
        -- FIXME should be able to match against null too
        if rawDoccomment = null {
            doccomment := null
        }
        else {
            match rawDoccomment {
                when ASTNode.STRING(position, text):
                    doccomment := text
                otherwise:
                    assert false
            }
        }
        def fields := Array<Type>()
        for t in rawFields {
            fields.add(convertType(t))
        }
        def entry := ChoiceEntry(cl, position, name, doccomment, cl.choiceEntries.get_count(),
                fields)
        cl.choiceEntries.add(entry)
        cl.symbolTable.add(entry)
        var found := false
        outer: for m in cl.methods {
            assert m.methodKind = MethodDecl.Kind.INIT
            if m.parameters.get_count() != fields.get_count() + 1 {
                continue
            }
            assert m.parameters[0].type = Type.Int64()
            for i in 0 .. fields.get_count() {
                if fields[i] != m.parameters[i + 1].type {
                    continue outer
                }
            }
            entry.initMethod := m
            found := true
            break
        }
        if !found {
            -- need a synthetic init for this particular combination of parameters
            def parameters := Array<MethodDecl.Parameter>()
            parameters.add(MethodDecl.Parameter("rv", Type.Int64()))
            def statements := Array<ASTNode>()
            statements.add(ASTNode.BINARY(cl.position,
                    ASTNode.IDENTIFIER(cl.position, ClassDecl.RAW_VALUE_NAME),
                    Token.Kind.ASSIGNMENT,
                    ASTNode.IDENTIFIER(cl.position, "rv")))
            for i in 0 .. fields.get_count() {
                parameters.add(MethodDecl.Parameter("f\{i}", fields[i]))
                statements.add(ASTNode.BINARY(cl.position,
                        ASTNode.CHOICE_FIELD_REFERENCE(cl.position,
                            ASTNode.SELF(cl.position),
                            entry,
                            i),
                        Token.Kind.ASSIGNMENT,
                        ASTNode.IDENTIFIER(cl.position, "f\{i}")))
            }
            def synthetic := MethodDecl(cl, cl.position, null, Annotations(), MethodDecl.Kind.INIT,
                    "init", parameters, Type.Void(), statements.finish())
            entry.initMethod := synthetic
            cl.methods.add(synthetic)
            cl.symbolTable.add(synthetic)
        }
    }

    method scanClass(source:File, aliases:MapView<String, String>, contextName:String,
            position:Position, rawDoccomment:ASTNode?, rawAnnotations:ImmutableArray<ASTNode>,
            kind:ClassDecl.Kind, name:String, generics:ImmutableArray<ASTNode>?,
            rawSupertypes:ImmutableArray<ASTNode>?, members:ImmutableArray<ASTNode>):ClassDecl? {
        def fullName:String
        if contextName != "" {
            fullName := "\{contextName}.\{name}"
        }
        else {
            fullName := name
        }
        def doccomment:String?
        -- FIXME should be able to match against null too
        if rawDoccomment = null {
            doccomment := null
        }
        else {
            match rawDoccomment {
                when ASTNode.STRING(position, text):
                    doccomment := text
                otherwise:
                    assert false
            }
        }
        def annotations := convertAnnotations(rawAnnotations)
        def parameters := Array<ClassDecl.GenericParameter>()
        if generics != null {
            for p in generics {
                def name:String
                def bound:Type
                match p {
                    when ASTNode.IDENTIFIER(_, id):
                        name := id
                        bound := Type.Any()
                    when ASTNode.TYPED_IDENTIFIER(_, id, type):
                        name := id
                        bound := convertType(type)
                    otherwise:
                        assert false
                }
                parameters.add(ClassDecl.GenericParameter(p.position(), fullName, name, bound))
            }
            if kind = ClassDecl.Kind.CHOICE {
                compiler.error(position, "choices may not have generic parameters")
            }
        }
        def supertypes := Array<Type>()
        if rawSupertypes != null {
            if kind = ClassDecl.Kind.CHOICE {
                compiler.error(position, "choices may not specify supertypes")
            }
            for s in rawSupertypes {
                supertypes.add(convertType(s))
            }
        }
        def result := ClassDecl(source, position, aliases, doccomment, annotations, kind, fullName,
                supertypes, parameters, compiler.root)
        compiler.currentClass.push(result)
        if kind = ClassDecl.Kind.CHOICE {
            def rawValue := FieldDecl(result, result.position, null, Annotations(),
                        FieldDecl.Kind.DEF, ClassDecl.RAW_VALUE_NAME, Type.Int64(), null)
            result.fields.add(rawValue)
            result.symbolTable.add(rawValue)
            def data := FieldDecl(result, result.position, null, Annotations(), FieldDecl.Kind.DEF,
                        ClassDecl.CHOICE_DATA_NAME, Type.ChoiceData(), null)
            result.fields.add(data)
            result.symbolTable.add(data)
        }
        for m in members {
            match m {
                when ASTNode.METHOD(mPosition, _, _, methodKind, _,  _, _, _):
                    if methodKind = MethodDecl.Kind.INIT {
                        match kind {
                            when ClassDecl.Kind.CLASS: -- do nothing
                            when ClassDecl.Kind.INTERFACE:
                                compiler.error(mPosition, "interfaces may not have 'init' methods")
                            when ClassDecl.Kind.CHOICE:
                                compiler.error(mPosition, "choices may not have 'init' methods")
                        }
                    }
                otherwise:
                    -- do nothing
            }
            scanClassChild(result, m)
        }
        var foundInit := false
        var foundCleanup := false
        for m in result.methods {
            if m.methodKind = MethodDecl.Kind.INIT {
                foundInit := true
            }
            if m.name = "cleanup" & m.parameters.get_count() = 0 {
                foundCleanup := true
                if kind = ClassDecl.Kind.CHOICE {
                    compiler.error(position, "choice cleanup method cannot be overridden")
                }
            }
        }
        if !foundInit & kind = ClassDecl.Kind.CLASS & result.name != "panda.unsafe.Pointer" {
            def defaultInit := MethodDecl(result, position, null, Annotations(),
                    MethodDecl.Kind.INIT, "init", Array<MethodDecl.Parameter>(), Type.Void(),
                    ImmutableArray<ASTNode>())
            result.methods.add(defaultInit)
            result.symbolTable.add(defaultInit)
        }
        if !foundCleanup & (kind = ClassDecl.Kind.CLASS | kind = ClassDecl.Kind.CHOICE) &
                result.name != "panda.unsafe.Pointer" {
            def defaultCleanup := MethodDecl(result, position, null,
                    Annotations(Annotations.Flag.OVERRIDE), MethodDecl.Kind.METHOD, "cleanup",
                    Array<MethodDecl.Parameter>(), Type.Void(), ImmutableArray<ASTNode>())
            result.methods.add(defaultCleanup)
            result.symbolTable.add(defaultCleanup)
        }
        if kind = ClassDecl.Kind.CHOICE {
            var haveFields := false
            for e in result.choiceEntries {
                if e.fields.get_count() > 0 {
                    haveFields := true
                    break
                }
            }
            if !haveFields {
                result.rawSuper := Type.Value()
            }
        }
        compiler.currentClass.pop()
        return result
    }

    method addClass(cl:ClassDecl, arr:Array<ClassDecl>) {
        arr.add(cl)
        for inner in cl.classes {
            addClass(inner, arr)
        }
    }

    method scan(source:File, file:ASTNode):ListView<ClassDecl> {
        match file {
            when ASTNode.FILE(entries):
                def result := Array<ClassDecl>()
                var currentPackage := "anonymous"
                def aliases := HashMap<String, String>()
                for e in entries {
                    match e {
                        when ASTNode.PACKAGE(_, name):
                            currentPackage := name
                        when ASTNode.USES(_, fullName):
                            def idx := fullName.lastIndexOf(".")
                            def alias:String
                            if idx != null {
                                alias := fullName[fullName.next(idx)..]
                            }
                            else {
                                alias := fullName
                            }
                            aliases[alias] := fullName
                        when ASTNode.CLASS(position, dc, annotations, kind, name, generics,
                                supertypes, members):
                            def cl := scanClass(source, aliases, currentPackage, position, dc,
                                    annotations, kind, name, generics, supertypes, members)
                            if cl != null {
                                addClass(cl, result)
                            }
                        otherwise:
                            assert false, "unsupported: \{e}"
                    }
                }
                return result
            otherwise:
                assert false
        }
    }
}