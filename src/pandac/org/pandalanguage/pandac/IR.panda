package org.pandalanguage.pandac

uses org.pandalanguage.pandac.parser.Token

class IR {
    choice Statement {
        ============================================================================================
        Perform a binary operation on two values. Arithmetic, shift, and comparison operations
        are supported on all builtin integer types. Arithmetic and comparison are supported on
        builtin float types. Class types support the IDENTITY and NIDENTITY operations. The left and
        right types must match on all comparisons other than IDENTITY and NIDENTITY.
        ============================================================================================
        BINARY(Value, Token.Kind, Value, Type)

        ============================================================================================
        Unconditionally branch to the given block.
        ============================================================================================
        BRANCH(Block.ID)

        ============================================================================================
        Casts a value of one type to another type. This handles bitcasting, truncating / extending,
        wrapping, unwrapping, and nullable->non-nullable value / vice versa as needed.
        ============================================================================================
        CAST(Value, Type)

        COMMENT(String)

        GET_CHOICE_FIELD_POINTER(Value, ChoiceCase, Int)

        ============================================================================================
        Conditionally branch to the first block if true, the second block if false.
        ============================================================================================
        CONDITIONAL_BRANCH(Value, Block.ID, Block.ID)

        ============================================================================================
        Constructs a new object instance. The object will have an initialized class pointer and a
        refcount of 1, with all other fields initialized to 0. `init` calls appear separately as
        `STATIC_CALL` statements. `CONSTRUCT` is used only for non-`Value` objects; `Value`s are
        directly returned by their `init` methods (non-`Value` `init` methods instead return void).
        ============================================================================================
        CONSTRUCT(ClassDecl)

        ============================================================================================
        Dynamically calls a method reference. `args` is the actual, IR-level arguments, meaning that
        `self` (if any) appears explicitly as `args[0]`.
        ============================================================================================
        DYNAMIC_CALL(Value -* method *-, ImmutableArray<Value> -* args *-)

        ============================================================================================
        Given a value, returns the value of a field within the value.
        ============================================================================================
        EXTRACT_FIELD(Value, FieldDecl)

        ============================================================================================
        Given a pointer to an object, returns a pointer to a field within the object.
        ============================================================================================
        GET_FIELD_POINTER(Value, FieldDecl)

        ============================================================================================
        Gets a reference to a virtual method from an object, by its vtable index.
        ============================================================================================
        GET_VIRTUAL_METHOD(Value, Int, Type)

        ============================================================================================
        Gets a reference to an interface method from an object, by its class and itable index.
        ============================================================================================
        GET_INTERFACE_METHOD(Value, ClassDecl, Int, Type)

        ============================================================================================
        Loads the value of the given pointer.
        ============================================================================================
        LOAD(Value)

        ============================================================================================
        Negates a number.
        ============================================================================================
        NEGATE(Value)

        ============================================================================================
        Bitwise inverts a number or bit.
        ============================================================================================
        NOT(Value)

        ============================================================================================
        Allocates memory and returns a raw pointer to it. Only POINTER_ operations are legal on a
        raw pointer.
        ============================================================================================
        POINTER_ALLOC(Value -* count *-, Type)

        ============================================================================================
        Deallocates a pointer
        ============================================================================================
        POINTER_DESTROY(Value -* pointer *-)

        ============================================================================================
        Dereferences a raw pointer.
        ============================================================================================
        POINTER_GET(Value)

        ============================================================================================
        Reads from `pointer + index * sizeof(type)`.
        ============================================================================================
        POINTER_GET_INDEX(Value -* pointer *-, Value -* index *-)

        ============================================================================================
        Returns `pointer + index * sizeof(type)`.
        ============================================================================================
        POINTER_OFFSET(Value -* pointer *-, Value -* index *-)

        ============================================================================================
        Equivalent to the C realloc function (other than additionally requiring the old size).
        ============================================================================================
        POINTER_REALLOC(Value -* pointer *-, Value -* oldSize *-, Value -* newSize *-)

        ============================================================================================
        Writes to a raw pointer.
        ============================================================================================
        POINTER_SET(Value -* value *-, Value -* pointer *-)

        ============================================================================================
        Writes to `pointer + index * sizeof(type)`.
        ============================================================================================
        POINTER_SET_INDEX(Value -* value *-, Value -* pointer *-, Value -* index *-)

        ============================================================================================
        A `return` statement.
        ============================================================================================
        RETURN(IR.Value?)

        ============================================================================================
        A static (non-virtual, non-dynamic) call to a method. `args` is the actual, IR-level
        arguments, meaning that `self` (if any) appears explicitly as `args[0]`.
        ============================================================================================
        STATIC_CALL(MethodDecl, ImmutableArray<Value> -* args *-)

        ============================================================================================
        Writes a value to the target of the given pointer.
        ============================================================================================
        STORE(Value -* value *-, Value -* dest pointer *-)

        UNREACHABLE

        class ID : panda.core.Value, Key<ID> {
            def value:Int

            init(value:Int) {
                self.value := value
            }

            @override
            function hash():Int {
                return value
            }

            @override
            function =(other:ID):Bit {
                return value = other.value
            }

            @override
            function convert():String {
                return "$\{value}"
            }
        }

        @override
        function convert():String {
            match self {
                when BINARY(left, op, right, type):
                    return "binary \{left}, \{op}, \{right}, \{type}"
                when BRANCH(id):
                    return "branch \{id}"
                when CAST(value, type):
                    return "cast \{value}->\{type}"
                when COMMENT(text):
                    return "-- \{text}"
                when CONDITIONAL_BRANCH(test, ifTrue, ifFalse):
                    return "branch \{test}, \{ifTrue}, \{ifFalse}"
                when CONSTRUCT(cl):
                    return "construct \{cl.name}"
                when DYNAMIC_CALL(m, args):
                    return "dynamic_call \{m}(\{args.join(", ")})"
                when EXTRACT_FIELD(value, field):
                    return "load_field \{value}, \{field.owner.name}.\{field.name}"
                when GET_CHOICE_FIELD_POINTER(target, cc, index):
                    return "get_choice_field_pointer \{target}, \{cc.name}, \{index}"
                when GET_FIELD_POINTER(ptr, field):
                    return "get_field_pointer \{ptr}, \{field.owner.name}.\{field.name}"
                when GET_INTERFACE_METHOD(value, cl, id, type):
                    return "get_interface_method \{value}, \{cl.name}, \{id}, \{type}"
                when GET_VIRTUAL_METHOD(value, id, type):
                    return "get_virtual_method \{value}, \{id}, \{type}"
                when LOAD(ptr):
                    return "load \{ptr}"
                when NEGATE(value):
                    return "negate \{value}"
                when NOT(value):
                    return "not \{value}"
                when POINTER_ALLOC(count, type):
                    return "pointer_alloc \{count}, \{type}"
                when POINTER_DESTROY(ptr):
                    return "pointer_destroy \{ptr}"
                when POINTER_GET(ptr):
                    return "pointer_get \{ptr}"
                when POINTER_GET_INDEX(ptr, index):
                    return "pointer_get_index \{ptr}, \{index}"
                when POINTER_OFFSET(ptr, index):
                    return "pointer_offset \{ptr}, \{index}"
                when POINTER_REALLOC(ptr, oldSize, newSize):
                    return "pointer_realloc \{ptr}, \{oldSize}, \{newSize}"
                when POINTER_SET(value, ptr):
                    return "pointer_set \{value}, \{ptr}"
                when POINTER_SET_INDEX(value, ptr, index):
                    return "pointer_set_index \{value}, \{ptr}, \{index}"
                when RETURN(value):
                    if value !== null {
                        return "return \{value}"
                    }
                    return "return"
                when STATIC_CALL(m, args):
                    return "static_call \{m.declaration()}(\{args.join(", ")})"
                when STORE(value, ptr):
                    return "store \{value}, \{ptr}"
                when UNREACHABLE:
                    return "unreachable"
            }
        }
    }

    class Block {
        class ID : panda.core.Value, Equatable<ID> {
            def value:Int

            init(value:Int) {
                self.value := value
            }

            @override
            function =(other:ID):Bit {
                return value = other.value
            }

            @override
            function convert():String {
                return "block\{value}"
            }
        }

        def id:ID

        def comment:String

        def ids := Array<Statement.ID>()

        def statements := Array<Statement>()

        init(id:ID, comment:String) {
            self.id := id
            self.comment := comment
        }

        @override
        function convert():String {
            def result := MutableString("\{id}: -- \{comment}\n")
            for i in 0 .. statements.count {
                result.append(ids[i])
                result.append(": ")
                result.append(statements[i])
                result.append("\n")
            }
            return result.finish()
        }
    }

    choice Value {
        BIT(Bit)
        INT(UInt64, Type)
        -- value is a *pointer to* the given type
        LOCAL(Int, Type)
        METHOD_POINTER(MethodDecl, Type)
        NULL(Type)
        PARAMETER(Int, Type)
        REAL(Real64, Type)
        REF(Statement.ID, Type)
        STRING(String)

        -- intermediate values; these never show up in finished IR sent to the code generator
        METHOD(Value? -* target *-, MethodDecl)
        METHODS(Value? -* target *-, ImmutableArray<MethodDecl>)
        SUPER(Type)
        TYPE(Type)

        function type():Type {
            match self {
                when BIT:
                    return Type.BuiltinBit()
                when INT(_, type):
                    return type
                when LOCAL(_, type):
                    return type -- note that the actual IR type is a pointer to this type
                when METHOD_POINTER(_, type):
                    return type
                when NULL(type):
                    return type
                when PARAMETER(_, type):
                    return type
                when REAL(_, type):
                    return type
                when REF(_, type):
                    return type
                when STRING:
                    return Type.StringType()

                when METHOD(_, m):
                    return m.type()
                when METHODS:
                    return Type.Invalid()
                when SUPER(type):
                    return type
                when TYPE(type):
                    return Type.ClassLiteral(type)
            }
        }

        @override
        function convert():String {
            match self {
                when BIT(value):
                    return value.convert()
                when INT(value, _):
                    return value.convert()
                when LOCAL(slot, type):
                    return "LOCAL(\{slot}:\{type}*)"
                when NULL(type):
                    return "NULL(\{type})"
                when METHOD_POINTER(m, _):
                    return "METHOD_POINTER(\{m.declaration()})"
                when PARAMETER(index, type):
                    return "PARAMETER(\{index}:\{type})"
                when REAL(value, _):
                    return value.convert()
                when REF(id, type):
                    return "REF(\{id}:\{type})"
                when STRING(s):
                    return s.format("panda")

                when METHOD(target, m):
                    if target !== null {
                        return "METHOD(\{target}, \{m.declaration()})"
                    }
                    return m.declaration()
                when METHODS(target, m):
                    if target !== null {
                        return "METHODS(\{target}, \{m})"
                    }
                    return "METHODS(<null>, \{m})"
                when SUPER(type):
                    return "SUPER(\{type})"
                when TYPE(type):
                    return type.convert()
            }
        }
    }

    def locals := Array<Type>()

    def blocks := Array<Block>()

    @private
    var currentStatementId := -1

    @private
    def currentBlock:Block

    init() {
        newBlock("start")
        currentBlock := blocks[0]
    }

    ================================================================================================
    Adds a new statement to the end of the current block and returns its id.
    ================================================================================================
    @pre(!currentBlockFinished())
    method add(s:Statement):Statement.ID {
        currentStatementId += 1
        def result := Statement.ID(currentStatementId)
        currentBlock.ids.add(result)
        currentBlock.statements.add(s)
        return result
    }

    ================================================================================================
    Creates (but does not make current!) a new block and returns its id.
    ================================================================================================
    method newBlock(comment:String):Block.ID {
        def result := Block.ID(blocks.count)
        blocks.add(Block(result, comment))
        return result
    }

    method setCurrentBlock(id:Block.ID) {
        currentBlock := blocks[id.value]
    }

    function currentBlockFinished():Bit {
        if currentBlock.statements.count = 0 {
            return false
        }
        match currentBlock.statements[currentBlock.statements.count - 1] {
            when Statement.BRANCH, Statement.CONDITIONAL_BRANCH, Statement.RETURN:
                return true
            otherwise:
                return false
        }
    }

    @override
    function convert():String {
        def result := MutableString()
        for i in 0 .. locals.count {
            result.append("local\{i}: \{locals[i]}\n")
        }
        result.append(blocks.join("\n"))
        return result.finish()
    }
}