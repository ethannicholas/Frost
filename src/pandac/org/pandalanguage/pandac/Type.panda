package org.pandalanguage.pandac

class Type : Symbol (Equatable<Type>) {
    class Kind {
        constant CLASS := 10
        constant NULLABLE := 11
        constant BUILTIN_INT := 12
        constant BUILTIN_UINT := 13
        constant VOID := 14
        constant INT_LITERAL := 15
        constant INVALID := 16
        constant UNRESOLVED := 17
        constant BIT_LITERAL := 18
        constant BUILTIN_BIT := 19
        constant BUILTIN_FLOAT := 20
        constant GENERIC := 21
        constant GENERIC_PARAMETER := 22
    }

    def resolved:Bit

    def typeKind:Int

    def subtypes:ImmutableArray<Type>

    init(name:String, typeKind:Int, offset:Int) {
        init(name, typeKind, offset, false)
    }

    init(name:String, typeKind:Int, offset:Int, resolved:Bit) {
        assert !name.endsWith("?")
        self.typeKind := typeKind
        self.offset := offset
        self.resolved := resolved
        self.subtypes := ImmutableArray<Type>()
        super.init(Symbol.Kind.TYPE, offset, name)
    }

    init(name:String, typeKind:Int, offset:Int, subtypes:ListView<Type>, resolved:Bit) {
        assert (typeKind = Type.Kind.NULLABLE) = name.endsWith("?")
        self.typeKind := typeKind
        self.offset := offset
        self.resolved := resolved
        self.subtypes := ImmutableArray<Type>(subtypes)
        super.init(Symbol.Kind.TYPE, offset, name)
    }

    init(subtypes:ListView<Type>) {
        self.typeKind := Kind.UNRESOLVED
        self.subtypes := ImmutableArray<Type>(subtypes)
        def name := MutableString("unresolved<")
        var separator := ""
        self.resolved := true
        for t in subtypes {
            name.append(separator)
            name.append(t)
            separator := "|"
            self.resolved &= t.resolved
        }
        name.append(">")
        super.init(Symbol.Kind.TYPE, offset, name.convert())
    }

    @override
    function =(other:Type):Bit {
        return name = other.name
    }

    @override
    function !=(other:Type):Bit {
        return name != other.name
    }

    @class
    method Void():Type {
        return Type("void", Kind.VOID, -1, true)
    }

    @class
    method Object():Type {
        return Type("panda.core.Object", Kind.CLASS, -1, true)
    }

    @class
    method Any():Type {
        def subtypes := Array<Type>()
        subtypes.add(Object())
        return Type("panda.core.Object?", Kind.NULLABLE, -1, subtypes, true)
    }

    @class
    method Class():Type {
        return Type("panda.core.Class", Kind.CLASS, -1, true)
    }

    @class
    method Value():Type {
        return Type("panda.core.Value", Kind.CLASS, -1, true)
    }

    @class
    method Int64():Type {
        return Type("panda.core.Int64", Kind.CLASS, -1, true)
    }

    @class
    method Bit():Type {
        return Type("panda.core.Bit", Kind.CLASS, -1, true)
    }

    @class
    method IntLiteral():Type {
        return Type("$int_literal", Kind.INT_LITERAL, -1, true)
    }

    @class
    method BitLiteral():Type {
        return Type("$bit_literal", Kind.BIT_LITERAL, -1, true)
    }

    @class
    method BuiltinBit():Type {
        return Type("builtin_bit", Type.Kind.BUILTIN_BIT, -1, true)
    }

    @class
    method Invalid():Type {
        return Type("<invalid>", Kind.INVALID, -1, true)
    }

    function isNumber():Bit {
        return name.startsWith("panda.core.Int") | name.startsWith("panda.core.UInt")
    }

    function isBuiltinNumber():Bit {
        return typeKind = Kind.BUILTIN_INT | typeKind = Kind.BUILTIN_UINT
    }

    function isClass():Bit {
        return !isBuiltinNumber()
    }

    function isPointer():Bit {
        return name.startsWith("panda.unsafe.Pointer")
    }

    @override
    function convert():String {
        return name
    }
}