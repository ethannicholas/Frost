package org.pandalanguage.pandac

@final
class Type : Symbol, Key<Type> {
    class Kind {
        constant CLASS := 10
        constant NULLABLE := 11
        constant BUILTIN_INT := 12
        constant BUILTIN_UINT := 13
        constant VOID := 14
        constant INT_LITERAL := 15
        constant INVALID := 16
        constant UNRESOLVED := 17
        constant BIT_LITERAL := 18
        constant BUILTIN_BIT := 19
        constant BUILTIN_FLOAT := 20
        constant GENERIC := 21
        constant GENERIC_PARAMETER := 22
        constant NULL := 23
        constant FUNCTION := 24
        constant METHOD := 25
    }

    def resolved:Bit

    def typeKind:Int

    def subtypes:Array<Type>

    def test:ClassDecl

    def parameter:ClassDecl.GenericParameter? := null

    init(name:String, typeKind:Int, position:Position) {
        init(name, typeKind, position, false)
    }

    init(name:String, typeKind:Int, position:Position, resolved:Bit) {
        assert !name.endsWith("?")
        self.typeKind := typeKind
        self.position := position
        self.resolved := resolved
        self.subtypes := Array<Type>()
        super.init(Symbol.Kind.TYPE, position, name)
    }

    init(name:String, typeKind:Int, size:Int) {
        assert !name.endsWith("?")
        self.typeKind := typeKind
        self.position := Position(size, size)
        self.resolved := true
        self.subtypes := Array<Type>()
        super.init(Symbol.Kind.TYPE, position, name)
    }

    init(name:String, typeKind:Int, position:Position, subtypes:ListView<Type>, resolved:Bit) {
        assert (typeKind = Kind.NULLABLE) = name.endsWith("?"),
                "invalid type: name=\{name}, nullable=\{typeKind = Kind.NULLABLE}"
        assert (typeKind = Kind.GENERIC) = name.endsWith(">"),
                "invalid type: name=\{name}, generic=\{typeKind = Kind.GENERIC}"
        assert typeKind != Kind.GENERIC_PARAMETER
        self.typeKind := typeKind
        self.position := position
        self.resolved := resolved
        self.subtypes := Array<Type>(subtypes)
        super.init(Symbol.Kind.TYPE, position, name)
    }

    init(subtypes:ListView<Type>) {
        self.typeKind := Kind.UNRESOLVED
        self.subtypes := Array<Type>(subtypes)
        def name := MutableString("unresolved<")
        var separator := ""
        self.resolved := true
        for t in subtypes {
            name.append(separator)
            name.append(t)
            separator := "|"
            self.resolved &= t.resolved
        }
        name.append(">")
        super.init(Symbol.Kind.TYPE, position, name.finish())
    }

    init(param:ClassDecl.GenericParameter) {
        self.name := "\{param.owner}.\{param.name}"
        self.typeKind := Kind.GENERIC_PARAMETER
        self.parameter := param
        self.resolved := true
    }

    function size():Int {
        assert typeKind = Kind.BUILTIN_INT | typeKind = Kind.BUILTIN_UINT, "not a number: \{self}"
        return position.line
    }

    @override
    function =(other:Type):Bit {
        return name = other.name
    }

    @override
    function !=(other:Type):Bit {
        return name != other.name
    }

    @class
    method Void():Type {
        return Type("void", Kind.VOID, Position(), true)
    }

    @class
    method Null():Type {
        return Type("null", Kind.NULL, Position(), true)
    }

    @class
    method Object():Type {
        return Type("panda.core.Object", Kind.CLASS, Position(), true)
    }

    @class
    method Any():Type {
        def subtypes := Array<Type>()
        subtypes.add(Object())
        return Type("panda.core.Object?", Kind.NULLABLE, Position(), subtypes, true)
    }

    @class
    method Class():Type {
        return Type("panda.core.Class", Kind.CLASS, Position(), true)
    }

    @class
    method Value():Type {
        return Type("panda.core.Value", Kind.CLASS, Position(), true)
    }

    @class
    method StringType():Type {
        return Type("panda.core.String", Kind.CLASS, Position(), true)
    }

    @class
    method Int64():Type {
        return Type("panda.core.Int64", Kind.CLASS, Position(), true)
    }

    @class
    method Bit():Type {
        return Type("panda.core.Bit", Kind.CLASS, Position(), true)
    }

    @class
    method IntLiteral():Type {
        return Type("$int_literal", Kind.INT_LITERAL, Position(), true)
    }

    @class
    method BitLiteral():Type {
        return Type("$bit_literal", Kind.BIT_LITERAL, Position(), true)
    }

    @class
    method BuiltinBit():Type {
        return Type("builtin_bit", Kind.BUILTIN_BIT, Position(), true)
    }

    @class
    method Iterator():Type {
        return Type("panda.collections.Iterator", Kind.CLASS, Position(), true)
    }

    @class
    method Iterable():Type {
        return Type("panda.collections.Iterable", Kind.CLASS, Position(), true)
    }

    @class
    method Panda():Type {
        return Type("panda.core.Panda", Kind.CLASS, Position(), true)
    }

    @class
    method RangeOf(t:Type):Type {
        def children := Array<Type>() -- FIXME literal
        children.add(Type(Compiler.RANGE_NAME, Kind.CLASS, Position(), true))
        children.add(t)
        return Type("\{Compiler.RANGE_NAME}<\{t}>", Kind.GENERIC, t.position, children, t.resolved)
    }

    @class
    method SteppedRangeOf(endPoint:Type, step:Type):Type {
        def children := Array<Type>() -- FIXME literal
        children.add(Type(Compiler.STEPPED_RANGE_NAME, Kind.CLASS, Position(), true))
        children.add(endPoint)
        children.add(step)
        return Type("\{Compiler.STEPPED_RANGE_NAME}<\{endPoint}, \{step}>", Kind.GENERIC,
                endPoint.position, children, endPoint.resolved & step.resolved)
    }

    @class
    method Invalid():Type {
        return Type("<invalid>", Kind.INVALID, Position(), true)
    }

    function isNumber():Bit {
        return name.startsWith("panda.core.Int") | name.startsWith("panda.core.UInt")
    }

    function isBuiltinNumber():Bit {
        return typeKind = Kind.BUILTIN_INT | typeKind = Kind.BUILTIN_UINT |
                typeKind = Kind.INT_LITERAL
    }

    function isClass():Bit {
        match typeKind {
            when Kind.CLASS, Kind.NULLABLE, Kind.GENERIC:
                return true
            otherwise:
                return false
        }
    }

    function isMethod():Bit {
        return typeKind = Kind.METHOD | typeKind = Kind.FUNCTION
    }

    function isPointer():Bit {
        return name.startsWith("panda.unsafe.Pointer")
    }

    function isRange():Bit {
        if typeKind = Kind.NULLABLE {
            return subtypes[0].isRange()
        }
        return typeKind = Kind.GENERIC & subtypes[0].name = Compiler.RANGE_NAME
    }

    function isSteppedRange():Bit {
        if typeKind = Kind.NULLABLE {
            return subtypes[0].isSteppedRange()
        }
        return typeKind = Kind.GENERIC & subtypes[0].name = Compiler.STEPPED_RANGE_NAME
    }

    function nullable():Type {
        if typeKind = Kind.NULLABLE {
            return self
        }
        def subtypes := Array<Type>()
        subtypes.add(self)
        return Type("\{name}?", Kind.NULLABLE, Position(), subtypes, true)
    }

    -- returns the narrowest type that can hold an instance of either type
    function union(other:Type):Type {
        if self = other {
            return self
        }
        if self = Null() {
            if other.typeKind = Kind.NULLABLE {
                return other
            }
            return other.nullable()
        }
        if other = Null() {
            if typeKind = Kind.NULLABLE {
                return self
            }
            return nullable()
        }
        if self = IntLiteral() & other.isNumber() {
            return other
        }
        if isNumber() & other = IntLiteral() {
            return self
        }
        if typeKind = Kind.NULLABLE {
            return subtypes[0].union(other).nullable()
        }
        if other.typeKind = Kind.NULLABLE {
            return union(other.subtypes[0]).nullable()
        }
        -- FIXME not implemented
        return Type.Any()
    }

    method remap(types:HashMap<String, Type>):Type {
        if types.get_count() = 0 {
            return self
        }
        match typeKind {
            when Kind.GENERIC_PARAMETER:
                def found := types[name]
                if found != null {
                    return found
                }
                return self
            when Kind.GENERIC:
                def remapped := Array<Type>()
                def name := MutableString(subtypes[0].name)
                name.append("<")
                var separator := ""
                for i in 0 .. subtypes.get_count() {
                    def child := subtypes[i].remap(types)
                    remapped.add(child)
                    if i > 0 {
                        name.append(separator)
                        name.append(child.name)
                        separator := ", "
                    }
                }
                name.append(">")
                return Type(name.finish(), Kind.GENERIC, position, remapped, resolved)
            when Kind.NULLABLE:
                return subtypes[0].remap(types).nullable()
            when Kind.METHOD, Kind.FUNCTION:
                def remapped := Array<Type>()
                def name := MutableString("(")
                var separator := ""
                assert subtypes.get_count() >= 1
                for i in 0 .. subtypes.get_count() - 1 {
                    def child := subtypes[i].remap(types)
                    name.append(separator)
                    name.append(child.name)
                    remapped.add(child)
                    separator := ", "
                }
                if typeKind = Kind.FUNCTION {
                    name.append(")=>(")
                }
                else {
                    name.append(")=&>(")
                }
                if subtypes[subtypes.get_count() - 1] != Type.Void() {
                    def child := subtypes[subtypes.get_count() - 1].remap(types)
                    name.append(child.name)
                    remapped.add(child)
                }
                else {
                    remapped.add(Type.Void())
                }
                name.append(")")
                return Type(name.finish(), typeKind, position, remapped, resolved)
            otherwise: return self
        }
    }

    @override
    function hash():Int {
        return name.hash()
    }

    @override
    function convert():String {
        return name
    }
}