package org.pandalanguage.pandac

@final
class Type : Symbol, Key<Type> {
    choice Kind {
        CLASS
        NULLABLE
        BUILTIN_INT
        BUILTIN_UINT
        VOID
        INT_LITERAL
        INVALID
        UNRESOLVED
        BIT_LITERAL
        BUILTIN_BIT
        BUILTIN_FLOAT
        GENERIC
        GENERIC_PARAMETER
        NULL
        FUNCTION
        METHOD
        IMMUTABLE_FUNCTION
        IMMUTABLE_METHOD
        REAL_LITERAL
    }

    def resolved:Bit

    def typeKind:Kind

    def subtypes:Array<Type>?

    property parameterCount:Int

    @weak
    def genericParameter:ClassDecl.GenericParameter?

    init(name:String, typeKind:Kind, position:Position) {
        init(name, typeKind, position, false)
    }

    init(name:String, typeKind:Kind, position:Position, resolved:Bit) {
        self.typeKind := typeKind
        self.position := position
        self.resolved := resolved
        self.subtypes := null
        super.init(Symbol.Kind.TYPE, position, name)
    }

    init(name:String, typeKind:Kind, size:Int) {
        assert !name.endsWith("?")
        self.typeKind := typeKind
        self.position := Position(size, size)
        self.resolved := true
        self.subtypes := null
        super.init(Symbol.Kind.TYPE, position, name)
    }

    init(name:String, typeKind:Kind, position:Position, subtypes:ListView<Type>, resolved:Bit) {
        assert (typeKind = Kind.NULLABLE) = name.endsWith("?"),
                "invalid type: name=\{name}, nullable=\{typeKind = Kind.NULLABLE}"
        assert (typeKind = Kind.GENERIC) = name.endsWith(">"),
                "invalid type: name=\{name}, generic=\{typeKind = Kind.GENERIC}"
        assert typeKind != Kind.GENERIC_PARAMETER
        self.typeKind := typeKind
        self.position := position
        self.resolved := resolved
        self.subtypes := Array<Type>(subtypes)
        super.init(Symbol.Kind.TYPE, position, name)
    }

    init(subtypes:ListView<Type>) {
        self.typeKind := Kind.UNRESOLVED
        self.subtypes := Array<Type>(subtypes)
        def name := MutableString("unresolved<")
        var separator := ""
        self.resolved := true
        for t in subtypes {
            name.append(separator)
            name.append(t)
            separator := "|"
            self.resolved &= t.resolved
        }
        name.append(">")
        super.init(Symbol.Kind.TYPE, position, name.finish())
    }

    init(param:ClassDecl.GenericParameter) {
        self.typeKind := Kind.GENERIC_PARAMETER
        self.genericParameter := param
        self.resolved := true
        self.subtypes := null
        super.init(Symbol.Kind.TYPE, position, "\{param.owner}.\{param.name}")
    }

    @class
    function generic(base:Type, arguments:ListView<Type>):Type {
        var resolved := base.resolved
        def name := MutableString()
        name.append(base.name)
        name.append("<")
        var separator := ""
        for a in arguments {
            resolved &= a.resolved
            name.append(separator)
            name.append(a.name)
            separator := ", "
        }
        name.append(">")
        def subtypes := Array<Type>()
        subtypes.add(base)
        subtypes.addAll(arguments)
        return Type(name.finish(), Kind.GENERIC, base.position, subtypes.finish(), resolved)
    }

    @class
    function methodType(position:Position, kind:Type.Kind, parameterTypes:ListView<Type>,
            returnType:Type):Type {
        var resolved := returnType.resolved
        def name := MutableString("(")
        def subtypes := Array<Type>()
        var separator := ""
        for p in parameterTypes {
            subtypes.add(p)
            resolved &= p.resolved
            name.append(separator)
            name.append(p.name)
            separator := ", "
        }
        match kind {
            when Kind.FUNCTION:
                name.append(")=>(")
            when Kind.METHOD:
                name.append(")=&>(")
            when Kind.IMMUTABLE_FUNCTION:
                name.append(")=>*(")
            when Kind.IMMUTABLE_METHOD:
                name.append(")=&>*(")
            otherwise:
                assert false
        }
        subtypes.add(returnType)
        if returnType != Type.Void() {
            name.append(returnType.name)
        }
        name.append(")")
        return Type(name.finish(), kind, position, subtypes.finish(), resolved)
    }

    function size():Int {
        assert typeKind = Kind.BUILTIN_INT | typeKind = Kind.BUILTIN_UINT |
                typeKind = Kind.BUILTIN_FLOAT, "not a number: \{self}"
        return position.line
    }

    @override
    function =(other:Type):Bit {
        return name = other.name
    }

    @override
    function !=(other:Type):Bit {
        return name != other.name
    }

    @class
    method Void():Type {
        return Type("void", Kind.VOID, Position(), true)
    }

    @class
    method Null():Type {
        return Type("null", Kind.NULL, Position(), true)
    }

    @class
    method Object():Type {
        return Type("panda.core.Object", Kind.CLASS, Position(), true)
    }

    @class
    method Any():Type {
        def subtypes := Array<Type>()
        subtypes.add(Object())
        return Type("panda.core.Object?", Kind.NULLABLE, Position(), subtypes, true)
    }

    @class
    method Class():Type {
        return Type("panda.core.Class", Kind.CLASS, Position(), true)
    }

    @class
    method Immutable():Type {
        return Type("panda.core.Immutable", Kind.CLASS, Position(), true)
    }

    @class
    method Value():Type {
        return Type("panda.core.Value", Kind.CLASS, Position(), true)
    }

    @class
    method StringType():Type {
        return Type("panda.core.String", Kind.CLASS, Position(), true)
    }

    @class
    method RegularExpression():Type {
        return Type("panda.core.RegularExpression", Kind.CLASS, Position(), true)
    }

    @class
    method BuiltinInt8():Type {
        return Type("builtin_int8", Type.Kind.BUILTIN_INT, 8)
    }

    @class
    method BuiltinInt16():Type {
        return Type("builtin_int16", Type.Kind.BUILTIN_INT, 16)
    }

    @class
    method BuiltinInt32():Type {
        return Type("builtin_int32", Type.Kind.BUILTIN_INT, 32)
    }

    @class
    method BuiltinInt64():Type {
        return Type("builtin_int64", Type.Kind.BUILTIN_INT, 64)
    }

    @class
    method BuiltinUInt8():Type {
        return Type("builtin_uint8", Type.Kind.BUILTIN_UINT, 8)
    }

    @class
    method BuiltinUInt16():Type {
        return Type("builtin_uint16", Type.Kind.BUILTIN_UINT, 16)
    }

    @class
    method BuiltinUInt32():Type {
        return Type("builtin_uint32", Type.Kind.BUILTIN_UINT, 32)
    }

    @class
    method BuiltinUInt64():Type {
        return Type("builtin_uint64", Type.Kind.BUILTIN_UINT, 64)
    }

    @class
    method BuiltinFloat32():Type {
        return Type("builtin_float32", Type.Kind.BUILTIN_FLOAT, 32)
    }

    @class
    method BuiltinFloat64():Type {
        return Type("builtin_float64", Type.Kind.BUILTIN_FLOAT, 64)
    }

    @class
    method Int8():Type {
        return Type("panda.core.Int8", Kind.CLASS, Position(), true)
    }

    @class
    method Int16():Type {
        return Type("panda.core.Int16", Kind.CLASS, Position(), true)
    }

    @class
    method Int32():Type {
        return Type("panda.core.Int32", Kind.CLASS, Position(), true)
    }

    @class
    method Int64():Type {
        return Type("panda.core.Int64", Kind.CLASS, Position(), true)
    }

    @class
    method UInt8():Type {
        return Type("panda.core.UInt8", Kind.CLASS, Position(), true)
    }

    @class
    method UInt16():Type {
        return Type("panda.core.UInt16", Kind.CLASS, Position(), true)
    }

    @class
    method UInt32():Type {
        return Type("panda.core.UInt32", Kind.CLASS, Position(), true)
    }

    @class
    method UInt64():Type {
        return Type("panda.core.UInt64", Kind.CLASS, Position(), true)
    }

    @class
    method Real32():Type {
        return Type("panda.core.Real32", Kind.CLASS, Position(), true)
    }

    @class
    method Real64():Type {
        return Type("panda.core.Real64", Kind.CLASS, Position(), true)
    }

    @class
    method Char8():Type {
        return Type("panda.core.Char8", Kind.CLASS, Position(), true)
    }

    @class
    method Char16():Type {
        return Type("panda.core.Char16", Kind.CLASS, Position(), true)
    }

    @class
    method Char32():Type {
        return Type("panda.core.Char32", Kind.CLASS, Position(), true)
    }

    @class
    method Bit():Type {
        return Type("panda.core.Bit", Kind.CLASS, Position(), true)
    }

    @class
    method IntLiteral(value:UInt64):Type {
        return Type("IntegerLiteral(\{value})", Kind.INT_LITERAL, Position(), true)
    }

    @class
    method NegatedIntLiteral(value:UInt64):Type {
        return Type("IntegerLiteral(-\{value.convert()})", Kind.INT_LITERAL, Position(), true)
    }

    @class
    method RealLiteral(value:Real64):Type {
        return Type("RealLiteral(\{value.convert()})", Kind.REAL_LITERAL, Position(), true)
    }

    @class
    method BitLiteral():Type {
        return Type("$bit_literal", Kind.BIT_LITERAL, Position(), true)
    }

    @class
    method ClassLiteral(cl:ClassDecl):Type {
        def children := Array<Type>() -- FIXME literal
        children.add(cl.type())
        return generic(Class(), children)
    }

    @class
    method BuiltinBit():Type {
        return Type("builtin_bit", Kind.BUILTIN_BIT, Position(), true)
    }

    @class
    method Iterator():Type {
        return Type("panda.collections.Iterator", Kind.CLASS, Position(), true)
    }

    @class
    method Iterable():Type {
        return Type("panda.collections.Iterable", Kind.CLASS, Position(), true)
    }

    @class
    method Panda():Type {
        return Type("panda.core.Panda", Kind.CLASS, Position(), true)
    }

    @class
    method Method():Type {
        return Type("panda.core.Method", Kind.CLASS, Position(), true)
    }

    @class
    method MutableMethod():Type {
        return Type("panda.core.MutableMethod", Kind.CLASS, Position(), true)
    }

    @class
    method WeakOf(t:Type):Type {
        def children := Array<Type>() -- FIXME literal
        children.add(Type(Compiler.WEAK_NAME, Kind.CLASS, Position(), true))
        children.add(t)
        return Type("\{Compiler.WEAK_NAME}<\{t}>", Kind.GENERIC, t.position, children, t.resolved)
    }

    @class
    method pointerTo(t:Type):Type {
        def children := Array<Type>() -- FIXME literal
        children.add(t)
        return generic(Type("panda.unsafe.Pointer", Kind.CLASS, Position(), true), children)
    }

    @class
    method RangeOf(t:Type):Type {
        def children := Array<Type>() -- FIXME literal
        children.add(t)
        return generic(Type(Compiler.RANGE_NAME, Kind.CLASS, Position(), true), children)
    }

    @class
    method SteppedRangeOf(t:Type):Type {
        def children := Array<Type>() -- FIXME literal
        children.add(t)
        if t = Char8() {
            children.add(Int8())
        }
        else if t = Char16() {
            children.add(Int16())
        }
        else if t = Char32() {
            children.add(Int32())
        }
        else {
            children.add(t.nonnullable())
        }
        return generic(Type(Compiler.STEPPED_RANGE_NAME, Kind.CLASS, Position(), true), children)
    }

    @class
    method ChoiceData():Type {
        return Type("<choice data>", Kind.INVALID, Position(), true)
    }

    @class
    method Invalid():Type {
        return Type("<invalid>", Kind.INVALID, Position(), true)
    }

    function isNumber():Bit {
        return name.startsWith("panda.core.Int") | name.startsWith("panda.core.UInt") |
                name.startsWith("panda.core.Real") | typeKind = Kind.INT_LITERAL |
                typeKind = Kind.REAL_LITERAL
    }

    function isBuiltinNumber():Bit {
        return typeKind = Kind.BUILTIN_INT | typeKind = Kind.BUILTIN_UINT |
                typeKind = Kind.BUILTIN_FLOAT | typeKind = Kind.INT_LITERAL
    }

    function isReal():Bit {
        return typeKind = Kind.REAL_LITERAL | name.startsWith("panda.core.Real")
    }

    function isChar():Bit {
        return name.startsWith("panda.core.Char")
    }

    function isNumeric():Bit {
        return isNumber() | isChar()
    }

    function isClass():Bit {
        match typeKind {
            when Kind.CLASS, Kind.NULLABLE, Kind.GENERIC, Kind.GENERIC_PARAMETER, Kind.METHOD,
                    Kind.FUNCTION, Kind.IMMUTABLE_METHOD, Kind.IMMUTABLE_FUNCTION:
                return true
            otherwise:
                return false
        }
    }

    function isMethod():Bit {
        match typeKind {
            when Kind.METHOD, Kind.FUNCTION, Kind.IMMUTABLE_METHOD, Kind.IMMUTABLE_FUNCTION:
                return true
            otherwise:
                return false
        }
    }

    function isPointer():Bit {
        return name.startsWith("panda.unsafe.Pointer")
    }

    function isRange():Bit {
        if typeKind = Kind.NULLABLE {
            return subtypes[0].isRange()
        }
        return typeKind = Kind.GENERIC & subtypes[0].name = Compiler.RANGE_NAME
    }

    function isSteppedRange():Bit {
        if typeKind = Kind.NULLABLE {
            return subtypes[0].isSteppedRange()
        }
        return typeKind = Kind.GENERIC & subtypes[0].name = Compiler.STEPPED_RANGE_NAME
    }

    function nullable():Type {
        if typeKind = Kind.NULLABLE {
            return self
        }
        def subtypes := Array<Type>()
        subtypes.add(self)
        return Type("\{name}?", Kind.NULLABLE, Position(), subtypes, true)
    }

    function nonnullable():Type {
        if typeKind != Kind.NULLABLE {
            return self
        }
        return subtypes[0]
    }

    @pre(typeKind = Kind.FUNCTION | typeKind = Kind.METHOD | typeKind = Kind.IMMUTABLE_FUNCTION |
            typeKind = Kind.IMMUTABLE_METHOD)
    function get_parameterCount():Int {
        return subtypes.count - 1
    }

    @pre((typeKind = Kind.FUNCTION | typeKind = Kind.METHOD | typeKind = Kind.IMMUTABLE_FUNCTION |
            typeKind = Kind.IMMUTABLE_METHOD) & i >= 0 & i < subtypes.count - 1)
    function parameterType(i:Int):Type {
        return subtypes[i]
    }

    @pre(typeKind = Kind.FUNCTION | typeKind = Kind.METHOD | typeKind = Kind.IMMUTABLE_FUNCTION |
            typeKind = Kind.IMMUTABLE_METHOD)
    function returnType():Type {
        return subtypes[subtypes.count - 1]
    }

    -- returns the narrowest type that can hold an instance of either type
    function union(compiler:Compiler, other:Type):Type {
        if self = other {
            return self
        }
        if self = Null() {
            if other.typeKind = Kind.NULLABLE {
                return other
            }
            return other.nullable()
        }
        if other = Null() {
            if typeKind = Kind.NULLABLE {
                return self
            }
            return nullable()
        }
        if typeKind = Kind.INT_LITERAL & other.isNumber() {
            return other
        }
        if isNumber() & other.typeKind = Kind.INT_LITERAL {
            return self
        }
        if isReal() {
            if other.typeKind = Kind.INT_LITERAL | other.typeKind = Kind.REAL_LITERAL {
                return self
            }
            if other.isNumber() {
                if other.name.endsWith("64") {
                    return Real64()
                }
                return Real32()
            }
        }
        if other.isReal() {
            if typeKind = Kind.INT_LITERAL | typeKind = Kind.REAL_LITERAL {
                return other
            }
            if isNumber() {
                if name.endsWith("64") {
                    return Real64()
                }
                return Real32()
            }
        }
        if typeKind = Kind.NULLABLE {
            return subtypes[0].union(compiler, other).nullable()
        }
        if other.typeKind = Kind.NULLABLE {
            return union(compiler, other.subtypes[0]).nullable()
        }
        def t1 := compiler.preferredType(self)
        def t2 := compiler.preferredType(other)
        if t1.isClass() & t2.isClass() {
            def ancestors := HashSet<Type>()
            var t := self
            var cl := compiler.getClass(t1)
            while cl != null {
                ancestors.add(t)
                if cl.rawSuper != null {
                    t := compiler.remapType(t, cl.rawSuper)
                    cl := compiler.getClass(t)
                }
                else {
                    cl := null
                }
            }
            t := other
            cl := compiler.getClass(t2)
            while cl != null {
                if ancestors.contains(t) {
                    return t
                }
                if cl.rawSuper != null {
                    t := compiler.remapType(t, cl.rawSuper)
                    cl := compiler.getClass(t)
                }
                else {
                    cl := null
                }
            }
        }
        return Type.Object()
    }

    @pre(typeKind != Kind.INVALID)
    @post(@return.typeKind != Kind.INVALID)
    method remap(types:HashMap<String, Type>):Type {
        if types.count = 0 {
            return self
        }
        match typeKind {
            when Kind.GENERIC_PARAMETER:
                def found := types[name]
                if found != null {
                    return found
                }
                return self
            when Kind.GENERIC:
                def base := subtypes[0].remap(types)
                def remappedArgs := Array<Type>()
                for i in 1 .. subtypes.count {
                    remappedArgs.add(subtypes[i].remap(types))
                }
                return Type.generic(base, remappedArgs)
            when Kind.NULLABLE:
                return subtypes[0].remap(types).nullable()
            when Kind.METHOD, Kind.FUNCTION, Kind.IMMUTABLE_METHOD, Kind.IMMUTABLE_FUNCTION:
                def parameters := Array<Type>()
                assert subtypes.count >= 1
                for i in 0 .. subtypes.count - 1 {
                    parameters.add(subtypes[i].remap(types))
                }
                return methodType(position, typeKind, parameters,
                        subtypes[subtypes.count - 1].remap(types))
            otherwise: return self
        }
    }

    @override
    function hash():Int {
        return name.hash()
    }

    @override
    function convert():String {
        return name
    }
}