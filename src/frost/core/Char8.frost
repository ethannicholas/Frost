package frost.core

uses frost.unsafe.Pointer

====================================================================================================
Depending on context, represents either a Unicode codepoint in the range 0 to 255 or a single byte
of a UTF-8 encoded string. For ASCII characters (0 to 127), there is no difference between the two
interpretations.

A single-codepoint string literal whose single codepoint fits into a `Char8` (that is, Unicode
codepoints 0 to 255) may be used wherever a `Char8` is expected. That is, it is legal to write:

    def c:Char8 := "A"
====================================================================================================
@final
class Char8 : Value, HashKey<Char8>, Comparable<Char8> {
    @private
    def value:UInt8

    init(value:UInt8) {
        self.value := value
    }

    @override
    function =(other:Char8):Bit {
        return value = other.value
    }

    @override
    function !=(other:Char8):Bit {
        return value != other.value
    }

    @override
    function <(other:Char8):Bit {
        return value < other.value
    }

    @override
    function >(other:Char8):Bit {
        return value > other.value
    }

    @override
    function <=(other:Char8):Bit {
        return value <= other.value
    }

    @override
    function >=(other:Char8):Bit {
        return value >= other.value
    }

    function isWhitespace():Bit {
        match self {
            when "\n", "\r", "\t", " " {
                return true
            }
            otherwise {
                return false
            }
        }
    }

    ================================================================================================
    Returns a string consisting of `count` copies of this character.
    ================================================================================================
    function *(count:Int):String {
        def result := MutableString()
        for i in 0 .. count {
            result.append(self)
        }
        return result.finish()
    }

    ================================================================================================
    Returns a string consisting of `count` copies of the given character.
    ================================================================================================
    @class
    function *(count:Int, char:Char8):String {
        return char * count
    }

    @override
    function get_hash():Int {
        return asInt
    }

    property asChar16:Char16
    function get_asChar16():Char16 {
        return Char16(asUInt16)
    }

    property asChar32:Char32
    function get_asChar32():Char32 {
        return Char32(asInt32)
    }

    property asInt:Int
    function get_asInt():Int {
        return value.asInt
    }

    property asInt8:Int8
    function get_asInt8():Int8 {
        return value.asInt8
    }

    property asInt16:Int16
    function get_asInt16():Int16 {
        return value.asInt16
    }

    property asInt32:Int32
    function get_asInt32():Int32 {
        return value.asInt32
    }

    property asInt64:Int64
    function get_asInt64():Int64 {
        return value.asInt64
    }

    property asUInt8:UInt8
    function get_asUInt8():UInt8 {
        return value
    }

    property asUInt16:UInt16
    function get_asUInt16():UInt16 {
        return value.asUInt16
    }

    property asUInt32:UInt32
    function get_asUInt32():UInt32 {
        return value.asUInt32
    }

    property asUInt64:UInt64
    function get_asUInt64():UInt64 {
        return value.asUInt64
    }




    property toChar16:Char16
    function get_toChar16():Char16 {
        return Char16(toUInt16)
    }

    property toChar32:Char32
    function get_toChar32():Char32 {
        return Char32(toInt32)
    }

    property toInt:Int
    function get_toInt():Int {
        return value.toInt
    }

    property toInt8:Int8
    function get_toInt8():Int8 {
        return value.toInt8
    }

    property toInt16:Int16
    function get_toInt16():Int16 {
        return value.toInt16
    }

    property toInt32:Int32
    function get_toInt32():Int32 {
        return value.toInt32
    }

    property toInt64:Int64
    function get_toInt64():Int64 {
        return value.toInt64
    }

    property toUInt8:UInt8
    function get_toUInt8():UInt8 {
        return value
    }

    property toUInt16:UInt16
    function get_toUInt16():UInt16 {
        return value.toUInt16
    }

    property toUInt32:UInt32
    function get_toUInt32():UInt32 {
        return value.toUInt32
    }

    property toUInt64:UInt64
    function get_toUInt64():UInt64 {
        return value.toUInt64
    }

    ================================================================================================
    Interprets this character as a Unicode codepoint and converts it to a string. Note that if this
    `Char8` represents part of a multi-byte UTF-8 sequence (e.g. it came from [String.utf8]),
    interpreting it as a Unicode codepoint in its own right is incorrect and will lead to mangled
    strings.
    ================================================================================================
    @override
    function get_toString():String {
        if value < 0x80 {
            def data := Pointer<Char8>.alloc(1)
            data[0] := self
            return String(data, 1)
        }
        def data := Pointer<Char8>.alloc(2)
        data[0] := Char8((value >> 6 || 0b11000000).asUInt8)
        data[1] := Char8((value && 0b111111 || 0b10000000).asUInt8)
        return String(data, 2)
    }
}