package frost.core
===@hidden===
class KeyTuple5<T0:HashKey<T0>, T1:HashKey<T1>, T2:HashKey<T2>, T3:HashKey<T3>, T4:HashKey<T4>> : HashKey<(T0, T1, T2, T3, T4)> {
    def f0:T0
    def f1:T1
    def f2:T2
    def f3:T3
    def f4:T4

    init(f0:T0, f1:T1, f2:T2, f3:T3, f4:T4) {
       self.f0 := f0
       self.f1 := f1
       self.f2 := f2
       self.f3 := f3
       self.f4 := f4
    }

    @pre(i >= 0 & i < 5)
    function []<T>(i:Int):T {
        match i {
            when 0 { return f0->T }
            when 1 { return f1->T }
            when 2 { return f2->T }
            when 3 { return f3->T }
            when 4 { return f4->T }
        }
        unreachable
    }

    @override
    function =(other:(T0, T1, T2, T3, T4)):Bit {
        if f0 != other.f0 { return false }
        if f1 != other.f1 { return false }
        if f2 != other.f2 { return false }
        if f3 != other.f3 { return false }
        if f4 != other.f4 { return false }
        return true
    }
    @override
    function get_hash():Int {
        var result := 0
        result ~~= f0.hash *& 1
        result ~~= f1.hash *& 73
        result ~~= f2.hash *& 179
        result ~~= f3.hash *& 283
        result ~~= f4.hash *& 419
        return result
    }
    @override
    function get_toString():String {
        function nonnull(o:Object?):Object {
            if o !== null { return o } else { return '<null>' }
        }
        return "(\{nonnull(f0)}, \{nonnull(f1)}, \{nonnull(f2)}, \{nonnull(f3)}, \{nonnull(f4)})"
    }
}
