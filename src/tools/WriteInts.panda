class WriteInts {
    choice Type {
        INT8
        INT16
        INT32
        INT64
        UINT8
        UINT16
        UINT32
        UINT64
        REAL32
        REAL64
        INVALID
    }

    @class
    function builtin(type:Type):String {
        match type {
            when Type.INT8:   return "builtin_int8"
            when Type.INT16:  return "builtin_int16"
            when Type.INT32:  return "builtin_int32"
            when Type.INT64:  return "builtin_int64"
            when Type.UINT8:  return "builtin_uint8"
            when Type.UINT16: return "builtin_uint16"
            when Type.UINT32: return "builtin_uint32"
            when Type.UINT64: return "builtin_uint64"
            when Type.REAL32: return "builtin_float32"
            when Type.REAL64: return "builtin_float64"
        }
        assert false, "invalid type \{type}"
    }

    @class
    function object(type:Type):String {
        match type {
            when Type.INT8:   return "Int8"
            when Type.INT16:  return "Int16"
            when Type.INT32:  return "Int32"
            when Type.INT64:  return "Int64"
            when Type.UINT8:  return "UInt8"
            when Type.UINT16: return "UInt16"
            when Type.UINT32: return "UInt32"
            when Type.UINT64: return "UInt64"
            when Type.REAL32: return "Real32"
            when Type.REAL64: return "Real64"
        }
        assert false, "invalid type \{type}"
    }

    @class
    function max32(type:Type):Type {
        match type {
            when Type.INT8,  Type.INT16:  return Type.INT32
            when Type.UINT8, Type.UINT16: return Type.UINT32
            otherwise: return type
        }
    }

    @class
    function signed(type:Type):Bit {
        match type {
            when Type.INT8,  Type.INT16,  Type.INT32,  Type.INT64:  return true
            when Type.UINT8, Type.UINT16, Type.UINT32, Type.UINT64: return false
        }
    }

    @class
    function size(type:Type):Int {
        match type {
            when Type.INT8,  Type.UINT8:  return 8
            when Type.INT16, Type.UINT16: return 16
            when Type.INT32, Type.UINT32: return 32
            when Type.INT64, Type.UINT64: return 64
        }
    }

    @class
    function cast(type:Type, target:Type):String {
        if type = target {
            return ""
        }
        return "->\{builtin(target)}"
    }

    @class
    function castInt(type:Type, target:Type):String {
        if type = target {
            return ""
        }
        return ".convert()->\{object(target)}"
    }

    @class
    function min(type:Type):String {
        match type {
            when Type.INT8:   return "-128"
            when Type.INT16:  return "-32768"
            when Type.INT32:  return "-2147483648"
            when Type.INT64:  return "-9223372036854775808"
            when Type.UINT8:  return "0"
            when Type.UINT16: return "0"
            when Type.UINT32: return "0"
            when Type.UINT64: return "0"
        }
    }

    @class
    function max(type:Type):String {
        match type {
            when Type.INT8:   return "127"
            when Type.INT16:  return "32767"
            when Type.INT32:  return "2147483647"
            when Type.INT64:  return "9223372036854775807"
            when Type.UINT8:  return "255"
            when Type.UINT16: return "65535"
            when Type.UINT32: return "4294967295"
            when Type.UINT64: return "18446744073709551615"
        }
    }

    @class
    function binaryType(leftType:Type, rightType:Type, signMatters:Bit):Type {
        if signed(leftType) = signed(rightType) | !signMatters {
            def left32 := max32(leftType)
            def right32 := max32(rightType)
            if left32 = right32 {
                return left32
            }
            if size(left32) > size(right32) {
                return left32
            }
            return right32
        }
        else if size(leftType) = 8 & size(rightType) = 8 {
            return Type.INT16
        }
        else if size(leftType) <= 16 & size(rightType) <= 16 {
            return Type.INT32
        }
        else if size(leftType) <= 32 & size(rightType) <= 32 {
            return Type.INT64
        }
        else {
            return Type.INVALID
        }
    }

    @class
    method writeConstructor(type:Type, other:Type, out:OutputStream) {
        out.printLine()
        out.printLine("    @implicit")
        out.printLine("    init(value:\{object(other)}) {")
        out.printLine("        self.value := value.value\{cast(other, type)}")
        out.printLine("    }")
    }

    @class
    method writeConstructors(type:Type, out:OutputStream) {
        if size(type) > size(Type.INT8) & signed(type) {
            writeConstructor(type, Type.INT8, out)
        }
        if size(type) > size(Type.INT16) & signed(type) {
            writeConstructor(type, Type.INT16, out)
        }
        if size(type) > size(Type.INT32) & signed(type) {
            writeConstructor(type, Type.INT32, out)
        }
        if size(type) > size(Type.UINT8) {
            writeConstructor(type, Type.UINT8, out)
        }
        if size(type) > size(Type.UINT16) {
            writeConstructor(type, Type.UINT16, out)
        }
        if size(type) > size(Type.UINT32) {
            writeConstructor(type, Type.UINT32, out)
        }
    }

    @class
    method writeOperator(op:String, leftType:Type, rightType:Type, signMatters:Bit,
            out:OutputStream) {
        def resultType := binaryType(leftType, rightType, signMatters)
        if resultType = Type.INVALID {
            return
        }
        out.printLine()
        out.printLine("    function \{op}(other:\{object(rightType)}):\{object(resultType)} {")
        out.printLine("        return value\{cast(leftType, resultType)} \{op} " +
                "other.value\{cast(rightType, resultType)}")
        out.printLine("    }")
    }

    @class
    method writeOperator(op:String, type:Type, signMatters:Bit, out:OutputStream) {
        writeOperator(op, type, Type.INT8,   signMatters, out)
        writeOperator(op, type, Type.INT16,  signMatters, out)
        writeOperator(op, type, Type.INT32,  signMatters, out)
        writeOperator(op, type, Type.INT64,  signMatters, out)
        writeOperator(op, type, Type.UINT8,  signMatters, out)
        writeOperator(op, type, Type.UINT16, signMatters, out)
        writeOperator(op, type, Type.UINT32, signMatters, out)
        writeOperator(op, type, Type.UINT64, signMatters, out)
    }

    @class
    method writeDivide(leftType:Type, rightType:Type, out:OutputStream) {
        def resultType:Type
        if size(leftType).max(size(rightType)) = 64 {
            resultType := Type.REAL64
        }
        else {
            resultType := Type.REAL32
        }
        out.printLine()
        out.printLine("    function /(other:\{object(rightType)}):\{object(resultType)} {")
        out.printLine("        return value\{cast(leftType, resultType)} / " +
                "other.value\{cast(rightType, resultType)}")
        out.printLine("    }")
    }

    @class
    method writeDivide(type:Type, out:OutputStream) {
        writeDivide(type, Type.INT8,   out)
        writeDivide(type, Type.INT16,  out)
        writeDivide(type, Type.INT32,  out)
        writeDivide(type, Type.INT64,  out)
        writeDivide(type, Type.UINT8,  out)
        writeDivide(type, Type.UINT16, out)
        writeDivide(type, Type.UINT32, out)
        writeDivide(type, Type.UINT64, out)
    }

    @class
    method writePrefixOperator(op:String, type:Type, out:OutputStream) {
        out.printLine()
        out.printLine("    function \{op}():\{object(type)} {")
        out.printLine("        return \{object(type)}(\{op}value)")
        out.printLine("    }")
    }

    @class
    method writeComparisonOperator(op:String, leftType:Type, rightType:Type, out:OutputStream) {
        def operandType := binaryType(leftType, rightType, true)
        if operandType = Type.INVALID {
            return
        }
        out.printLine()
        if leftType = rightType {
            out.printLine("    @override")
        }
        out.printLine("    function \{op}(other:\{object(rightType)}):Bit {")
        out.printLine("        return value\{cast(leftType, operandType)} \{op} " +
                "other.value\{cast(rightType, operandType)}")
        out.printLine("    }")
    }

    @class
    method writeComparisonOperator(op:String, type:Type, out:OutputStream) {
        writeComparisonOperator(op, type, Type.INT8,   out)
        writeComparisonOperator(op, type, Type.INT16,  out)
        writeComparisonOperator(op, type, Type.INT32,  out)
        writeComparisonOperator(op, type, Type.INT64,  out)
        writeComparisonOperator(op, type, Type.UINT8,  out)
        writeComparisonOperator(op, type, Type.UINT16, out)
        writeComparisonOperator(op, type, Type.UINT32, out)
        writeComparisonOperator(op, type, Type.UINT64, out)
    }

    @class
    method writeMax(leftType:Type, rightType:Type, out:OutputStream) {
        out.printLine()
        def resultType := binaryType(leftType, rightType, true)
        if resultType = Type.INVALID {
            return
        }
        out.printLine("    function max(other:\{object(rightType)}):\{object(resultType)} {")
        out.printLine("        if value\{cast(leftType, resultType)} > " +
                "other.value\{cast(rightType, resultType)} {")
        out.printLine("            return value\{cast(leftType, resultType)}")
        out.printLine("        }")
        out.printLine("        return other.value\{cast(rightType, resultType)}")
        out.printLine("    }")
    }

    @class
    method writeMax(type:Type, out:OutputStream) {
        writeMax(type, Type.INT8,   out)
        writeMax(type, Type.INT16,  out)
        writeMax(type, Type.INT32,  out)
        writeMax(type, Type.INT64,  out)
        writeMax(type, Type.UINT8,  out)
        writeMax(type, Type.UINT16, out)
        writeMax(type, Type.UINT32, out)
        writeMax(type, Type.UINT64, out)
    }

    @class
    method writeMin(leftType:Type, rightType:Type, out:OutputStream) {
        out.printLine()
        def resultType := binaryType(leftType, rightType, true)
        if resultType = Type.INVALID {
            return
        }
        out.printLine("    function min(other:\{object(rightType)}):\{object(resultType)} {")
        out.printLine("        if value\{cast(leftType, resultType)} < " +
                "other.value\{cast(rightType, resultType)} {")
        out.printLine("            return value\{cast(leftType, resultType)}")
        out.printLine("        }")
        out.printLine("        return other.value\{cast(rightType, resultType)}")
        out.printLine("    }")
    }

    @class
    method writeMin(type:Type, out:OutputStream) {
        writeMin(type, Type.INT8,   out)
        writeMin(type, Type.INT16,  out)
        writeMin(type, Type.INT32,  out)
        writeMin(type, Type.INT64,  out)
        writeMin(type, Type.UINT8,  out)
        writeMin(type, Type.UINT16, out)
        writeMin(type, Type.UINT32, out)
        writeMin(type, Type.UINT64, out)
    }

    @class
    method writeIndex(leftType:Type, rightType:Type, out:OutputStream) {
        out.printLine()
        if rightType = Type.INT64 {
            out.printLine("    @override")
        }
        out.printLine("    function [](index:\{object(rightType)}):Bit {")
        out.printLine("        return self && (1 << index) != 0")
        out.printLine("    }")
    }

    @class
    method writeIndex(type:Type, out:OutputStream) {
        out.printLine("    @class")
        out.printLine("    function [](range:Range<\{object(type)}>):ListView<\{object(type)}> {")
        out.printLine("        return org.pandalanguage.panda.\{object(type)}List(SteppedRange<" +
                "\{object(type)}, \{object(type)}>(range.min, range.max, 1, range.inclusive))")
        out.printLine("    }")
        out.printLine("    @class")
        out.printLine("    function [](range:SteppedRange<\{object(type)}, \{object(type)}>):" +
                "ListView<\{object(type)}> {")
        out.printLine("        return org.pandalanguage.panda.\{object(type)}List(range)")
        out.printLine("    }")
        writeIndex(type, Type.INT8,   out)
        writeIndex(type, Type.INT16,  out)
        writeIndex(type, Type.INT32,  out)
        writeIndex(type, Type.INT64,  out)
        writeIndex(type, Type.UINT8,  out)
        writeIndex(type, Type.UINT16, out)
        writeIndex(type, Type.UINT32, out)
        writeIndex(type, Type.UINT64, out)
    }

    @class
    method writeIterator(type:Type, out:OutputStream) {
        out.printLine()
        out.printLine("    @override")
        out.printLine("    function iterator():Iterator<Bit> {")
        out.printLine("        return org.pandalanguage.panda.IntBitIterator(self\{castInt(type, Type.UINT64)}, 1 << " +
                "\{size(type) - 1})")
        out.printLine("    }")
    }

    @class
    method writeCount(type:Type, out:OutputStream) {
        out.printLine()
        out.printLine("    @override")
        out.printLine("    function get_count():Int {")
        out.printLine("        return \{size(type)}")
        out.printLine("    }")
    }

    @class
    method writeHash(type:Type, out:OutputStream) {
        out.printLine()
        out.printLine("    @override")
        out.printLine("    function hash():Int {")
        out.printLine("        return Int(value\{cast(type, Type.INT64)})")
        out.printLine("    }")
    }

    @class
    method writeConvertToString(type:Type, out:OutputStream) {
        out.printLine()
        out.printLine("    @override")
        out.printLine("    function convert():String {")
        var max := max(type).convert()->String.length()
        if signed(type) {
            max += 1 -- for minus sign
        }
        out.printLine("        constant max := \{max}")
        out.printLine("        def chars := Pointer<Char8>.alloc(max)")
        out.printLine("        var index := max - 1")
        out.printLine("        var value := self")
        out.printLine("        if value >= 0 {")
        out.printLine("            do {")
        out.printLine("                chars[index] := Char8((value % 10 + 48).convert())")
        out.printLine("                value := (value // 10)\{castInt(max32(type), type)}")
        out.printLine("                index -= 1")
        out.printLine("            }")
        out.printLine("            while value > 0")
        out.printLine("            index += 1")
        out.printLine("        }")
        out.printLine("        else {")
        out.printLine("            do {")
        out.printLine("                chars[index] := Char8((48 - value % 10).convert())")
        out.printLine("                value := (value // 10)\{castInt(max32(type), type)}")
        out.printLine("                index -= 1")
        out.printLine("            }")
        out.printLine("            while value < 0")
        out.printLine("            chars[index] := \"-\"")
        out.printLine("        }")
        out.printLine("        def size := max - index")
        out.printLine("        for i in 0 .. size {")
        out.printLine("            chars[i] := chars[i + index]")
        out.printLine("        }")
        out.printLine("        return String(chars, size)")
        out.printLine("    }")
    }

    @class
    method writeConvert(type:Type, target:Type, out:OutputStream) {
        out.printLine()
        out.printLine("    function convert():\{object(target)} {")
        out.printLine("        return \{object(target)}(value->\{builtin(target)})")
        out.printLine("    }")
    }

    @class
    method writeConvert(type:Type, out:OutputStream) {
        if type != Type.INT8 {
            writeConvert(type, Type.INT8, out)
        }
        if type != Type.INT16 {
            writeConvert(type, Type.INT16, out)
        }
        if type != Type.INT32 {
            writeConvert(type, Type.INT32, out)
        }
        if type != Type.INT64 {
            writeConvert(type, Type.INT64, out)
        }
        if type != Type.UINT8 {
            writeConvert(type, Type.UINT8, out)
        }
        if type != Type.UINT16 {
            writeConvert(type, Type.UINT16, out)
        }
        if type != Type.UINT32 {
            writeConvert(type, Type.UINT32, out)
        }
        if type != Type.UINT64 {
            writeConvert(type, Type.UINT64, out)
        }
        writeConvert(type, Type.REAL32, out)
        writeConvert(type, Type.REAL64, out)
        writeConvertToString(type, out)
    }

    @class
    method writeFormat(type:Type, out:OutputStream) {
        out.printLine()
        def mask:String
        match size(type) {
            when  8: mask := "0xFF"
            when 16: mask := "0xFFFF"
            when 32: mask := "0xFFFFFFFF"
            when 64: mask := "0xFFFFFFFFFFFFFFFF"
        }
        out.printLine("    @override")
        out.printLine("    function format(fmt:String):String {")
        if signed(type) {
            out.printLine("        return Panda.format(value < 0, abs().convert(), \{mask}, fmt)")
        }
        else {
            out.printLine("        return Panda.format(false, self\{castInt(type, Type.UINT64)}, " +
                    "\{mask}, fmt)")
        }
        out.printLine("    }")
    }

    @class
    method writeAbs(type:Type, out:OutputStream) {
        out.printLine()
        out.printLine("    function abs():\{object(type)} {")
        out.printLine("        if self < 0 {")
        out.printLine("            return -self")
        out.printLine("        }")
        out.printLine("        return self")
        out.printLine("    }")
    }

    @class
    method writeParse(type:Type, out:OutputStream) {
        out.printLine()
        out.printLine("    @class")
        out.printLine("    function parse(str:String, radix:Int):\{object(type)}? {")
        if signed(type) {
            out.printLine("        if str.startsWith(\"-\") {")
            out.printLine("            def abs := Panda.parse(str[1..], radix)")
            out.printLine("            if abs = null {")
            out.printLine("                return null")
            out.printLine("            }")
            out.printLine("            return -(abs\{castInt(Type.UINT64, type)})")
            out.printLine("        }")
            out.printLine("        else {")
            out.printLine("            def result := Panda.parse(str, radix)")
            out.printLine("            if result = null {")
            out.printLine("                return null")
            out.printLine("            }")
            out.printLine("            return result\{castInt(Type.UINT64, type)}")
            out.printLine("        }")
        }
        else {
            out.printLine("        def result := Panda.parse(str, radix)")
            out.printLine("        if result = null {")
            out.printLine("            return null")
            out.printLine("        }")
            out.printLine("        return result\{castInt(Type.UINT64, type)}")
        }
        out.printLine("    }")
    }

    @class
    method writeInt(type:Type, out:OutputStream) {
        out.printLine("-- This file was autogenerated by 'writeints', do not modify")
        out.printLine("package panda.core")
        out.printLine()
        out.printLine("uses panda.unsafe.Pointer")
        out.printLine()
        out.printLine("@final")
        out.printLine("class \{object(type)} : Value, Key<\{object(type)}>, " +
                "Comparable<\{object(type)}>, Formattable, ListView<Bit> {")
        out.printLine("    constant MIN:\{object(type)} := \{min(type)}")
        out.printLine()
        out.printLine("    constant MAX:\{object(type)} := \{max(type)}")
        out.printLine()
        out.printLine("    @private")
        out.printLine("    def value:\{builtin(type)}")
        out.printLine()
        out.printLine("    @private")
        out.printLine("    @implicit")
        out.printLine("    init(value:\{builtin(type)}) {")
        out.printLine("        self.value := value")
        out.printLine("    }")
        writeConstructors(type, out)
        writeOperator("+", type, true, out)
        writeOperator("-", type, true, out)
        writePrefixOperator("-", type, out)
        writeOperator("*", type, true, out)
        writeOperator("//", type, true, out)
        writeOperator("%", type, true, out)
        writeDivide(type, out)
        writePrefixOperator("!!", type, out)
        writeOperator("&&", type, false, out)
        writeOperator("||", type, false, out)
        writeOperator("~~", type, false, out)
        writeOperator("<<", type, false, out)
        writeOperator(">>", type, false, out)
        writeComparisonOperator("=", type, out)
        writeComparisonOperator("!=", type, out)
        writeComparisonOperator("<", type, out)
        writeComparisonOperator(">", type, out)
        writeComparisonOperator(">=", type, out)
        writeComparisonOperator("<=", type, out)
        if signed(type) {
            writeAbs(type, out)
        }
        writeMin(type, out)
        writeMax(type, out)
        writeIndex(type, out)
        writeCount(type, out)
        writeIterator(type, out)
        writeHash(type, out)
        writeParse(type, out)
        writeConvert(type, out)
        writeFormat(type, out)
        out.printLine("}")
    }

    @class
    method writeIntList(type:Type, out:OutputStream) {
        def cl := object(type)
        out.printLine("-- This file was autogenerated by 'writeints', do not modify")
        out.printLine("package org.pandalanguage.panda")
        out.printLine()
        out.printLine("@final")
        out.printLine("class \{cl}List : ListView<\{cl}> {")
        out.printLine("    @private")
        out.printLine("    def range:SteppedRange<\{cl}, \{cl}>")
        out.printLine()
        out.printLine("    @private")
        out.printLine("    def _count:Int")
        out.printLine()
        out.printLine("    init(range:SteppedRange<\{cl}, \{cl}>) {")
        out.printLine("        self.range := range")
        out.printLine("        self._count := computeCount()")
        out.printLine("    }")
        out.printLine()
        out.printLine("    @private")
        out.printLine("    function computeCount():Int {")
        def cast:String
        if type = Type.UINT64 {
            cast := ".convert()->Int"
        }
        else {
            cast := ""
        }
        out.printLine("        if range.inclusive {")
        out.printLine("            if range.step > 0 {")
        out.printLine("                if range.end < range.start {")
        out.printLine("                    return 0")
        out.printLine("                }")
        out.printLine("            } else if range.end > range.start {")
        out.printLine("                return 0")
        out.printLine("            }")
        out.printLine("            return ((range.end - range.start) // range.step)\{cast}.max(0) + 1")
        out.printLine("        }")
        out.printLine("        else {")
        out.printLine("            def offset:\{cl}")
        if signed(type) {
            out.printLine("            if range.step > 0 {")
            out.printLine("                if range.end <= range.start {")
            out.printLine("                    return 0")
            out.printLine("                }")
            out.printLine("                offset := -1")
            out.printLine("            } else {")
            out.printLine("                if range.end >= range.start {")
            out.printLine("                    return 0")
            out.printLine("                }")
            out.printLine("                offset := 1")
            out.printLine("            }")
        }
        else {
            out.printLine("        offset := 1")
        }
        out.printLine("            return ((range.end - range.start + offset) // range.step)" +
                "\{cast}.max(0) + 1")
        out.printLine("        }")
        out.printLine("    }")
        out.printLine()
        out.printLine("    @override")
        out.printLine("    function get_count():Int {")
        out.printLine("        return _count")
        out.printLine("    }")
        out.printLine()
        out.printLine("    @override")
        out.printLine("    function [](index:Int):\{cl} {")
        out.printLine("        return (range.start + range.step * index" +
                "\{castInt(Type.INT64, type)})\{castInt(max32(type), type)}")
        out.printLine("    }")
        out.printLine()
        out.printLine("    @override")
        out.printLine("    function convert():String {")
        out.printLine("        return \"[\\{join()}]\"")
        out.printLine("    }")
        out.printLine("}")
    }

    @class
    method main() {
        def corePath := File("../src/panda/core")
        writeInt(Type.INT8, corePath.resolve("Int8.panda").openOutputStream())
        writeInt(Type.INT16, corePath.resolve("Int16.panda").openOutputStream())
        writeInt(Type.INT32, corePath.resolve("Int32.panda").openOutputStream())
        writeInt(Type.INT64, corePath.resolve("Int64.panda").openOutputStream())
        writeInt(Type.UINT8, corePath.resolve("UInt8.panda").openOutputStream())
        writeInt(Type.UINT16, corePath.resolve("UInt16.panda").openOutputStream())
        writeInt(Type.UINT32, corePath.resolve("UInt32.panda").openOutputStream())
        writeInt(Type.UINT64, corePath.resolve("UInt64.panda").openOutputStream())

        def listPath := File("../src/org/pandalanguage/panda")
        writeIntList(Type.INT8, listPath.resolve("Int8List.panda").openOutputStream())
        writeIntList(Type.INT16, listPath.resolve("Int16List.panda").openOutputStream())
        writeIntList(Type.INT32, listPath.resolve("Int32List.panda").openOutputStream())
        writeIntList(Type.INT64, listPath.resolve("Int64List.panda").openOutputStream())
        writeIntList(Type.UINT8, listPath.resolve("UInt8List.panda").openOutputStream())
        writeIntList(Type.UINT16, listPath.resolve("UInt16List.panda").openOutputStream())
        writeIntList(Type.UINT32, listPath.resolve("UInt32List.panda").openOutputStream())
        writeIntList(Type.UINT64, listPath.resolve("UInt64List.panda").openOutputStream())
    }
}