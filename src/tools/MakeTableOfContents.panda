class Node {
    def name:String

    def children := HashMap<String, Node>()

    init(name:String) {
        self.name := name
    }

    @private
    @class
    method swap(a:List<Node>, i1:Int, i2:Int) {
        def tmp := a[i1]
        a[i1] := a[i2]
        a[i2] := tmp
    }

    @private
    @class
    function lessThan(a:String, b:String):Bit {
        for i in 0 .. a.length().min(b.length()) {
            if a[i] < b[i] {
                return true
            }
            if a[i] > b[i] {
                return false
            }
        }
        return a.length() < b.length()
    }

    @private
    @class
    method sort(a:List<Node>, left:Int, right:Int) {
        if left >= right {
            return
        }
        def pivotIndex := left + (right - left) // 2
        def pivot := a[pivotIndex]
        swap(a, right, pivotIndex)
        var storeIndex := left
        for i in left ... right - 1 {
            if lessThan(a[i].name, pivot.name) {
                swap(a, i, storeIndex)
                storeIndex += 1
            }
        }
        swap(a, storeIndex, right)
        sort(a, left, storeIndex - 1)
        sort(a, storeIndex + 1, right)
    }

    ================================================================================================
    Quick and dirty naive quicksort, until generics are done and ListView can be 
    sorted natively. FIXME kill this.
    ================================================================================================
    @class
    method sort(a:List<Node>) {
        sort(a, 0, a.get_count() - 1)
    }

    method write(out:IndentedOutputStream) {
        out.printLine("<entry>")
        out.level += 1
        if name != "" {
            var index := name.lastIndexOf(".")
            if index != null {
                index := name.next(index)
            }
            else {
                index := name.start()
            }
            out.printLine("<name>\{name}</name>")
            out.printLine("<simpleName>\{name[index..]}</simpleName>")
            out.printLine("<path>\{name.replace(".", "/")}.html</path>")
        }
        if children.get_count() != 0 {
            out.printLine("<contents>")
            out.level += 1
            def list := children.values().all()
            sort(list)
            for child in list {
                child.write(out)
            }
            out.level -= 1
            out.printLine("</contents>")
        }
        out.level -= 1
        out.printLine("</entry>")
    }
}

def root := Node("")

method add(s:String) {
    if s.contains("<") | s.startsWith("org.") {
        -- don't add specializations or org.* classes
        return
    }
    var name := ""
    var current := root
    for component in s.split(".") {
        if name != "" {
            name += "."
        }
        name += component
        var child := current.children[component]
        if child = null {
            child := Node(name)
            current.children[component] := child
        }
        current := child
    }
}

method main(args:ListView<String>) {
    assert args.get_count() = 3
    File(args[1]).lines().apply(add)
    def dest := File(args[2])
    dest.parent().createDirectories()
    root.write(IndentedOutputStream(dest.openOutputStream()))
}