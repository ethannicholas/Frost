package org.frostlang.frostc

uses frost.unsafe.Pointer
uses org.frostlang.frostc.expression.Binary

====================================================================================================
Incredibly slow, even for an interpreter. Just a proof of concept at this point.
====================================================================================================
class Interpreter : Backend {
    def strings := HashMap<String, Int64>()

    def stackSize := 10240

    def stackBase := Pointer<UInt8>.alloc(stackSize)

    def stack := stackBase

    def maxId:Int

    class MethodCode {
        def locals:Array<Type>

        def blocks:Array<Int>

        def ids:Array<Array<IR.Statement.ID>>

        def ir:Array<Array<IR.Statement>>

        def maxId:Int

        init(locals:Array<Type>, blocks:Array<Int>, ids:Array<Array<IR.Statement.ID>>,
                ir:Array<Array<IR.Statement>>, maxId:Int) {
            self.locals := locals
            self.blocks := blocks
            self.ids := ids
            self.ir := ir
            self.maxId := maxId
        }
    }

    class Context {
        @weak
        def interpreter:Interpreter

        def code:MethodCode

        def locals:Array<Int>

        -- if the value fits into an Int64, contains the value. Otherwise, contains a Pointer to
        -- the value.
        def arguments:Array<Int64>

        -- if the value fits into an Int64, contains the value. Otherwise, contains a Pointer to
        -- the value.
        def statements:Array<Int64?>

        init(interpreter:Interpreter, code:MethodCode) {
            self.interpreter := interpreter
            self.code := code

            locals := Array<Int>(code.locals.count)
            for i in 0 .. code.locals.count {
                def t := code.locals[i]
                locals.add(interpreter.alloca(t).asInt)
            }

            arguments := Array<Int64>()

            statements := Array<Int64?>(code.maxId + 1, null)
        }

        method value(value:IR.Value):Int64 {
            match value {
                when IR.Value.BIT(b, _) {
                    return b.choose(1, 0)
                }
                when IR.Value.INT(i, _) {
                    return i.asInt64
                }
                when IR.Value.LOCAL(idx, _) {
                    return locals[idx].asInt64
                }
                when IR.Value.METHOD_POINTER(MethodDecl, Type) {
                    System.crash()
                }
                when IR.Value.NULL(Type) {
                    return 0
                }
                when IR.Value.PARAMETER(idx, _) {
                    return arguments[idx]
                }
                when IR.Value.REAL(r, _) {
                    return Frost.floatToIntBits(r)
                }
                when IR.Value.REF(id, _) {
                    return statements[id.value]
                }
                when IR.Value.STRING(s, _) {
                    var result := interpreter.strings[s]
                    if result == null {
                        def compiler := interpreter.compiler
                        def memoryLayout := compiler.memoryLayout
                        assert memoryLayout.pointerSize = memoryLayout.intSize
                        def base := Pointer<UInt8>.alloc(interpreter.memoryLayout.sizeOf(
                                compiler.STRING_TYPE))
                        def string := compiler.getClass(compiler.STRING_TYPE)
                        var current := base

                        -- class
                        assert compiler.instanceFields(string)[0].name = "$class"
                        assert current.asInt - base.asInt =
                                compiler.instanceFields(string)[0].offset
                        current->Pointer<ClassDecl>.set(string)
                        current += memoryLayout.pointerSize

                        -- refCount
                        assert compiler.instanceFields(string)[1].name = "refCount"
                        assert current.asInt - base.asInt =
                                compiler.instanceFields(string)[1].offset
                        current->Pointer<Int32>.set(LLVMBackend.NO_REFCNT.asInt32)
                        current += 4

                        -- flags
                        assert compiler.instanceFields(string)[2].name = "$flags"
                        assert current.asInt - base.asInt =
                                compiler.instanceFields(string)[2].offset
                        current->Pointer<Int8>.set(0)
                        current += 4

                        -- data
                        assert compiler.instanceFields(string)[3].name = "data"
                        assert current.asInt - base.asInt =
                                compiler.instanceFields(string)[3].offset
                        def data := Pointer<Char8>.alloc(s._length)
                        for i in 0 .. s._length {
                            data[i] := s.data[i]
                        }
                        current->Pointer<Int>.set(data.asInt)
                        current += memoryLayout.pointerSize

                        -- _length
                        assert compiler.instanceFields(string)[4].name = "_length"
                        assert current.asInt - base.asInt =
                                compiler.instanceFields(string)[4].offset
                        current->Pointer<Int>.set(s._length)
                        current += memoryLayout.intSize

                        -- dummy
                        assert compiler.instanceFields(string)[5].name = "dummy"
                        assert current.asInt - base.asInt =
                                compiler.instanceFields(string)[5].offset
                        current += memoryLayout.intSize

                        -- owner
                        assert compiler.instanceFields(string)[6].name = "owner"
                        assert current.asInt - base.asInt =
                                compiler.instanceFields(string)[6].offset
                        current->Pointer<Int>.set(0)
                        current += memoryLayout.intSize

                        assert current.asInt - base.asInt =
                                interpreter.memoryLayout.sizeOf(string.type)
                        result := base.asInt.asInt64
                        interpreter.strings[s] := result
                    }
                    return result
                }
                otherwise {
                    unreachable
                }
            }
        }
    }

    @weak
    def compiler:Compiler?

    def memoryLayout:MemoryLayout

    def methodCode := IdentityMap<MethodDecl, MethodCode>()

    def builtins := IdentityMap<MethodDecl, (Context, FixedArray<IR.Value>)=&>(Int64)>()

    def contexts := Stack<Context>()

    def main:MethodDecl?

    @override
    method setCompiler(compiler:Compiler) {
        self.compiler := compiler
        self.memoryLayout := compiler.memoryLayout
    }

    @override
    method start(cl:ClassDecl) {
    }

    @override
    method end(cl:ClassDecl) {
    }

    @override
    method writeDeclaration(m:MethodDecl) {
    }

    @override
    method write(m:MethodDecl, ir:IR) {
        if m.name = "main" & m.annotations.isClass {
            main := m
        }
        def blockIds := Array<Int>(ir.blocks.count)
        for i in 0 .. ir.blocks.count {
            def b := ir.blocks[i].id.value
            while blockIds.count <= b {
                blockIds.add(-1)
            }
            blockIds[b] := i
        }
        methodCode[m] := MethodCode(ir.locals, blockIds,
                ir.blocks.map(b => Array<IR.Statement.ID>(b.ids)),
                ir.blocks.map(b => Array<IR.Statement>(b.statements)),
                ir.blocks.map(b => b.ids.map(id => id.value).fold(Int.max)).fold(Int.max))
    }

    @override
    method finish() {
    }

    function align(p:Pointer<UInt8>, alignment:Int):Pointer<UInt8> {
        def rem := p.asInt % alignment
        if rem != 0 {
            return Pointer<UInt8>(p.asInt + alignment - rem)
        } 
        return p
    }

    -- we reserve 8 bytes of working stack space
    @pre(stack.asInt - stackBase.asInt + memoryLayout.sizeOf(t) < stackSize - 8)
    method alloca(t:Type):Pointer<UInt8> {
        stack := align(stack, memoryLayout.alignment(t))
        def result := stack
        stack := Pointer<UInt8>(stack.asInt + memoryLayout.sizeOf(t))
        return result
    }

    ================================================================================================
    Returns true if the type in question is a Value which is too big to be passed around inside an
    `Int64`.
    ================================================================================================
    function needsStructPointer(t:Type):Bit {
        return t.typeKind != Type.Kind.NULLABLE & compiler.isValue(t) & memoryLayout.sizeOf(t) > 8
    }

    method destroyObject(o:Pointer<UInt8>) {
        -- call cleanup
-*        def cl := Pointer<Int>(o->Pointer<Int>.get()).convertTo<ClassDecl>()
        def cleanup := compiler.getVTable(cl)[1]
        call(cleanup, FixedArray<IR.Value>([IR.Value.INT(o.asInt.asUInt64,
                compiler.INVALID_TYPE)]))

        o.destroy()*-
        unreachable
    }

    method ref(o:Pointer<UInt8>) {
        if o.asInt = 0 {
            return
        }
        def refCntPtr := (o + memoryLayout.pointerSize)->Pointer<Int32>
        def refCnt := refCntPtr.get()
        if refCnt = LLVMBackend.NO_REFCNT.asInt32 {
            return
        }
        refCntPtr.set(refCnt + 1)
    }

    method unref(o:Pointer<UInt8>) {
        if o.asInt = 0 {
            return
        }
        def refCntPtr := (o + memoryLayout.pointerSize)->Pointer<Int32>
        def refCnt := refCntPtr.get()
        if refCnt = LLVMBackend.NO_REFCNT.asInt32 {
            return
        }
        if refCnt = 1 {
            destroyObject(o)
        }
        else {
            refCntPtr.set(refCnt - 1)
        }
    }

    method getBuiltin(m:MethodDecl):(Context, FixedArray<IR.Value>)=&>(Int64) {
        var builtin := builtins[m]
        if builtin == null {
            def signature := m.owner.name + " " + m.declaration
            match signature {
                when "frost.core.Frost method frost.core.Frost.alloc(size:builtin_int):builtin_int" {
                    builtin := method(context:Context, args:FixedArray<IR.Value>):Int64 {
                        return Int(Frost.alloc(context.value(args[0]).asInt.value)).asInt64
                    }
                }
                when "frost.core.Frost method frost.core.Frost.destroy(ptr:builtin_int)" {
                    builtin := method(context:Context, args:FixedArray<IR.Value>):Int64 {
                        Frost.destroy(context.value(args[0]).asInt.value)
                        return -1
                    }
                }
                when "frost.core.Frost method frost.core.Frost.ref(o:frost.core.Object?)" {
                    builtin := method(context:Context, args:FixedArray<IR.Value>):Int64 {
                        self.ref(Pointer<UInt8>(context.value(args[0]).asInt))
                        return -1
                    }
                }
                when "frost.core.Frost method frost.core.Frost.unref(o:frost.core.Object?)" {
                    builtin := method(context:Context, args:FixedArray<IR.Value>):Int64 {
                        self.unref(Pointer<UInt8>(context.value(args[0]).asInt))
                        return -1
                    }
                }
                when "frost.core.Frost method frost.core.Frost.debugPrint(i:builtin_int64)" {
                    builtin := method(context:Context, args:FixedArray<IR.Value>):Int64 {
                        Frost.debugPrint(context.value(args[0]).value)
                        return -1
                    }
                }
                when "frost.io.Console method frost.io.Console.print(s:frost.core.String)" {
                    builtin := method(context:Context, args:FixedArray<IR.Value>):Int64 {
-*                        def p := context.value(args[0]).asInt
                        def s := Pointer<UInt8>(p).convertTo<String>()
                        Console.print(s)
                        return -1*-
                        unreachable
                    }
                }
                when "frost.io.Console function frost.io.Console.errorStream():frost.io.OutputStream" {
                    builtin := method(context:Context, args:FixedArray<IR.Value>):Int64 {
                        def interpreter := context.interpreter
                        def compiler := interpreter.compiler
                        def memoryLayout := compiler.memoryLayout
                        assert memoryLayout.pointerSize = memoryLayout.intSize
                        def type := Type("frost.io.FileOutputStream", Type.Kind.CLASS, Position(),
                                true)
                        def cl := compiler.getClass(type)!
                        compiler.resolve(cl)
                        def base := Pointer<UInt8>.alloc(interpreter.memoryLayout.sizeOf(type))
                        var current := base

                        -- class
                        assert compiler.instanceFields(cl)[0].name = "$class"
                        assert current.asInt - base.asInt = compiler.instanceFields(cl)[0].offset
                        current->Pointer<ClassDecl>.set(cl)
                        current += memoryLayout.pointerSize

                        -- refCount
                        assert compiler.instanceFields(cl)[1].name = "refCount"
                        assert current.asInt - base.asInt = compiler.instanceFields(cl)[1].offset
                        current->Pointer<Int32>.set(1)
                        current += 4

                        -- flags
                        assert compiler.instanceFields(cl)[2].name = "$flags"
                        assert current.asInt - base.asInt = compiler.instanceFields(cl)[2].offset
                        current->Pointer<Int8>.set(0)
                        current += 4

                        -- byteOrder
                        assert compiler.instanceFields(cl)[3].name = "byteOrder"
                        assert current.asInt - base.asInt = compiler.instanceFields(cl)[3].offset
                        current->Pointer<Int>.set(0)
                        current += memoryLayout.intSize

                        -- lineEnding
                        assert compiler.instanceFields(cl)[4].name = "lineEnding"
                        assert current.asInt - base.asInt = compiler.instanceFields(cl)[4].offset
                        current->Pointer<Int>.set(context.value(IR.Value.STRING("\n",
                                compiler.STRING_TYPE)).asInt)
                        current += memoryLayout.pointerSize

                        -- handle
                        assert compiler.instanceFields(cl)[5].name = "handle"
                        assert current.asInt - base.asInt = compiler.instanceFields(cl)[5].offset
                        current->Pointer<Int>.set(2)
                        current += memoryLayout.intSize

                        -- closeOnCleanup
                        assert compiler.instanceFields(cl)[6].name = "closeOnCleanup"
                        assert current.asInt - base.asInt = compiler.instanceFields(cl)[6].offset
                        current->Pointer<Bit>.set(false)
                        current += 1

                        return base.asInt.asInt64
                    }
                }
                when "frost.io.FileOutputStream method frost.io.FileOutputStream.write(ptr:frost.unsafe.Pointer<frost.core.UInt8>, size:frost.core.Int):frost.core.Error?" {
                    builtin := method(context:Context, args:FixedArray<IR.Value>):Int64 {
                        Console.printLine("printing some stuff to stderr")
                        return -1
                    }
                }
                otherwise {
                    Console.printLine("Fatal error: \{signature} is not supported by the " +
                            "interpreter")
                    System.exit(1)
                }
            }
            builtins[m] := builtin
        }
        return builtin
    }

    method callBuiltin(context:Context, m:MethodDecl, args:FixedArray<IR.Value>):Int64 {
        return getBuiltin(m)(context, args)
    }

    method cast(context:Context, id:IR.Statement.ID, v:IR.Value, t:Type) {
        def srcType := v.type()
        def value := context.value(v)
        if (compiler.isValue(srcType) & !compiler.isValue(t)) | (compiler.isValue(srcType) &
                t.typeKind = Type.Kind.NULLABLE & t.subtypes[0] = srcType) {
            -- wrap value
            def raw := Pointer<UInt8>.alloc(memoryLayout.sizeOfWrapper(srcType))
            def cl := compiler.getClass(srcType)!
            raw->Pointer<ClassDecl>.set(cl)
            var dest := raw + memoryLayout.pointerSize
            dest->Pointer<Int32>.set(1)
            -- FIXME alignment
            dest += 5
            var src:Pointer<UInt8>
            if needsStructPointer(srcType) {
                src := Pointer<UInt8>(value.asInt)
            }
            else {
                stack->Pointer<Int64>.set(value)
                src := stack
            }
            -- FIXME need memcpy
            for i in 0 .. memoryLayout.sizeOf(cl.type) {
                dest[i] := src[i]
            }
            context.statements[id.value] := raw.asInt.asInt64
            return
        }
        else if (!compiler.isValue(srcType) & compiler.isValue(t)) | (compiler.isValue(t) &
                srcType.typeKind = Type.Kind.NULLABLE & srcType.subtypes[0] = t) {
            -- unwrap value
            -- FIXME alignment
            def src := Pointer<UInt8>(value.asInt) + 13
            if needsStructPointer(srcType) {
                context.statements[id.value] := stack.asInt
                def size := memoryLayout.sizeOf(srcType)
                -- FIXME memcpy
                for i in 0 .. size {
                    stack[i] := src[i]
                }
                var start := stack
                stack += size
                context.statements[id.value] := start.asInt.asInt64
                return
            }
            else {
                context.statements[id.value] := src->Pointer<Int64>.get()
                return
            }
        }
        if srcType.isBuiltinInt & t.isBuiltinInt {
            if srcType.size > t.size {
                context.statements[id.value] := (value.asUInt64 &&
                        UInt64.MAX >> (64 - t.size).asUInt64).asInt64
                return
            }
            if srcType.size = t.size {
                context.statements[id.value] := value
                return
            }
        }
        context.statements[id.value] := value
    }

    method createStruct(context:Context, id:IR.Statement.ID, cl:ClassDecl,
            args:FixedArray<IR.Value>) {
        def size := memoryLayout.sizeOf(cl.type)
        var current := stack
        for a in args {
            def v := context.value(a)
            match memoryLayout.sizeOf(a.type()) {
                -- FIXME ALIGNMENT
                when 1 {
                    current.set(v.asUInt8)
                    current += 1
                }
                when 2 {
                    current->Pointer<Int16>.set(v.asInt16)
                    current += 2
                }
                when 4 {
                    current->Pointer<Int32>.set(v.asInt32)
                    current += 4
                }
                when 8 {
                    current->Pointer<Int64>.set(v)
                    current += 8
                }
                otherwise {
                    unreachable, "unsupported value \{a}"
                }
            }
        }
        if needsStructPointer(cl.type) {
            context.statements[id.value] := stack.asInt
            stack := current
        }
        else {
            for i in current.asInt .. stack.asInt + 8 {
                Pointer<UInt8>(i).set(0)
            }
            context.statements[id.value] := stack->Pointer<Int64>.get()
        }
    }

    method extractField(context:Context, id:IR.Statement.ID, value:IR.Value, field:FieldDecl) {
        if needsStructPointer(field.owner.type) {
            def p := Pointer<UInt8>(getFieldPointer(context, value, field))
            match memoryLayout.sizeOf(field.type) {
                when 1 {
                    context.statements[id.value] := p.get().asInt64
                }
                when 2 {
                    context.statements[id.value] := p->Pointer<UInt16>.get().asInt64
                }
                when 4 {
                    context.statements[id.value] := p->Pointer<UInt32>.get().asInt64
                }
                when 8 {
                    context.statements[id.value] := p->Pointer<UInt64>.get().asInt64
                }
                otherwise {
                    unreachable, "unsupported field size"
                }
            }
        }
        else {
            -- need to implement the full behavior...
            assert compiler.instanceFields(field.owner).count = 1
            context.statements[id.value] := context.value(value)
        }
    }

    method getFieldPointer(context:Context, value:IR.Value, field:FieldDecl):Int {
        -- force offset to be calculated
        if field.offset < 0 {
            memoryLayout.computeLayout(field.owner)
            assert field.offset >= 0
        }
        return context.value(value).asInt + field.offset
    }

    method getFieldPointer(context:Context, id:IR.Statement.ID, value:IR.Value, field:FieldDecl) {
        context.statements[id.value] := getFieldPointer(context, value, field)
    }

    function bit(b:Bit):Int64 {
        if b {
            return 1
        }
        return 0
    }

    method binary(context:Context, id:IR.Statement.ID, left:IR.Value, op:Binary.Operator,
            right:IR.Value) {
        def leftValue := context.value(left)
        def rightValue := context.value(right)
        match op {
            when Binary.Operator.ADD {
                context.statements[id.value] := leftValue + rightValue
            }
            when Binary.Operator.SUB {
                context.statements[id.value] := leftValue - rightValue
            }
            when Binary.Operator.MUL {
                context.statements[id.value] := leftValue * rightValue
            }
            when Binary.Operator.INTDIV {
                context.statements[id.value] := leftValue // rightValue
            }
            when Binary.Operator.REM {
                context.statements[id.value] := leftValue % rightValue
            }
            when Binary.Operator.BITWISEAND {
                context.statements[id.value] := leftValue && rightValue
            }
            when Binary.Operator.BITWISEOR {
                context.statements[id.value] := leftValue || rightValue
            }
            when Binary.Operator.BITWISEXOR {
                context.statements[id.value] := leftValue ~~ rightValue
            }
            when Binary.Operator.GT {
                context.statements[id.value] := bit(leftValue > rightValue)
            }
            when Binary.Operator.GTEQ {
                context.statements[id.value] := bit(leftValue >= rightValue)
            }
            when Binary.Operator.LT {
                context.statements[id.value] := bit(leftValue < rightValue)
            }
            when Binary.Operator.LTEQ {
                context.statements[id.value] := bit(leftValue <= rightValue)
            }
            when Binary.Operator.IDENTITY {
                if leftValue = rightValue {
                    context.statements[id.value] := 1
                }
                else {
                    context.statements[id.value] := 0
                }
            }
            when Binary.Operator.NIDENTITY {
                if leftValue != rightValue {
                    context.statements[id.value] := 1
                }
                else {
                    context.statements[id.value] := 0
                }
            }
            otherwise {
                unreachable, "unsupported binary operator '\{op}'"
            }
        }
    }

    method call(m:MethodDecl, args:FixedArray<IR.Value>):Int64 {
        return call(m, args, null)
    }

    method call(m:MethodDecl, args:FixedArray<IR.Value>, selfOverride:Int64?):Int64 {
        var code := methodCode[m]
        if code == null {
            if m.body !== null {
                compiler.compile(m.owner)
                code := methodCode[m]
                assert code !== null
            }
            else {
                return callBuiltin(contexts[0], m, args)
            }
        }
        def start:Int
        def context := Context(self, code)
        if selfOverride !== null {
            context.arguments.add(selfOverride)
            start := 1
        }
        else {
            start := 0
        }
        for i in start .. args.count {
            context.arguments.add(contexts[0].value(args[i]))
        }
        contexts.push(context)
        var block := 0
        var statement := 0
        loop {
            def id := code.ids[block][statement]
            def stmt := code.ir[block][statement]
            Console.printLine(stmt)
            match stmt {
                when IR.Statement.BINARY(_, left, op, right, _) {
                    binary(context, id, left, op, right)
                }
                when IR.Statement.BRANCH(_, target) {
                    block := code.blocks[target.value]
                    statement := 0
                    continue
                }
                when IR.Statement.CAST(_, v, t, _) {
                    cast(context, id, v, t)
                }
                when IR.Statement.COMMENT {
                }
                when IR.Statement.CONDITIONAL_BRANCH(_, test, target1, target2) {
                    if context.value(test) != 0 {
                        block := code.blocks[target1.value]
                    }
                    else {
                        block := code.blocks[target2.value]
                    }
                    statement := 0
                    continue
                }
                when IR.Statement.CONSTRUCT(_, cl) {
                    def raw := Pointer<UInt8>.alloc(memoryLayout.sizeOf(cl.type))
                    raw->Pointer<ClassDecl>.set(cl)
                    Pointer<Int32>((raw + memoryLayout.pointerSize).asInt).set(1)
                    context.statements[id.value] := raw.asInt.asInt64
                }
                when IR.Statement.CREATE_STRUCT(_, cl, args) {
                    createStruct(context, id, cl, args)
                }
                when IR.Statement.DYNAMIC_CALL(_, value, args) {
-*                    def target := Pointer<UInt8>(context.value(value).asInt).convertTo<MethodDecl>()
                    def selfOverride:Int64?
                    if compiler!.isValue(target.owner) {
                        cast(context, id, args[0], target.owner.type)
                        selfOverride := context.statements[id.value]
                    }
                    else {
                        selfOverride := null
                    }
                    context.statements[id.value] := call(target, args, selfOverride)*-
                    unreachable
                }
                when IR.Statement.EXTRACT_FIELD(_, value, field) {
                    extractField(context, id, value, field)
                }
                when IR.Statement.GET_FIELD_POINTER(_, value, field) {
                    getFieldPointer(context, id, value, field)
                }
                when IR.Statement.GET_VIRTUAL_METHOD(_, target, index, _) {
-*                    def p := Pointer<Int>(context.value(target).asInt)
                    def cl := Pointer<UInt8>(p.get()).convertTo<ClassDecl>()
                    def m := compiler.getVTable(cl)[index]
                    context.statements[id.value] := Frost.addressOf(m)*-
                    unreachable
                }
                when IR.Statement.LOAD(_, source) {
                    def p := Pointer<Int>(context.value(source).asInt)
                    if needsStructPointer(source.type()) {
                        context.statements[id.value] := p.asInt
                    }
                    else {
                        context.statements[id.value] := p.get()
                    }
                }
                when IR.Statement.NEGATE(_, v) {
                    context.statements[id.value] := -context.value(v)
                }
                when IR.Statement.POINTER_GET_INDEX(_, p, index, type) {
                    def src := Pointer<UInt8>((context.value(p) + context.value(index) *
                            memoryLayout.sizeOf(type)).asInt)
                    stack->Pointer<Int64>.set(0)
                    for i in 0 .. memoryLayout.sizeOf(type).min(8) {
                        stack[i] := src[i]
                    }
                    context.statements[id.value] := stack->Pointer<Int64>.get()
                }
                when IR.Statement.POINTER_SET_INDEX(_, value, p, index, type) {
                    def dest := Pointer<UInt8>((context.value(p) + context.value(index) *
                            memoryLayout.sizeOf(value.type())).asInt)
                    def v := context.value(value)
                    stack->Pointer<Int64>.set(v)
                    for i in 0 .. memoryLayout.sizeOf(value.type()).min(8) {
                        dest[i] := stack[i]
                    }
                }
                when IR.Statement.RETURN(_, value) {
                    contexts.pop()
                    if value !== null {
                        return context.value(value)
                    }
                    return -1
                }
                when IR.Statement.STATIC_CALL(_, target, args) {
                    context.statements[id.value] := call(target, args)
                }
                when IR.Statement.STORE(_, source, dest) {
                    def v := context.value(source)
                    def p := context.value(dest)
                    Pointer<Int64>(p.asInt).set(v)
                }
                otherwise {
                    unreachable, "unsupported statement: \{stmt}"
                }
            }
            statement += 1
        }
    }

    method run() {
        if main == null {
            Console.printLine("no main method")
            System.exit(1)
        }
        call(main, FixedArray<IR.Value>())
        contexts.push(Context(self, MethodCode([], [], [], [], 0)))
        for v in strings.values {
            destroyObject(Pointer<UInt8>(v.asInt))
        }
        strings.clear()
        contexts.pop()
        builtins.clear()
        assert contexts.count = 0
    }
}