package org.frostlang.frostc

uses frost.unsafe.Pointer

@final
class Interpreter : Backend {
    class Context {
        @weak
        def interpreter:Interpreter

        -- if the value fits into an Int64, contains the value. Otherwise, contains a Pointer to
        -- the value.
        def arguments:Array<Int64>

        -- if the value fits into an Int64, contains the value. Otherwise, contains a Pointer to
        -- the value.
        def statements := HashMap<Code.Statement.ID, Int64>()

        init(interpreter:Interpreter) {
            self.interpreter := interpreter

            arguments := Array<Int64>()
        }

        method value64(v:Code.Value):Int64 {
            match v {
                when Code.Value.ARRAY(t, _) {
                    def result := Interpreter.alignUp(interpreter.stack,
                            t.alignment(interpreter.settings!)).asUInt.asInt64
                    interpreter.stack := interpreter.write(v, interpreter.stack)
                    return result
                }
                when Code.Value.BIT(b) {
                    return b.choose(1, 0)
                }
                when Code.Value.CHARS(s) {
                    def result := interpreter.stack.asUInt.asInt64
                    interpreter.stack := interpreter.write(v, interpreter.stack)
                    return result
                }
                when Code.Value.CHOICE_FIELD_OFFSET(cc, index) {
                    return (interpreter.cg.struct(cc.owner).elementOffset(interpreter.settings!,
                                CodeGenerator.CHOICE_DATA_INDEX) +
                            Code.PrimitiveType.STRUCT(FixedArray<Code.PrimitiveType>(
                                cc.fields.map(interpreter.cg.primitiveType))).elementOffset(
                                    interpreter.settings!, index))
                }
                when Code.Value.FIELD_OFFSET(t, index) {
                    return t.elementOffset(interpreter.settings!, index).asInt64
                }
                when Code.Value.GLOBAL_POINTER(index) {
                    return (interpreter.globalMemory + interpreter.globals[index][1]).asUInt.asInt64
                }
                when Code.Value.INT(i, type) {
                    match type.size(interpreter.settings) {
                        when 1 { return i.asInt8.asInt64 }
                        when 2 { return i.asInt16.asInt64 }
                        when 4 { return i.asInt32.asInt64 }
                        when 8 { return i.asInt64 }
                        otherwise { unreachable }
                    }
                }
                when Code.Value.ITABLE_OFFSET(index) {
                    return ((2 + index) * interpreter.settings!.intSize).asInt64
                }
                when Code.Value.REAL(r, _) {
                    return Frost.floatToIntBits(r)
                }
                when Code.Value.METHOD_POINTER(signature) {
                    return interpreter.getMethodPointer(signature)
                }
                when Code.Value.PARAMETER(idx, _) {
                    return arguments[idx]
                }
                when Code.Value.REF(indirect) {
                    return value(indirect.value)
                }
                when Code.Value.SIZE_OF(t) {
                    return t.size(interpreter.settings!).asInt64
                }
                when Code.Value.STATEMENT(id, type) {
                    assert statements.contains(id)
                    return statements[id]
                }
                when Code.Value.STRUCT(args) {
                    def alignment := args.map(
                            a => a.type.alignment(self.interpreter.settings!)).fold(Int.max)
                    def result := Interpreter.alignUp(interpreter.stack, alignment).asUInt.asInt64
                    interpreter.stack := interpreter.write(v, interpreter.stack)
                    return result
                }
                when Code.Value.UNDEFINED(t) {
                    return 0
                }
                when Code.Value.VTABLE_OFFSET(cc, index) {
                    def ccType:Code.PrimitiveType
                    match cc {
                        when Code.Value.GLOBAL_POINTER(idx) {
                            ccType := interpreter.cg.globals[idx].type
                        }
                        otherwise {
                            unreachable
                        }
                    }
                    return (ccType.elementOffset(interpreter.settings!,
                            CodeGenerator.VTABLE_INDEX) +
                            index * interpreter.settings!.intSize).asInt64
                }
                otherwise {
                    unreachable, "unsupported value \{v}"
                }
            }
        }

        method value(v:Code.Value):Int64 {
            def result := value64(v)

            match v.type {
                when Code.PrimitiveType.INT, Code.PrimitiveType.INT8, Code.PrimitiveType.INT16,
                        Code.PrimitiveType.INT32, Code.PrimitiveType.INT64 {
                    match v.type.size(interpreter.settings) {
                        when 1 { return (result << 56) >> 56  }
                        when 2 { return (result << 48) >> 48 }
                        when 4 { return (result << 32) >> 32 }
                        when 8 { return result }
                        otherwise { unreachable }
                    }
                }
                otherwise { return result }
            }
        }

        method valueU(v:Code.Value):UInt64 {
            def result := value(v)
            match v.type.size(interpreter.settings) {
                when 1 { return result.asUInt64 && 0xFF }
                when 2 { return result.asUInt64 && 0xFFFF }
                when 4 { return result.asUInt64 && 0xFFFFFFFF }
                when 8 { return result.asUInt64 }
                otherwise { unreachable }
            }
        }

        method floatValue(v:Code.Value):Real64 {
            return Frost.intBitsToFloat(value(v))
        }
    }

    class InterpreterCode {
        def blocks := HashMap<Code.Block.ID, Code.Block>()

        init(code:Code) {
            for b in code.blocks {
                blocks[b.id] := b
            }
        }
    }

    constant NO_REFCNT := -999

    constant OBJECT_FIELD_COUNT := 3

    def physicalOut:OutputStream

    def out:OutputStream

    @weak
    def compiler:Compiler?

    def cg:CodeGenerator?

    def settings:Compiler.Settings?

    def stackSize := 1 << 20

    constant MEMORY_SIZE := 1 << 20

    def stackBase := Pointer<Int8>.alloc(stackSize)

    def stack := stackBase

    -- the ints are offsets into globalMemory
    def globals := Array<(Code.Value?, Int)>()

    def globalIndices := IdentityMap<Code.Global, Int>()

    var nextGlobal := 0

    def globalMemory := Pointer<Int8>.alloc(MEMORY_SIZE)

    def interpreterCode := HashMap<String, InterpreterCode>()

    def methodIndices := HashMap<String, Int64>()

    def methods := Array<Code.Signature>()

    def contexts := Stack<Context>()

    def builtins := HashMap<String, (Context, FixedArray<Code.Value>)=&>(Int64)>()

    init() {
        methods.add(Code.Signature(null, null, "<null method pointer>",
                FixedArray<Code.PrimitiveType>(), false))
    }

    @override
    method cleanup() {
        stackBase.destroy()
        globalMemory.destroy()
    }

    @class
    @pre(align > 0)
    @post(@return % align = 0)
    function alignUp(i:Int, align:Int):Int {
        if i % align != 0 {
            return i + align - i % align
        }
        return i
    }

    @class
    @pre(align > 0)
    @post(@return.asUInt % align = 0)
    function alignUp<T>(p:Pointer<T>, align:Int):Pointer<T> {
        def offset := p.asUInt
        if offset % align != 0 {
            return Pointer<T>(offset + align.asUInt - offset % align.asUInt)
        }
        return p
    }


    @override
    method setCompiler(compiler:Compiler) {
        self.compiler := compiler
        self.cg := compiler.cg
        self.settings := compiler.settings
    }

    @override
    method writeSignature(s:Code.Signature) {
    }

    method createStruct(id:Code.Statement.ID, type:Code.PrimitiveType,
            args:FixedArray<Code.Value>) {
        contexts[0].statements[id] := contexts[0].value(Code.Value.STRUCT(args))
    }

    @pre((id == null) = (returnType == null))
    method dynamicCall(id:Code.Statement.ID?, returnType:Code.PrimitiveType?, m:Code.Value,
            args:FixedArray<Code.Value>) {
        def signature := methods[contexts[0].value(m).asInt]
        def result := call(signature, args)
        if id !== null {
            contexts[0].statements[id] := result
        }
    }

    @class
    function int(b:Bit):Int64 {
        if b {
            return 1
        }
        return 0
    }

    method destroyObject(o:Pointer<Int8>) {
        -- call cleanup
        def offset:UInt
        match compiler.settings.intSize {
            when 4 { offset := 28 }
            when 8 { offset := 48 }
            otherwise { unreachable }
        }
        def cleanup := Pointer<UInt>(o->Pointer<UInt>.get() + offset).get()
        dynamicCall(null, null, Code.Value.INT(cleanup.asUInt64, Code.PrimitiveType.INT),
                FixedArray<Code.Value>.from([Code.Value.INT(o.asUInt.asUInt64,
                    Code.PrimitiveType.INT)]))
        o.destroy()
    }

    method ref(o:Pointer<Int8>) {
        if o.asUInt = 0 {
            return
        }
        def refCntPtr := (o + settings.intSize)->Pointer<Int32>
        def refCnt := refCntPtr.get()
        if refCnt = NO_REFCNT.asInt32 {
            return
        }
        refCntPtr.set(refCnt + 1)
    }

    method unref(o:Pointer<Int8>) {
        if o.asUInt = 0 {
            return
        }
        def refCntPtr := (o + settings.intSize)->Pointer<Int32>
        def refCnt := refCntPtr.get()
        if refCnt = NO_REFCNT.asInt32 {
            return
        }
        if refCnt = 1 {
            destroyObject(o)
        }
        else {
            refCntPtr.set(refCnt - 1)
        }
    }

    method getInterpreterCode(s:Code.Signature):InterpreterCode? {
        var result := interpreterCode[s.name]
        if result == null & s.methodDecl !== null & !s.methodDecl.annotations.isExternal {
            def cl := s.methodDecl.owner
            def auto := Compiler.AutoScope(compiler, compiler.getSymbolTable(cl))
            compiler.currentClass.push(cl)
            compiler.resolve(cl)
            compiler.compile(s.methodDecl)
            if compiler.showErrors() {
                return null
            }
            -- create the shim, if needed
            cg.getMethodTableEntry(s.methodDecl)
            def shim := cg.methodShims[s.methodDecl]
            if shim !== null {
                -- FIXME shouldn't need !'s
                interpreterCode[shim![0].name] := InterpreterCode(shim![1])
            }
            compiler.currentClass.pop()
            result := interpreterCode[s.name]
            assert result !== null, "didn't receive code for \{s.name}"
        }
        return result
    }

    @class
    method dump(p:Pointer<Int8>, count:Int) {
        Console.printLine("Dumping \{p}:")
        for i in 0 .. count {
            Console.printLine("\{i, >5}: \{p[i]:x}")
        }
    }

    ================================================================================================
    Creates an interpreter string from a native Frost string. While interpreter objects have the
    same memory layout as their native counterparts, they differ in that their class pointer points
    to a ClassDecl rather than to a Class. We could in theory convert the objects back and forth by
    simply updating the class pointer, and might do that in the future, but right this second we're
    playing things safe and keeping interpreter objects and Frost objects segregated.
    ================================================================================================
    method interpreterStringFrom(str:String?):Int64 {
        if str == null {
            return 0
        }
        def cl := compiler.getClass("frost.core.String")!
        def cc := cg.getClassConstant(cl)
        def type := cg.struct(cl)
        def copy := Pointer<Char8>.alloc(str.byteLength)
        -- FIXME memcpy
        for i in 0 .. str.byteLength {
            copy[i] := str.data[i]
        }
        def result := heapAlloc(type, cc)
        assert cl.methods[0].name = "init"
        call(cg.getSignature(cl.methods[0]),
                FixedArray<Code.Value>.from([Code.Value.INT(result.asUInt64,
                    Code.PrimitiveType.INT), Code.Value.INT(copy.asUInt.asUInt64,
                    Code.PrimitiveType.INT), Code.Value.INT(str.byteLength.asUInt64,
                    Code.PrimitiveType.INT)]))
        return result
    }

    ================================================================================================
    Creates a native Frost string from an interpreter string. See the comment on
    [interpreterStringFrom] for why this is necessary.
    ================================================================================================
    method frostStringFrom(value:Int64):String {
        def cl := compiler.getClass("frost.core.String")!
        def type := cg.struct(cl)
        def data := Pointer<Pointer<Char8>>(value.asUInt +
                type.elementOffset(settings, OBJECT_FIELD_COUNT).asUInt).get()
        def length := Pointer<Int>(value.asUInt +
                type.elementOffset(settings, OBJECT_FIELD_COUNT + 1).asUInt).get()
        def copy := Pointer<Char8>.alloc(length)
        -- FIXME memcpy
        for i in 0 .. length {
            copy[i] := data[i]
        }
        return String(copy, length)
    }

    method getBuiltin(s:Code.Signature):(Context, FixedArray<Code.Value>)=&>(Int64) {
        var builtin := builtins[s.name]
        if builtin == null {
            def intSize := settings.intSize
            def weakSelf := Weak<Interpreter>(self)
            -- note that while the objects match the structure and layout of "real" Frost objects,
            -- the class pointers and vtable / itable entries are not the same. Thus it is sometimes
            -- possible to call the "real" Frost method directly on an object, and sometimes not,
            -- depending upon what that method does with the object. Anything that involves making
            -- dynamic method calls is right out.
            match s.name {
                when "frost$core$Frost$unrefThreadSafe$frost$core$Object$Q" {
                    builtin := method(context:Context, args:FixedArray<Code.Value>):Int64 {
                        weakSelf.get().unref(Pointer<Int8>(context.value(args[0]).asUInt))
                        return -1
                    }
                }
                when "frost$core$Frost$alloc$builtin_int$R$builtin_uint" {
                    builtin := method(context:Context, args:FixedArray<Code.Value>):Int64 {
                        return UInt(Frost.alloc(context.value(args[0]).asInt.value)).asInt64
                    }
                }
                when "frost$core$Frost$destroy$builtin_uint" {
                    builtin := method(context:Context, args:FixedArray<Code.Value>):Int64 {
                        Frost.destroy(context.value(args[0]).asUInt.value)
                        return -1
                    }
                }
                when "frost$core$Frost$realloc$builtin_uint$builtin_int$builtin_int$R$builtin_uint" {
                    builtin := method(context:Context, args:FixedArray<Code.Value>):Int64 {
                        return UInt(Frost.realloc(context.value(args[0]).asUInt.value,
                                context.value(args[1]).asInt.value,
                                context.value(args[2]).asInt.value)).asInt64
                    }
                }
                when "frost$core$Frost$debugPrint$builtin_int64" {
                    builtin := method(context:Context, args:FixedArray<Code.Value>):Int64 {
                        Console.printLine("Debug: \{context.value(args[0])}")
                        return -1
                    }
                }
                when "frost$io$Console$read$R$frost$core$Char8$Q" {
                    builtin := method(context:Context, args:FixedArray<Code.Value>):Int64 {
                        def target := Pointer<Char8?>(context.value(args[0]).asUInt)
                        target.set(Console.read())
                        return -1
                    }
                }
                when "frost$io$Console$print$frost$core$String" {
                    def out := Console.outputStream()
                    builtin := method(context:Context, args:FixedArray<Code.Value>):Int64 {
                        def p := context.value(args[0]).asUInt
                        def s := Pointer<Int8>(p).convertTo<String>()
                        def error := out.write(s.data, s.byteLength)
                        assert error == null
                        return -1
                    }
                }
                when "frost$io$Console$outputStream$R$frost$io$OutputStream",
                        "frost$io$Console$errorStream$R$frost$io$OutputStream" {
                    def cl := compiler.getClass("frost.io.FileOutputStream")!
                    def cc := cg.getClassConstant(cl)
                    def type := cg.struct(cl)
                    builtin := method(context:Context, args:FixedArray<Code.Value>):Int64 {
                        def result := weakSelf.get().heapAlloc(type, cc)
                        assert cl.methods[0].name = "init"
                        weakSelf.get().call(weakSelf.get().cg.getSignature(cl.methods[0]),
                                FixedArray<Code.Value>.from([Code.Value.INT(result.asUInt64,
                                    Code.PrimitiveType.INT)]))
                        -- Note that we don't bother to initialize the stream's native handle. See
                        -- the comment in FileOutputStream.write below.
                        return result
                    }
                }
                when "frost$io$FileOutputStream$write$frost$unsafe$Pointer$LTfrost$core$UInt8$GT$frost$core$Int$R$frost$core$Error$Q" {
                    -- There's currently no way to get a FileOutputStream in interpreted code other
                    -- than Console.outputStream / errorStream, so we just assume that we should be
                    -- writing to stdout (we don't bother to separate stdout / stderr at the moment)
                    def out := Console.outputStream()
                    builtin := method(context:Context, args:FixedArray<Code.Value>):Int64 {
                        def p := context.value(args[1]).asUInt
                        def error := out.write(Pointer<Int8>(p), context.value(args[2]).asInt)
                        assert error == null
                        return 0
                    }
                }
                when "frost$core$Real64$get_toString$R$frost$core$String" {
                    builtin := method(context:Context, args:FixedArray<Code.Value>):Int64 {
                        def str := Frost.intBitsToFloat(context.value(args[0])).toString
                        return weakSelf.get().interpreterStringFrom(str)
                    }
                }
                when "frost$core$RegularExpression$compile$frost$core$String$frost$core$Int" {
                    def cl := compiler.getClass("frost.core.RegularExpression")!
                    def type := cg.struct(cl)
                    builtin := method(context:Context, args:FixedArray<Code.Value>):Int64 {
                        def str := weakSelf.get().frostStringFrom(context.value(args[1]))
                        def flags := context.value(args[2]).asInt
                        def r := RegularExpression(str, flags)
                        def offset := type.elementOffset(weakSelf.get().settings,
                                Interpreter.OBJECT_FIELD_COUNT).asUInt
                        Pointer<RegularExpression>(context.value(args[0]).asUInt + offset).set(r)
                        return -1
                    }
                }
                when "frost$core$RegularExpression$matcher$frost$core$String$R$frost$core$Matcher" {
                    def rcl := compiler.getClass("frost.core.RegularExpression")!
                    def mcl := compiler.getClass("frost.core.Matcher")!
                    def mcc := cg.getClassConstant(mcl)
                    def mtype := cg.struct(mcl)
                    builtin := method(context:Context, args:FixedArray<Code.Value>):Int64 {
                        def result := weakSelf.get().heapAlloc(mtype, mcc)
                        def offset := mtype.elementOffset(weakSelf.get().settings,
                                Interpreter.OBJECT_FIELD_COUNT).asUInt
                        def r := Pointer<RegularExpression>(context.value(args[0]).asUInt +
                                offset).get()
                        def m := r.matcher(weakSelf.get().frostStringFrom(context.value(args[1])))
                        Pointer<Matcher>(result.asUInt + offset).set(m)
                        Pointer<Int>(result.asUInt + offset +
                                weakSelf.get().settings.intSize.asUInt).set(
                                    context.value(args[1]).asInt)
                        return result
                    }
                }
                when "frost$core$Matcher$matches$R$frost$core$Bit" {
                    def cl := compiler.getClass("frost.core.Matcher")!
                    def type := cg.struct(cl)
                    builtin := method(context:Context, args:FixedArray<Code.Value>):Int64 {
                        def offset := type.elementOffset(weakSelf.get().settings,
                                Interpreter.OBJECT_FIELD_COUNT).asUInt
                        def m := Pointer<Matcher>(context.value(args[0]).asUInt + offset).get()
                        return m.matches().choose(1, 0)
                    }
                }
                when "frost$core$Matcher$get_groupCount$R$frost$core$Int" {
                    def cl := compiler.getClass("frost.core.Matcher")!
                    def type := cg.struct(cl)
                    builtin := method(context:Context, args:FixedArray<Code.Value>):Int64 {
                        def offset := type.elementOffset(weakSelf.get().settings,
                                Interpreter.OBJECT_FIELD_COUNT).asUInt
                        def m := Pointer<Matcher>(context.value(args[0]).asUInt + offset).get()
                        return m.groupCount.asInt64
                    }
                }
                when "frost$core$Matcher$group$frost$core$Int$R$frost$core$String$Q" {
                    def cl := compiler.getClass("frost.core.Matcher")!
                    def type := cg.struct(cl)
                    builtin := method(context:Context, args:FixedArray<Code.Value>):Int64 {
                        def offset := type.elementOffset(weakSelf.get().settings,
                                Interpreter.OBJECT_FIELD_COUNT).asUInt
                        def m := Pointer<Matcher>(context.value(args[0]).asUInt + offset).get()
                        return weakSelf.get().interpreterStringFrom(
                                m.group(context.value(args[1]).asInt))
                    }
                }
                when "frost$core$Matcher$nativeFind$frost$core$String$Index$R$frost$core$Bit" {
                    def cl := compiler.getClass("frost.core.Matcher")!
                    def type := cg.struct(cl)
                    builtin := method(context:Context, args:FixedArray<Code.Value>):Int64 {
                        def offset := type.elementOffset(weakSelf.get().settings,
                                Interpreter.OBJECT_FIELD_COUNT).asUInt
                        def m := Pointer<Matcher>(context.value(args[0]).asUInt + offset).get()
                        return m.nativeFind(String.Index(context.value(args[1]).asInt)).choose(1, 0)
                    }
                }
                when "frost$core$Matcher$get_start$R$frost$core$String$Index" {
                    def cl := compiler.getClass("frost.core.Matcher")!
                    def type := cg.struct(cl)
                    builtin := method(context:Context, args:FixedArray<Code.Value>):Int64 {
                        def offset := type.elementOffset(weakSelf.get().settings,
                                Interpreter.OBJECT_FIELD_COUNT).asUInt
                        def m := Pointer<Matcher>(context.value(args[0]).asUInt + offset).get()
                        return m.start.byteOffset.asInt64
                    }
                }
                when "frost$core$Matcher$get_end$R$frost$core$String$Index" {
                    def cl := compiler.getClass("frost.core.Matcher")!
                    def type := cg.struct(cl)
                    builtin := method(context:Context, args:FixedArray<Code.Value>):Int64 {
                        def offset := type.elementOffset(weakSelf.get().settings,
                                Interpreter.OBJECT_FIELD_COUNT).asUInt
                        def m := Pointer<Matcher>(context.value(args[0]).asUInt + offset).get()
                        return m.end.byteOffset.asInt64
                    }
                }
                when "frost$core$Matcher$destroy" {
                    def cl := compiler.getClass("frost.core.Matcher")!
                    def type := cg.struct(cl)
                    builtin := method(context:Context, args:FixedArray<Code.Value>):Int64 {
                        def offset := type.elementOffset(weakSelf.get().settings,
                                Interpreter.OBJECT_FIELD_COUNT).asUInt
                        Pointer<Matcher>(context.value(args[0]).asUInt + offset).clear(0)
                        return -1
                    }
                }
                when "frost$core$RegularExpression$destroy" {
                    def cl := compiler.getClass("frost.core.RegularExpression")!
                    def type := cg.struct(cl)
                    builtin := method(context:Context, args:FixedArray<Code.Value>):Int64 {
                        def offset := type.elementOffset(weakSelf.get().settings,
                                Interpreter.OBJECT_FIELD_COUNT).asUInt
                        Pointer<frost.core.RegularExpression>(context.value(args[0]).asUInt +
                                offset).clear(0)
                        return -1
                    }
                }
                when "frost$core$Frost$addressOf$frost$core$Object$R$frost$core$Int" {
                    builtin := method(context:Context, args:FixedArray<Code.Value>):Int64 {
                        return context.value(args[0]).asInt
                    }
                }
                otherwise {
                    if s.name.startsWith("frost$core$Frost$ref") {
                        builtin := method(context:Context, args:FixedArray<Code.Value>):Int64 {
                            weakSelf.get().ref(Pointer<Int8>(context.value(args[0]).asUInt))
                            return -1
                        }
                    }
                    else if s.name.startsWith("frost$core$Frost$unref") {
                        builtin := method(context:Context, args:FixedArray<Code.Value>):Int64 {
                            weakSelf.get().unref(Pointer<Int8>(context.value(args[0]).asUInt))
                            return -1
                        }
                    }
                    else {
                        Console.printLine("Fatal error: \{s.name} is not supported by the " +
                                "interpreter")
                        System.exit(1)
                    }
                }
            }
            builtins[s.name] := builtin
        }
        return builtin
    }

    method load(target:Code.Statement.ID, value:Code.Value, type:Code.PrimitiveType) {
        def ptr := Pointer<Int8>(contexts[0].value(value).asUInt)
        load(target, ptr, type)
    }

    method load(target:Code.Statement.ID, ptr:Pointer<Int8>, type:Code.PrimitiveType) {
        match type {
            when Code.PrimitiveType.INT8, Code.PrimitiveType.BIT {
                contexts[0].statements[target] := ptr.get().asInt64
            }
            when Code.PrimitiveType.INT16 {
                contexts[0].statements[target] := ptr->Pointer<Int16>.get().asInt64
            }
            when Code.PrimitiveType.INT32, Code.PrimitiveType.FLOAT32 {
                contexts[0].statements[target] := ptr->Pointer<Int32>.get().asInt64
            }
            when Code.PrimitiveType.INT64, Code.PrimitiveType.FLOAT64 {
                contexts[0].statements[target] := ptr->Pointer<Int64>.get()
            }
            when Code.PrimitiveType.INT {
                match settings.intSize {
                    when 4 { contexts[0].statements[target] := ptr->Pointer<UInt32>.get().asUInt64.asInt64 }
                    when 8 { contexts[0].statements[target] := ptr->Pointer<Int64>.get() }
                    otherwise { unreachable }
                }
            }
            when Code.PrimitiveType.ARRAY, Code.PrimitiveType.STRUCT {
                stack := alignUp(stack, type.alignment(settings!))
                contexts[0].statements[target] := stack.asUInt.asInt64
                -- FIXME need memcpy
                for i in 0 .. type.size(settings!) {
                    stack[i] := ptr[i]
                }
                stack += type.size(settings!)
            }
            otherwise {
                unreachable
            }
        }
    }

    method convert(result:Code.Statement.ID, value:Code.Value, target:Code.PrimitiveType,
            signed:Bit) {
        if signed {
            def v := contexts[0].value(value)
            match target.size(settings!) {
                when 1 { contexts[0].statements[result] := v.asInt8.asInt64 }
                when 2 { contexts[0].statements[result] := v.asInt16.asInt64 }
                when 4 { contexts[0].statements[result] := v.asInt32.asInt64 }
                when 8 { contexts[0].statements[result] := v }
                otherwise { unreachable }
            }
        }
        else {
            contexts[0].statements[result] := contexts[0].valueU(value).asInt64
        }
    }

    method heapAlloc(type:Code.PrimitiveType, classConstant:Code.Value):Int64 {
        def raw := Pointer<Int8>.alloc(type.size(settings!))
        match settings.intSize {
            when 4 { raw->Pointer<Int32>.set(contexts[0].value(classConstant).asInt32) }
            when 8 { raw->Pointer<Int64>.set(contexts[0].value(classConstant)) }
            otherwise { unreachable }
        }
        Pointer<Int32>((raw + settings.intSize).asUInt).set(1)
        return raw.asUInt.asInt64
    }

    method call(s:Code.Signature, args:FixedArray<Code.Value>):Int64 {
        def code := getInterpreterCode(s)
        if code == null {
            def builtin := getBuiltin(s)
            return builtin(contexts[0], args)
        }
        def context := Context(self)
        for a in args {
            context.arguments.add(contexts[0].value(a))
        }
        contexts.push(context)
        var block := code.blocks[Code.Block.ID(0)]
        var statement := 0
        def stackStart := stack
        outer: loop {
            def stmt := block.statements[statement]
            match stmt {
                when Code.Statement.ADDI(_, result, left, right, wrap) {
                    context.statements[result] := context.value(left) + context.value(right)
                }
                when Code.Statement.ADDF(_, result, left, right) {
                    context.statements[result] := Frost.floatToIntBits(context.floatValue(left) +
                            context.floatValue(right))
                }
                when Code.Statement.SUBI(_, result, left, right, wrap) {
                    context.statements[result] := context.value(left) - context.value(right)
                }
                when Code.Statement.SUBF(_, result, left, right) {
                    context.statements[result] := Frost.floatToIntBits(context.floatValue(left) -
                            context.floatValue(right))
                }
                when Code.Statement.MULI(_, result, left, right, wrap) {
                    context.statements[result] := context.value(left) * context.value(right)
                }
                when Code.Statement.MULF(_, result, left, right) {
                    context.statements[result] := Frost.floatToIntBits(context.floatValue(left) *
                            context.floatValue(right))
                }
                when Code.Statement.DIVS(_, result, left, right, wrap) {
                    context.statements[result] := context.value(left) // context.value(right)
                }
                when Code.Statement.DIVU(_, result, left, right) {
                    context.statements[result] := (context.valueU(left) //
                            context.valueU(right)).asInt64
                }
                when Code.Statement.DIVF(_, result, left, right) {
                    context.statements[result] := Frost.floatToIntBits(context.floatValue(left) /
                            context.floatValue(right))
                }
                when Code.Statement.REMS(_, result, left, right) {
                    context.statements[result] := context.value(left) % context.value(right)
                }
                when Code.Statement.REMU(_, result, left, right) {
                    context.statements[result] := (context.valueU(left) %
                            context.valueU(right)).asInt64
                }
                when Code.Statement.ANDI(_, result, left, right) {
                    context.statements[result] := context.value(left) && context.value(right)
                }
                when Code.Statement.ANDB(_, result, left, right) {
                    context.statements[result] := int(context.value(left) != 0 &
                            context.value(right) != 0)
                }
                when Code.Statement.ORI(_, result, left, right) {
                    context.statements[result] := context.value(left) || context.value(right)
                }
                when Code.Statement.ORB(_, result, left, right) {
                    context.statements[result] := int(context.value(left) != 0 |
                            context.value(right) != 0)
                }
                when Code.Statement.XORI(_, result, left, right) {
                    context.statements[result] := context.value(left) ~~ context.value(right)
                }
                when Code.Statement.XORB(_, result, left, right) {
                    context.statements[result] := int(context.value(left) != 0 ~
                            context.value(right) != 0)
                }
                when Code.Statement.SHRS(_, result, left, right) {
                    context.statements[result] := context.value(left) >> context.value(right)
                }
                when Code.Statement.SHRU(_, result, left, right) {
                    context.statements[result] := (context.valueU(left) >>
                            context.valueU(right)).asInt64
                }
                when Code.Statement.SHL(_, result, left, right, wrap) {
                    context.statements[result] := context.value(left) << context.value(right)
                }
                when Code.Statement.EQI(_, result, left, right) {
                    context.statements[result] := int(context.value(left) = context.value(right))
                }
                when Code.Statement.EQF(_, result, left, right) {
                    context.statements[result] := int(context.floatValue(left) =
                            context.floatValue(right))
                }
                when Code.Statement.NEQI(_, result, left, right) {
                    context.statements[result] := int(context.value(left) != context.value(right))
                }
                when Code.Statement.NEQF(_, result, left, right) {
                    context.statements[result] := int(context.floatValue(left) !=
                            context.floatValue(right))
                }
                when Code.Statement.GTS(_, result, left, right) {
                    context.statements[result] := int(context.value(left) > context.value(right))
                }
                when Code.Statement.GTU(_, result, left, right) {
                    context.statements[result] := int(context.valueU(left) >
                            context.valueU(right))
                }
                when Code.Statement.GTF(_, result, left, right) {
                    context.statements[result] := int(context.floatValue(left) >
                            context.floatValue(right))
                }
                when Code.Statement.GES(_, result, left, right) {
                    context.statements[result] := int(context.value(left) >= context.value(right))
                }
                when Code.Statement.GEU(_, result, left, right) {
                    context.statements[result] := int(context.valueU(left) >= context.valueU(right))
                }
                when Code.Statement.GEF(_, result, left, right) {
                    context.statements[result] := int(context.floatValue(left) >=
                            context.floatValue(right))
                }
                when Code.Statement.LTS(_, result, left, right) {
                    context.statements[result] := int(context.value(left) < context.value(right))
                }
                when Code.Statement.LTU(_, result, left, right) {
                    context.statements[result] := int(context.valueU(left) < context.valueU(right))
                }
                when Code.Statement.LTF(_, result, left, right) {
                    context.statements[result] := int(context.floatValue(left) <
                            context.floatValue(right))
                }
                when Code.Statement.LES(_, result, left, right) {
                    context.statements[result] := int(context.value(left) <= context.value(right))
                }
                when Code.Statement.LEU(_, result, left, right) {
                    context.statements[result] := int(context.valueU(left) <= context.valueU(right))
                }
                when Code.Statement.LEF(_, result, left, right) {
                    context.statements[result] := int(context.floatValue(left) <=
                            context.floatValue(right))
                }
                when Code.Statement.BRANCH(_, target) {
                    block := code.blocks[target]
                    statement := 0
                    continue
                }
                when Code.Statement.COMMENT(_, text) {
                }
                when Code.Statement.CONVERTS(_, result, value, target) {
                    convert(result, value, target, true)
                }
                when Code.Statement.CONVERTU(_, result, value, target) {
                    convert(result, value, target, false)
                }
                when Code.Statement.CONDITIONAL_BRANCH(_, test, ifTrue, ifFalse) {
                    if context.value(test) != 0 {
                        block := code.blocks[ifTrue]
                    }
                    else {
                        block := code.blocks[ifFalse]
                    }
                    statement := 0
                    continue
                }
                when Code.Statement.CREATE_STRUCT(_, result, type, args) {
                    createStruct(result, type, args)
                }
                when Code.Statement.DYNAMIC_CALL(_, result, returnType, m, args) {
                    dynamicCall(result, returnType, m, args)
                }
                when Code.Statement.DYNAMIC_CALL_VOID(_, m, args) {
                    dynamicCall(null, null, m, args)
                }
                when Code.Statement.EXTRACT_FIELD(_, result, target, index) {
                    def ptr := Pointer<Int8>((context.value(target) +
                            target.type.elementOffset(settings!, index)).asUInt)
                    match target.type {
                        when Code.PrimitiveType.STRUCT(fields) {
                            load(result, ptr, fields[index])
                        }
                        otherwise {
                            unreachable
                        }
                    }
                }
                when Code.Statement.HEAP_ALLOC(_, result, type, classConstant) {
                    context.statements[result] := heapAlloc(type, classConstant)
                }
                when Code.Statement.LOAD(position, result, value, type) {
                    load(result, value, type)
                }
                when Code.Statement.NEGS(position, result, value) {
                    context.statements[result] := -context.value(value)
                }
                when Code.Statement.NEGF(position, result, value) {
                    context.statements[result] := Frost.floatToIntBits(-context.floatValue(value))
                }
                when Code.Statement.NOTB(position, result, value) {
                    if context.value(value) = 0 {
                        context.statements[result] := 1
                    }
                    else {
                        context.statements[result] := 0
                    }
                }
                when Code.Statement.NOTI(position, result, value) {
                    context.statements[result] := !!context.value(value)
                }
                when Code.Statement.RETURN(position, value) {
                    contexts.pop()
                    if value !== null {
                        def result := context.value(value)
                        -- can't clear stack because return value might be sitting on it
                        --stack := stackStart
                        return result
                    }
                    else {
                        stack := stackStart
                        return 0xDEADBEEFDEADBEEF
                    }
                }
                when Code.Statement.STACK_ALLOC(_, result, type) {
                    stack := alignUp(stack, type.alignment(settings))
                    contexts[0].statements[result] := stack.asUInt.asInt64
                    -- FIXME need memset
                    for i in 0 .. type.size(settings) {
                        stack[i] := 0
                    }
                    stack += type.size(settings)
                }
                when Code.Statement.STATIC_CALL(_, result, m, args) {
                    context.statements[result] := call(m, args)
                }
                when Code.Statement.STATIC_CALL_VOID(_, m, args) {
                    call(m, args)
                }
                when Code.Statement.STORE(_, value, dest) {
                    write(value, Pointer<Int8>(context.value64(dest).asUInt))
                }
                when Code.Statement.SWITCH(_, value, cases, other) {
                    def v := context.value(value).asUInt64
                    for c in cases {
                        if v = c[0] {
                            block := code.blocks[c[1]]
                            statement := 0
                            continue outer
                        }
                    }
                    block := code.blocks[other]
                    statement := 0
                    continue
                }
                when Code.Statement.UNREACHABLE(position) {
                    unreachable
                }
                otherwise {
                    unreachable, "unsupported statement \{stmt}"
                }
            }
            statement += 1
        }
    }

    @override
    method writeMethod(m:MethodDecl?, s:Code.Signature, code:Code, linkOnce:Bit) {
        interpreterCode[s.name] := InterpreterCode(code)
    }

    @override
    method start(cl:ClassDecl) {
        try {
            if cl.annotations.isSpecialize {
                return
            }
            cg.getClassConstant(cl)
        }
        fail(error) {
            unreachable, error.toString
        }
    }

    @override
    method end(cl:ClassDecl) {
    }

    method getMethodPointer(s:Code.Signature):Int64 {
        var result := methodIndices[s.name]
        if result == null {
            result := methods.count
            methods.add(s)
            methodIndices[s.name] := result
        }
        return result
    }

    method write(v:Int64, type:Code.PrimitiveType, dest:Pointer<Int8>):Pointer<Int8> {
        var result := dest
        match type {
            when Code.PrimitiveType.INT {
                match settings.intSize {
                    when 4 { result->Pointer<Int32>.set(v.asInt32) }
                    when 8 { result->Pointer<Int64>.set(v) }
                    otherwise { unreachable }
                }
                result += settings.intSize
            }
            when Code.PrimitiveType.INT8, Code.PrimitiveType.BIT {
                result.set(v.asInt8)
                result += 1
            }
            when Code.PrimitiveType.INT16 {
                result := alignUp(result, 2)
                result->Pointer<Int16>.set(v.asInt16)
                result += 2
            }
            when Code.PrimitiveType.INT32, Code.PrimitiveType.FLOAT32 {
                result := alignUp(result, 4)
                result->Pointer<Int32>.set(v.asInt32)
                result += 4
            }
            when Code.PrimitiveType.INT64, Code.PrimitiveType.FLOAT64 {
                result := alignUp(result, 8)
                result->Pointer<Int64>.set(v)
                result += 8
            }
            when Code.PrimitiveType.ARRAY, Code.PrimitiveType.STRUCT {
                result := alignUp(result, type.alignment(settings))
                def src := Pointer<Int8>(v.asUInt)
                -- FIXME need memcpy
                for i in 0 .. type.size(settings) {
                    result[i] := src[i]
                }
                result += type.size(settings)
            }
            otherwise {
                unreachable, "unsupported write: \{type}"
            }
        }
        return result
    }

    method ensureClassLoaded(cl:ClassDecl) {
        if cl.external {
            cl.external := false
            cg.getClassConstant(cl)
        }
    }

    method write(v:Code.Value, dest:Pointer<Int8>):Pointer<Int8> {
        var result := dest
        match v {
            when Code.Value.ARRAY(_, elements) {
                result := write(Code.Value.STRUCT(elements), result)
            }
            when Code.Value.BIT(b) {
                if b {
                    result.set(1)
                }
                else {
                    result.set(0)
                }
                result += 1
            }
            when Code.Value.CHARS(s) {
                for c in s.utf8 {
                    result.set(c.asInt8)
                    result += 1
                }
            }
            when Code.Value.FIELD_OFFSET(type, index) {
                result := write(type.elementOffset(settings, index).asInt64, Code.PrimitiveType.INT,
                        result)
            }
            when Code.Value.GLOBAL_POINTER(index) {
                def newResult := Interpreter.alignUp(result, settings.intSize)
                result := newResult
                match settings.intSize {
                    when 4 {
                        result->Pointer<Int32>.set((globalMemory + globals[index][1]).asUInt.asInt32)
                    }
                    when 8 {
                        result->Pointer<Int64>.set((globalMemory + globals[index][1]).asUInt.asInt64)
                    }
                    otherwise {
                        unreachable
                    }
                }
                result += settings.intSize
            }
            when Code.Value.INT(i, t) {
                result := write(i.asInt64, t, result)
            }
            when Code.Value.REAL(r, t) {
                result := write(Frost.floatToIntBits(r), t, result)
            }
            when Code.Value.METHOD_POINTER(signature) {
                def p := getMethodPointer(signature)
                result := alignUp(result, settings.intSize)
                match settings.intSize {
                    when 4 { result->Pointer<Int32>.set(p.asInt32) }
                    when 8 { result->Pointer<Int64>.set(p) }
                    otherwise { unreachable }
                }
                result += settings.intSize
            }
            when Code.Value.PARAMETER(idx, type) {
                result := write(contexts[0].arguments[idx], type, result)
            }
            when Code.Value.REF(r) {
                result := write(r.value, result)
            }
            when Code.Value.SIZE_OF(type) {
                result := write(type.size(settings).asInt64, Code.PrimitiveType.INT, result)
            }
            when Code.Value.STATEMENT(id, type) {
                result := write(contexts[0].statements[id], type, result)
            }
            when Code.Value.STRUCT(args) {
                result := alignUp(result,
                        Code.PrimitiveType.STRUCT(FixedArray<Code.PrimitiveType>.from(
                                args.map(a => a.type))).alignment(settings))
                for a in args {
                    result := write(a, result)
                }
            }
            when Code.Value.UNDEFINED(t) {
                result := alignUp(result, t.alignment(settings))
                result += t.size(settings)
            }
            otherwise {
                unreachable, "unsupported value \{v}"
            }
        }
        return result
    }

    @override
    method writeGlobal(g:Code.Global) {
        nextGlobal := alignUp(nextGlobal, g.type.alignment(settings))
        globalIndices[g] := globals.count
        globals.add((null, nextGlobal))
        nextGlobal += g.type.size(settings)
    }

    @override
    method writeGlobalValue(g:Code.Global, value:Code.Value) {
        def index := globalIndices[g]
        def offset:Int
        if index !== null {
            offset := globals[index][1]
            globals[index] := (value, offset)
        }
        else {
            offset := alignUp(nextGlobal, g.type.alignment(settings))
            globalIndices[g] := globals.count
            globals.add((value, offset))
            nextGlobal := offset + g.type.size(settings)
            assert nextGlobal <= MEMORY_SIZE
        }
        if globalMemory.asUInt != 0 {
            write(value, globalMemory + offset)
        }
    }

    @override
    method finish() {
        for (v, offset) in globals {
            if v !== null {
                write(v, globalMemory + offset)
            }
        }
    }

    method run() {
        call(Code.Signature(null, null, "frostMain", FixedArray<Code.PrimitiveType>.from([]),
                false), FixedArray<Code.Value>.from([]))
    }
}