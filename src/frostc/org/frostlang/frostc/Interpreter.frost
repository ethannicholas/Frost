package org.frostlang.frostc

uses frost.unsafe.Pointer

@final
class Interpreter : Backend {
    class Context {
        @weak
        def interpreter:Interpreter

        -- if the value fits into an Int64, contains the value. Otherwise, contains a Pointer to
        -- the value.
        def arguments:Array<Int64>

        -- if the value fits into an Int64, contains the value. Otherwise, contains a Pointer to
        -- the value.
        def statements := HashMap<Code.Statement.ID, Int64>()

        init(interpreter:Interpreter) {
            self.interpreter := interpreter

            arguments := Array<Int64>()
        }

        method value(v:Code.Value):Int64 {
            match v {
                when Code.Value.ARRAY(t, _) {
                    def result := Interpreter.alignUp(interpreter.stack,
                            t.alignment(interpreter.settings!)).asUInt.asInt64
                    interpreter.stack := interpreter.write(v, interpreter.stack)
                    return result
                }
                when Code.Value.BIT(b) {
                    return b.choose(1, 0)
                }
                when Code.Value.FIELD_OFFSET(t, index) {
                    return t.elementOffset(interpreter.settings!, index).asInt64
                }
                when Code.Value.GLOBAL_POINTER(index) {
                    return (interpreter.globalMemory + interpreter.globals[index][1]).asUInt.asInt64
                }
                when Code.Value.INT(i, _) {
                    return i.asInt64
                }
                when Code.Value.ITABLE_OFFSET(index) {
                    return ((2 + index) * interpreter.settings!.intSize).asInt64
                }
                when Code.Value.REAL(r, _) {
                    return Frost.floatToIntBits(r)
                }
                when Code.Value.METHOD_POINTER(signature) {
                    return interpreter.getMethodPointer(signature)
                }
                when Code.Value.PARAMETER(idx, _) {
                    return arguments[idx]
                }
                when Code.Value.SIZE_OF(t) {
                    return t.size(interpreter.settings!).asInt64
                }
                when Code.Value.STATEMENT(id, type) {
                    return statements[id]
                }
                when Code.Value.STRUCT(args) {
                    def alignment := args.map(
                            a => a.type.alignment(self.interpreter.settings!)).fold(Int.max)
                    def result := Interpreter.alignUp(interpreter.stack, alignment).asUInt.asInt64
                    interpreter.stack := interpreter.write(v, interpreter.stack)
                    return result
                }
                when Code.Value.UNDEFINED(t) {
                    return 0
                }
                when Code.Value.VTABLE_OFFSET(cc, index) {
                    def ccType:Code.PrimitiveType
                    match cc {
                        when Code.Value.GLOBAL_POINTER(idx) {
                            ccType := interpreter.cg.globals[idx].type
                        }
                        otherwise {
                            unreachable
                        }
                    }
                    return (ccType.elementOffset(interpreter.settings!,
                            CodeGenerator.VTABLE_INDEX) +
                            index * interpreter.settings!.intSize).asInt64
                }
                otherwise {
                    unreachable, "unsupported value \{v}"
                }
            }
        }

        method floatValue(v:Code.Value):Real64 {
            return Frost.intBitsToFloat(value(v))
        }
    }

    class InterpreterCode {
        def blocks := HashMap<Code.Block.ID, Code.Block>()

        init(code:Code) {
            for b in code.blocks {
                blocks[b.id] := b
            }
        }
    }

    constant NO_REFCNT := -999

    def physicalOut:OutputStream

    def out:OutputStream

    @weak
    def compiler:Compiler?

    def cg:CodeGenerator?

    def settings:Compiler.Settings?

    def stackSize := 1 << 20

    constant MEMORY_SIZE := 1 << 20

    def stackBase := Pointer<Int8>.alloc(stackSize)

    def stack := stackBase

    -- the ints are offsets into globalMemory
    def globals := Array<(Code.Value?, Int)>()

    def globalIndices := IdentityMap<Code.Global, Int>()

    var nextGlobal := 0

    def globalMemory := Pointer<Int8>.alloc(MEMORY_SIZE)

    def interpreterCode := HashMap<String, InterpreterCode>()

    def methodIndices := HashMap<String, Int64>()

    def methods := Array<Code.Signature>()

    def contexts := Stack<Context>()

    def builtins := HashMap<String, (Context, FixedArray<Code.Value>)=&>(Int64)>()

    init() {
        methods.add(Code.Signature(null, null, "<null method pointer>",
                FixedArray<Code.PrimitiveType>(), false))
    }

    @class
    @pre(align > 0)
    @post(@return % align = 0)
    function alignUp(i:Int, align:Int):Int {
        if i % align != 0 {
            return i + align - i % align
        }
        return i
    }

    @class
    @pre(align > 0)
    @post(@return.asUInt % align = 0)
    function alignUp<T>(p:Pointer<T>, align:Int):Pointer<T> {
        def offset := p.asUInt
        if offset % align != 0 {
            return Pointer<T>(offset + align.asUInt - offset % align.asUInt)
        }
        return p
    }


    @override
    method setCompiler(compiler:Compiler) {
        self.compiler := compiler
        self.cg := compiler.cg
        self.settings := compiler.settings
    }

    @override
    method writeSignature(s:Code.Signature) {
    }

    method createStruct(id:Code.Statement.ID, type:Code.PrimitiveType,
            args:FixedArray<Code.Value>) {
        contexts[0].statements[id] := contexts[0].value(Code.Value.STRUCT(args))
    }

    @pre((id == null) = (returnType == null))
    method dynamicCall(id:Code.Statement.ID?, returnType:Code.PrimitiveType?, m:Code.Value,
            args:FixedArray<Code.Value>) {
        def signature := methods[contexts[0].value(m).asInt]
        def result := call(signature, args)
        if id !== null {
            contexts[0].statements[id] := result
        }
    }

    @class
    function int(b:Bit):Int64 {
        if b {
            return 1
        }
        return 0
    }

    method destroyObject(o:Pointer<Int8>) {
        -- call cleanup
        def offset:UInt
        match compiler.settings.intSize {
            when 4 { offset := 28 }
            when 8 { offset := 48 }
            otherwise { unreachable }
        }
        def cleanup := Pointer<UInt>(o->Pointer<UInt>.get() + offset).get()
        dynamicCall(null, null, Code.Value.INT(cleanup.asUInt64, Code.PrimitiveType.INT),
                FixedArray<Code.Value>.from([Code.Value.INT(o.asUInt.asUInt64,
                    Code.PrimitiveType.INT)]))
        o.destroy()
    }

    method ref(o:Pointer<Int8>) {
        if o.asUInt = 0 {
            return
        }
        def refCntPtr := (o + settings.intSize)->Pointer<Int32>
        def refCnt := refCntPtr.get()
        if refCnt = NO_REFCNT.asInt32 {
            return
        }
        refCntPtr.set(refCnt + 1)
    }

    method unref(o:Pointer<Int8>) {
        if o.asUInt = 0 {
            return
        }
        def refCntPtr := (o + settings.intSize)->Pointer<Int32>
        def refCnt := refCntPtr.get()
        if refCnt = NO_REFCNT.asInt32 {
            return
        }
        if refCnt = 1 {
            destroyObject(o)
        }
        else {
            refCntPtr.set(refCnt - 1)
        }
    }

    method getInterpreterCode(s:Code.Signature):InterpreterCode? {
        var result := interpreterCode[s.name]
        if result == null & s.methodDecl !== null & !s.methodDecl.annotations.isExternal {
            def cl := s.methodDecl.owner
            def auto := Compiler.AutoScope(compiler, compiler.getSymbolTable(cl))
            compiler.currentClass.push(cl)
            compiler.resolve(cl)
            compiler.compile(s.methodDecl)
            -- create the shim, if needed
            cg.getMethodTableEntry(s.methodDecl)
            def shim := cg.methodShims[s.methodDecl]
            if shim !== null {
                -- FIXME shouldn't need !'s
                interpreterCode[shim![0].name] := InterpreterCode(shim![1])
            }
            compiler.currentClass.pop()
            result := interpreterCode[s.name]
            assert result !== null, "didn't receive code for \{s.name}"
        }
        return result
    }

    @class
    method dump(p:Pointer<Int8>, count:Int) {
        Console.printLine("Dumping \{p}:")
        for i in 0 .. count {
            Console.printLine("\{i, >5}: \{p[i]:x}")
        }
    }

    method getBuiltin(s:Code.Signature):(Context, FixedArray<Code.Value>)=&>(Int64) {
        var builtin := builtins[s.name]
        if builtin == null {
            def intSize := settings.intSize
            -- note that while the objects match the structure and layout of "real" Frost objects,
            -- the class pointers and vtable / itable entries are not the same. Thus it is sometimes
            -- possible to call the "real" Frost method directly on an object, and sometimes not,
            -- depending upon what that method does with the object. Anything that involves making
            -- dynamic method calls is right out.
            match s.name {
                when "frost$core$Frost$unrefThreadSafe$frost$core$Object$Q" {
                    builtin := method(context:Context, args:FixedArray<Code.Value>):Int64 {
                        self.unref(Pointer<Int8>(context.value(args[0]).asUInt))
                        return -1
                    }
                }
                when "frost$core$Frost$alloc$builtin_int$R$builtin_uint" {
                    builtin := method(context:Context, args:FixedArray<Code.Value>):Int64 {
                        return UInt(Frost.alloc(context.value(args[0]).asInt.value)).asInt64
                    }
                }
                when "frost$core$Frost$destroy$builtin_uint" {
                    builtin := method(context:Context, args:FixedArray<Code.Value>):Int64 {
                        Frost.destroy(context.value(args[0]).asUInt.value)
                        return -1
                    }
                }
                when "frost$core$Frost$realloc$builtin_uint$builtin_int$builtin_int$R$builtin_uint" {
                    builtin := method(context:Context, args:FixedArray<Code.Value>):Int64 {
                        return UInt(Frost.realloc(context.value(args[0]).asUInt.value,
                                context.value(args[1]).asInt.value,
                                context.value(args[2]).asInt.value)).asInt64
                    }
                }
                when "frost$core$Frost$debugPrint$builtin_int64" {
                    builtin := method(context:Context, args:FixedArray<Code.Value>):Int64 {
                        Console.printLine("Debug: \{context.value(args[0])}")
                        return -1
                    }
                }
                when "frost$io$Console$read$R$frost$core$Char8$Q" {
                    builtin := method(context:Context, args:FixedArray<Code.Value>):Int64 {
                        def target := Pointer<Char8?>(context.value(args[0]).asUInt)
                        target.set(Console.read())
                        return -1
                    }
                }
                when "frost$io$Console$print$frost$core$String" {
                    def out := Console.outputStream()
                    builtin := method(context:Context, args:FixedArray<Code.Value>):Int64 {
                        def p := context.value(args[0]).asUInt
                        def s := Pointer<Int8>(p).convertTo<String>()
                        def error := out.write(s.data, s.byteLength)
                        assert error == null
                        return -1
                    }
                }
                when "frost$io$Console$errorStream$R$frost$io$OutputStream" {
                    builtin := method(context:Context, args:FixedArray<Code.Value>):Int64 {
                        return Frost.addressOf(Console.errorStream()).asInt64
                    }
                }
                otherwise {
                    if s.name.startsWith("frost$core$Frost$ref") {
                        builtin := method(context:Context, args:FixedArray<Code.Value>):Int64 {
                            self.ref(Pointer<Int8>(context.value(args[0]).asUInt))
                            return -1
                        }
                    }
                    else if s.name.startsWith("frost$core$Frost$unref") {
                        builtin := method(context:Context, args:FixedArray<Code.Value>):Int64 {
                            self.unref(Pointer<Int8>(context.value(args[0]).asUInt))
                            return -1
                        }
                    }
                    else {
                        Console.printLine("Fatal error: \{s.name} is not supported by the " +
                                "interpreter")
                        System.exit(1)
                    }
                }
            }
            builtins[s.name] := builtin
        }
        return builtin
    }

    method load(target:Code.Statement.ID, value:Code.Value, type:Code.PrimitiveType) {
        def ptr := Pointer<Int8>(contexts[0].value(value).asUInt)
        load(target, ptr, type)
    }

    method load(target:Code.Statement.ID, ptr:Pointer<Int8>, type:Code.PrimitiveType) {
        match type {
            when Code.PrimitiveType.INT8, Code.PrimitiveType.BIT {
                contexts[0].statements[target] := ptr.get().asInt64
            }
            when Code.PrimitiveType.INT16 {
                contexts[0].statements[target] := ptr->Pointer<UInt16>.get().asUInt64.asInt64
            }
            when Code.PrimitiveType.INT32, Code.PrimitiveType.FLOAT32 {
                contexts[0].statements[target] := ptr->Pointer<UInt32>.get().asUInt64.asInt64
            }
            when Code.PrimitiveType.INT64, Code.PrimitiveType.FLOAT64 {
                contexts[0].statements[target] := ptr->Pointer<Int64>.get()
            }
            when Code.PrimitiveType.INT {
                match settings.intSize {
                    when 4 { contexts[0].statements[target] := ptr->Pointer<UInt32>.get().asUInt64.asInt64 }
                    when 8 { contexts[0].statements[target] := ptr->Pointer<Int64>.get() }
                    otherwise { unreachable }
                }
            }
            when Code.PrimitiveType.ARRAY, Code.PrimitiveType.STRUCT {
                stack := alignUp(stack, type.alignment(settings!))
                contexts[0].statements[target] := stack.asUInt.asInt64
                -- FIXME need memcpy
                for i in 0 .. type.size(settings!) {
                    stack[i] := ptr[i]
                }
                stack += type.size(settings!)
            }
            otherwise {
                unreachable
            }
        }
    }

    method convert(result:Code.Statement.ID, value:Code.Value, target:Code.PrimitiveType,
            signed:Bit) {
        def v := contexts[0].value(value)
        if value.type.size(settings!) > target.size(settings!) {
            match target.size(settings!) {
                when 1 { contexts[0].statements[result] := v && 0xFF }
                when 2 { contexts[0].statements[result] := v && 0xFFFF }
                when 4 { contexts[0].statements[result] := v && 0xFFFFFFFF }
            }
        }
        else if signed & value.type.size(settings!) <  target.size(settings!) {
            match value.type.size(settings!) {
                when 1 { contexts[0].statements[result] := v.asInt8.asInt64 }
                when 2 { contexts[0].statements[result] := v.asInt16.asInt64 }
                when 4 { contexts[0].statements[result] := v.asInt32.asInt64 }
            }
        }
        else {
            contexts[0].statements[result] := v
        }
    }

    method call(s:Code.Signature, args:FixedArray<Code.Value>):Int64 {
        def code := getInterpreterCode(s)
        if code == null {
            def builtin := getBuiltin(s)
            return builtin(contexts[0], args)
        }
        def context := Context(self)
        for a in args {
            context.arguments.add(contexts[0].value(a))
        }
        contexts.push(context)
        var block := code.blocks[Code.Block.ID(0)]
        var statement := 0
        def stackStart := stack
        loop {
            def stmt := block.statements[statement]
            match stmt {
                when Code.Statement.ADDI(_, result, left, right) {
                    context.statements[result] := context.value(left) + context.value(right)
                }
                when Code.Statement.ADDF(_, result, left, right) {
                    context.statements[result] := Frost.floatToIntBits(context.floatValue(left) +
                            context.floatValue(right))
                }
                when Code.Statement.SUBI(_, result, left, right) {
                    context.statements[result] := context.value(left) - context.value(right)
                }
                when Code.Statement.SUBF(_, result, left, right) {
                    context.statements[result] := Frost.floatToIntBits(context.floatValue(left) -
                            context.floatValue(right))
                }
                when Code.Statement.MULI(_, result, left, right) {
                    context.statements[result] := context.value(left) * context.value(right)
                }
                when Code.Statement.MULF(_, result, left, right) {
                    context.statements[result] := Frost.floatToIntBits(context.floatValue(left) *
                            context.floatValue(right))
                }
                when Code.Statement.DIVS(_, result, left, right) {
                    context.statements[result] := context.value(left) // context.value(right)
                }
                when Code.Statement.DIVU(_, result, left, right) {
                    context.statements[result] := (context.value(left).asUInt64 //
                            context.value(right).asUInt64).asInt64
                }
                when Code.Statement.DIVF(_, result, left, right) {
                    context.statements[result] := Frost.floatToIntBits(context.floatValue(left) /
                            context.floatValue(right))
                }
                when Code.Statement.REMS(_, result, left, right) {
                    context.statements[result] := context.value(left) % context.value(right)
                }
                when Code.Statement.REMU(_, result, left, right) {
                    context.statements[result] := (context.value(left).asUInt64 %
                            context.value(right).asUInt64).asInt64
                }
                when Code.Statement.ANDI(_, result, left, right) {
                    context.statements[result] := context.value(left) && context.value(right)
                }
                when Code.Statement.ANDB(_, result, left, right) {
                    context.statements[result] := int(context.value(left) != 0 &
                            context.value(right) != 0)
                }
                when Code.Statement.ORI(_, result, left, right) {
                    context.statements[result] := context.value(left) || context.value(right)
                }
                when Code.Statement.ORB(_, result, left, right) {
                    context.statements[result] := int(context.value(left) != 0 |
                            context.value(right) != 0)
                }
                when Code.Statement.XORI(_, result, left, right) {
                    context.statements[result] := context.value(left) ~~ context.value(right)
                }
                when Code.Statement.XORB(_, result, left, right) {
                    context.statements[result] := int(context.value(left) != 0 ~
                            context.value(right) != 0)
                }
                when Code.Statement.SHRS(_, result, left, right) {
                    context.statements[result] := context.value(left) >> context.value(right)
                }
                when Code.Statement.SHRU(_, result, left, right) {
                    context.statements[result] := (context.value(left).asUInt64 >>
                            context.value(right).asUInt64).asInt64
                }
                when Code.Statement.SHL(_, result, left, right) {
                    context.statements[result] := context.value(left) << context.value(right)
                }
                when Code.Statement.EQI(_, result, left, right) {
                    context.statements[result] := int(context.value(left) = context.value(right))
                }
                when Code.Statement.EQF(_, result, left, right) {
                    context.statements[result] := int(context.floatValue(left) =
                            context.floatValue(right))
                }
                when Code.Statement.NEQI(_, result, left, right) {
                    context.statements[result] := int(context.value(left) != context.value(right))
                }
                when Code.Statement.NEQF(_, result, left, right) {
                    context.statements[result] := int(context.floatValue(left) !=
                            context.floatValue(right))
                }
                when Code.Statement.GTS(_, result, left, right) {
                    context.statements[result] := int(context.value(left) > context.value(right))
                }
                when Code.Statement.GTU(_, result, left, right) {
                    context.statements[result] := int(context.value(left).asUInt64 >
                            context.value(right).asUInt64)
                }
                when Code.Statement.GTF(_, result, left, right) {
                    context.statements[result] := int(context.floatValue(left) >
                            context.floatValue(right))
                }
                when Code.Statement.GES(_, result, left, right) {
                    context.statements[result] := int(context.value(left) >= context.value(right))
                }
                when Code.Statement.GEU(_, result, left, right) {
                    context.statements[result] := int(context.value(left).asUInt64 >=
                            context.value(right).asUInt64)
                }
                when Code.Statement.GEF(_, result, left, right) {
                    context.statements[result] := int(context.floatValue(left) >=
                            context.floatValue(right))
                }
                when Code.Statement.LTS(_, result, left, right) {
                    context.statements[result] := int(context.value(left) < context.value(right))
                }
                when Code.Statement.LTU(_, result, left, right) {
                    context.statements[result] := int(context.value(left).asUInt64 <
                            context.value(right).asUInt64)
                }
                when Code.Statement.LTF(_, result, left, right) {
                    context.statements[result] := int(context.floatValue(left) <
                            context.floatValue(right))
                }
                when Code.Statement.LES(_, result, left, right) {
                    context.statements[result] := int(context.value(left) <= context.value(right))
                }
                when Code.Statement.LEU(_, result, left, right) {
                    context.statements[result] := int(context.value(left).asUInt64 <=
                            context.value(right).asUInt64)
                }
                when Code.Statement.LEF(_, result, left, right) {
                    context.statements[result] := int(context.floatValue(left) <=
                            context.floatValue(right))
                }
                when Code.Statement.BRANCH(_, target) {
                    block := code.blocks[target]
                    statement := 0
                    continue
                }
                when Code.Statement.COMMENT(_, text) {
                }
                when Code.Statement.CONVERTS(_, result, value, target) {
                    convert(result, value, target, true)
                }
                when Code.Statement.CONVERTU(_, result, value, target) {
                    convert(result, value, target, true)
                }
                when Code.Statement.CONDITIONAL_BRANCH(_, test, ifTrue, ifFalse) {
                    if context.value(test) != 0 {
                        block := code.blocks[ifTrue]
                    }
                    else {
                        block := code.blocks[ifFalse]
                    }
                    statement := 0
                    continue
                }
                when Code.Statement.CREATE_STRUCT(_, result, type, args) {
                    createStruct(result, type, args)
                }
                when Code.Statement.DYNAMIC_CALL(_, result, returnType, m, args) {
                    dynamicCall(result, returnType, m, args)
                }
                when Code.Statement.DYNAMIC_CALL_VOID(_, m, args) {
                    dynamicCall(null, null, m, args)
                }
                when Code.Statement.EXTRACT_FIELD(_, result, target, index) {
                    def ptr := Pointer<Int8>((context.value(target) +
                            target.type.elementOffset(settings!, index)).asUInt)
                    match target.type {
                        when Code.PrimitiveType.STRUCT(fields) {
                            load(result, ptr, fields[index])
                        }
                        otherwise {
                            unreachable
                        }
                    }
                }
                when Code.Statement.HEAP_ALLOC(_, result, type, classConstant) {
                    def raw := Pointer<Int8>.alloc(type.size(settings!))
                    match settings.intSize {
                        when 4 { raw->Pointer<Int32>.set(context.value(classConstant).asInt32) }
                        when 8 { raw->Pointer<Int64>.set(context.value(classConstant)) }
                        otherwise { unreachable }
                    }
                    Pointer<Int32>((raw + settings.intSize).asUInt).set(1)
                    context.statements[result] := raw.asUInt.asInt64
                }
                when Code.Statement.LOAD(position, result, value, type) {
                    load(result, value, type)
                }
                when Code.Statement.NEGS(position, result, value) {
                    context.statements[result] := -context.value(value)
                }
                when Code.Statement.NEGF(position, result, value) {
                    context.statements[result] := Frost.floatToIntBits(-context.floatValue(value))
                }
                when Code.Statement.NOTB(position, result, value) {
                    if context.value(value) = 0 {
                        context.statements[result] := 1
                    }
                    else {
                        context.statements[result] := 0
                    }
                }
                when Code.Statement.NOTI(position, result, value) {
                    context.statements[result] := !!context.value(value)
                }
                when Code.Statement.RETURN(position, value) {
                    contexts.pop()
                    if value !== null {
                        def result := context.value(value)
                        -- can't clear stack because return value might be sitting on it
                        --stack := stackStart
                        return result
                    }
                    else {
                        stack := stackStart
                        return 0xDEADBEEFDEADBEEF
                    }
                }
                when Code.Statement.STACK_ALLOC(_, result, type) {
                    stack := alignUp(stack, type.alignment(settings))
                    contexts[0].statements[result] := stack.asUInt.asInt64
                    -- FIXME need memset
                    for i in 0 .. type.size(settings) {
                        stack[i] := 0
                    }
                    stack += type.size(settings)
                }
                when Code.Statement.STATIC_CALL(_, result, m, args) {
                    context.statements[result] := call(m, args)
                }
                when Code.Statement.STATIC_CALL_VOID(_, m, args) {
                    call(m, args)
                }
                when Code.Statement.STORE(position, value, dest) {
                    write(value, Pointer<Int8>(context.value(dest).asUInt))
                }
                when Code.Statement.UNREACHABLE(position) {
                    unreachable
                }
                otherwise {
                    unreachable, "unsupported statement \{stmt}"
                }
            }
            statement += 1
        }
    }

    @override
    method writeMethod(m:MethodDecl?, s:Code.Signature, code:Code, linkOnce:Bit) {
        interpreterCode[s.name] := InterpreterCode(code)
    }

    @override
    method start(cl:ClassDecl) {
        try {
            if cl.annotations.isSpecialize {
                return
            }
            cg.getClassConstant(cl)
        }
        fail(error) {
            unreachable, error.asString
        }
    }

    @override
    method end(cl:ClassDecl) {
    }

    method getMethodPointer(s:Code.Signature):Int64 {
        var result := methodIndices[s.name]
        if result == null {
            result := methods.count
            methods.add(s)
            methodIndices[s.name] := result
        }
        return result
    }

    method write(v:Int64, type:Code.PrimitiveType, dest:Pointer<Int8>):Pointer<Int8> {
        var result := dest
        match type {
            when Code.PrimitiveType.INT {
                match settings.intSize {
                    when 4 { result->Pointer<Int32>.set(v.asInt32) }
                    when 8 { result->Pointer<Int64>.set(v) }
                    otherwise { unreachable }
                }
                result += settings.intSize
            }
            when Code.PrimitiveType.INT8, Code.PrimitiveType.BIT {
                result.set(v.asInt8)
                result += 1
            }
            when Code.PrimitiveType.INT16 {
                result := alignUp(result, 2)
                result->Pointer<Int16>.set(v.asInt16)
                result += 2
            }
            when Code.PrimitiveType.INT32, Code.PrimitiveType.FLOAT32 {
                result := alignUp(result, 4)
                result->Pointer<Int32>.set(v.asInt32)
                result += 4
            }
            when Code.PrimitiveType.INT64, Code.PrimitiveType.FLOAT64 {
                result := alignUp(result, 8)
                result->Pointer<Int64>.set(v)
                result += 8
            }
            when Code.PrimitiveType.ARRAY, Code.PrimitiveType.STRUCT {
                result := alignUp(result, type.alignment(settings))
                def src := Pointer<Int8>(v.asUInt)
                -- FIXME need memcpy
                for i in 0 .. type.size(settings) {
                    result[i] := src[i]
                }
                result += type.size(settings)
            }
            otherwise {
                unreachable, "unsupported write: \{type}"
            }
        }
        return result
    }

    method ensureClassLoaded(cl:ClassDecl) {
        if cl.external {
            cl.external := false
            cg.getClassConstant(cl)
        }
    }

    method write(v:Code.Value, dest:Pointer<Int8>):Pointer<Int8> {
        var result := dest
        match v {
            when Code.Value.ARRAY(_, elements) {
                result := write(Code.Value.STRUCT(elements), result)
            }
            when Code.Value.BIT(b) {
                if b {
                    result.set(1)
                }
                else {
                    result.set(0)
                }
                result += 1
            }
            when Code.Value.FIELD_OFFSET(type, index) {
                result := write(type.elementOffset(settings, index).asInt64, Code.PrimitiveType.INT,
                        result)
            }
            when Code.Value.GLOBAL_POINTER(index) {
                def newResult := Interpreter.alignUp(result, settings.intSize)
                result := newResult
                match settings.intSize {
                    when 4 {
                        result->Pointer<Int32>.set((globalMemory + globals[index][1]).asUInt.asInt32)
                    }
                    when 8 {
                        result->Pointer<Int64>.set((globalMemory + globals[index][1]).asUInt.asInt64)
                    }
                    otherwise {
                        unreachable
                    }
                }
                result += settings.intSize
            }
            when Code.Value.INT(i, t) {
                result := write(i.asInt64, t, result)
            }
            when Code.Value.REAL(r, t) {
                result := write(Frost.floatToIntBits(r), t, result)
            }
            when Code.Value.METHOD_POINTER(signature) {
                def p := getMethodPointer(signature)
                result := alignUp(result, settings.intSize)
                match settings.intSize {
                    when 4 { result->Pointer<Int32>.set(p.asInt32) }
                    when 8 { result->Pointer<Int64>.set(p) }
                    otherwise { unreachable }
                }
                result += settings.intSize
            }
            when Code.Value.PARAMETER(idx, type) {
                result := write(contexts[0].arguments[idx], type, result)
            }
            when Code.Value.REF(r) {
                result := write(r.value, result)
            }
            when Code.Value.SIZE_OF(type) {
                result := write(type.size(settings).asInt64, Code.PrimitiveType.INT, result)
            }
            when Code.Value.STATEMENT(id, type) {
                result := write(contexts[0].statements[id], type, result)
            }
            when Code.Value.STRUCT(args) {
                result := alignUp(result,
                        Code.PrimitiveType.STRUCT(FixedArray<Code.PrimitiveType>.from(
                                args.map(a => a.type))).alignment(settings))
                for a in args {
                    result := write(a, result)
                }
            }
            when Code.Value.UNDEFINED(t) {
                result := alignUp(result, t.alignment(settings))
                result += t.size(settings)
            }
            otherwise {
                unreachable, "unsupported value \{v}"
            }
        }
        return result
    }

    @override
    method writeGlobal(g:Code.Global) {
        nextGlobal := alignUp(nextGlobal, g.type.alignment(settings))
        globalIndices[g] := globals.count
        globals.add((null, nextGlobal))
        nextGlobal += g.type.size(settings)
    }

    @override
    method writeGlobalValue(g:Code.Global, value:Code.Value) {
        def index := globalIndices[g]
        def offset:Int
        if index !== null {
            offset := globals[index][1]
            globals[index] := (value, offset)
        }
        else {
            offset := alignUp(nextGlobal, g.type.alignment(settings))
            globalIndices[g] := globals.count
            globals.add((value, offset))
            nextGlobal := offset + g.type.size(settings)
            assert nextGlobal <= MEMORY_SIZE
        }
        if globalMemory.asUInt != 0 {
            write(value, globalMemory + offset)
        }
    }

    @override
    method finish() {
        for (v, offset) in globals {
            if v !== null {
                write(v, globalMemory + offset)
            }
        }
    }

    method run() {
        call(Code.Signature(null, null, "frostMain", FixedArray<Code.PrimitiveType>.from([]),
                false), FixedArray<Code.Value>.from([]))
    }
}