package org.frostlang.frostc.parser

uses org.frostlang.frostc.ASTNode
uses org.frostlang.frostc.ClassDecl
uses org.frostlang.frostc.Compiler
uses org.frostlang.frostc.FixedArray
uses org.frostlang.frostc.MethodDecl
uses org.frostlang.frostc.Position
uses org.frostlang.frostc.Variable
uses org.frostlang.frostc.expression.Binary
uses org.frostlang.frostc.expression.Unary
uses org.frostlang.regex.RegexParser

@final
class Parser {
    class AutoSyntaxHighlight {
        def parser:Parser

        def kind:SyntaxHighlighter.Kind

        init(parser:Parser, kind:SyntaxHighlighter.Kind) {
            self.parser := parser
            self.kind := kind
            if parser.syntaxHighlighter !== null {
                parser.syntaxHighlighter.open(kind)
            }
        }

        @override
        method cleanup() {
            if parser.syntaxHighlighter !== null {
                parser.syntaxHighlighter.close(kind)
            }
        }
    }

    def lexer := Lexer()

    def regexParser:RegexParser

    def errors:MessageQueue<Compiler.Message>

    var path:File

    var source:String

    def pushbackBuffer := SpecializedArray<Token>()

    def commaSeparatedExpressionContext := Stack<Bit>()

    def speculativeBuffers := Stack<SpecializedArray<Token>>()

    var allowLambdas := true

    var reportErrors := true

    var syntaxHighlighter:SyntaxHighlighter?

    init(errors:MessageQueue<Compiler.Message>) {
        self.errors := errors
        commaSeparatedExpressionContext.push(false)
        regexParser := RegexParser(errors)
    }

    method start(path:File, source:String) {
        reportErrors := true
        lexer.start(source)
        self.path := path
        self.source := source
        pushbackBuffer.clear()
        regexParser.start(path, source)
        if syntaxHighlighter !== null {
            syntaxHighlighter.reset()
        }
    }

    method rawNext():Token {
        if pushbackBuffer.count != 0 {
            def idx := pushbackBuffer.count - 1
            def result := pushbackBuffer[idx]
            pushbackBuffer.removeIndex(idx)
            if syntaxHighlighter !== null {
                syntaxHighlighter.add(result)
            }
            return result
        }
        def result := lexer.next()
        if syntaxHighlighter !== null {
            if result.kind = Token.Kind.DOC_COMMENT {
                if syntaxHighlighter.stack.count = 0 |
                        syntaxHighlighter.stack[0] != SyntaxHighlighter.Kind.DOC_COMMENT {
                    syntaxHighlighter.open(SyntaxHighlighter.Kind.DOC_COMMENT)
                }
                else {
                    syntaxHighlighter.close(SyntaxHighlighter.Kind.DOC_COMMENT)
                }
            }
            syntaxHighlighter.add(result)
        }
        if speculativeBuffers.count > 0 {
            speculativeBuffers[0].add(result)
        }
        return result
    }

    method next():Token {
        outer: loop {
            def result := rawNext()
            match result.kind {
                when Token.Kind.WHITESPACE {
                    continue
                }
                when Token.Kind.LINE_COMMENT {
                    def auto := AutoSyntaxHighlight(self, SyntaxHighlighter.Kind.COMMENT)
                    loop {
                        def t := rawNext()
                        match t.kind {
                            when Token.Kind.WHITESPACE {
                                if text(t).contains("\n") {
                                    break
                                }
                            }
                            when Token.Kind.EOF {
                                return t
                            }
                        }
                    }
                }
                when Token.Kind.BLOCK_COMMENT_START {
                    def auto := AutoSyntaxHighlight(self, SyntaxHighlighter.Kind.COMMENT)
                    loop {
                        def t := next()
                        match t.kind {
                            when Token.Kind.BLOCK_COMMENT_END {
                                break
                            }
                            when Token.Kind.EOF {
                                error(result, "unterminated comment")
                                reportErrors := false
                                return t
                            }
                        }
                    }
                }
                otherwise {
                    return result
                }
            }
        }
    }

    method pushback(token:Token) {
        if syntaxHighlighter !== null {
            while text(syntaxHighlighter.tokens[syntaxHighlighter.tokens.count - 1].first) !=
                    text(token) {
                pushbackBuffer.add(syntaxHighlighter.tokens[syntaxHighlighter.tokens.count -
                        1].first)
                syntaxHighlighter.rewind()
            }
            syntaxHighlighter.rewind()
        }
        pushbackBuffer.add(token)
    }

    method peek():Token {
        if pushbackBuffer.count = 0 {
            pushback(next())
        }
        return pushbackBuffer[pushbackBuffer.count - 1]
    }

    method checkNext(kind:Token.Kind):Token? {
        def result := next()
        if result.kind = kind {
            return result
        }
        pushback(result)
        return null
    }

    method expect(kind:Token.Kind, expected:String):Token? {
        def result := next()
        if result.kind = kind {
            return result
        }
        error(result, "expected \{expected}, but found '\{text(result)}'")
        return null
    }

    method error(token:Token, msg:String) {
        if speculativeBuffers.count = 0 & reportErrors {
            errors.post(Compiler.Message.ERROR(path, token.position, msg))
        }
    }

    method open(kind:SyntaxHighlighter.Kind) {
        if syntaxHighlighter !== null {
            syntaxHighlighter.open(kind)
        }
    }

    method close(kind:SyntaxHighlighter.Kind) {
        if syntaxHighlighter !== null {
            syntaxHighlighter.close(kind)
        }
    }

    method startSpeculative() {
        speculativeBuffers.push(SpecializedArray<Token>())
        speculativeBuffers[0].addAll(pushbackBuffer)
    }

    method accept() {
        speculativeBuffers.pop()
    }

    method rewind() {
        for i in speculativeBuffers[0].count - 1 ... 0 by -1 {
            pushbackBuffer.add(speculativeBuffers[0][i])
        }
        speculativeBuffers.pop()
    }

    function text(token:Token):String {
        return source.substring(token.start .. token.end)
    }

    function addStringChunk(string:ASTNode?, chunk:ASTNode):ASTNode {
        if string == null {
            return chunk
        }
        return ASTNode.BINARY(string.position(), string, Binary.Operator.ADD, chunk)
    }

    method formatString(start:Token):String? {
        def result := MutableString()
        loop {
            def token := rawNext()
            match token.kind {
                when Token.Kind.WHITESPACE {
                    def str := text(token)
                    if str.contains("\n") {
                        error(token, "unterminated string literal")
                        return null
                    }
                    result.append(str)
                }
                when Token.Kind.EOF {
                    error(token, "unterminated string literal")
                    return null
                }
                when Token.Kind.BACKSLASH {
                    def escape := rawNext()
                    if escape.kind = Token.Kind.EOF {
                        error(token, "unterminated string literal")
                        return null
                    }
                    def escapeText := text(escape)
                    def c := escapeText.utf8[0]
                    match c {
                        when "n"  { result.append("\n") }
                        when "r"  { result.append("\r") }
                        when "t"  { result.append("\t") }
                        when "'"  { result.append("'") }
                        when "\"" { result.append("\"") }
                        when "\\" { result.append("\\") }
                        when "}"  { result.append("}") }
                        otherwise {
                            error(token, "invalid format string escape sequence")
                            return null
                        }
                    }
                    result.append(escapeText[escapeText.next(escapeText.start)..])
                }
                when Token.Kind.RBRACE {
                    pushback(token)
                    return result.finish()
                }
                otherwise {
                    result.append(text(token))
                }
            }
        }
    }

    method alignmentString(start:Token):String? {
        def result := MutableString()
        loop {
            def token := rawNext()
            match token.kind {
                when Token.Kind.WHITESPACE {
                    def str := text(token)
                    if str.contains("\n") {
                        error(token, "unterminated string literal")
                        return null
                    }
                    result.append(str)
                }
                when Token.Kind.EOF {
                    error(token, "unterminated string literal")
                    return null
                }
                when Token.Kind.BACKSLASH {
                    def escape := rawNext()
                    if escape.kind = Token.Kind.EOF {
                        error(token, "unterminated string literal")
                        return null
                    }
                    def escapeText := text(escape)
                    def c := escapeText.utf8[0]
                    match c {
                        when "n"  { result.append("\n") }
                        when "r"  { result.append("\r") }
                        when "t"  { result.append("\t") }
                        when "'"  { result.append("'") }
                        when "\"" { result.append("\"") }
                        when "\\" { result.append("\\") }
                        when ":"  { result.append(":") }
                        when "}"  { result.append("}") }
                        otherwise {
                            error(token, "invalid format string escape sequence")
                            return null
                        }
                    }
                    result.append(escapeText[escapeText.next(escapeText.start)..])
                }
                when Token.Kind.COLON {
                    pushback(token)
                    return result.finish()
                }
                when Token.Kind.RBRACE {
                    pushback(token)
                    return result.finish()
                }
                otherwise {
                    result.append(text(token))
                }
            }
        }
    }

    @private
    function convertToString(expr:ASTNode):ASTNode {
        def dot := ASTNode.DOT(expr.position(), expr, "get_asString")
        def call := ASTNode.CALL(expr.position(), dot, FixedArray<ASTNode>())
        def stringType := ASTNode.TYPE(expr.position(), "frost.core.String")
        return ASTNode.BINARY(expr.position(), call, Binary.Operator.CAST, stringType)
    }

    @post(allowLambdas = @pre(allowLambdas))
    method string():ASTNode? {
        def auto := AutoSyntaxHighlight(self, SyntaxHighlighter.Kind.STRING)
        def start := next()
        if start.kind != Token.Kind.DOUBLE_QUOTE & start.kind != Token.Kind.SINGLE_QUOTE {
            error(start, "expected a string, but found '\{text(start)}'")
            return null
        }
        var result:ASTNode? := null
        def chunk := MutableString()
        loop {
            def token := rawNext()
            if token.kind = start.kind {
                break
            }
            match token.kind {
                when Token.Kind.WHITESPACE {
                    def str := text(token)
                    if str.contains("\n") {
                        error(start, "unterminated string literal")
                        return null
                    }
                    chunk.append(str)
                }
                when Token.Kind.EOF {
                    error(start, "unterminated string literal")
                    return null
                }
                when Token.Kind.BACKSLASH {
                    def escape := rawNext()
                    if escape.kind = Token.Kind.EOF {
                        error(start, "unterminated string literal")
                        return null
                    }
                    def escapeText := text(escape)
                    def c := escapeText.utf8[0]
                    match c {
                        when "n"  { chunk.append("\n") }
                        when "r"  { chunk.append("\r") }
                        when "t"  { chunk.append("\t") }
                        when "'"  { chunk.append("'") }
                        when "\"" { chunk.append("\"") }
                        when "\\" { chunk.append("\\") }
                        when "{" {
                            -- handle string interpolation
                            def oldAllow := allowLambdas
                            allowLambdas := false
                            var expr := expression()
                            allowLambdas := oldAllow
                            if expr == null {
                                return null
                            }
                            def align:String? := null
                            def format:String? := null
                            if checkNext(Token.Kind.COMMA) !== null {
                                align := alignmentString(start)
                            }
                            if checkNext(Token.Kind.COLON) !== null {
                                format := formatString(start)
                                if format == null {
                                    return null
                                }
                                def formattable := ASTNode.TYPE(expr.position(),
                                        "frost.core.Formattable")
                                def cast := ASTNode.BINARY(expr.position(), expr,
                                        Binary.Operator.CAST, formattable)
                                def dot := ASTNode.DOT(expr.position(), cast, "format")
                                def callArgs := Array<ASTNode>() -- FIXME literal
                                callArgs.add(ASTNode.STRING(start.position, format))
                                expr := ASTNode.CALL(expr.position(), dot,
                                        FixedArray<ASTNode>.from(callArgs))
                            }
                            if expect(Token.Kind.RBRACE, "'}'") == null {
                                return null
                            }
                            if align !== null {
                                if format == null {
                                    expr := convertToString(expr)
                                }
                                def frostType := ASTNode.TYPE(expr.position(), "frost.core.Frost")
                                def callTarget := ASTNode.DOT(expr.position(), frostType, "align")
                                def callArgs := Array<ASTNode>()
                                callArgs.add(expr)
                                callArgs.add(ASTNode.STRING(start.position, align))
                                expr := ASTNode.CALL(expr.position(), callTarget,
                                        FixedArray<ASTNode>.from(callArgs))
                            }
                            def text := chunk.finish()
                            chunk := MutableString()
                            if text != "" | result !== null {
                                result := addStringChunk(result, ASTNode.STRING(start.position,
                                        text))
                                result := addStringChunk(result, expr)
                            }
                            else {
                                result := convertToString(expr)
                            }
                        }
                        otherwise {
                            error(token, "invalid string escape sequence")
                            return null
                        }
                    }
                    chunk.append(escapeText[escapeText.next(escapeText.start)..])
                }
                otherwise {
                    chunk.append(text(token))
                }
            }
        }
        return addStringChunk(result, ASTNode.STRING(start.position, chunk.finish()))
    }

    ================================================================================================
    parenthesizedExpression = LPAREN expression (COMMA expression)* RPAREN |
            LPAREN IDENTIFIER (COMMA IDENTIFIER)* RPAREN YIELDS expression |
            LPAREN IDENTIFIER COLON type (COMMA IDENTIFIER COLON type)* RPAREN YIELDS expression
    ================================================================================================
    method parenthesizedExpression():ASTNode? {
        def start := expect(Token.Kind.LPAREN, "'('")
        if start == null {
            return null
        }
        def peek1 := next()
        if peek1.kind = Token.Kind.IDENTIFIER {
            -- possible tuple or lambda
            def peek2 := next()
            match peek2.kind {
                when Token.Kind.COLON {
                    -- typed lambda
                    def parameters := Array<ASTNode>()
                    def firstType := type()
                    if firstType == null {
                        return null
                    }
                    parameters.add(ASTNode.PARAMETER(peek1.position, text(peek1), firstType))
                    while checkNext(Token.Kind.COMMA) !== null {
                        def nextName := expect(Token.Kind.IDENTIFIER, "an identifier")
                        if expect(Token.Kind.COLON, "':'") == null {
                            return null
                        }
                        def nextType := type()
                        if nextType == null {
                            return null
                        }
                        parameters.add(ASTNode.PARAMETER(nextName.position, text(nextName),
                                nextType))
                    }
                    -- we might have a parenthesis here, as in (x:Int)=>1, or it might be around the
                    -- whole lambda, as in (x:Int=>1)
                    def needClosingParen:Bit
                    if parameters.count > 1 {
                        expect(Token.Kind.RPAREN, "')'")
                        return null
                    }
                    else {
                        needClosingParen := checkNext(Token.Kind.RPAREN) == null
                    }
                    if expect(Token.Kind.YIELDS, "'=>1'") == null {
                        return null
                    }
                    def body := expression()
                    if body == null {
                        return null
                    }
                    if needClosingParen {
                        expect(Token.Kind.RPAREN, "')'")
                    }
                    return ASTNode.TYPED_LAMBDA(start.position,
                            FixedArray<ASTNode>.from(parameters), body)
                }
                when Token.Kind.COMMA {
                    -- untyped lambda or tuple
                    def parameters := Array<ASTNode>()
                    parameters.add(ASTNode.IDENTIFIER(peek1.position, text(peek1)))
                    var validLambda := true
                    do {
                        def nextExpr := expression()
                        if nextExpr == null {
                            return null
                        }
                        match nextExpr {
                            when ASTNode.IDENTIFIER {
                                -- do nothing
                            }
                            otherwise {
                                validLambda := false
                            }
                        }
                        parameters.add(nextExpr)
                    }
                    while checkNext(Token.Kind.COMMA) !== null
                    if expect(Token.Kind.RPAREN, "')'") == null {
                        return null
                    }
                    if validLambda & checkNext(Token.Kind.YIELDS) !== null {
                        def body := expression()
                        if body == null {
                            return null
                        }
                        return ASTNode.UNTYPED_LAMBDA(start.position,
                                FixedArray<ASTNode>.from(parameters), body)
                    }
                    return ASTNode.TUPLE(start.position, FixedArray<ASTNode>.from(parameters))
                }
                when Token.Kind.RPAREN {
                    -- either a single-parameter untyped lambda or a parenthesized identifier
                    if checkNext(Token.Kind.YIELDS) !== null {
                        def parameters := Array<ASTNode>()
                        parameters.add(ASTNode.IDENTIFIER(peek1.position, text(peek1)))
                        def body := expression()
                        if body == null {
                            return null
                        }
                        return ASTNode.UNTYPED_LAMBDA(start.position,
                                FixedArray<ASTNode>.from(parameters), body)
                    }
                    -- just a parenthesized identifier
                    return ASTNode.IDENTIFIER(peek1.position, text(peek1))
                }
                otherwise {
                    pushback(peek2)
                }
            }
        }
        pushback(peek1)
        var expr := expression()
        if expr == null {
            return null
        }
        if peek().kind = Token.Kind.COMMA {
            -- tuple
            def args:Array<ASTNode> := [expr]
            while checkNext(Token.Kind.COMMA) !== null {
                def next := expression()
                if next == null {
                    return null
                }
                args.add(next)
            }
            expr := ASTNode.TUPLE(start.position, FixedArray<ASTNode>.from(args))
        }
        expect(Token.Kind.RPAREN, "')'")
        return expr
    }

    ================================================================================================
    arrayLiteral = LBRACKET (expression (COMMA expression)*)? RBRACKET
    ================================================================================================
    method arrayLiteral():ASTNode? {
        def start := expect(Token.Kind.LBRACKET, "'['")
        def args := Array<ASTNode>()
        if checkNext(Token.Kind.RBRACKET) == null {
            commaSeparatedExpressionContext.push(true) -- FIXME use init / cleanup to automate this
            if checkNext(Token.Kind.RPAREN) == null {
                var expr := expression()
                if expr == null {
                    commaSeparatedExpressionContext.pop()
                    return null
                }
                args.add(expr)
                while checkNext(Token.Kind.COMMA) !== null {
                    expr := expression()
                    if expr == null {
                        commaSeparatedExpressionContext.pop()
                        return null
                    }
                    args.add(expr)
                }
                if expect(Token.Kind.RBRACKET, "']'") == null {
                    commaSeparatedExpressionContext.pop()
                    return null
                }
            }
            commaSeparatedExpressionContext.pop()
        }
        return ASTNode.ARRAY(start.position, FixedArray<ASTNode>.from(args))
    }

    ================================================================================================
    lambda = IDENTIFIER (COLON type) YIELDS expression
    ================================================================================================
    method lambda():ASTNode? {
        def start := expect(Token.Kind.IDENTIFIER, "an identifier")
        if checkNext(Token.Kind.COLON) !== null {
            def t := type()
            if t == null {
                return null
            }
            def parameters := Array<ASTNode>()
            parameters.add(ASTNode.PARAMETER(start.position, text(start), t))
            if expect(Token.Kind.YIELDS, "'=>'") == null {
                return null
            }
            def expr := expression()
            if expr == null {
                return null
            }
            return ASTNode.TYPED_LAMBDA(start.position, FixedArray<ASTNode>.from(parameters),
                    expr)
        }
        def parameters := Array<ASTNode>()
        parameters.add(ASTNode.IDENTIFIER(start.position, text(start)))
        if expect(Token.Kind.YIELDS, "'=>'") == null {
            return null
        }
        def expr := expression()
        if expr == null {
            return null
        }
        return ASTNode.UNTYPED_LAMBDA(start.position, FixedArray<ASTNode>.from(parameters),
                expr)
    }

    ================================================================================================
    REGEX = DIV <see org.frostlangauge.regex.Parser for grammar> DIV
    ================================================================================================
    method regex():ASTNode? {
        if expect(Token.Kind.DIV, "'/'") == null {
            return null
        }

        def start := lexer.dfa.offset - 1
        regexParser.lexer.dfa.offset := lexer.dfa.offset
        regexParser.lexer.dfa.line := lexer.dfa.line
        regexParser.lexer.dfa.column := lexer.dfa.column
        def regex := regexParser.regex()
        lexer.dfa.offset := regexParser.lexer.dfa.offset
        lexer.dfa.line := regexParser.lexer.dfa.line
        lexer.dfa.column := regexParser.lexer.dfa.column
        if regex == null {
            return null
        }
        if expect(Token.Kind.DIV, "'/'") == null {
            return null
        }
        if syntaxHighlighter !== null {
            -- remove the two '/'s
            syntaxHighlighter.rewind()
            syntaxHighlighter.rewind()
            -- add back the whole regex
            syntaxHighlighter.add(Token(Token.Kind.REGEX, String.Index(start),
                    String.Index(lexer.dfa.offset), regex.position()))
        }
        return regex
    }

    ================================================================================================
    term = IDENTIFIER | DECIMAL | BINARY | HEX | REAL | SELF | SUPER | NULL | TRUE | FALSE |
            string | parenthesizedExpression | arrayLiteral |
            ANNOTATION(@pre) LPAREN expression RPAREN | anonymousMethod | lambda | regex |
            ANNOTATION(@return)
    ================================================================================================
    method term():ASTNode? {
        def t := next()
        match t.kind {
            when Token.Kind.IDENTIFIER {
                def check := peek().kind
                if (allowLambdas & check = Token.Kind.COLON) | check = Token.Kind.YIELDS {
                    pushback(t)
                    return lambda()
                }
                return ASTNode.IDENTIFIER(t.position, text(t))
            }
            when Token.Kind.DECIMAL {
                return ASTNode.INT(t.position, text(t).asUInt64)
            }
            when Token.Kind.BINARY {
                return ASTNode.INT(t.position, UInt64.parse(text(t)[2..], 2))
            }
            when Token.Kind.HEX {
                return ASTNode.INT(t.position, UInt64.parse(text(t)[2..], 16))
            }
            when Token.Kind.REAL {
                return ASTNode.REAL(t.position, text(t).asReal64)
            }
            when Token.Kind.SELF {
                return ASTNode.SELF(t.position)
            }
            when Token.Kind.SUPER {
                return ASTNode.SUPER(t.position)
            }
            when Token.Kind.NULL {
                return ASTNode.NULL(t.position)
            }
            when Token.Kind.TRUE {
                return ASTNode.BIT(t.position, true)
            }
            when Token.Kind.FALSE {
                return ASTNode.BIT(t.position, false)
            }
            when Token.Kind.DOUBLE_QUOTE, Token.Kind.SINGLE_QUOTE {
                pushback(t)
                return string()
            }
            when Token.Kind.LPAREN {
                pushback(t)
                return parenthesizedExpression()
            }
            when Token.Kind.LBRACKET {
                pushback(t)
                return arrayLiteral()
            }
            when Token.Kind.ANNOTATION {
                def name := text(t)
                if name = "@pre" {
                    expect(Token.Kind.LPAREN, "'('")
                    def expr := expression()
                    if expr == null {
                        return null
                    }
                    expect(Token.Kind.RPAREN, "')'")
                    return ASTNode.AT_PRE(t.position, expr)
                }
                else if name = "@return" {
                    return ASTNode.AT_RETURN(t.position)
                }
                error(t, "expected an expression, but found '\{name}'")
                return null
            }
            when Token.Kind.FUNCTION, Token.Kind.METHOD {
                pushback(t)
                return anonymousMethod()
            }
            when Token.Kind.DIV {
                pushback(t)
                return regex()
            }
            otherwise {
                error(t, "expected an expression, but found '\{text(t)}'")
                return null
            }
        }
    }

    @class
    function getClassName(expr:ASTNode):String? {
        match expr {
            when ASTNode.IDENTIFIER(_, text) {
                return text
            }
            when ASTNode.DOT(_, base, field) {
                var result := getClassName(base)
                if result !== null {
                    result += "." + field
                }
                return result
            }
            otherwise {
                return null
            }
        }
    }

    ================================================================================================
    methodName = IDENTIFIER | ADD | SUB | MUL | DIV | INTDIV | POW | EQ | GT | LT | GTEQ | LTEQ |
            REM | AND | BITWISEAND | OR | BITWISEOR | XOR | BITWISEXOR | NOT | BITWISENOT |
            SHIFTLEFT | SHIFTRIGHT | (LBRACKET RBRACKET ASSIGNMENT?)
    ================================================================================================
    method methodName():String? {
        def name := next()
        match name.kind {
            when Token.Kind.IDENTIFIER, Token.Kind.ADD, Token.Kind.SUB, Token.Kind.MUL,
                    Token.Kind.DIV, Token.Kind.INTDIV, Token.Kind.POW, Token.Kind.EQ,
                    Token.Kind.NEQ, Token.Kind.LT, Token.Kind.GTEQ, Token.Kind.LTEQ,
                    Token.Kind.REM, Token.Kind.AND, Token.Kind.BITWISEAND, Token.Kind.OR,
                    Token.Kind.BITWISEOR, Token.Kind.XOR, Token.Kind.BITWISEXOR, Token.Kind.NOT,
                    Token.Kind.BITWISENOT, Token.Kind.SHIFTLEFT {
                return text(name)
            }
            when Token.Kind.GT {
                def token := rawNext()
                if token.kind = Token.Kind.GT { -- two GT's in a row = SHIFTRIGHT
                    return ">>"
                }
                else {
                    pushback(token)
                    return ">"
                }
            }
            when Token.Kind.LBRACKET {
                if expect(Token.Kind.RBRACKET, "']'") == null {
                    return null
                }
                if checkNext(Token.Kind.ASSIGNMENT) !== null {
                    return "[]:="
                }
                return "[]"
            }
            otherwise {
                error(name,
                        "expected an identifier or operator, but found '\{text(name)}'")
                return null
            }
        }
    }

    method type():ASTNode? {
        return type(true)
    }

    ================================================================================================
    functionOrTupleType = LPAREN (type (COMMA type)*)? RPAREN ((YIELDS | YIELDS_METHOD |
            YIELDS_IMMUTABLE | YIELDS_METHOD_IMMUTABLE) LPAREN (type (COMMA type)*)? RPAREN)?
    ================================================================================================
    method functionOrTupleType():ASTNode? {
        def start := expect(Token.Kind.LPAREN, "'('")
        if start == null {
            return null
        }
        def subtypes := Array<ASTNode>()
        if checkNext(Token.Kind.RPAREN) == null {
            var t := type()
            if t == null {
                return null
            }
            subtypes.add(t)
            while checkNext(Token.Kind.COMMA) !== null {
                t := type()
                if t == null {
                    return null
                }
                subtypes.add(t)
            }
            if expect(Token.Kind.RPAREN, "')'") == null {
                return null
            }
        }
        def yields := peek()
        match yields.kind {
            when Token.Kind.YIELDS, Token.Kind.YIELDS_METHOD, Token.Kind.YIELDS_IMMUTABLE,
                    Token.Kind.YIELDS_METHOD_IMMUTABLE {
                next()
                if expect(Token.Kind.LPAREN, "'('") == null {
                    return null
                }
                def returnTypes := Array<ASTNode>()
                if checkNext(Token.Kind.RPAREN) == null {
                    var t := type()
                    if t == null {
                        return null
                    }
                    returnTypes.add(t)
                    while checkNext(Token.Kind.COMMA) !== null {
                        t := type()
                        if t == null {
                            return null
                        }
                        returnTypes.add(t)
                    }
                    if expect(Token.Kind.RPAREN, "')'") == null {
                        return null
                    }
                }
                def returnType:ASTNode?
                if returnTypes.count = 0 {
                    returnType := null
                }
                else if returnTypes.count = 1 {
                    returnType := returnTypes[0]
                }
                else {
                    --returnType := ASTNode.TUPLE_TYPE(start.position, returnTypes.finish())
                    error(start, "tuple types are not yet supported")
                    return null
                }
                return ASTNode.METHOD_TYPE(start.position, yields.kind,
                        FixedArray<ASTNode>.from(subtypes), returnType)
            }
            otherwise {
                --return ASTNode.TUPLE_TYPE(start.position, FixedArray<ASTNode>.from(subtypes))
                error(start, "tuple types are not yet supported")
                return null
            }
        }
    }

    ================================================================================================
    type = (IDENTIFIER (DOT IDENTIFIER)* (LT type (COMMA type)*) GT)? | functionOrTupleType)
            QUESTION?
    ================================================================================================
    method type(needSpeculativeParse:Bit):ASTNode? {
        var result:ASTNode?
        if peek().kind = Token.Kind.LPAREN {
            result := functionOrTupleType()
            if result == null {
                return null
            }
        }
        else {
            def start := expect(Token.Kind.IDENTIFIER, "an identifier")
            if start == null {
                return null
            }
            def name := MutableString(text(start))
            while checkNext(Token.Kind.DOT) !== null {
                def id := expect(Token.Kind.IDENTIFIER, "an identifier")
                if id == null {
                    return null
                }
                name.append(".")
                name.append(text(id))
            }
            def finalName := name.finish()
            result := ASTNode.TYPE(start.position, finalName)
            if peek().kind = Token.Kind.LT {
                -- may need to speculatively parse, because foo->Int8<bar looks like the start of a cast
                -- to "Int8<bar...", but is actually a cast to Int8 followed by less-than bar
                if needSpeculativeParse {
                    startSpeculative()
                }
                next()
                def children := Array<ASTNode>()
                var t := type(false)
                if t == null {
                    if needSpeculativeParse {
                        rewind()
                        return result
                    }
                    return null
                }
                children.add(t)
                while checkNext(Token.Kind.COMMA) !== null {
                    t := type(false)
                    if t == null {
                        if needSpeculativeParse {
                            rewind()
                            return result
                        }
                        return null
                    }
                    children.add(t)
                }
                if expect(Token.Kind.GT, "'>'") == null {
                    if needSpeculativeParse {
                        rewind()
                        return result
                    }
                    return null
                }
                result := ASTNode.GENERIC_TYPE(start.position, finalName,
                        FixedArray<ASTNode>.from(children))
                if needSpeculativeParse {
                    accept()
                }
            }
        }
        if checkNext(Token.Kind.QUESTION) !== null {
            result := ASTNode.NULLABLE_TYPE(result.position(), result)
        }
        return result
    }

    ================================================================================================
    typeSpecifiers = LT type (COMMA type)* GR
    ================================================================================================
    method typeSpecifiers():FixedArray<ASTNode>? {
        if expect(Token.Kind.LT, "'<'") == null {
            return null
        }
        def result := Array<ASTNode>()
        {
            def t := type()
            if t == null {
                return null
            }
            result.add(t)
        }
        while checkNext(Token.Kind.COMMA) !== null {
            def t := type()
            if t == null {
                return null
            }
            result.add(t)
        }
        if expect(Token.Kind.GT, "'>'") == null {
            return null
        }
        return FixedArray<ASTNode>.from(result)
    }

    ================================================================================================
    postfixExpression = term ((LPAREN (expression (COMMA expression)*)? RPAREN |
            DOT (methodName | INIT) typeSpecifiers? | LBRACKET expression RBRACKET)* |
            (CAST | INSTANCEOF | NINSTANCEOF) type)*
            (<if result so far is a valid class name> LT type (COMMA type)* GT)?
    Note there is a great deal of special handling to deal with class names, due to ambiguities
    between generic parameters and comparison expressions, e.g. foo(X < Y, Z > ... could be either a
    generic type X<Y, Z> or two comparison expressions X < Y and Z > <whatever the next token is>.
    We can't disambiguate this until we see the next token.
    ================================================================================================
    method postfixExpression():ASTNode? {
        var result := term()
        if result == null {
            return null
        }
        loop {
            def token := next()
            match token.kind {
                when Token.Kind.LPAREN {
                    commaSeparatedExpressionContext.push(true) -- FIXME use init / cleanup to automate this
                    def args := Array<ASTNode>()
                    if checkNext(Token.Kind.RPAREN) == null {
                        var expr := expression()
                        if expr == null {
                            commaSeparatedExpressionContext.pop()
                            return null
                        }
                        args.add(expr)
                        while checkNext(Token.Kind.COMMA) !== null {
                            expr := expression()
                            if expr == null {
                                commaSeparatedExpressionContext.pop()
                                return null
                            }
                            args.add(expr)
                        }
                        if expect(Token.Kind.RPAREN, "')'") == null {
                            commaSeparatedExpressionContext.pop()
                            return null
                        }
                    }
                    commaSeparatedExpressionContext.pop()
                    result := ASTNode.CALL(token.position, result,
                            FixedArray<ASTNode>.from(args))
                }
                when Token.Kind.LBRACKET {
                    def arg := expression()
                    if arg == null {
                        return null
                    }
                    if expect(Token.Kind.RBRACKET, "']'") == null {
                        return null
                    }
                    result := ASTNode.BINARY(token.position, result, Binary.Operator.INDEX, arg)
                }
                when Token.Kind.DOT {
                    def name:String?
                    if checkNext(Token.Kind.INIT) !== null {
                        name := "init"
                    }
                    else {
                        name := methodName()
                        if name == null {
                            return null
                        }
                    }
                    def base := result
                    result := ASTNode.DOT(token.position, base, name)
                    if peek().kind = Token.Kind.LT {
                        startSpeculative()
                        def types := typeSpecifiers()
                        if types !== null {
                            accept()
                            result := ASTNode.DOT_GENERICS(token.position, base, name, types)
                        }
                        else {
                            rewind()
                            return result
                        }
                    }
                }
                when Token.Kind.CAST {
                    def target := type()
                    if target == null {
                        return null
                    }
                    result := ASTNode.BINARY(token.position, result, Binary.Operator.CAST, target)
                }
                when Token.Kind.LT {
                    -- this is where we need to be careful. First, we make sure it makes sense to
                    -- interpret this as the start of a generic parameter list...
                    pushback(token)
                    def name := getClassName(result)
                    if name !== null {
                        startSpeculative()
                        next()
                        -- no matter what, we might have to backtrack, because we might not find a
                        -- '>', e.g. foo(X < Y)
                        def types := Array<ASTNode>()
                        var t := type(false)
                        if t == null {
                            rewind()
                            return result
                        }
                        types.add(t)
                        while checkNext(Token.Kind.COMMA) !== null {
                            t := type(false)
                            if t == null {
                                rewind()
                                return result
                            }
                            types.add(t)
                        }
                        def gt := expect(Token.Kind.GT, "'>'")
                        if gt == null {
                            rewind()
                            return result
                        }
                        -- ok, we've successfully parsed a type... but we still might be wrong. If
                        -- we have, say, X<Y, Z>, it's possible that was supposed to be two
                        -- comparison expressions (which would include whatever the next token is).
                        -- Consider the following cases:
                        --
                        -- var x := X<Y, Z>
                        -- foo() -- type name followed by a method call
                        --
                        -- bar(X<Y, Z>foo) -- two expressions, X<Y and Z>foo
                        --
                        -- note that, ignoring whitespace, the sequence X<Y,Z>foo is identical in
                        -- both cases. We can resolve the ambiguity by noting that the other
                        -- interpretation is incorrect in both cases; there is no way for
                        -- var x := (two expressions) to make sense, and there is no way for
                        -- (<type name> <identifier>) to make sense in function call parameters.
                        -- So, we keep track of whether we are in a context that expects a comma-
                        -- separated list of expressions. If so, we need to look at the next token
                        -- after the type, as only a very few tokens can legally follow a type name
                        -- in an expression list. If not, we know it's a type regardless of what
                        -- follows it, because there is no way it can resolve to multiple
                        -- expressions.
                        --
                        -- There is one remaining ambiguity: if the next token is a left
                        -- parenthesis ('bar(X<Y, Z>(foo))'), either interpretation is valid . We
                        -- resolve this (very rare) case using whitespace: if there is no space
                        -- between the '>' and '(', we assume it is a type, otherwise we assume it
                        -- is an operator.
                        def shouldAccept:Bit
                        if commaSeparatedExpressionContext[0] {
                            def n := next()
                            match n.kind {
                                when Token.Kind.DOT, Token.Kind.COMMA, Token.Kind.CAST {
                                    shouldAccept := true
                                }
                                when Token.Kind.LPAREN {
                                    shouldAccept := n.position.line = gt.position.line &
                                            n.position.column = gt.position.column + 1
                                }
                                otherwise {
                                    shouldAccept := false
                                }
                            }
                            if shouldAccept {
                                pushback(n)
                            }
                        }
                        else {
                            shouldAccept := true
                        }
                        if shouldAccept {
                            accept()
                            result := ASTNode.GENERIC_TYPE(result.position(), name,
                                    FixedArray<ASTNode>.from(types))
                            continue
                        }
                        else {
                            rewind()
                            return result
                        }
                    }
                    return result
                }
                otherwise {
                    pushback(token)
                    return result
                }
            }
        }
    }

    ================================================================================================
    exponentExression = postfixExpression (POW postfixExpression)*
    ================================================================================================
    method exponentExpression():ASTNode? {
        var result := postfixExpression()
        if result == null {
            return null
        }
        loop {
            def op := checkNext(Token.Kind.POW)
            if op == null {
                break
            }
            def next := postfixExpression()
            if next == null {
                return null
            }
            result := ASTNode.BINARY(op.position, result, Binary.Operator.fromToken(op), next)
        }
        return result
    }

    ================================================================================================
    prefixExpression = (SUB | NOT | BITWISENOT)? exponentExpression
    ================================================================================================
    method prefixExpression():ASTNode? {
        def op := next()
        match op.kind {
            when Token.Kind.SUB, Token.Kind.NOT, Token.Kind.BITWISENOT {
                def base := exponentExpression()
                if base == null {
                    return null
                }
                return ASTNode.UNARY(op.position, Unary.Operator.fromToken(op), base)
            }
            otherwise {
                pushback(op)
                return exponentExpression()
            }
        }
    }

    ================================================================================================
    multiplicativeExpression = prefixExpression ((MUL | DIV | INTDIV | REM | SHIFTLEFT |
            SHIFTRIGHT | BITWISEAND | BITWISEXOR) prefixExpression)*
    Note that SHIFTRIGHT is handled specially, as the lexer only produces GT and we synthesize the
    SHIFTRIGHT token here.
    ================================================================================================
    method multiplicativeExpression():ASTNode? {
        var result := prefixExpression()
        if result == null {
            return null
        }
        loop {
            def op := next()
            match op.kind {
                when Token.Kind.MUL, Token.Kind.DIV, Token.Kind.INTDIV, Token.Kind.REM,
                        Token.Kind.SHIFTLEFT, Token.Kind.BITWISEAND, Token.Kind.BITWISEOR {
                    def next := prefixExpression()
                    if next == null {
                        return null
                    }
                    result := ASTNode.BINARY(op.position, result, Binary.Operator.fromToken(op),
                            next)
                }
                when Token.Kind.GT {
                    def nextToken := rawNext()
                    if nextToken.kind = Token.Kind.GT {
                        -- two GTs in a row = SHIFTRIGHT
                        def next := prefixExpression()
                        if next == null {
                            return null
                        }
                        result := ASTNode.BINARY(op.position, result, Binary.Operator.SHIFTRIGHT,
                                next)
                    }
                    else {
                        pushback(nextToken)
                        pushback(op)
                        return result
                    }
                }
                otherwise {
                    pushback(op)
                    return result
                }
            }
        }
    }

    ================================================================================================
    additiveExpression = multiplicativeExpression
            ((ADD | SUB | BITWISEOR) multiplicativeExpression)*
    ================================================================================================
    method additiveExpression():ASTNode? {
        var result := multiplicativeExpression()
        if result == null {
            return null
        }
        loop {
            def op := next()
            match op.kind {
                when Token.Kind.ADD, Token.Kind.SUB, Token.Kind.BITWISEXOR {
                    def next := multiplicativeExpression()
                    if next == null {
                        return null
                    }
                    result := ASTNode.BINARY(op.position, result, Binary.Operator.fromToken(op),
                            next)
                }
                otherwise {
                    pushback(op)
                    return result
                }
            }
        }
    }

    ================================================================================================
    rangeExpression = additiveExpression | (additiveExpression? (DOTDOT | ELLIPSIS)
           additiveExpression? (BY additiveExpression)?)
    ================================================================================================
    method rangeExpression():ASTNode? {
        var result:ASTNode?
        match peek().kind {
            when Token.Kind.DOTDOT, Token.Kind.ELLIPSIS {
                result := null
            }
            otherwise {
                result := additiveExpression()
                if result == null {
                    return null
                }
            }
        }
        def op := next()
        match op.kind {
            when Token.Kind.DOTDOT, Token.Kind.ELLIPSIS {
                def next := peek()
                def right:ASTNode?
                match next.kind {
                    -- Technically there is an ambiguity here with tokens that can begin both a
                    -- statement or an expression, like "self". You could write something beginning
                    -- e.g. "def a := 1 ... self", and it's unclear whether that "self" is the
                    -- beginning of a new statement or the beginning of an expression designating
                    -- the end of the range. I don't know how likely it is that anyone will ever
                    -- encounter this in practice (there's little reason to use a range out in the
                    -- open like that) but it's easily worked around with some parentheses.
                    when Token.Kind.RBRACKET, Token.Kind.RPAREN, Token.Kind.BY, Token.Kind.LBRACE,
                            Token.Kind.RBRACE, Token.Kind.COMMA, Token.Kind.IF, Token.Kind.FOR,
                            Token.Kind.WHILE, Token.Kind.DO, Token.Kind.LOOP, Token.Kind.ASSERT,
                            Token.Kind.MATCH, Token.Kind.VAR, Token.Kind.DEF, Token.Kind.PROPERTY,
                            Token.Kind.CONSTANT, Token.Kind.INIT, Token.Kind.METHOD,
                            Token.Kind.FUNCTION, Token.Kind.TRY, Token.Kind.UNREACHABLE {
                        right := null
                    }
                    otherwise {
                        right := additiveExpression()
                        if right == null {
                            return null
                        }
                    }
                }
                def step:ASTNode?
                if checkNext(Token.Kind.BY) !== null {
                    step := additiveExpression()
                    if step == null {
                        return null
                    }
                }
                else {
                    step := null
                }
                return ASTNode.RANGE(op.position, result, op.kind = Token.Kind.ELLIPSIS, right,
                        step)
            }
            otherwise {
                pushback(op)
                return result
            }
        }
    }

    ================================================================================================
    comparisonExpression = rangeExpression ((EQ | IDENTITY | NEQ |
             NIDENTITY | LT | GT | LTEQ | GTEQ | IN) rangeExpression)*
    ================================================================================================
    method comparisonExpression():ASTNode? {
        var result := rangeExpression()
        if result == null {
            return null
        }
        loop {
            def op := next()
            match op.kind {
                when Token.Kind.EQ,
                        Token.Kind.NEQ,
                        Token.Kind.IDENTITY,
                        Token.Kind.NIDENTITY,
                        Token.Kind.LT,
                        Token.Kind.GT,
                        Token.Kind.LTEQ,
                        Token.Kind.GTEQ {
                    def next := rangeExpression()
                    if next == null {
                        return null
                    }
                    result := ASTNode.BINARY(op.position, result, Binary.Operator.fromToken(op),
                            next)
                }
                otherwise {
                    pushback(op)
                    return result
                }
            }
        }
    }

    ================================================================================================
    andExpression = comparisonExpression ((AND | XOR) comparisonExpression)*
    ================================================================================================
    method andExpression():ASTNode? {
        var result := comparisonExpression()
        if result == null {
            return null
        }
        loop {
            def op := next()
            match op.kind {
                when Token.Kind.AND, Token.Kind.XOR {
                    def next := comparisonExpression()
                    if next == null {
                        return null
                    }
                    result := ASTNode.BINARY(op.position, result, Binary.Operator.fromToken(op),
                            next)
                }
                otherwise {
                    pushback(op)
                    return result
                }
            }
        }
    }

    ================================================================================================
    expression = andExpression (OR andExpression)*
    ================================================================================================
    method expression():ASTNode? {
        var result := andExpression()
        if result == null {
            return null
        }
        loop {
            def op := checkNext(Token.Kind.OR)
            if op == null {
                break
            }
            def next := andExpression()
            if next == null {
                return null
            }
            result := ASTNode.BINARY(op.position, result, Binary.Operator.fromToken(op), next)
        }
        return result
    }

    ================================================================================================
    ifStatement = IF expression block (else (ifStatement | block))?
    ================================================================================================
    method ifStatement():ASTNode? {
        def start := expect(Token.Kind.IF, "'if'")
        if start == null {
            return null
        }
        def test := expression()
        if test == null {
            return null
        }
        def ifTrue := blockStatements()
        if ifTrue == null {
            return null
        }
        var ifFalse:ASTNode?
        if checkNext(Token.Kind.ELSE) !== null {
            if peek().kind = Token.Kind.IF {
                ifFalse := ifStatement()
                if ifFalse == null {
                    return null
                }
            }
            else {
                ifFalse := block()
                if ifFalse == null {
                    return null
                }
            }
        }
        else {
            ifFalse := null
        }
        return ASTNode.IF(start.position, test, ifTrue, ifFalse)
    }

    ================================================================================================
    typeDeclaration = COLON type
    ================================================================================================
    method typeDeclaration():ASTNode? {
        if expect(Token.Kind.COLON, "':'") == null {
            return null
        }
        return type(false)
    }

    ================================================================================================
    target = IDENTIFIER (typeDeclaration?)
    ================================================================================================
    method target():ASTNode? {
        def id := expect(Token.Kind.IDENTIFIER, "an identifier")
        if id == null {
            return null
        }
        if peek().kind = Token.Kind.COLON {
            def type := typeDeclaration()
            if type == null {
                return null
            }
            return ASTNode.TYPED_IDENTIFIER(id.position, text(id), type)
        }
        return ASTNode.IDENTIFIER(id.position, text(id))
    }

    ================================================================================================
    forLoop = FOR target IN expression block
    ================================================================================================
    method forLoop(label:String?):ASTNode? {
        def start := expect(Token.Kind.FOR, "'for'")
        if start == null {
            return null
        }
        def t := target()
        if t == null {
            return null
        }
        if expect(Token.Kind.IN, "'in'") == null {
            return null
        }
        def list := expression()
        if list == null {
            return null
        }
        def block := blockStatements()
        if block == null {
            return null
        }
        return ASTNode.FOR(start.position, label, t, list, block)
    }

    ================================================================================================
    whileLoop = WHILE expression block
    ================================================================================================
    method whileLoop(label:String?):ASTNode? {
        def start := expect(Token.Kind.WHILE, "'while'")
        if start == null {
            return null
        }
        def test := expression()
        if test == null {
            return null
        }
        def body := blockStatements()
        if body == null {
            return null
        }
        return ASTNode.WHILE(start.position, label, test, body)
    }

    ================================================================================================
    doLoop = DO block WHILE expression
    ================================================================================================
    method doLoop(label:String?):ASTNode? {
        def start := expect(Token.Kind.DO, "'do'")
        if start == null {
            return null
        }
        def body := blockStatements()
        if body == null {
            return null
        }
        if expect(Token.Kind.WHILE, "'while'") == null {
            return null
        }
        def test := expression()
        if test == null {
            return null
        }
        return ASTNode.DO(start.position, label, body, test)
    }

    ================================================================================================
    loopLoop = LOOP block
    ================================================================================================
    method loopLoop(label:String?):ASTNode? {
        def start := expect(Token.Kind.LOOP, "'loop'")
        if start == null {
            return null
        }
        def body := blockStatements()
        if body == null {
            return null
        }
        return ASTNode.LOOP(start.position, label, body)
    }

    ================================================================================================
    assertStatement = ASSERT expression (COMMA expression)?
    ================================================================================================
    method assertStatement():ASTNode? {
        def start := expect(Token.Kind.ASSERT, "'assert'")
        if start == null {
            return null
        }
        def expr := expression()
        if expr == null {
            return null
        }
        def message:ASTNode?
        if checkNext(Token.Kind.COMMA) !== null{
            message := expression()
            if message == null {
                return null
            }
        }
        else {
            message := null
        }
        return ASTNode.ASSERT(start.position, expr, message)
    }

    ================================================================================================
    unreachableStatement = UNREACHABLE (COMMA expression)?
    ================================================================================================
    method unreachableStatement():ASTNode? {
        def start := expect(Token.Kind.UNREACHABLE, "'unreachable'")
        if start == null {
            return null
        }
        def message:ASTNode?
        if checkNext(Token.Kind.COMMA) !== null{
            message := expression()
            if message == null {
                return null
            }
        }
        else {
            message := null
        }
        return ASTNode.UNREACHABLE(start.position, message)
    }

    ================================================================================================
    whenClause = WHEN expression (COMMA expression)* COLON statement* terminalStatement?
    ================================================================================================
    @pre(allowLambdas)
    @post(allowLambdas)
    method whenClause():ASTNode? {
        def start := expect(Token.Kind.WHEN, "'when'")
        if start == null {
            return null
        }
        def expressions := Array<ASTNode>()
        var expr := expression()
        if expr == null {
            return null
        }
        expressions.add(expr)
        while checkNext(Token.Kind.COMMA) !== null {
            expr := expression()
            if expr == null {
                return null
            }
            expressions.add(expr)
        }
        def statements := blockStatements()
        if statements == null {
            return null
        }
        return ASTNode.WHEN(start.position, FixedArray<ASTNode>.from(expressions), statements)
    }

    ================================================================================================
    match = MATCH expression LBRACE when* (DEFAULT COLON statement*)? RBRACE
    ================================================================================================
    method matchStatement():ASTNode? {
        def start := expect(Token.Kind.MATCH, "'match'")
        if start == null {
            return null
        }
        def expr := expression()
        if expr == null {
            return null
        }
        if expect(Token.Kind.LBRACE, "'{'") == null {
            return null
        }
        def whens := Array<ASTNode>()
        var other:FixedArray<ASTNode>? := null
        loop {
            def token := peek()
            match token.kind {
                when Token.Kind.RBRACE {
                    break
                }
                when Token.Kind.WHEN {
                    def w := whenClause()
                    if w == null {
                        return null
                    }
                    whens.add(w)
                }
                when Token.Kind.OTHERWISE {
                    def o := next()
                    other := blockStatements()
                    if other == null {
                        return null
                    }
                    break
                }
                otherwise {
                    next()
                    error(token, "expected 'when', 'otherwise', or '}', but " +
                            "found '\{text(token)}'")
                    break
                }
            }
        }
        if expect(Token.Kind.RBRACE, "'}'") == null {
            return null
        }
        if other !== null {
            return ASTNode.MATCH(start.position, expr, FixedArray<ASTNode>.from(whens), other)
        }
        return ASTNode.MATCH(start.position, expr, FixedArray<ASTNode>.from(whens), null)
    }

    ================================================================================================
    blockStatements = LBRACE statement* terminalStatement? RBRACE
    ================================================================================================
    method blockStatements():FixedArray<ASTNode>? {
        def start := expect(Token.Kind.LBRACE, "'{'")
        if start == null {
            return null
        }
        def result := Array<ASTNode>()
        loop {
            match peek().kind {
                when Token.Kind.RBRACE {
                    next()
                    break
                }
                when Token.Kind.BREAK, Token.Kind.CONTINUE, Token.Kind.RETURN {
                    def stmt := terminalStatement()
                    if stmt == null {
                        return null
                    }
                    if expect(Token.Kind.RBRACE, "'}'") == null {
                        return null
                    }
                    result.add(stmt)
                    break
                }
                otherwise {
                    def stmt := statement()
                    if stmt == null {
                        return null
                    }
                    result.add(stmt)
                }
            }
        }
        return FixedArray<ASTNode>.from(result)
    }

    ================================================================================================
    block = blockStatements
    ================================================================================================
    method block():ASTNode? {
        def statements := blockStatements()
        if statements == null {
            return null
        }
        return ASTNode.BLOCK(Position(), statements)
    }

    ================================================================================================
    expressionOrAssignment = expression assignmentOperator expression)?
    ================================================================================================
    method expressionOrAssignment():ASTNode? {
        def start := expression()
        if start == null {
            return null
        }
        match peek().kind {
            when Token.Kind.ASSIGNMENT, Token.Kind.ADDEQ, Token.Kind.SUBEQ, Token.Kind.MULEQ,
                    Token.Kind.DIVEQ, Token.Kind.REMEQ, Token.Kind.INTDIVEQ, Token.Kind.POWEQ,
                    Token.Kind.OREQ, Token.Kind.BITWISEOREQ, Token.Kind.ANDEQ,
                    Token.Kind.BITWISEANDEQ, Token.Kind.XOREQ, Token.Kind.BITWISEXOREQ,
                    Token.Kind.SHIFTLEFTEQ, Token.Kind.SHIFTRIGHTEQ {
                def op := next()
                def rvalue := expression()
                if rvalue == null {
                    return null
                }
                return ASTNode.BINARY(start.position(), start, Binary.Operator.fromToken(op),
                        rvalue)
            }
            when Token.Kind.EQ {
                error(peek(), "unexpected '=', perhaps you meant ':='?")
                def op := next()
                def rvalue := expression()
                if rvalue == null {
                    return null
                }
                return ASTNode.BINARY(start.position(), start, Binary.Operator.fromToken(op),
                        rvalue)
            }
            otherwise {
                return start
            }
        }
    }

    ================================================================================================
    singleVar = target (ASSIGNMENT expression)?
    ================================================================================================
    method singleVar():ASTNode? {
        def t := target()
        if t == null {
            return null
        }
        def value:ASTNode?
        if checkNext(Token.Kind.ASSIGNMENT) !== null {
            value := expression()
            if value == null {
                return null
            }
        }
        else if peek().kind = Token.Kind.EQ {
            error(next(), "unexpected '=', perhaps you meant ':='?")
            value := expression()
            if value == null {
                return null
            }
        }
        else {
            value := null
        }
        return ASTNode.DECLARATION(t.position(), t, value)
    }

    ================================================================================================
    varDeclaration = (VAR | DEF | PROPERTY | CONSTANT) singleVar (COMMA singleVar*)
    ================================================================================================
    method varDeclaration():ASTNode? {
        def start := next()
        def kind:Variable.Kind
        match start.kind {
            when Token.Kind.VAR {
                kind := Variable.Kind.VAR
            }
            when Token.Kind.DEF {
                kind := Variable.Kind.DEF
            }
            when Token.Kind.PROPERTY {
                kind := Variable.Kind.PROPERTY
            }
            when Token.Kind.CONSTANT {
                kind := Variable.Kind.CONSTANT
            }
            otherwise {
                error(start, "expected 'var', 'def', 'property', or 'constant'")
            }
        }
        def declarations := Array<ASTNode>()
        var decl := singleVar()
        if decl == null {
            return null
        }
        declarations.add(decl)
        while checkNext(Token.Kind.COMMA) !== null {
            var decl := singleVar()
            if decl == null {
                return null
            }
            declarations.add(decl)
        }
        return ASTNode.VAR(start.position, kind, FixedArray<ASTNode>.from(declarations))
    }

    ================================================================================================
    initCall = INIT LPAREN (expression (COMMA expression)*)? RPAREN
    ================================================================================================
    method initCall():ASTNode? {
        def start := expect(Token.Kind.INIT, "'init'")
        if start == null {
            return null
        }
        if expect(Token.Kind.LPAREN, "'('") == null {
            return null
        }
        commaSeparatedExpressionContext.push(true) -- FIXME use init / cleanup to automate this
        def target := ASTNode.IDENTIFIER(start.position, text(start))
        def args := Array<ASTNode>()
        if checkNext(Token.Kind.RPAREN) == null {
            var expr := expression()
            if expr == null {
                commaSeparatedExpressionContext.pop()
                return null
            }
            args.add(expr)
            while checkNext(Token.Kind.COMMA) !== null {
                expr := expression()
                if expr == null {
                    commaSeparatedExpressionContext.pop()
                    return null
                }
                args.add(expr)
            }
            if expect(Token.Kind.RPAREN, "')'") == null {
                commaSeparatedExpressionContext.pop()
                return null
            }
        }
        commaSeparatedExpressionContext.pop()
        return ASTNode.CALL(start.position, target, FixedArray<ASTNode>.from(args))
    }

    ================================================================================================
    breakStatement = BREAK IDENTIFIER?
    ================================================================================================
    method breakStatement():ASTNode? {
        def start := expect(Token.Kind.BREAK, "'break'")
        if start == null {
            return null
        }
        def label := checkNext(Token.Kind.IDENTIFIER)
        if label !== null {
            return ASTNode.BREAK(start.position, text(label))
        }
        return ASTNode.BREAK(start.position, null)
    }

    ================================================================================================
    continueStatement = CONTINUE IDENTIFIER?
    ================================================================================================
    method continueStatement():ASTNode? {
        def start := expect(Token.Kind.CONTINUE, "'continue'")
        if start == null {
            return null
        }
        def label := checkNext(Token.Kind.IDENTIFIER)
        if label !== null {
            return ASTNode.CONTINUE(start.position, text(label))
        }
        return ASTNode.CONTINUE(start.position, null)
    }

    ================================================================================================
    returnStatement = RETURN expression?
    ================================================================================================
    method returnStatement():ASTNode? {
        def start := expect(Token.Kind.RETURN, "'return'")
        if start == null {
            return null
        }
        match peek().kind {
            when Token.Kind.RBRACE, Token.Kind.WHEN, Token.Kind.OTHERWISE {
                return ASTNode.RETURN(start.position, null)
            }
            otherwise {
                def children := Array<ASTNode>()
                def expr := expression()
                if expr == null {
                    return null
                }
                children.add(expr)
                return ASTNode.RETURN(start.position, expr)
            }
        }
    }

    ================================================================================================
    terminalStatement = breakStatement | continueStatement | returnStatement
    ================================================================================================
    method terminalStatement():ASTNode? {
        match peek().kind {
            when Token.Kind.BREAK    { return breakStatement() }
            when Token.Kind.CONTINUE { return continueStatement() }
            when Token.Kind.RETURN   { return returnStatement() }
            otherwise                { unreachable }
        }
    }

    ================================================================================================
    anyLoop = doLoop | forLoop | loopLoop | whileLoop
    ================================================================================================
    method anyLoop(label:String?):ASTNode? {
        match peek().kind {
            when Token.Kind.DO     { return doLoop(label) }
            when Token.Kind.FOR    { return forLoop(label) }
            when Token.Kind.LOOP   { return loopLoop(label) }
            when Token.Kind.WHILE  { return whileLoop(label) }
            otherwise {
                -- trigger error
                expect(Token.Kind.DO, "'do', 'for', 'loop', or 'while' following label")
                return null
            }
        }
    }

    ================================================================================================
    innerMethod = (METHOD | FUNCTION) IDENTIFIER parameters typeDeclaration? block
    ================================================================================================
    method innerMethod():ASTNode? {
        def kind:MethodDecl.Kind
        def start := checkNext(Token.Kind.FUNCTION)
        if start == null {
            start := expect(Token.Kind.METHOD, "'method' or 'function'")
            if start == null {
                return null
            }
            kind := MethodDecl.Kind.METHOD
        }
        else {
            kind := MethodDecl.Kind.FUNCTION
        }
        def name := expect(Token.Kind.IDENTIFIER, "an identifier")
        if name == null {
            return null
        }
        def params := parameters()
        if params == null {
            return null
        }
        def returnType:ASTNode?
        if peek().kind = Token.Kind.COLON {
            returnType := typeDeclaration()
            if returnType == null {
                return null
            }
        }
        else {
            returnType := null
        }
        def body := blockStatements()
        if body == null {
            return null
        }
        return ASTNode.METHOD(start.position, null, FixedArray<ASTNode>(), kind, text(name), -- FIXME literal
                null, params, returnType, body)
    }

    ================================================================================================
    tryStatement = TRY block FAIL (LPAREN identifier RPAREN)? block
    ================================================================================================
    method tryStatement():ASTNode? {
        def start := expect(Token.Kind.TRY, "'try'")
        if start == null {
            return null
        }
        def block := blockStatements()
        if block == null {
            return null
        }
        if expect(Token.Kind.FAIL, "'fail'") == null {
            return null
        }
        def identifier:ASTNode?
        if checkNext(Token.Kind.LPAREN) !== null {
            def idText := expect(Token.Kind.IDENTIFIER, "an identifier")
            if idText == null {
                return null
            }
            identifier := ASTNode.IDENTIFIER(idText.position, text(idText))
            if expect(Token.Kind.RPAREN, "')'") == null {
                return null
            }
        }
        else {
            identifier := null
        }
        def failBlock := blockStatements()
        if failBlock == null {
            return null
        }
        return ASTNode.TRY(start.position, block, identifier, failBlock)
    }

    ================================================================================================
    statement = ifStatement | anyLoop | expressionOrAssignment | assertStatement | matchStatement |
            block | varDeclaration | initCall | innerMethod | try | unreachable
    ================================================================================================
    method statement():ASTNode? {
        match peek().kind {
            when Token.Kind.IF     { return ifStatement() }
            when Token.Kind.FOR    { return forLoop(null) }
            when Token.Kind.WHILE  { return whileLoop(null) }
            when Token.Kind.DO     { return doLoop(null) }
            when Token.Kind.LOOP   { return loopLoop(null) }
            when Token.Kind.ASSERT { return assertStatement() }
            when Token.Kind.MATCH  { return matchStatement() }
            when Token.Kind.LBRACE { return block() }
            when Token.Kind.IDENTIFIER {
                def id := next()
                def colon := checkNext(Token.Kind.COLON)
                if colon !== null {
                    if syntaxHighlighter !== null {
                        pushback(colon)
                        pushback(id)
                        syntaxHighlighter.open(SyntaxHighlighter.Kind.LABEL)
                        next()
                        next()
                        syntaxHighlighter.close(SyntaxHighlighter.Kind.LABEL)
                    }
                    return anyLoop(text(id))
                }
                pushback(id)
                return expressionOrAssignment()
            }
            when Token.Kind.SELF, Token.Kind.SUPER {
                return expressionOrAssignment()
            }
            when Token.Kind.VAR, Token.Kind.DEF, Token.Kind.PROPERTY, Token.Kind.CONSTANT {
                return varDeclaration()
            }
            when Token.Kind.INIT {
                return initCall()
            }
            when Token.Kind.METHOD, Token.Kind.FUNCTION {
                return innerMethod()
            }
            when Token.Kind.TRY {
                return tryStatement()
            }
            when Token.Kind.UNREACHABLE {
                return unreachableStatement()
            }
            otherwise {
                -- trigger error
                expect(Token.Kind.IF, "a statement")
                return null
            }
        }
    }

    ================================================================================================
    packageDeclaration = PACKAGE IDENTIFIER (DOT IDENTIFIER)*
    ================================================================================================
    method packageDeclaration():ASTNode? {
        def start := expect(Token.Kind.PACKAGE, "'package'")
        if start == null {
            return null
        }
        var next := expect(Token.Kind.IDENTIFIER, "an identifier")
        if next == null {
            return null
        }
        def name := MutableString(text(next))
        loop {
            next := checkNext(Token.Kind.DOT)
            if next == null {
                break
            }
            name.append(".")
            next := expect(Token.Kind.IDENTIFIER, "an identifier")
            if next == null {
                return null
            }
            name.append(text(next))
        }
        return ASTNode.PACKAGE(start.position, name.finish())
    }

    ================================================================================================
    usesDeclaration = USES IDENTIFIER (DOT IDENTIFIER)*
    ================================================================================================
    method usesDeclaration():ASTNode? {
        def start := expect(Token.Kind.USES, "'uses'")
        if start == null {
            return null
        }
        def next := expect(Token.Kind.IDENTIFIER, "an identifier")
        if next == null {
            return null
        }
        def name := MutableString(text(next))
        loop {
            next := checkNext(Token.Kind.DOT)
            if next == null {
                break
            }
            name.append(".")
            next := expect(Token.Kind.IDENTIFIER, "an identifier")
            if next == null {
                return null
            }
            name.append(text(next))
        }
        return ASTNode.USES(start.position, name.finish())
    }

    ================================================================================================
    genericsDeclaration = LT IDENTIFIER typeDeclaration? (COMMA IDENTIFIER typeDeclaration?)* GT
    ================================================================================================
    method genericsDeclaration():FixedArray<ASTNode>? {
        def start := expect(Token.Kind.LT, "'<'")
        if start == null {
            return null
        }
        var id := expect(Token.Kind.IDENTIFIER, "an identifier")
        if id == null {
            return null
        }
        def parameters := Array<ASTNode>()
        if checkNext(Token.Kind.COLON) !== null {
            def t := type()
            if t == null {
                return null
            }
            parameters.add(ASTNode.TYPED_IDENTIFIER(id.position, text(id), t))
        }
        else {
            parameters.add(ASTNode.IDENTIFIER(id.position, text(id)))
        }
        while checkNext(Token.Kind.COMMA) !== null {
            id := expect(Token.Kind.IDENTIFIER, "an identifier")
            if id == null {
                return null
            }
            if checkNext(Token.Kind.COLON) !== null {
                def t := type()
                if t == null {
                    return null
                }
                parameters.add(ASTNode.TYPED_IDENTIFIER(id.position, text(id), t))
            }
            else {
                parameters.add(ASTNode.IDENTIFIER(id.position, text(id)))
            }
        }
        if expect(Token.Kind.GT, "'>'") == null {
            return null
        }
        return FixedArray<ASTNode>.from(parameters)
    }

    ================================================================================================
    supertypes = COLON type (COMMA type)*
    ================================================================================================
    method supertypes():FixedArray<ASTNode>? {
        def start := expect(Token.Kind.COLON, "':'")
        if start == null {
            return null
        }
        def result := Array<ASTNode>()
        var t := type()
        if t == null {
            return null
        }
        result.add(t)
        while checkNext(Token.Kind.COMMA) !== null {
            t := type()
            if t == null {
                return null
            }
            result.add(t)
        }
        return FixedArray<ASTNode>.from(result)
    }

    ================================================================================================
    annotation = ANNOTATION (LPAREN expression RPAREN)?
    ================================================================================================
    method annotation():ASTNode? {
        def a := expect(Token.Kind.ANNOTATION, "an annotation")
        def exprText:String?
        def expr:ASTNode? := null
        def exprStart := checkNext(Token.Kind.LPAREN)
        if exprStart !== null {
            expr := expression()
            if expr == null {
                return null
            }
            def exprEnd := expect(Token.Kind.RPAREN, "')'")
            if exprEnd == null {
                return null
            }
            exprText := source.substring(source.next(exprStart.start) .. exprEnd.start)
        }
        return ASTNode.ANNOTATION(a.position, text(a), exprText, expr)
    }

    ================================================================================================
    annotations = annotation*
    ================================================================================================
    method annotations():FixedArray<ASTNode> {
        def result := Array<ASTNode>()
        while peek().kind = Token.Kind.ANNOTATION {
            def a := annotation()
            if a == null {
                break
            }
            result.add(a)
        }
        return FixedArray<ASTNode>.from(result)
    }

     method doccomment():ASTNode? {
         def start := expect(Token.Kind.DOC_COMMENT, "a documentation comment")
         if start == null {
             return null
         }
        def result := MutableString()
        loop {
            def next := rawNext()
            if next.kind = Token.Kind.DOC_COMMENT {
                break
            }
            if next.kind = Token.Kind.EOF {
                error(start, "unterminated documentation comment")
                return null
            }
            result.append(text(next))
        }
        return ASTNode.STRING(start.position, result.finish())
    }

    ================================================================================================
    parameter = IDENTIFIER typeDeclaration
    ================================================================================================
    method parameter():ASTNode? {
        open(SyntaxHighlighter.Kind.METHOD_PARAMETER)
        def id := expect(Token.Kind.IDENTIFIER, "an identifier")
        close(SyntaxHighlighter.Kind.METHOD_PARAMETER)
        if id == null {
            return null
        }
        def t := typeDeclaration()
        if t == null {
            return null
        }
        return ASTNode.PARAMETER(id.position, text(id), t)
    }

    ================================================================================================
    parameters = LPAREN (parameter (COMMA parameter)*)? RPAREN
    ================================================================================================
    method parameters():FixedArray<ASTNode>? {
        def start := expect(Token.Kind.LPAREN, "'('")
        if start == null {
            return null
        }
        def result := Array<ASTNode>()
        if checkNext(Token.Kind.RPAREN) == null {
            def param := parameter()
            if param == null {
                return null
            }
            result.add(param)
            while checkNext(Token.Kind.COMMA) !== null {
                param := parameter()
                if param == null {
                    return null
                }
                result.add(param)
            }
            if expect(Token.Kind.RPAREN, "')'") == null {
                return null
            }
        }
        return FixedArray<ASTNode>.from(result)
    }

    ================================================================================================
    methodDeclaration = (METHOD | FUNCTION) methodName genericsDeclaration parameters
            typeDeclaration? block?
    ================================================================================================
    method methodDeclaration(doccomment:ASTNode?, annotations:FixedArray<ASTNode>):ASTNode? {
        def kind:MethodDecl.Kind
        def start := checkNext(Token.Kind.FUNCTION)
        if start == null {
            start := expect(Token.Kind.METHOD, "'method' or 'function'")
            if start == null {
                return null
            }
            kind := MethodDecl.Kind.METHOD
        }
        else {
            kind := MethodDecl.Kind.FUNCTION
        }
        open(SyntaxHighlighter.Kind.METHOD_NAME)
        def name := methodName()
        close(SyntaxHighlighter.Kind.METHOD_NAME)
        if name == null {
            return null
        }
        def generics:FixedArray<ASTNode>?
        if peek().kind = Token.Kind.LT {
            generics := genericsDeclaration()
        }
        else {
            generics := null
        }
        def params := parameters()
        if params == null {
            return null
        }
        def returnType:ASTNode?
        if peek().kind = Token.Kind.COLON {
            returnType := typeDeclaration()
            if returnType == null {
                return null
            }
        }
        else {
            returnType := null
        }
        def body:FixedArray<ASTNode>?
        if peek().kind = Token.Kind.LBRACE {
            body := blockStatements()
            if body == null {
                return null
            }
        }
        else {
            body := null
        }
        return ASTNode.METHOD(start.position, doccomment, annotations, kind, name, generics, params,
                returnType, body)
    }

    ================================================================================================
    anonymousMethod = (METHOD | FUNCTION) parameters typeDeclaration? block
    ================================================================================================
    method anonymousMethod():ASTNode? {
        def kind:MethodDecl.Kind
        def start := checkNext(Token.Kind.FUNCTION)
        if start == null {
            start := expect(Token.Kind.METHOD, "'method' or 'function'")
            if start == null {
                return null
            }
            kind := MethodDecl.Kind.METHOD
        }
        else {
            kind := MethodDecl.Kind.FUNCTION
        }
        def params := parameters()
        if params == null {
            return null
        }
        def returnType:ASTNode?
        if peek().kind = Token.Kind.COLON {
            returnType := typeDeclaration()
            if returnType == null {
                return null
            }
        }
        else {
            returnType := null
        }
        def body := blockStatements()
        if body == null {
            return null
        }
        return ASTNode.METHOD(start.position, null, FixedArray<ASTNode>(), kind, "<anonymous>", -- FIXME literal
                null, params, returnType, body)
    }

    ================================================================================================
    initDeclaration = INIT parameters block
    ================================================================================================
    method initDeclaration(doccomment:ASTNode?, annotations:FixedArray<ASTNode>):ASTNode? {
        def start := expect(Token.Kind.INIT, "'init'")
        if start == null {
            return null
        }
        def params := parameters()
        if params == null {
            return null
        }
        def b := blockStatements()
        if b == null {
            return null
        }
        return ASTNode.METHOD(start.position, doccomment, annotations, MethodDecl.Kind.INIT, "init",
                null, params, null, b)
    }

    ================================================================================================
    fieldDeclaration = varDeclaration
    ================================================================================================
    method fieldDeclaration(doccomment:ASTNode?, annotations:FixedArray<ASTNode>):ASTNode? {
        def decl := varDeclaration()
        if decl == null {
            return null
        }
        return ASTNode.FIELD(decl.position(), doccomment, annotations, decl)
    }

    ================================================================================================
    choiceCase = IDENTIFIER (LPAREN (type (COMMA type)*)? RPAREN)?
    ================================================================================================
    method choiceCase(doccomment:ASTNode?):ASTNode? {
        def name := expect(Token.Kind.IDENTIFIER, "an identifier")
        if name == null {
            return null
        }
        def fields := Array<ASTNode>()
        if checkNext(Token.Kind.LPAREN) !== null {
            if peek().kind != Token.Kind.RPAREN {
                var field := type()
                if field == null {
                    return null
                }
                fields.add(field)
                while checkNext(Token.Kind.COMMA) !== null {
                    field := type()
                    if field == null {
                        return null
                    }
                    fields.add(field)
                }
            }
            if expect(Token.Kind.RPAREN, "')'") == null {
                return null
            }
        }
        return ASTNode.CHOICE_CASE(name.position, doccomment, text(name),
                FixedArray<ASTNode>.from(fields))
    }

    ================================================================================================
    choiceDeclaration = CHOICE IDENTIFIER genericsDeclaration? LBRACE choiceCase* declaration*
            RBRACE
    ================================================================================================
    method choiceDeclaration(choiceDoccomment:ASTNode?,
            choiceAnnotations:FixedArray<ASTNode>):ASTNode? {
        def start := expect(Token.Kind.CHOICE, "'choice'")
        if start == null {
            return null
        }
        def name := expect(Token.Kind.IDENTIFIER, "an identifier")
        if name == null {
            return null
        }
        def generics:FixedArray<ASTNode>?
        if peek().kind = Token.Kind.LT {
            generics := genericsDeclaration()
            if generics == null {
                return null
            }
        }
        else {
            generics := null
        }
        if expect(Token.Kind.LBRACE, "'{'") == null {
            return null
        }
        def members := Array<ASTNode>()
        var dc:ASTNode? := null
        loop {
            def next := peek()
            match next.kind {
                when Token.Kind.CLASS, Token.Kind.INTERFACE, Token.Kind.CHOICE, Token.Kind.METHOD,
                        Token.Kind.FUNCTION, Token.Kind.ANNOTATION, Token.Kind.VAR, Token.Kind.DEF,
                        Token.Kind.PROPERTY, Token.Kind.CONSTANT {
                    break
                }
                when Token.Kind.DOC_COMMENT {
                    if dc !== null {
                        error(next, "expected a declaration, but found '\{text(next)}'")
                    }
                    dc := doccomment()
                }
                when Token.Kind.IDENTIFIER {
                    def c := choiceCase(dc)
                    if c == null {
                        return null
                    }
                    members.add(c)
                    dc := null
                }
                otherwise {
                    break
                }
            }
        }
        var a := FixedArray<ASTNode>() -- FIXME literal
        loop {
            def next := peek()
            match next.kind {
                when Token.Kind.ANNOTATION {
                    if a.count > 0 {
                        error(next, "expected a declaration, but found '\{text(next)}'")
                        return null
                    }
                    a := annotations()
                }
                when Token.Kind.DOC_COMMENT {
                    if dc !== null | a.count > 0 {
                        error(next, "expected a declaration, but found '\{text(next)}'")
                        return null
                    }
                    dc := doccomment()
                }
                when Token.Kind.CLASS {
                    def decl := classDeclaration(dc, a)
                    if decl == null {
                        return null
                    }
                    members.add(decl)
                    dc := null
                    a := FixedArray<ASTNode>()
                }
                when Token.Kind.INTERFACE {
                    def decl := interfaceDeclaration(dc, a)
                    if decl == null {
                        return null
                    }
                    members.add(decl)
                    dc := null
                    a := FixedArray<ASTNode>()
                }
                when Token.Kind.CHOICE {
                    def decl := choiceDeclaration(dc, a)
                    if decl == null {
                        return null
                    }
                    members.add(decl)
                    dc := null
                    a := FixedArray<ASTNode>()
                }
                when Token.Kind.METHOD, Token.Kind.FUNCTION {
                    def decl := methodDeclaration(dc, a)
                    if decl == null {
                        return null
                    }
                    members.add(decl)
                    dc := null
                    a := FixedArray<ASTNode>()
                }
                when Token.Kind.VAR, Token.Kind.DEF, Token.Kind.PROPERTY, Token.Kind.CONSTANT {
                    def decl := fieldDeclaration(dc, a)
                    if decl == null {
                        return null
                    }
                    members.add(decl)
                    dc := null
                    a := FixedArray<ASTNode>()
                }
                when Token.Kind.RBRACE {
                    expect(Token.Kind.RBRACE, "'}'")
                    break
                }
                otherwise {
                    error(next, "expected a declaration, but found '\{text(next)}'")
                    self.next()
                    return null
                }
            }
        }
        return ASTNode.CLASS(start.position, choiceDoccomment, choiceAnnotations,
                ClassDecl.Kind.CHOICE, text(name), generics, null,
                FixedArray<ASTNode>.from(members))
    }

    ================================================================================================
    declaration = invariant | (doccomment? annotations) (classDeclaration | interfaceDeclaration |
            choiceDeclaration | methodDeclaration | initDeclaration | fieldDeclaration)
    ================================================================================================
    method declaration():ASTNode? {
        def start := peek()
        def dc:ASTNode?
        if start.kind = Token.Kind.DOC_COMMENT {
            dc := doccomment()
            if dc == null {
                return null
            }
        }
        else {
            dc := null
        }
        def a := annotations()
        if a == null {
            return null
        }
        match peek().kind {
            when Token.Kind.CLASS {
                return classDeclaration(dc, a)
            }
            when Token.Kind.INTERFACE {
                return interfaceDeclaration(dc, a)
            }
            when Token.Kind.CHOICE {
                return choiceDeclaration(dc, a)
            }
            when Token.Kind.METHOD, Token.Kind.FUNCTION {
                return methodDeclaration(dc, a)
            }
            when Token.Kind.INIT {
                return initDeclaration(dc, a)
            }
            when Token.Kind.VAR, Token.Kind.DEF, Token.Kind.PROPERTY, Token.Kind.CONSTANT {
                return fieldDeclaration(dc, a)
            }
            otherwise {
                -- trigger error
                expect(Token.Kind.CLASS, "a declaration")
                return null
            }
        }
    }

    ================================================================================================
    classDeclaration = CLASS IDENTIFIER genericsDeclaration? supertypes? LBRACE declaration* RBRACE
    ================================================================================================
    method classDeclaration(doccomment:ASTNode?, annotations:FixedArray<ASTNode>):ASTNode? {
        def start := expect(Token.Kind.CLASS, "'class'")
        if start == null {
            return null
        }
        def name := expect(Token.Kind.IDENTIFIER, "an identifier")
        if name == null {
            return null
        }
        def generics:FixedArray<ASTNode>?
        if peek().kind = Token.Kind.LT {
            generics := genericsDeclaration()
            if generics == null {
                return null
            }
        }
        else {
            generics := null
        }
        def stypes:FixedArray<ASTNode>?
        if peek().kind = Token.Kind.COLON {
            stypes := supertypes()
            if stypes == null {
                return null
            }
        }
        else {
            stypes := null
        }
        if expect(Token.Kind.LBRACE, "'{'") == null {
            return null
        }
        def members := Array<ASTNode>()
        while checkNext(Token.Kind.RBRACE) == null {
            def member := declaration()
            if member == null {
                return null
            }
            members.add(member)
        }
        return ASTNode.CLASS(start.position, doccomment, annotations, ClassDecl.Kind.CLASS,
                text(name), generics, stypes, FixedArray<ASTNode>.from(members))
    }

    ================================================================================================
    interfaceDeclaration = INTERFACE IDENTIFIER genericsDeclaration? (COLON type (COMMA type)*)?
            LBRACE declaration* RBRACE
    ================================================================================================
    method interfaceDeclaration(doccomment:ASTNode?, annotations:FixedArray<ASTNode>):ASTNode? {
        def start := expect(Token.Kind.INTERFACE, "'interface'")
        if start == null {
            return null
        }
        def name := expect(Token.Kind.IDENTIFIER, "an identifier")
        if name == null {
            return null
        }
        def generics:FixedArray<ASTNode>?
        if peek().kind = Token.Kind.LT {
            generics := genericsDeclaration()
            if generics == null {
                return null
            }
        }
        else {
            generics := FixedArray<ASTNode>()
        }
        def intfs := Array<ASTNode>()
        if checkNext(Token.Kind.COLON) !== null {
            var t := type()
            if t == null {
                return null
            }
            intfs.add(t)
            while checkNext(Token.Kind.COMMA) !== null {
                t := type()
                if t == null {
                    return null
                }
                intfs.add(t)
            }
        }
        if expect(Token.Kind.LBRACE, "'{'") == null {
            return null
        }
        def members := Array<ASTNode>()
        while checkNext(Token.Kind.RBRACE) == null {
            def member := declaration()
            if member == null {
                return null
            }
            members.add(member)
        }
        return ASTNode.CLASS(start.position, doccomment, annotations, ClassDecl.Kind.INTERFACE,
                text(name), generics, FixedArray<ASTNode>.from(intfs),
                FixedArray<ASTNode>.from(members))
    }

    ================================================================================================
    bodyEntry = usesDeclaration | declaration
    ================================================================================================
    method bodyEntry():ASTNode? {
        match peek().kind {
            when Token.Kind.USES {
                return usesDeclaration()
            }
            otherwise {
                return declaration()
            }
        }
    }

    ================================================================================================
    file = packageDeclaration? bodyEntry*
    ================================================================================================
    method file():ASTNode? {
        def entries := Array<ASTNode>()
        if peek().kind = Token.Kind.PACKAGE {
            def decl := packageDeclaration()
            if decl !== null {
                entries.add(decl)
            }
        }
        while peek().kind != Token.Kind.EOF {
            def entry := bodyEntry()
            if entry == null {
                return null
            }
            assert speculativeBuffers.count = 0
            entries.add(entry)
        }
        return ASTNode.FILE(FixedArray<ASTNode>.from(entries))
    }
}
