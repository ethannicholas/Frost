package org.frostlang.frostc.pass

uses org.frostlang.frostc.Compiler
uses org.frostlang.frostc.IR
uses org.frostlang.frostc.MethodDecl
uses org.frostlang.frostc.Pair
uses org.frostlang.frostc.Type
uses org.frostlang.frostc.expression.Binary

====================================================================================================
Performs dataflow analysis on Frost methods to detect errors such as reassigned `def`s, missing
returns, unreachable code, and unsafe nullable usage.
====================================================================================================
class Analyzer {
    class DataFlowValue : Equatable<DataFlowValue> {
        def type:Type

        -- if this value represents a Bit or builtin_bit, then its true/false state may imply that
        -- other values are / are not nullable. We track that here. An entry in this list means that
        -- the value is known to be non-null when this value matches its Bit. So (LOCAL(0), true)
        -- means that we know LOCAL(0) is non-null when this value is true.
        def nonNullImplications:ListView<Pair<IR.Value, Bit>>?

        init(type:Type) {
            self.type := type
        }

        init(type:Type, implications:ListView<Pair<IR.Value, Bit>>?) {
            self.type := type
            self.nonNullImplications := implications
        }

        @override
        function =(other:DataFlowValue):Bit {
            return type = other.type
        }

        method union(compiler:Compiler, other:DataFlowValue):DataFlowValue {
            def type := type.union(compiler, other.type)
            if nonNullImplications !== null {
                if other.nonNullImplications !== null {
                    -- FIXME deal with duplicates
                    def merged := Array<Pair<IR.Value, Bit>>(nonNullImplications)
                    merged.addAll(other.nonNullImplications)
                    return DataFlowValue(type, merged)
                }
                return DataFlowValue(type, nonNullImplications)
            }
            else if other.nonNullImplications !== null {
                return DataFlowValue(type, other.nonNullImplications)
            }
            return DataFlowValue(type)
        }

        -- reverses the sense of a boolean value
        property invert:DataFlowValue
        function get_invert():DataFlowValue {
            -- FIXME implement
            return self
        }

        @override
        function get_asString():String {
            if nonNullImplications !== null {
                return "DataFlowValue(\{type}, \{nonNullImplications})"
            }
            return "DataFlowValue(\{type})"
        }
    }

    ================================================================================================
    Represents an exit from a block. Blocks which end in conditional branches have two exits (exit
    0 for when the condition is true, and exit 1 for when it is false), blocks which end in
    unconditional branches have only a single exit, and other blocks do not have exits.
    ================================================================================================
    class BlockExit : Value, Key<BlockExit> {
        def id:IR.Block.ID
        def exit:Int

        init(id:IR.Block.ID, exit:Int) {
            self.id := id
            self.exit := exit
        }

        @override
        function =(other:BlockExit):Bit {
            return id = other.id & exit = other.exit
        }

        @override
        function get_hash():Int {
            return id.value ~~ exit
        }
    }

    class State {
        def locals:Array<DataFlowValue>

        init() {
            locals := Array<DataFlowValue>()
        }

        init(src:State) {
            locals := Array<DataFlowValue>(src.locals)
        }

        method add(compiler:Compiler, s:State):Bit {
            var modified := false
            assert locals.count = s.locals.count
            for i in 0 .. locals.count {
                def union := locals[i].union(compiler, s.locals[i])
                if union != locals[i] {
                    modified := true
                    locals[i] := union
                }
            }
            return modified
        }

        @override
        function get_asString():String {
            return "State(\{locals})"
        }
    }

    def compiler:Compiler

    def m:MethodDecl

    def ir:IR

    def blocks := HashMap<IR.Block.ID, IR.Block>()

    def predecessors := HashMap<IR.Block.ID, HashSet<BlockExit>>()

    def entryStates := HashMap<IR.Block.ID, State>()

    def worklist := HashSet<IR.Block.ID>()

    def statements := HashMap<IR.Statement.ID, IR.Statement>()

    var reportErrors := false

    init(compiler:Compiler, m:MethodDecl, ir:IR) {
        self.compiler := compiler
        self.m := m
        self.ir := ir
    }

    function getValue(stmt:IR.Statement.ID, state:State):DataFlowValue {
        match statements[stmt] {
            when IR.Statement.BINARY(_, left, op, right, type) {
                return binaryValue(left, op, right, state, type)
            }
            when IR.Statement.CAST(position, value, type, explicit) {
                if explicit {
                    return DataFlowValue(type)
                }
                else {
                    return getValue(value, state)
                }
                if !explicit & reportErrors & !type.isNullable &
                        getValue(value, state).type.isNullable {
                    compiler.warn(position, "value may be null")
                }
            }
            when IR.Statement.CONSTRUCT(_, cl) {
                return DataFlowValue(cl.type)
            }
            when IR.Statement.CREATE_STRUCT(_, cl, _) {
                return DataFlowValue(cl.type)
            }
            when IR.Statement.DYNAMIC_CALL(_, m, _) {
                def type := m.type()
                if type.isPointer {
                    return DataFlowValue(type.subtypes[1].returnType)
                }
                else {
                    return DataFlowValue(type.returnType)
                }
            }
            when IR.Statement.EXTRACT_FIELD(_, target, f) {
                if f.owner.type = compiler.BIT_TYPE {
                    return DataFlowValue(f.type, getValue(target, state).nonNullImplications)
                }
                else {
                    return DataFlowValue(f.type)
                }
            }
            when IR.Statement.GET_CHOICE_FIELD_POINTER(_, _, cc, index) {
                return DataFlowValue(Type.pointerTo(compiler, cc.fields[index]))
            }
            when IR.Statement.GET_FIELD_POINTER(_, _, f) {
                return DataFlowValue(f.type)
            }
            when IR.Statement.LOAD(position, v) {
                def value := getValue(v, state)
                if reportErrors & value.type = compiler.INVALID_TYPE {
                    compiler.warn(position, "value \{stmt}:\{v} has not been initialized")
                }
                return value
            }
            when IR.Statement.NEGATE(_, v) {
                return getValue(v, state)
            }
            when IR.Statement.NOT(_, v) {
                return getValue(v, state).invert
            }
            when IR.Statement.POINTER_ALLOC(_, _, t) {
                return DataFlowValue(Type.pointerTo(compiler, t))
            }
            when IR.Statement.POINTER_GET(_, p) {
                def value := getValue(p, state)
                assert value.type.isPointer
                return DataFlowValue(value.type.subtypes[1])
            }
            when IR.Statement.POINTER_GET_INDEX(_, p, _) {
                def value := getValue(p, state)
                assert value.type.isPointer
                return DataFlowValue(value.type.subtypes[1])
            }
            when IR.Statement.POINTER_OFFSET(_, p, _) {
                return getValue(p, state)
            }
            when IR.Statement.POINTER_REALLOC(_, p, _, _) {
                return getValue(p, state)
            }
            when IR.Statement.STATIC_CALL(_, m, args) {
                if m.returnType = compiler.BIT_TYPE {
                    return DataFlowValue(m.returnType, getValue(args[0], state).nonNullImplications)
                }
                else {
                    return DataFlowValue(m.returnType)
                }
            }
            otherwise {
                unreachable, "unsupported statement: \{statements[stmt]}"
            }
        }
    }

    function getValue(v:IR.Value, s:State):DataFlowValue {
        match v {
            when IR.Value.BIT(_, type) {
                return DataFlowValue(type)
            }
            when IR.Value.INT(_, type) {
                return DataFlowValue(type)
            }
            when IR.Value.LOCAL(slot, _) {
                return s.locals[slot]
            }
            when IR.Value.NULL(type) {
                return DataFlowValue(type)
            }
            when IR.Value.PARAMETER(_, type) {
                return DataFlowValue(type)
            }
            when IR.Value.REAL(_, type) {
                return DataFlowValue(type)
            }
            when IR.Value.REF(statement, _) {
                return getValue(statement, s)
            }
            when IR.Value.STRING(_, type) {
                return DataFlowValue(type)
            }
            otherwise {
                unreachable, "unsupported value '\{v}'"
            }
        }
    }

    method propagate(src:BlockExit, target:IR.Block.ID) {
        var preds := predecessors[target]
        if preds == null {
            preds := HashSet<BlockExit>()
            predecessors[target] := preds
        }
        preds.add(src)
        var updated := false
        def predIterator := preds.iterator
        var entry := entryStates[target]
        if entry == null {
            entry := computeExitState(predIterator.next())
            entryStates[target] := entry
            updated := true
        }
        for pred in predIterator {
            updated |= entry.add(compiler, computeExitState(pred))
        }
        if updated {
            worklist.add(target)
        }
    }

    ================================================================================================
    When this is called, we have computed a unified exit state upon reaching the end of the block.
    But if the block ends in a conditional branch, the state that leaves the block may be different
    depending on which exit we take. For instance, given the block:
        $0: load LOCAL(0:frost.core.Object?)
        $1: binary REF($0:frost.core.Object?), !==, NULL(frost.core.Object?), builtin_bit
        $2: branch REF($1:builtin_bit), block2, block3

    The type of LOCAL(0) will need to be seen differently depending on whether the branch takes us
    to block2 (exit 0) or block3 (exit 1). This method applies that change, resulting in a
    non-nullable LOCAL(0) entering block2 and a nullable LOCAL(1) entering block3.
    ================================================================================================
    method updateStateForExitIndex(b:IR.Block, exit:Int, state:State) {
        match b.statements.last {
            when IR.Statement.CONDITIONAL_BRANCH(_, flag, _, _) {
                def value := getValue(flag, state)
                if value.nonNullImplications !== null {
                    for impl in value.nonNullImplications {
                        if impl.second = (exit = 0) {
                            match impl.first {
                                when IR.Value.LOCAL(slot, _) {
                                    def old := state.locals[slot]
                                    assert old !== null
                                    state.locals[slot] := DataFlowValue(old.type.nonnullable())
                                }
                            }
                        }
                    }
                }
            }
            otherwise {
                return
            }
        }
    }

    method binaryValue(left:IR.Value, op:Binary.Operator, right:IR.Value, state:State,
            type:Type):DataFlowValue {
        match op {
            when Binary.Operator.NIDENTITY {
                match right {
                    when IR.Value.NULL {
                        assert type = compiler.BUILTIN_BIT_TYPE
                        def nonNullImplications := [Pair<IR.Value, Bit>(left, true)]
                        match left {
                            when IR.Value.REF(id, _) {
                                def ref := statements[id]
                                match ref {
                                    when IR.Statement.LOAD(_, value) {
                                        nonNullImplications.add(Pair<IR.Value, Bit>(value, true))
                                    }
                                }
                            }
                        }
                        return DataFlowValue(type, nonNullImplications)
                    }
                }
            }
            when Binary.Operator.IDENTITY {
                match right {
                    when IR.Value.NULL {
                        assert type = compiler.BUILTIN_BIT_TYPE
                        def nonNullImplications := [Pair<IR.Value, Bit>(left, false)]
                        match left {
                            when IR.Value.REF(id, _) {
                                def ref := statements[id]
                                match ref {
                                    when IR.Statement.LOAD(_, value) {
                                        nonNullImplications.add(Pair<IR.Value, Bit>(value, false))
                                    }
                                }
                            }
                        }
                        return DataFlowValue(type, nonNullImplications)
                    }
                }
            }
        }

        return DataFlowValue(type)
    }

    method computeExitState(target:BlockExit):State {
        def result := State(entryStates[target.id])
        def block := blocks[target.id]
        def iter1 := block.ids.iterator
        def iter2 := block.statements.iterator
        while !iter1.done {
            def id := iter1.next()
            match iter2.next() {
                when IR.Statement.STORE(_, v, target) {
                    match target {
                        when IR.Value.LOCAL(slot, _) {
                            result.locals[slot] := getValue(v, result)
                        }
                        when IR.Value.REF(s, _) {
                            match statements[s] {
                                when IR.Statement.GET_FIELD_POINTER(_, v, _) {
                                    match v {
                                        when IR.Value.LOCAL(slot, _) {
                                            result.locals[slot] := DataFlowValue(ir.locals[slot])
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            }
        }
        updateStateForExitIndex(block, target.exit, result)
        return result
    }

    method process(id:IR.Block.ID) {
        def block := blocks[id]
        match block.statements.last {
            when IR.Statement.BRANCH(_, id) {
                propagate(BlockExit(block.id, 0), id)
            }
            when IR.Statement.CONDITIONAL_BRANCH(_, _, id1, id2) {
                propagate(BlockExit(block.id, 0), id1)
                propagate(BlockExit(block.id, 1), id2)
            }
            when IR.Statement.END {
            }
            when IR.Statement.RETURN {
            }
            when IR.Statement.UNREACHABLE {
            }
            otherwise {
                unreachable, "block ended in nonterminal statement " + block.statements.last
            }
        }
    }

    method dump() {
        Console.printLine(m.declaration)
        for i in 0 .. ir.locals.count {
            Console.printLine("local\{i}: \{ir.locals[i]}")
        }
        for b in ir.blocks {
            Console.print("\n\{b.id}:")
            if entryStates[b.id] !== null {
                Console.print(" " + entryStates[b.id])
            }
            Console.printLine()
            def iter1 := b.ids.iterator
            def iter2 := b.statements.iterator
            while !iter1.done {
                Console.print(iter1.next())
                Console.print(": ")
                Console.printLine(iter2.next())
            }
        }
    }

    method analyze() {
        def invalid := DataFlowValue(compiler.INVALID_TYPE)
        def startState := State()
        for i in 0 .. ir.locals.count {
            startState.locals.add(invalid)
        }
        entryStates[ir.blocks[0].id] := startState
        for b in ir.blocks {
            blocks[b.id] := b
            def iter1 := b.ids.iterator
            def iter2 := b.statements.iterator
            while !iter1.done {            
                statements[iter1.next()] := iter2.next()
            }
        }
        worklist.add(ir.blocks[0].id)
        while worklist.count > 0 {
            def next := worklist.iterator.next()
            worklist.remove(next)
            process(next)
        }
        reportErrors := true
        for b in ir.blocks {
            if entryStates[b.id] !== null {
                match b.statements.first {
                    when IR.Statement.END {
                        if m.methodKind != MethodDecl.Kind.INIT &
                                m.returnType != compiler.VOID_TYPE {
                            compiler.error(m.position, "method can exit without returning")
                        }
                    }
                    otherwise {
                        computeExitState(BlockExit(b.id, 0))
                    }
                }
            }
            else if b.containsExplicitCode & !b.forceReachable {
--                compiler.error(b.statements[0].position, "unreachable")
            }
        }
    }

    method makeUnreachable(b:IR.Block) {
        def id := b.ids.first
        def pos := b.statements.first.position
        b.ids.clear()
        b.ids.add(id)
        b.statements.clear()
        b.statements.add(IR.Statement.UNREACHABLE(pos))
    }

    method removeBlock(index:Int) {
        def removed := ir.blocks[index].id
        ir.blocks.removeIndex(index)
        for b in ir.blocks {
            def last := b.statements.count - 1
            match b.statements.last {
                when IR.Statement.BRANCH(_, id) {
                    if id = removed {
                        makeUnreachable(b)
                    }
                }
                when IR.Statement.CONDITIONAL_BRANCH(position, _, ifTrue, ifFalse) {
                    assert ifTrue != ifFalse
                    if ifTrue = removed {
--                        b.statements[last] := IR.Statement.BRANCH(position, ifFalse)
                        System.crash()
                    }
                    else if ifFalse = removed {
--                        b.statements[last] := IR.Statement.BRANCH(position, ifTrue)
                        System.crash()
                    }
                }
            }
        }
    }
}