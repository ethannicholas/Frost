package org.frostlang.frostc.expression

uses org.frostlang.frostc.ASTNode
uses org.frostlang.frostc.Compiler
uses org.frostlang.frostc.Compiler.TypeContext
uses org.frostlang.frostc.IR
uses org.frostlang.frostc.MethodDecl
uses org.frostlang.frostc.MethodRef
uses org.frostlang.frostc.Methods
uses org.frostlang.frostc.Pair
uses org.frostlang.frostc.Position
uses org.frostlang.frostc.Symbol
uses org.frostlang.frostc.Type
uses org.frostlang.frostc.parser.Token

class Binary {
    choice Operator {
        ADD
        SUB
        MUL
        DIV
        INTDIV
        REM
        EQ
        NEQ
        GT
        LT
        GTEQ
        LTEQ
        OR
        BITWISEOR
        AND
        BITWISEAND
        XOR
        BITWISEXOR
        SHIFTLEFT
        SHIFTRIGHT
        INDEX
        IDENTITY
        NIDENTITY
        CAST
        ASSIGNMENT
        ADDEQ
        SUBEQ
        MULEQ
        DIVEQ
        INTDIVEQ
        REMEQ
        OREQ
        BITWISEOREQ
        ANDEQ
        BITWISEANDEQ
        XOREQ
        BITWISEXOREQ
        SHIFTLEFTEQ
        SHIFTRIGHTEQ

        @class
        function fromToken(op:Token):Operator {
            match op.kind {
                when Token.Kind.ADD          { return ADD }
                when Token.Kind.SUB          { return SUB }
                when Token.Kind.MUL          { return MUL }
                when Token.Kind.DIV          { return DIV }
                when Token.Kind.INTDIV       { return INTDIV }
                when Token.Kind.REM          { return REM }
                when Token.Kind.EQ           { return EQ }
                when Token.Kind.NEQ          { return NEQ }
                when Token.Kind.GT           { return GT }
                when Token.Kind.LT           { return LT }
                when Token.Kind.GTEQ         { return GTEQ }
                when Token.Kind.LTEQ         { return LTEQ }
                when Token.Kind.OR           { return OR }
                when Token.Kind.BITWISEOR    { return BITWISEOR }
                when Token.Kind.AND          { return AND }
                when Token.Kind.BITWISEAND   { return BITWISEAND }
                when Token.Kind.XOR          { return XOR }
                when Token.Kind.BITWISEXOR   { return BITWISEXOR }
                when Token.Kind.SHIFTLEFT    { return SHIFTLEFT }
                when Token.Kind.SHIFTRIGHT   { return SHIFTRIGHT }
                when Token.Kind.LBRACKET     { return INDEX }
                when Token.Kind.ASSIGNMENT   { return ASSIGNMENT }
                when Token.Kind.IDENTITY     { return IDENTITY }
                when Token.Kind.NIDENTITY    { return NIDENTITY }
                when Token.Kind.CAST         { return CAST }
                when Token.Kind.ADDEQ        { return ADDEQ }
                when Token.Kind.SUBEQ        { return SUBEQ }
                when Token.Kind.MULEQ        { return MULEQ }
                when Token.Kind.DIVEQ        { return DIVEQ }
                when Token.Kind.INTDIVEQ     { return INTDIVEQ }
                when Token.Kind.REMEQ        { return REMEQ }
                when Token.Kind.OREQ         { return OREQ }
                when Token.Kind.BITWISEOREQ  { return BITWISEOREQ }
                when Token.Kind.ANDEQ        { return ANDEQ }
                when Token.Kind.BITWISEANDEQ { return BITWISEANDEQ }
                when Token.Kind.XOREQ        { return XOREQ }
                when Token.Kind.BITWISEXOREQ { return BITWISEXOREQ }
                when Token.Kind.SHIFTLEFTEQ  { return SHIFTLEFTEQ }
                when Token.Kind.SHIFTRIGHTEQ { return SHIFTRIGHTEQ }
                otherwise                    { unreachable, "not a binary operator: \{op.kind}" }
            }
        }

        property isAssignment:Bit
        function get_isAssignment():Bit {
            match self {
                when ASSIGNMENT, ADDEQ, SUBEQ, MULEQ, DIVEQ, INTDIVEQ, REMEQ, OREQ,
                        BITWISEOREQ, ANDEQ, BITWISEANDEQ, XOREQ, BITWISEXOREQ, SHIFTLEFTEQ,
                        SHIFTRIGHTEQ {
                    return true
                }
                otherwise {
                    return false
                }
            }
        }

        function removeAssignment():Operator {
            match self {
                when ADDEQ        { return ADD }
                when SUBEQ        { return SUB }
                when MULEQ        { return MUL }
                when DIVEQ        { return DIV }
                when INTDIVEQ     { return INTDIV }
                when REMEQ        { return REM }
                when OREQ         { return OR }
                when BITWISEOREQ  { return BITWISEOR }
                when ANDEQ        { return AND }
                when BITWISEANDEQ { return BITWISEAND }
                when XOREQ        { return XOR }
                when BITWISEXOREQ { return BITWISEXOR }
                when SHIFTLEFTEQ  { return SHIFTLEFT }
                when SHIFTRIGHTEQ { return SHIFTRIGHT }
                otherwise         { unreachable, "not a compound assignment operator: \{self}" }
            }
        }

        @override
        function get_asString():String {
            match self {
                when ADD          { return "+" }
                when SUB          { return "-" }
                when MUL          { return "*" }
                when DIV          { return "/" }
                when INTDIV       { return "//" }
                when REM          { return "%" }
                when EQ           { return "=" }
                when NEQ          { return "!=" }
                when GT           { return ">" }
                when LT           { return "<" }
                when GTEQ         { return ">=" }
                when LTEQ         { return "<=" }
                when OR           { return "|" }
                when BITWISEOR    { return "||" }
                when AND          { return "&" }
                when BITWISEAND   { return "&&" }
                when XOR          { return "~" }
                when BITWISEXOR   { return "~~" }
                when SHIFTLEFT    { return "<<" }
                when SHIFTRIGHT   { return ">>" }
                when INDEX        { return "[]" }
                when IDENTITY     { return "==" }
                when NIDENTITY    { return "!==" }
                when CAST         { return "->" }
                when ASSIGNMENT   { return ":=" }
                when ADDEQ        { return "+=" }
                when SUBEQ        { return "-=" }
                when MULEQ        { return "*=" }
                when DIVEQ        { return "/=" }
                when INTDIVEQ     { return "//=" }
                when REMEQ        { return "%=" }
                when OREQ         { return "|=" }
                when BITWISEOREQ  { return "||=" }
                when ANDEQ        { return "&=" }
                when BITWISEANDEQ { return "&&=" }
                when XOREQ        { return "~=" }
                when BITWISEXOREQ { return "~~=" }
                when SHIFTLEFTEQ  { return "<<=" }
                when SHIFTRIGHTEQ { return ">>=" }
            }
            unreachable
        }
    }

    @class
    method findOverloadedOperator(compiler:Compiler, left:Type, op:Operator, right:ASTNode,
            type:TypeContext):Pair<ListView<MethodRef>, Int>? {
        if !left.isClass {
            return null
        }
        def leftCl := compiler.getClass(left)
        if leftCl == null {
            return null
        }
        def target := IR.Value.REF(IR.Statement.ID(-1), left) -- fake target, just used for matching
        var methods := compiler.getSymbolTable(leftCl)[op.asString]
        if methods !== null {
            def args := [right]
            -- look for left.op(right)
            match methods.kind {
                when Symbol.Kind.METHOD {
                    if !methods->MethodDecl.annotations.isClass | left.isClassLiteral {
                        def list := Array<MethodDecl>()
                        list.add(methods->MethodDecl)
                        def result := Call.findBestMethod(compiler, Position(), target, list, args,
                                type)
                        if result !== null {
                            return result
                        }
                    }
                }
                when Symbol.Kind.METHODS {
                    def result := Call.findBestMethod(compiler, Position(), target,
                            methods->Methods.methods.filter(
                                    m => m.annotations.isClass = left.isClassLiteral), args, type)
                    if result !== null {
                        return result
                    }
                }
                otherwise {
                    unreachable
                }
            }
        }

        -- look for RightClass.op(left, right)
        def rightType := compiler.preferredType(right)
        if rightType == null {
            return null
        }
        if !rightType.isClass {
            return null
        }
        def rightCl := compiler.getClass(rightType)
        if rightCl == null {
            return null
        }
        methods := compiler.getSymbolTable(rightCl)[op.asString]
        if methods == null {
            return null
        }
        def args := [ASTNode.IR_WRAPPER(Position(), target), right]
        match methods.kind {
            when Symbol.Kind.METHOD {
                if methods->MethodDecl.annotations.isClass {
                    def list := Array<MethodDecl>()
                    list.add(methods->MethodDecl)
                    def result := Call.findBestMethod(compiler, Position(), null, list, args, type)
                    if result !== null {
                        return result
                    }
                }
            }
            when Symbol.Kind.METHODS {
                def result := Call.findBestMethod(compiler, Position(), null,
                        methods->Methods.methods.filter(m => m.annotations.isClass), args, type)
                if result !== null {
                    return result
                }
            }
            otherwise {
                unreachable
            }
        }
        return null
    }

    @class
    method findOverloadedOperator(compiler:Compiler, left:ASTNode, op:Operator, right:ASTNode,
            type:TypeContext):Pair<ListView<MethodRef>, Int>? {
        def leftTypes := compiler.possibleTypes(left)
        if leftTypes !== null {
            def best:Pair<ListView<MethodRef>, Int>? := null
            for t in leftTypes {
                def compilerCost := compiler.coercionCost(left, t)
                assert compilerCost !== null,
                        "failed compiler cast \{left}->\{t} at \{left.position()}"
                def ops := findOverloadedOperator(compiler, t, op, right, type)
                if ops !== null {
                    def cost := ops.second + compilerCost.second
                    if best == null | cost < best.second {
                        best := Pair<ListView<MethodRef>, Int>(ops.first, cost)
                    }
                    else if cost = best.second {
                        def a := Array<MethodRef>()
                        a.addAll(best.first)
                        outer: for op in ops.first {
                            for old in best.first {
                                if old.value == op.value {
                                    continue outer
                                }
                            }
                            a.add(op)
                        }
                        best := Pair<ListView<MethodRef>, Int>(a, cost)
                    }
                }
            }
            return best
        }
        return null
    }

    @class
    method foldInts(compiler:Compiler, left:ASTNode, op:Operator, right:ASTNode):ASTNode? {
        def l:Int64
        def r:Int64
        -- ensure both values fit into a signed Int64
        match left {
            when ASTNode.INT(_, int) {
                if int > Int64.MAX.asUInt64 {
                    return null
                }
                l := int.asInt64
            }
            otherwise {
                return null
            }
        }
        match right {
            when ASTNode.INT(_, int) {
                if int > Int64.MAX.asUInt64 {
                    return null
                }
                r := int.asInt64
            }
            otherwise {
                return null
            }
        }
        match op {
            when Operator.ADD {
                def v := (l + r).asUInt64
                return ASTNode.INT(left.position(), v)
            }
            when Operator.SUB {
                def v := (l - r).asUInt64
                return ASTNode.INT(left.position(), v)
            }
            when Operator.MUL {
                def v := (l * r).asUInt64
                return ASTNode.INT(left.position(), v)
            }
            when Operator.INTDIV {
                if r = 0 {
                    compiler.error(right.position(), "division by 0")
                    return null
                }
                def v := (l // r).asUInt64
                return ASTNode.INT(left.position(), v)
            }
            when Operator.REM {
                if r = 0 {
                    compiler.error(right.position(), "division by 0")
                    return null
                }
                def v := (l % r).asUInt64
                return ASTNode.INT(left.position(), v)
            }
            when Operator.EQ {
                return ASTNode.BIT(left.position(), l = r)
            }
            when Operator.NEQ {
                return ASTNode.BIT(left.position(), l != r)
            }
            when Operator.LT {
                return ASTNode.BIT(left.position(), l < r)
            }
            when Operator.GT {
                return ASTNode.BIT(left.position(), l > r)
            }
            when Operator.LTEQ {
                return ASTNode.BIT(left.position(), l <= r)
            }
            when Operator.GTEQ {
                return ASTNode.BIT(left.position(), l >= r)
            }
            when Operator.BITWISEAND {
                def v := (l && r).asUInt64
                return ASTNode.INT(left.position(), v)
            }
            when Operator.BITWISEOR {
                def v := (l || r).asUInt64
                return ASTNode.INT(left.position(), v)
            }
            when Operator.BITWISEXOR {
                def v := (l ~~ r).asUInt64
                return ASTNode.INT(left.position(), v)
            }
            when Operator.SHIFTLEFT {
                def v := (l << r).asUInt64
                return ASTNode.INT(left.position(), v)
            }
            when Operator.SHIFTRIGHT {
                def v := (l >> r).asUInt64
                return ASTNode.INT(left.position(), v)
            }
        }
        compiler.error(left.position(), "'\{op.asString}' cannot operate on 'frost.core.Int64', " +
                "'frost.core.Int64'")
        return null
    }

    @class
    function foldStrings(compiler:Compiler, left:ASTNode, op:Operator, right:ASTNode):ASTNode? {
        -- FIXME this doesn't work for longer concatenations like "A" + "B" + "C" + "D"; will only
        -- fold the innermost pair
        if op != Operator.ADD {
            return null
        }
        match left {
            when ASTNode.STRING(position, s1) {
                match right {
                    when ASTNode.STRING(_, s2) {
                        return ASTNode.STRING(position, s1 + s2)
                    }
                }
            }
        }
        return null
    }

    @class
    function fold(compiler:Compiler, left:ASTNode, op:Operator, right:ASTNode):ASTNode? {
        match left {
            when ASTNode.INT {
                return foldInts(compiler, left, op, right)
            }
            when ASTNode.STRING {
                return foldStrings(compiler, left, op, right)
            }
            otherwise {
                return null
            }
        }
    }

    @class
    method compile(compiler:Compiler, position:Position, left:ASTNode, op:Operator, right:ASTNode,
            type:TypeContext):IR.Value? {
        def folded := fold(compiler, left, op, right)
        if folded !== null {
            return compiler.compileExpression(folded, type)
        }
        match op {
            when Operator.CAST {
                def target := compiler.scanner.convertType(right)
                return compiler.coerce(position, compiler.compileCast(position, left, target), type)
            }
            when Operator.IDENTITY, Operator.NIDENTITY {
                return compiler.compileIdentityComparison(position, left, op, right, type)
            }
            otherwise {
                def matches := findOverloadedOperator(compiler, left, op, right, type)
                if matches !== null {
                    if matches.first.count > 1 {
                        compiler.reportAmbiguousMatch(position, matches.first, [left, right], type)
                        return null
                    }
                    def m := matches.first[0].value
                    if op = Operator.INDEX & compiler.isTuple(m.owner) {
                        match right {
                            when ASTNode.INT(_, v) {
                                def compiledLeft := compiler.compileExpression(left,
                                        TypeContext.NON_VOID)
                                if compiledLeft == null {
                                    return null
                                }
                                return compiler.coerce(position, compiler.cast(position,
                                        Dot.compile(compiler, position, compiledLeft, "f\{v}"),
                                            compiledLeft.type().subtypes[v.asInt64]), type)
                            }
                        }
                    }
                    if m.annotations.isClass {
                        if m.parameters.count = 2 {
                            return Call.compile(compiler, position, IR.Value.METHOD(null, m),
                                    [left, right], type)
                        }
                        assert m.parameters.count = 1
                        return Call.compile(compiler, position, IR.Value.METHOD(null, m), [right],
                                type)
                    }
                    if m.owner.name = "frost.core.Bit" {
                        if m.name = "&" {
                            return And.compile(compiler, position, left, right, type)
                        }
                        if m.name = "|" {
                            return Or.compile(compiler, position, left, right, type)
                        }
                    }
                    def found := compiler.findType(compiler.possibleTypes(left), m.owner)
                    assert found !== null
                    def target := compiler.compileExpression(left, TypeContext.TYPE(found, false))
                    if target == null {
                        return null
                    }
                    return Call.compile(compiler, position, IR.Value.METHOD(target, m), [right],
                            type)
                }
                def compiledLeft := compiler.compileExpression(left, TypeContext.NON_VOID)
                if compiledLeft == null {
                    return null
                }
                if op = Operator.INDEX & compiledLeft.type().isTuple {
                    match right {
                        when ASTNode.INT(_, v) {
                            return compiler.coerce(position, compiler.cast(position,
                                    Dot.compile(compiler, position, compiledLeft, "f\{v}"),
                                        compiledLeft.type().subtypes[v.asInt64]), type)
                        }
                    }
                }
                def compiledRight := compiler.compileExpression(right,
                        TypeContext.TYPE(compiledLeft.type(), false))
                if compiledRight == null {
                    return null
                }
                if (compiledLeft.type() = Type.BuiltinBit() |
                        compiledLeft.type().isBuiltinNumber) {
                    def resultType := compiler.preferredType(ASTNode.BINARY(position, left, op,
                             right))
                    if resultType !== null {
                        def result := compiler.ir.add(IR.Statement.BINARY(position, compiledLeft,
                                op, compiledRight, resultType))
                        return compiler.coerce(position, IR.Value.REF(result, resultType), type)
                    }
                }
                compiler.error(position, "no match for '\{op.asString}' on " +
                        "'\{compiledLeft.type()}', '\{compiledRight.type()}'" +
                        type.description())
                return null
            }
        }
    }
}