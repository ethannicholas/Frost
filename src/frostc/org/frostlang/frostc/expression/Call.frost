package org.frostlang.frostc.expression

uses org.frostlang.frostc.ASTNode
uses org.frostlang.frostc.ClassDecl
uses org.frostlang.frostc.Compiler
uses org.frostlang.frostc.Compiler.AutoContext
uses org.frostlang.frostc.Compiler.AutoScope
uses org.frostlang.frostc.Compiler.EnclosingContext
uses org.frostlang.frostc.Compiler.TypeContext
uses org.frostlang.frostc.FieldDecl
uses org.frostlang.frostc.FixedArray
uses org.frostlang.frostc.IR
uses org.frostlang.frostc.MethodDecl
uses org.frostlang.frostc.MethodPosition
uses org.frostlang.frostc.MethodRef
uses org.frostlang.frostc.Pair
uses org.frostlang.frostc.Symbol
uses org.frostlang.frostc.Type
uses org.frostlang.frostc.Variable
uses org.frostlang.frostc.parser.Token
uses org.frostlang.frostc.statement.Assert

class Call {
    @class
    method possibleTypes(compiler:Compiler, m:ASTNode,
            args:FixedArray<ASTNode>):CollectionView<Type>? {
        def methodTypes := compiler.possibleTypes(m)
        if methodTypes == null {
            return null
        }
        if methodTypes.count = 1 {
            def t := methodTypes.iterator.next()
            if t.isClass {
                def cl := compiler.getClass(t)
                if cl !== null & cl.classKind = ClassDecl.Kind.CHOICE {
                    -- choice case
                    return [t]
                }
            }
            if t.typeKind = Type.Kind.GENERIC & t.subtypes[0] = compiler.CLASS_TYPE {
                -- calling a class literal, this is actually object construction
                return [t.subtypes[1]]
            }
        }
        def result := possibleMatches(compiler, methodTypes, args, Compiler.TypeContext.NON_VOID)
        if result !== null {
            def resultTypes := HashSet<Type>()
            for m in result[0] {
                resultTypes.add(m.returnType)
            }
            return resultTypes
        }
        return null
    }

    @private
    @class
    method possibleMatches(compiler:Compiler, methodTypes:CollectionView<Type>,
            args:ListView<ASTNode>, type:TypeContext):(Array<Type>, Int)? {
        var bestCost := Int.MAX
        def best := Array<Type>()
        outer: for raw in methodTypes {
            var m := raw.nonnullable()
            if m.methodRef !== null & m.methodRef.value.genericParameters !== null {
                def inferred := performTypeInference(compiler, m.methodRef, args, type)
                if inferred == null {
                    continue
                }
                m := Type(inferred)
            }
            if m.typeKind != Type.Kind.METHOD &
                    m.typeKind != Type.Kind.FUNCTION &
                    m.typeKind != Type.Kind.IMMUTABLE_METHOD &
                    m.typeKind != Type.Kind.IMMUTABLE_FUNCTION {
                continue
            }
            if m.subtypes.count != args.count + 1->Int {
                continue
            }
            var cost := -m.priority
            for i in 0 .. args.count {
                def argCost := compiler.coercionCost(args[i], m.subtypes[i])
                if argCost == null {
                    continue outer
                }
                cost += argCost[1]
            }
            def returnType := m.returnType
            match type {
                when TypeContext.IMMUTABLE {
                    if returnType = compiler.VOID_TYPE | !compiler.isImmutable(returnType) {
                        continue
                    }
                }
                when TypeContext.TYPE(t, _) {
                    def returnCost := compiler.coercionCost(returnType, t)
                    if returnCost == null {
                        continue
                    }
                    cost += returnCost[1]
                }
                when TypeContext.NON_VOID {
                    if returnType = compiler.VOID_TYPE {
                        continue
                    }
                }
            }
            if cost < bestCost {
                bestCost := cost
                best.clear()
            }
            if cost = bestCost {
                best.add(m)
            }
        }
        if best.count = 0 {
            return null
        }
        return (best, bestCost)
    }

    @private
    @class
    method callCost(compiler:Compiler, methodTypes:CollectionView<Type>, args:ListView<ASTNode>,
            type:TypeContext):(Type, Int)? {
        def result := possibleMatches(compiler, methodTypes, args, type)
        if result !== null {
            -- we still might not actually be able to successfully perform the coercion, in the
            -- event that it's ambiguous, but for error reporting purposes we act like it's going to
            -- be ok right now
            return (result[0].iterator.next().returnType, result[1])
        }
        return null
    }

    @class
    method coercionCost(compiler:Compiler, m:ASTNode, args:FixedArray<ASTNode>,
            target:Type):(Type, Int)? {
        var methodTypes := compiler.possibleTypes(m)
        if methodTypes == null {
            return null
        }
        if methodTypes.count = 1 {
            def t := methodTypes.iterator.next()
            if t.isClassLiteral {
                def resultCost := compiler.coercionCost(t.subtypes[1], target)
                if resultCost == null {
                    return null
                }
                methodTypes := compiler.possibleTypes(ASTNode.DOT(m.position(), m, "init"))
                if methodTypes == null {
                    return null
                }
                def cc := callCost(compiler, methodTypes, args, TypeContext.UNSPECIFIED)
                if cc == null {
                    return null
                }
                return (resultCost[0], cc[1] + resultCost[1])
            }
        }
        return callCost(compiler, methodTypes, args, TypeContext.TYPE(target, false))
    }

    @class
    method compilePointerIntrinsic(compiler:Compiler, position:MethodPosition,
            rawTarget:IR.Value?, m:MethodRef, args:ListView<ASTNode>):(Bit, IR.Value?) {
        def ir := compiler.ir
        def pointerType:Type?
        assert m.target.isPointer
        if m.target.hasSubtypes {
            pointerType := compiler.resolve(m.target.subtypes[1])
        }
        else {
            pointerType := compiler.ANY_TYPE
        }
        if pointerType == null {
            return (false, null)
        }
        match m.value.name {
            when "get" {
                def target := compiler.extractBuiltinInt(position, rawTarget)
                assert target !== null
                def get := ir.add(IR.Statement.POINTER_GET(position, target, pointerType))
                return (true, IR.Value.REF(get, pointerType))
            }
            when "set" {
                def target := compiler.extractBuiltinInt(position, rawTarget)
                assert target !== null
                def value := compiler.compileExpression(args[0],
                        TypeContext.TYPE(pointerType, false))
                if value !== null {
                    if compiler.isRefCounted(pointerType) {
                        compiler.compileRef(value)
                        def load := ir.add(IR.Statement.POINTER_GET(position, target, pointerType))
                        compiler.compileUnref(IR.Value.REF(load, pointerType))
                    }
                    ir.add(IR.Statement.POINTER_SET(position, value, target, pointerType))
                }
                return (true, null)
            }
            when "[]" {
                def target := compiler.extractBuiltinInt(position, rawTarget)
                assert target !== null
                def index := compiler.compileExpression(args[0],
                        TypeContext.TYPE(compiler.INT_TYPE, false))
                if index == null {
                    return (false, null)
                }
                def get := ir.add(IR.Statement.POINTER_GET_INDEX(position, target,
                        compiler.extractBuiltinInt(position, index), pointerType))
                return (true, IR.Value.REF(get, pointerType))
            }
            when "[]:=" {
                def target := compiler.extractBuiltinInt(position, rawTarget)
                assert target !== null
                def index := compiler.compileExpression(args[0],
                        TypeContext.TYPE(compiler.INT_TYPE, false))
                def value := compiler.compileExpression(args[1],
                        TypeContext.TYPE(pointerType, false))
                if index !== null & value !== null {
                    def indexValue := compiler.extractBuiltinInt(position, index)
                    if compiler.isRefCounted(pointerType) {
                        compiler.compileRef(value)
                        def load := ir.add(IR.Statement.POINTER_GET_INDEX(position, target,
                                indexValue, pointerType))
                        compiler.compileUnref(IR.Value.REF(load, pointerType))
                    }
                    ir.add(IR.Statement.POINTER_SET_INDEX(position, value, target, indexValue,
                            pointerType))
                }
                return (true, null)
            }
            when "convertTo" {
                def target := compiler.extractBuiltinInt(position, rawTarget)
                assert target !== null
                def result := ir.add(IR.Statement.CAST(position, target, m.returnType, false))
                return (true, IR.Value.REF(result, m.returnType))
            }
            when "clear" {
                if args.count = 1 {
                    def target := compiler.extractBuiltinInt(position, rawTarget)
                    def nullableType := pointerType.nullable()
                    def index := compiler.compileExpression(args[0],
                            TypeContext.TYPE(compiler.INT_TYPE, false))
                    if compiler.isRefCounted(nullableType) {
                        def indexValue := compiler.extractBuiltinInt(position, index)
                        def load := ir.add(IR.Statement.POINTER_GET_INDEX(position, target,
                                indexValue, pointerType))
                        compiler.compileUnref(IR.Value.REF(load, nullableType))
                        ir.add(IR.Statement.POINTER_SET_INDEX(position,
                                IR.Value.NULL(nullableType), target, indexValue, pointerType))
                    }
                    return (true, null)
                }
            }
        }
        return (false, null)
    }

    @class
    method compileNumberIntrinsic(compiler:Compiler, position:MethodPosition, target:IR.Value,
            op:Binary.Operator, args:ListView<ASTNode>, operandType:Type,
            resultType:Type):(Bit, IR.Value?) {
        if args.count != 1 {
            return (false, null)
        }
        def left := compiler.coerce(position, target, operandType)
        if left == null {
            return (false, null)
        }
        def right := compiler.compileExpression(args[0], TypeContext.TYPE(operandType, false))
        if right == null {
            return (false, null)
        }
        def builtinLeft := compiler.extractBuiltinInt(position, left)
        def builtin:IR.Statement.ID
        def builtinResultType:Type
        if resultType = compiler.BIT_TYPE {
            builtinResultType := compiler.BUILTIN_BIT_TYPE
        }
        else {
            builtinResultType :=  builtinLeft.type()
        }
        builtin := compiler.ir.add(IR.Statement.BINARY(position, builtinLeft, op,
                compiler.extractBuiltinInt(position, right), builtinResultType))
        def constructArgs := Array<ASTNode>()
        constructArgs.add(ASTNode.IR_WRAPPER(position.asPosition, IR.Value.REF(builtin,
                builtinResultType)))
        def construct := compile(compiler, position, compiler.literalType(resultType),
                constructArgs, TypeContext.TYPE(resultType, false))
        assert construct !== null
        return (true, construct)
    }

    @class
    method compileNumberIntrinsic(compiler:Compiler, position:MethodPosition, target:IR.Value?,
            m:MethodRef, args:ListView<ASTNode>):(Bit, IR.Value?) {
        match m.value.name {
            when "init" {
                assert m.value.parameters.count = 1
                assert args.count = 1
                def paramType := m.value.parameters[0].type
                if paramType.isBuiltinNumber {
                    def value := compiler.compileExpression(args[0],
                            TypeContext.TYPE(paramType, false))
                    if value !== null {
                        def result := compiler.ir.add(IR.Statement.CREATE_STRUCT(position,
                                m.value.owner, FixedArray<IR.Value>.from([value])))
                        return (true, IR.Value.REF(result, m.value.owner.type))
                    }
                }
            }
            when "+" {
                return compileNumberIntrinsic(compiler, position, target, Binary.Operator.ADD, args,
                        m.returnType, m.returnType)
            }
            when "-" {
                return compileNumberIntrinsic(compiler, position, target, Binary.Operator.SUB, args,
                        m.returnType, m.returnType)
            }
            when "*" {
                return compileNumberIntrinsic(compiler, position, target, Binary.Operator.MUL, args,
                        m.returnType, m.returnType)
            }
            when "//" {
                return compileNumberIntrinsic(compiler, position, target, Binary.Operator.INTDIV,
                        args, m.returnType, m.returnType)
            }
            when ">" {
                return compileNumberIntrinsic(compiler, position, target, Binary.Operator.GT, args,
                        compiler.binaryType(m.value.owner.type, m.value.parameters[0].type, true,
                            false),
                        m.returnType)
            }
            when ">=" {
                return compileNumberIntrinsic(compiler, position, target, Binary.Operator.GTEQ,
                        args, compiler.binaryType(m.value.owner.type, m.value.parameters[0].type,
                            true, false),
                        m.returnType)
            }
            when "<" {
                return compileNumberIntrinsic(compiler, position, target, Binary.Operator.LT, args,
                        compiler.binaryType(m.value.owner.type, m.value.parameters[0].type, true,
                            false),
                        m.returnType)
            }
            when "<=" {
                return compileNumberIntrinsic(compiler, position, target, Binary.Operator.LTEQ,
                        args, compiler.binaryType(m.value.owner.type, m.value.parameters[0].type,
                            true, false),
                        m.returnType)
            }
            when "==" {
                return compileNumberIntrinsic(compiler, position, target, Binary.Operator.EQ, args,
                        compiler.binaryType(m.value.owner.type, m.value.parameters[0].type, true,
                            false),
                        m.returnType)
            }
            when "!=" {
                return compileNumberIntrinsic(compiler, position, target, Binary.Operator.NEQ, args,
                        compiler.binaryType(m.value.owner.type, m.value.parameters[0].type, true,
                            false),
                        m.returnType)
            }
        }
        return (false, null)
    }

    @class
    method compileBitIntrinsic(compiler:Compiler, position:MethodPosition, target:IR.Value?,
            m:MethodRef, args:ListView<ASTNode>):(Bit, IR.Value?) {
        match m.value.name {
            when "init" {
                assert m.value.parameters.count = 1
                assert args.count = 1
                def paramType := m.value.parameters[0].type
                if paramType = compiler.BUILTIN_BIT_TYPE {
                    def value := compiler.compileExpression(args[0],
                            TypeContext.TYPE(paramType, false))
                    if value !== null {
                        def result := compiler.ir.add(IR.Statement.CREATE_STRUCT(position,
                                m.value.owner, FixedArray<IR.Value>.from([value])))
                        return (true, IR.Value.REF(result, m.value.owner.type))
                    }
                }
            }
        }
        return (false, null)
    }

    @class
    method compileIntrinsic(compiler:Compiler, position:MethodPosition, target:IR.Value?,
            m:MethodRef, args:ListView<ASTNode>):(Bit, IR.Value?) {
        if m.target.isPointer {
            return compilePointerIntrinsic(compiler, position, target, m, args)
        }
        if m.target.isNumber {
            return compileNumberIntrinsic(compiler, position, target, m, args)
        }
        if m.target = compiler.BIT_TYPE {
            return compileBitIntrinsic(compiler, position, target, m, args)
        }
        return (false, null)
    }

    ================================================================================================
    Scans a type to find instances of unsubstituted generic parameters belonging to the method in
    it. For instance, when dealing with `map<U>(f:(T)=>(U)):ListView<U>`, the type
    `(String)=>(U)` contains an unsubstituted reference to the generic parameter `U`. Returns the
    "paths" to these parameters, where each path is a list of numbers representing the subtype
    index at which the parameter was found. In the given example, the result would be `[[1]]`, since
    there was one parameter located, and since it is located at index 1 in the type, its path is
    `[1]`. Returns null if no such type was located.
    ================================================================================================
    @class
    function findGenericParameters(m:MethodDecl, t:Type):Array<Array<Int>>? {
        if !t.hasSubtypes {
            return null
        }
        var result:Array<Array<Int>>? := null
        for i in 0 .. t.subtypes.count {
            if t.subtypes[i].typeKind = Type.Kind.GENERIC_METHOD_PARAMETER {
                if t.subtypes[i].genericMethodParameter.owner = m.owner.name + "." + m.name {
                    if result == null {
                        result := Array<Array<Int>>()
                    }
                    result.add([i])
                }
            }
            else {
                def paths := findGenericParameters(m, t.subtypes[i])
                if paths !== null {
                    if result == null {
                        result := Array<Array<Int>>()
                    }
                    for path in paths {
                        def finalPath:Array<Int> := [i]
                        finalPath.addAll(path)
                        result.add(finalPath)
                    }
                }
            }
        }
        return result
    }

    @class
    function getSubtype(type:Type, indices:ListView<Int>):Type? {
        var result := type
        for i in indices {
            if !result.hasSubtypes | i >= result.subtypes.count {
                return null
            }
            result := result.subtypes[i]
        }
        return result
    }

    @class
    function methodRemap(compiler:Compiler, type:Type, map:HashMap<String, Type>):Type {
        if type.typeKind = Type.Kind.NULLABLE {
            return methodRemap(compiler, type.nonnullable(), map).nullable()
        }
        if type.isMethod {
            def parameterTypes := Array<Type>()
            for i in 0 .. type.subtypes.count - 1 {
                parameterTypes.add(type.subtypes[i].remap(compiler, map))
            }
            def returnType := type.returnType.remap(compiler, map)
            def result := Type.methodType(compiler, type.position, type.typeKind, parameterTypes,
                    returnType, type.priority)
            return result
        }
        return type
    }

    ================================================================================================
    Return value of the [determineImplications] method.
    ================================================================================================
    choice ImplicationsResult {
        ============================================================================================
        The call was successful and the mappings were updated.
        ============================================================================================
        UPDATED

        ============================================================================================
        The call was successful, but the mappings were not updated.
        ============================================================================================
        NOT_UPDATED

        ============================================================================================
        It is not possible to use this argument as this type with these `currentMappings`.
        ============================================================================================
        FAILED
    }

    @class
    method determineImplications(compiler:Compiler, m:MethodDecl, src:Type, target:Type,
            currentMapping:HashMap<String, Type>):ImplicationsResult {
        if target.typeKind = Type.Kind.GENERIC_METHOD_PARAMETER {
            def newType := currentMapping[target.name].intersection(compiler, src)
            if newType == null {
                return ImplicationsResult.FAILED
            }
            if newType != currentMapping[target.name] {
                currentMapping[target.name] := newType
                return ImplicationsResult.UPDATED
            }
            return ImplicationsResult.NOT_UPDATED
        }
        else {
            def generics := findGenericParameters(m, target.nonnullable())
            var result := ImplicationsResult.NOT_UPDATED
            if generics !== null {
                for g in generics {
                    def parameter := getSubtype(target.nonnullable(), g)
                    if parameter == null {
                        break
                    }
                    assert parameter.typeKind = Type.Kind.GENERIC_METHOD_PARAMETER
                    def subtype := getSubtype(src.nonnullable(), g)
                    if subtype == null {
                        return ImplicationsResult.NOT_UPDATED
                    }
                    def newType := currentMapping[parameter.name].intersection(compiler, subtype)
                    if newType == null {
                        return ImplicationsResult.FAILED
                    }
                    if newType != currentMapping[parameter.name] {
                        currentMapping[parameter.name] := newType
                        result := ImplicationsResult.UPDATED
                    }
                }
            }
            return result
        }
    }

    ================================================================================================
    Update `currentMapping` with the implications of trying to use `src` as a parameter of type
    `target`. For instance, if we tried to use `Int.+`, which has type `(Int, Int)=>*(Int)`, as a
    parameter of type `(T, T)=>(U)`, the implication is that `T` and `U` are both `Int`.
    ================================================================================================
    @class
    method determineImplications(compiler:Compiler, m:MethodDecl, src:ASTNode, target:Type,
            currentMapping:HashMap<String, Type>):ImplicationsResult {
        match src {
            when ASTNode.UNTYPED_LAMBDA(_, parameterNames, expr) {
                def rawType := target.nonnullable()
                if rawType.isMethod {
                    if rawType.parameterCount != parameterNames.count {
                        return ImplicationsResult.FAILED
                    }
                    def parameters := Array<ASTNode>()
                    for (i, n) in parameterNames.enumeration {
                        match n {
                            when ASTNode.IDENTIFIER(position, name) {
                                def t := compiler.literalType(rawType.parameterType(i))
                                parameters.add(ASTNode.PARAMETER(position,
                                        name, ASTNode.IR_WRAPPER(position, t)))
                            }
                            otherwise {
                                unreachable
                            }
                        }
                    }
                    def type := Closure.typedLambdaType(compiler, parameters, expr,
                            TypeContext.NON_VOID)
                    if type !== null {
                        return determineImplications(compiler, m, type.returnType,
                                target.returnType, currentMapping)
                    }
                }
            }
        }
        def preferred := compiler.preferredType(src)
        if preferred !== null {
            def impl := determineImplications(compiler, m, preferred, target, currentMapping)
            if impl != ImplicationsResult.FAILED {
                return impl
            }
        }
        def possible := compiler.possibleTypes(src)
        if possible !== null {
            var type:Type? := null
            for p in possible {
                def tmp := HashMap<String, Type>(currentMapping)
                if determineImplications(compiler, m, p, target, tmp) != ImplicationsResult.FAILED {
                    if type !== null {
                        type := null
                        break
                    }
                    type := p
                }
            }
            if type !== null {
                return determineImplications(compiler, m, type, target, currentMapping)
            }
        }
        def targetRemapped := methodRemap(compiler, target, currentMapping)
        var argType := compiler.coercionCost(src, targetRemapped)
        if argType !== null {
            return determineImplications(compiler, m, argType[0], target, currentMapping)
        }
        return ImplicationsResult.NOT_UPDATED
    }

    @class
    method performTypeInference(compiler:Compiler, m:MethodRef, args:ListView<ASTNode>,
            type:TypeContext):MethodRef? {
        if !m.requiresTypeInference {
            return m
        }
        if m.value.parameters.count != args.count {
            return null
        }
        def remaps := HashMap<String, Type>()
        for p in m.value.genericParameters {
            remaps[m.value.owner.name + "." + m.value.name + "." + p.name] := p.bound
        }
        var updated := false
        do {
            updated := false
            for i in 0 .. m.value.parameters.count {
                def paramType := m.parameterType(i)
                def result := determineImplications(compiler, m.value, args[i], paramType, remaps)
                match result {
                    when ImplicationsResult.UPDATED {
                        updated := true
                    }
                    when ImplicationsResult.NOT_UPDATED {
                    }
                    when ImplicationsResult.FAILED {
                        return null
                    }
                }
            }
            match type {
                when TypeContext.TYPE(t, _) {
                    def result := determineImplications(compiler, m.value, t, m.returnType, remaps)
                    match result {
                        when ImplicationsResult.UPDATED {
                            updated := true
                        }
                        when ImplicationsResult.NOT_UPDATED {
                        }
                        when ImplicationsResult.FAILED {
                            return null
                        }
                    }
                }
            }
        }
        while updated
        def result := m.value.genericParameters.map(p => remaps[m.value.owner.name + "." +
                m.value.name + "." + p.name]!)
        return MethodRef(compiler, m.target, m.value, result)
    }

    @class
    method findBestMethod(compiler:Compiler, position:MethodPosition, target:IR.Value?,
            methods:ListView<MethodDecl>, args:ListView<ASTNode>,
            type:TypeContext):(Array<MethodRef>, Int)? {
        return findBestMethod(compiler, position, target, methods, null, args, type)
    }

    @class
    @post(@return == null | @return[0].count > 0)
    method findBestMethod(compiler:Compiler, position:MethodPosition, target:IR.Value?,
            methods:ListView<MethodDecl>, genericArguments:ListView<Type>?, args:ListView<ASTNode>,
            type:TypeContext):(Array<MethodRef>, Int)? {
        if methods.count = 0 {
            return null
        }
        var bestCost := Int.MAX
        var best := Array<MethodRef>()
        outer: for m in methods {
            if m.parameters.count != args.count {
                continue
            }
            if !compiler.resolve(m) {
                continue
            }
            if genericArguments !== null & (m.genericParameters == null |
                    genericArguments.count != m.genericParameters.count) {
                continue
            }
            var ref:MethodRef?
            if target !== null {
                var owner := target.type()
                if owner.typeKind = Type.Kind.GENERIC_METHOD_PARAMETER {
                    owner := owner.genericMethodParameter.bound
                }
                ref := MethodRef(compiler, owner, m, genericArguments)
            }
            else if m.annotations.isClass | m.methodKind = MethodDecl.Kind.INIT {
                ref := MethodRef(compiler, m.owner.type, m, genericArguments)
            }
            else {
                ref := MethodRef(compiler, compiler.findType(compiler.currentClass[0].type,
                        m.owner), m, genericArguments)
            }
            ref := performTypeInference(compiler, ref, args, type)
            if ref == null {
                return null
            }
            var cost := 0
            for i in 0 .. args.count {
                def argCost := compiler.coercionCost(args[i], ref.parameterType(i))
                if argCost == null {
                    continue outer
                }
                cost += argCost[1]
            }
            match type {
                when TypeContext.IMMUTABLE {
                    if m.returnType = compiler.VOID_TYPE | !compiler.isImmutable(ref.returnType) {
                        continue
                    }
                }
                when TypeContext.TYPE(t, _) {
                    def returnCost := compiler.coercionCost(ref.returnType, t)
                    if returnCost == null {
                        continue
                    }
                    cost += returnCost[1]
                }
            }
            cost -= m.priority
            if cost < bestCost {
                bestCost := cost
                best.clear()
            }
            if cost = bestCost {
                best.add(ref)
            }
        }
        if best.count = 0 {
            return null
        }
        return (best, bestCost)
    }

    @class
    method callMethodObject(compiler:Compiler, position:MethodPosition, m:IR.Value,
            args:ListView<ASTNode>, type:TypeContext):IR.Value? {
        def ir := compiler.ir
        def t := m.type().nonnullable()
        if !t.isMethod {
            compiler.error(position, "value of type '\{t}' is not a method")
            return null
        }
        if t.parameterCount != args.count {
            compiler.error(position, "method of type '\{t}' expected \{t.parameterCount} " +
                    "argument\{t.parameterCount = 1:|s}, but found \{args.count}")
            return null
        }
        def finalArgs := Array<IR.Value>(args.count)
        for i in 0 .. args.count {
            def compiled := compiler.compileExpression(args[i],
                    TypeContext.TYPE(t.parameterType(i), false))
            if compiled == null {
                return null
            }
            finalArgs.add(compiled)
        }
        def result:IR.Value?
        def resultSlot := ir.locals.count
        if t.returnType != compiler.VOID_TYPE {
            ir.locals.add(t.returnType)
            result := IR.Value.LOCAL(resultSlot, t.returnType)
        }
        else {
            result := null
        }
        def methodType:Type
        def targetType:Type
        if compiler.isImmutable(m.type()) {
            methodType := compiler.METHOD_TYPE
            targetType := compiler.IMMUTABLE_TYPE
        }
        else {
            methodType := compiler.MUTABLE_METHOD_TYPE
            targetType := compiler.OBJECT_TYPE
        }
        def st := compiler.getSymbolTable(compiler.getClass(methodType))
        def pointerField := st["pointer"]->FieldDecl
        if !compiler.resolve(pointerField) {
            return null
        }
        def methodObj := compiler.cast(position, m, methodType)
        def methodPtrPtr := ir.add(IR.Statement.GET_FIELD_POINTER(position, methodObj,
                pointerField))
        def methodPtr := ir.add(IR.Statement.LOAD(position, IR.Value.REF(methodPtrPtr,
                compiler.BUILTIN_INT_TYPE)))
        def targetField := st["target"]->FieldDecl
        if !compiler.resolve(targetField) {
            return null
        }
        def targetPtr := ir.add(IR.Statement.GET_FIELD_POINTER(position, methodObj, targetField))
        def target := ir.add(IR.Statement.LOAD(position, IR.Value.REF(targetPtr, targetType)))
        def targetNonNull := ir.add(IR.Statement.BINARY(position, IR.Value.REF(target, targetType),
                Binary.Operator.NIDENTITY, IR.Value.NULL(targetType.nullable()),
                compiler.BUILTIN_BIT_TYPE))
        def haveTargetBlock := ir.newBlock("dynamic call with target")
        def noTargetBlock := ir.newBlock("dynamic call without target")
        def mergeBlock := ir.newBlock("dynamic call merge")
        ir.add(IR.Statement.CONDITIONAL_BRANCH(position, IR.Value.REF(targetNonNull,
                compiler.BUILTIN_BIT_TYPE), haveTargetBlock, noTargetBlock))
        ir.setCurrentBlock(noTargetBlock)
        def noTargetCastType := Type.pointerTo(compiler, t)
        def noTargetCast := IR.Value.REF(ir.add(IR.Statement.CREATE_STRUCT(position,
                compiler.getClass(noTargetCastType)!, FixedArray<IR.Value>.from(
                    [IR.Value.REF(methodPtr, compiler.BUILTIN_INT_TYPE)]))), noTargetCastType)
        def noTargetResult := ir.add(IR.Statement.DYNAMIC_CALL(position, noTargetCast,
                FixedArray<IR.Value>(finalArgs)))
        if result !== null {
            ir.add(IR.Statement.STORE(position, IR.Value.REF(noTargetResult, t.returnType),
                    result))
        }
        ir.add(IR.Statement.BRANCH(position, mergeBlock))
        ir.setCurrentBlock(haveTargetBlock)
        def targetParams := Array<Type>()
        targetParams.add(targetType)
        for i in 0 .. t.parameterCount {
            targetParams.add(t.parameterType(i))
        }
        def haveTargetType := Type.methodType(compiler, position.asPosition, t.typeKind,
                targetParams, t.returnType, 0)
        def haveTargetCastType := Type.pointerTo(compiler, haveTargetType)
        def haveTargetCast := IR.Value.REF(ir.add(IR.Statement.CREATE_STRUCT(position,
                compiler.getClass(haveTargetCastType)!, FixedArray<IR.Value>.from(
                    [IR.Value.REF(methodPtr, compiler.BUILTIN_INT_TYPE)]))), haveTargetCastType)
        finalArgs.insert(0, IR.Value.REF(target, targetType))
        def haveTargetResult := ir.add(IR.Statement.DYNAMIC_CALL(position, haveTargetCast,
                FixedArray<IR.Value>(finalArgs)))
        if result !== null {
            ir.add(IR.Statement.STORE(position, IR.Value.REF(haveTargetResult, t.returnType),
                    result))
        }
        ir.add(IR.Statement.BRANCH(position, mergeBlock))
        ir.setCurrentBlock(mergeBlock)
        if result !== null {
            def resultLoad := ir.add(IR.Statement.LOAD(position, result))
            def loadRef := IR.Value.REF(resultLoad, t.returnType)
            if compiler.isRefCounted(t.returnType) {
                compiler.enclosingContexts.push(EnclosingContext.VALUE_SCOPE(loadRef))
            }
            return compiler.coerce(position, loadRef, type)
        }
        return null
    }

    @class
    method compile(compiler:Compiler, position:MethodPosition, m:IR.Value, args:ListView<ASTNode>,
            type:TypeContext):IR.Value? {
        def currentClass := compiler.currentClass[0]
        def ir := compiler.ir
        match m {
            when IR.Value.METHOD(target, m, _) {
                def targetType:Type
                if target !== null {
                    targetType := target.type()
                }
                else if m.annotations.isClass | m.methodKind = MethodDecl.Kind.INIT {
                    targetType := m.owner.type
                }
                else {
                    def found := compiler.findType(currentClass.type, m.owner)
                    assert found !== null,
                            "could not find \{currentClass.type} in \{m.owner.name}"
                    targetType := found
                }
                if !compiler.resolve(m) {
                    return null
                }
                return compile(compiler, position, target, MethodRef(compiler, targetType, m),
                        args, type)
            }
            when IR.Value.GENERIC_METHOD(target, m, types) {
                def targetType:Type
                if target !== null {
                    targetType := target.type()
                }
                else if m.annotations.isClass | m.methodKind = MethodDecl.Kind.INIT {
                    targetType := m.owner.type
                }
                else {
                    def found := compiler.findType(currentClass.type, m.owner)
                    assert found !== null,
                            "could not find \{currentClass.type} in \{m.owner.name}"
                    targetType := found
                }
                if !compiler.resolve(m) {
                    return null
                }
                return compile(compiler, position, target,
                        MethodRef(compiler, targetType, m, types), args, type)
            }
            when IR.Value.METHODS(target, methods, _) {
                def best := findBestMethod(compiler, position, target, methods, args, type)
                if best !== null {
                    if best[0].count > 1 {
                        compiler.reportAmbiguousMatch(position.asPosition, best[0], args, type)
                        return null
                    }
                    return compile(compiler, position, target, best[0][0], args, type)
                }
                -- no match
                def argTypes := Array<Type>()
                for a in args {
                    def preferred := compiler.preferredType(a)
                    if preferred == null {
                        -- force it to produce an error
                        def oldErrorCount := compiler.errorCount
                        compiler.compileExpression(a)
                        if compiler.errorCount = oldErrorCount {
                            -- could not determine type
                            compiler.error(position, "no match for call to '\{methods[0].name}'")
                        }
                        return null
                    }
                    argTypes.add(preferred)
                }
                compiler.error(position, "no match for \{methods[0].name}(\{argTypes.join(", ")})" +
                        type.description())
                return null
            }
            when IR.Value.GENERIC_METHODS(target, methods, types) {
                def best := findBestMethod(compiler, position, target, methods, types, args, type)
                if best !== null {
                    if best[0].count > 1 {
                        compiler.reportAmbiguousMatch(position.asPosition, best[0], args, type)
                        return null
                    }
                    return compile(compiler, position, target, best[0][0], args, type)
                }
                -- no match
                def argTypes := Array<Type>()
                for a in args {
                    def preferred := compiler.preferredType(a)
                    if preferred == null {
                        -- force it to produce an error
                        def oldErrorCount := compiler.errorCount
                        compiler.compileExpression(a)
                        if compiler.errorCount = oldErrorCount {
                            -- could not determine type
                            compiler.error(position, "no match for call to '\{methods[0].name}'")
                        }
                        return null
                    }
                    argTypes.add(preferred)
                }
                compiler.error(position, "no match for \{methods[0].name}(\{argTypes.join(", ")})" +
                        type.description())
                return null
            }
            when IR.Value.PARAMETER, IR.Value.REF {
                return callMethodObject(compiler, position, m, args, type)
            }
            when IR.Value.TYPE(t, _) {
                def finalType:Type
                if t.isClassLiteral {
                    finalType := t.subtypes[1]
                }
                else {
                    finalType := t
                }
                def cl := compiler.getClass(finalType)
                if cl == null {
                    return null
                }
                if !cl.isSpecialization() & !compiler.checkGenericArguments(position.asPosition, cl,
                        t) {
                    return null
                }
                match cl.classKind {
                    when ClassDecl.Kind.CHOICE {
--                        compiler.error(position, "'\{cl.name}' is a choice and may not be " +
--                                "directly constructed")
--                        return null
                    }
                    when ClassDecl.Kind.INTERFACE {
                        compiler.error(position, "'\{cl.name}' is an interface and may not be " +
                                "directly constructed")
                        return null
                    }
                }
                if !compiler.resolve(cl) {
                    return null
                }
                def inits := compiler.getSymbolTable(cl)["init"]
                assert inits !== null, "no init for \{cl.name}"
                if compiler.isValue(cl) {
                    def call := compile(compiler, position, compiler.symbolRef(position, null,
                            inits), args, Compiler.TypeContext.UNSPECIFIED)
                    if call == null {
                        return null
                    }
                    return compiler.coerce(position, compiler.cast(position, call, finalType), type)
                }
                def construct := ir.add(IR.Statement.CONSTRUCT(position, cl))
                def constructRef := IR.Value.REF(construct, finalType)
                compiler.enclosingContexts.push(EnclosingContext.VALUE_SCOPE(constructRef))
                compile(compiler, position, compiler.symbolRef(position, constructRef, inits), args,
                        TypeContext.UNSPECIFIED)
                return compiler.coerce(position, constructRef, type)
            }
            otherwise {
                unreachable, "cannot call \{m}"
            }
        }
    }

    @class
    method handleErrors(compiler:Compiler, position:MethodPosition, v:IR.Value):IR.Value? {
        def tryScope := compiler.getTryScope()
        if tryScope == null {
            return v
        }
        def ir := compiler.ir
        def type := v.type()
        def errorType := compiler.ERROR_TYPE
        def nullableError := errorType.nullable()
        if type = nullableError {
            def test := ir.add(IR.Statement.BINARY(position, v, Binary.Operator.IDENTITY,
                    IR.Value.NULL(nullableError), compiler.BUILTIN_BIT_TYPE))
            def success := ir.newBlock("error? null")
            def failure := ir.newBlock("error? error")
            ir.add(IR.Statement.CONDITIONAL_BRANCH(position, IR.Value.REF(test,
                    compiler.BUILTIN_BIT_TYPE), success, failure))
            ir.setCurrentBlock(failure)
            match tryScope[1].storage {
                when Variable.Storage.LOCAL(slot) {
                    compiler.compileRef(v)
                    def nonnull := compiler.cast(position, v, errorType)
                    ir.add(IR.Statement.STORE(position, nonnull, IR.Value.LOCAL(slot, errorType)))
                }
                otherwise {
                    unreachable
                }
            }
            compiler.leaveTryScope()
            ir.add(IR.Statement.BRANCH(position, tryScope[0]))
            ir.setCurrentBlock(success)
            return null
        }
        else if type.typeKind = Type.Kind.GENERIC & type.subtypes[0].name = "frost.core.Maybe" {
            def cl := compiler.getClass(type)
            assert cl !== null
            def rawValue := Dot.compile(compiler, position, ASTNode.IR_WRAPPER(position.asPosition,
                    v), ClassDecl.TAG_NAME)
            assert rawValue !== null
            def test := ir.add(IR.Statement.BINARY(position, compiler.extractBuiltinInt(position,
                    rawValue), Binary.Operator.EQ, IR.Value.INT(0, compiler.BUILTIN_INT64_TYPE),
                    compiler.BUILTIN_BIT_TYPE))
            def success := ir.newBlock("maybe success")
            def failure := ir.newBlock("maybe error")
            ir.add(IR.Statement.CONDITIONAL_BRANCH(position, IR.Value.REF(test,
                    compiler.BUILTIN_BIT_TYPE), success, failure))
            ir.setCurrentBlock(failure)
            def errorPtr := ir.add(IR.Statement.GET_CHOICE_FIELD_POINTER(position, v,
                    cl.choiceCases[1], 0))
            def errorValue := ir.add(IR.Statement.LOAD(position, IR.Value.REF(errorPtr,
                    errorType)))
            def errorRef := IR.Value.REF(errorValue, errorType)
            compiler.compileRef(errorRef)
            match tryScope[1].storage {
                when Variable.Storage.LOCAL(slot) {
                    ir.add(IR.Statement.STORE(position, errorRef, IR.Value.LOCAL(slot, errorType)))
                }
                otherwise {
                    unreachable
                }
            }
            compiler.leaveTryScope()
            ir.add(IR.Statement.BRANCH(position, tryScope[0]))
            ir.setCurrentBlock(success)
            def successPtr := ir.add(IR.Statement.GET_CHOICE_FIELD_POINTER(position, v,
                    cl.choiceCases[0], 0))
            def successValue := ir.add(IR.Statement.LOAD(position, IR.Value.REF(successPtr,
                    compiler.ANY_TYPE)))
            def successCast := compiler.cast(position, IR.Value.REF(successValue,
                    compiler.ANY_TYPE), type.subtypes[1])
            return successCast
        }
        return v
    }

    @class
    function countReturns(s:ASTNode):Int {
        match s {
            when ASTNode.BLOCK(_, b) {
                return countReturns(b)
            }
            when ASTNode.DO(_, _, b, _) {
                return countReturns(b)
            }
            when ASTNode.IF(_, _, b1, b2) {
                var result := countReturns(b1)
                if b2 !== null {
                    result += countReturns(b2)
                }
                return result
            }
            when ASTNode.FOR(_, _, _, _, b) {
                return countReturns(b) 
            }
            when ASTNode.LOOP(_, _, b) {
                return countReturns(b)
            }
            when ASTNode.MATCH(_, _, whens, other) {
                def o:Int
                if other !== null {
                    o := countReturns(other)
                }
                else {
                    o := 0
                }
                return o + countReturns(whens)
            }
            when ASTNode.RETURN {
                return 1
            }
            when ASTNode.WHEN(_, _, b) {
                return countReturns(b)
            }
            when ASTNode.WHILE(_, _, _, b)  {
                return countReturns(b)
            }
            otherwise {
                return 0
            }
        }
    }

    @class
    function countReturns(b:ListView<ASTNode>):Int {
        var result := 0
        for s in b {
            result += countReturns(s)
        }
        return result
    }

    @class
    method inlineCall(compiler:Compiler, position:MethodPosition, m:MethodDecl,
            args:FixedArray<IR.Value>):IR.Value? {
        if compiler.settings.debug {
            compiler.ir.add(IR.Statement.COMMENT(position,
                    "begin inline call to \{m.declaration} from \{position.toString(compiler)}"))
        }
        def scope:Compiler.EnclosingContext
        def inlineReturn:Compiler.InlineReturn
        def inlineReturnSlot:Int := -1
        def mergeBlock := compiler.ir.newBlock("inline merge")
        {
            def context:AutoContext
            if m.returnType = compiler.VOID_TYPE | countReturns(m.body) <= 1 {
                inlineReturn := Compiler.InlineReturn(null)
                context := AutoContext(compiler, EnclosingContext.INLINE_CONTEXT(args,
                        compiler.ir.locals.count, inlineReturn, mergeBlock))
            }
            else {
                compiler.tempCount += 1
                inlineReturnSlot := compiler.ir.locals.count
                def returnVar := Variable(position.asPosition, Variable.Kind.DEF,
                        "$inlineReturn\{compiler.tempCount}", m.returnType,
                        Variable.Storage.LOCAL(inlineReturnSlot))
                compiler.symbolTable.add(returnVar)
                returnVar.owner := compiler.currentMethod[0]
                inlineReturn := Compiler.InlineReturn(returnVar)
                context := AutoContext(compiler, EnclosingContext.INLINE_CONTEXT(args,
                        compiler.ir.locals.count, inlineReturn, mergeBlock))
                if compiler.isRefCounted(returnVar.type) {
                    def setNull := IR.Statement.STORE(position,
                            IR.Value.NULL(returnVar.type.nullable()),
                            IR.Value.LOCAL(inlineReturnSlot, returnVar.type))
                    def id := IR.Statement.ID(compiler.ir.currentStatementId)
                    compiler.ir.blocks[0].statements.insertHead(setNull)
                    compiler.ir.blocks[0].ids.insertHead(id)
                    compiler.ir.statements[id] := setNull
                    compiler.ir.currentStatementId += 1
                }
                compiler.ir.locals.add(returnVar.type)
            }
            compiler.currentClass.push(m.owner)
            -- FIXME move all of this stuff into a MethodContext(?) class for easier save / restore
            def oldCaptures := compiler.captures
            compiler.captures := Stack<(MethodDecl, Map<String, Compiler.Capture>)>()
            def oldInAtPre := compiler.inAtPre
            compiler.inAtPre := false
            def oldAtPreBlock := compiler.atPreBlock
            compiler.atPreBlock := null
            def oldPostconditionEntryBlock := compiler.postconditionEntryBlock
            compiler.postconditionEntryBlock := null
            def oldPostconditionCurrentBlock := compiler.postconditionCurrentBlock
            compiler.postconditionCurrentBlock := null
            def oldWriteCode := compiler.writeCode
            compiler.writeCode := false
            def oldReturnVar := compiler.returnVar
            compiler.returnVar := null
            def oldInFieldCleanup := compiler.inFieldCleanup
            compiler.inFieldCleanup := false
            def scope := AutoScope(compiler, compiler.getSymbolTable(m.owner))
            compiler.compile(m)
            compiler.writeCode := oldWriteCode
            compiler.captures := oldCaptures
            compiler.atPreBlock := oldAtPreBlock
            compiler.postconditionCurrentBlock := oldPostconditionCurrentBlock
            compiler.postconditionEntryBlock := oldPostconditionEntryBlock
            compiler.inAtPre := oldInAtPre
            compiler.returnVar := oldReturnVar
            compiler.inFieldCleanup := oldInFieldCleanup
        }
        compiler.currentClass.pop()
        if mergeBlock !== null {
            if !compiler.ir.currentBlockFinished {
                compiler.ir.add(IR.Statement.BRANCH(position, mergeBlock))            
            }
            compiler.ir.setCurrentBlock(mergeBlock)
        }
        if m.returnType = compiler.VOID_TYPE {
            return null
        }
        if inlineReturn.value !== null {
            return inlineReturn.value
        }
        def load := compiler.ir.add(IR.Statement.LOAD(position,
                IR.Value.LOCAL(inlineReturnSlot, m.returnType)))
        return IR.Value.REF(load, m.returnType)
    }

    @class
    function unwrapCast(compiler:Compiler, v:IR.Value):Type {
        match v {
            when IR.Value.REF(id, _) {
                if id.value >= 0 {
                    def s := compiler.ir.statements[id]
                    match s {
                        when IR.Statement.CAST(_, v, _, _) {
                            return v.type()
                        }
                    }
                }
            }
        }
        return v.type()
    }

    @class
    method findStaticImpl(compiler:Compiler, cl:ClassDecl, m:MethodRef):MethodRef? {
        def methods := cl.methods
        outer: for m2 in methods {
            if m2.name != m.value.name {
                continue
            }
            var testM:MethodDecl? := m2
            loop {
                if testM == m.value {
                    return MethodRef(compiler, m2.owner.type, m2)
                }
                testM := compiler.getOverriddenMethod(testM)
                if testM == null {
                    break
                }
            }
        }
        for raw in cl.rawInterfaces {
            def intf := compiler.getClass(raw)
            if intf !== null {
                def result := findStaticImpl(compiler, intf, m)
                if result !== null {
                    return result
                }
            }
        }
        if cl.rawSuper !== null {
            def s := compiler.getClass(cl.rawSuper)
            if s !== null {
                def result := findStaticImpl(compiler, s, m)
                if result !== null {
                    return result
                }
            }
        }
        return null
    }

    -- FIXME dear god this method this method has grown out of control and needs to be broken up
    @class
    @post((rawM.returnType = compiler.VOID_TYPE & @return == null) | @return !== null |
            compiler.errorCount > 0 | !compiler.reportErrors)
    method compile(compiler:Compiler, position:MethodPosition, rawTarget:IR.Value?, rawM:MethodRef,
            args:ListView<ASTNode>, type:TypeContext):IR.Value? {
        assert position.methodIndex >= 0, "call to \{rawM.value.declaration} with invalid " +
                "position: \{position}, \{position.methodIndex}"
        def ir := compiler.ir
        var target := rawTarget
        -- FIXME var param
        var m := rawM
        if m.value.methodKind = MethodDecl.Kind.INIT {
            var validTarget := false
            var selfOrSuper := false
            if target !== null {
                match target {
                    when IR.Value.PARAMETER(index, _) {
                        selfOrSuper := index = 0 & !compiler.isClassContext()
                        validTarget := true
                    }
                    when IR.Value.REF(id, _) {
                        if id = ir.currentBlock.ids.last {
                            def last := ir.currentBlock.statements.last
                            match last {
                                when IR.Statement.CONSTRUCT {
                                    validTarget := true
                                }
                            }
                        }
                    }
                    when IR.Value.SUPER {
                        selfOrSuper := true
                        validTarget := true
                    }
                }
            }
            else {
                if compiler.isValue(m.value.owner) {
                    selfOrSuper := false
                    validTarget := true
                }
                else {
                    selfOrSuper := !compiler.isClassContext()
                    validTarget := selfOrSuper
                }
            }
            if selfOrSuper & compiler.currentMethod[0].methodKind != MethodDecl.Kind.INIT {
                compiler.error(position, "cannot directly call 'init' outside of an init method")
                return null
            }
            if !validTarget {
                compiler.error(position, "'init' may only be called on 'self' or 'super'")
                return null
            }
        }
        if args.count != m.parameterCount {
            compiler.error(position, "\{m.value.declaration} expects \{m.parameterCount} " +
                    "argument\{m.parameterCount = 1:|s}, but found \{args.count}")
            return null
        }
        if target !== null & m.value.annotations.isClass {
            match target {
                when IR.Value.TYPE {
                    -- do nothing
                }
                otherwise {
                    compiler.error(position, "cannot call class \{m.value.declaration} on an " +
                            "instance")
                }
            }
        }
        def inferred := performTypeInference(compiler, m, args, type)
        if inferred == null {
            return null
        }
        m := inferred
        var intrinsic := compileIntrinsic(compiler, position, target, m, args)
        if intrinsic[0] {
            if intrinsic[1] !== null {
                return compiler.coerce(position, intrinsic[1], type)
            }
            return null
        }
        def isSuper:Bit
        if target !== null {
            match target {
                when IR.Value.SUPER {
                    isSuper := true
                }
                otherwise {
                    isSuper := false
                }
            }
        }
        else {
            isSuper := false
        }
        -- actualType always has a "self", even for a @class method. This will probably be tightened
        -- up in the future, but it simplifies the logic a bit here.
        def actualType:Type
        var selfType := m.value.owner.type
        if selfType.isPointer & !m.value.annotations.isClass {
            if target !== null {
                selfType := target.type()
            }
            else {
                selfType := m.value.owner.typeWithParameters()
            }
        }
        if m.value.isVirtual {
            actualType := compiler.inheritedTypeWithSelf(m.value, selfType)
        }
        else {
            actualType := compiler.declaredTypeWithSelf(m.value, selfType, false)
        }
        assert actualType.isMethod
        def effectiveType := m.effectiveType
        assert effectiveType.isMethod
        def finalArgs := Array<IR.Value>(args.count)
        var finalTarget:IR.Value?
        if target !== null {
            match target {
                when IR.Value.TYPE {
                    -- do nothing
                }
                otherwise {
                    if m.value.owner.name = Compiler.NEW_POINTER_NAME {
                        finalTarget := compiler.cast(position, target,
                                actualType.parameterType(0))
                    }
                    else if isSuper {
                        finalTarget := compiler.cast(position,
                                compiler.compileSelf(position, false),
                                m.value.owner.typeWithParameters())
                    }
                    else {
                        finalTarget := compiler.cast(position, target,
                                m.value.owner.typeWithParameters())
                    }
                    if finalTarget == null {
                        return null
                    }
                    finalArgs.add(finalTarget)
                }
            }
        }
        else if !m.value.annotations.isClass & !compiler.isValueInit(m.value) {
            if compiler.isClassContext() {
                compiler.error(position,
                        "cannot call instance \{m.value.declaration} from a @class context")
                return null
            }
            finalTarget := compiler.compileSelf(position, false)
            if !m.value.owner.type.isPointer {
                finalTarget := compiler.cast(position, finalTarget,
                        m.value.owner.typeWithParameters())
            }
            if finalTarget == null {
                return null
            }
            finalArgs.add(finalTarget)
        }
        else {
            finalTarget := null
        }
        var dynamic := false
        if !isSuper & m.value.isVirtual {
            if target !== null {
                var type1 := target.type()
                def cl1 := compiler.getClass(type1)
                if cl1 == null {
                    return null
                }
                dynamic := !cl1.annotations.isFinal
                if dynamic {
                    def type2 := unwrapCast(compiler, target)
                    if type1 != type2 {
                        def cl2 := compiler.getClass(type2)
                        if cl2 == null {
                            return null
                        }
                        dynamic := !cl2.annotations.isFinal
                        if !dynamic {
                            m := findStaticImpl(compiler, cl2, m)
                            finalTarget := compiler.cast(position, target,
                                    m.value.owner.typeWithParameters(), true)
                            finalArgs[0] := finalTarget
                            actualType := compiler.declaredTypeWithSelf(m.value, selfType, false)
                        }
                    }
                }
            }
            else {
                dynamic := true
            }
        }
        def start:Int -- skip over self if it's implicit
        if !m.value.annotations.isClass & target !== null & target.type().isClassLiteral {
            start := 0
        }
        else {
            start := 1
        }
        for i in 0 .. args.count {
            var a := compiler.compileExpression(args[i],
                    TypeContext.TYPE(effectiveType.parameterType(i), false))
            if a == null {
                return null
            }
            if a.type() != actualType.parameterType(i + start) {
                a := compiler.cast(position, a, actualType.parameterType(i + start))
            }
            if a == null {
                return null
            }
            finalArgs.add(a)
        }
        if m.value.annotations.isPointerSize {
            def targetType := target.type()
            if target !== null & targetType.isClassLiteral &
                    targetType.subtypes[1].name.startsWith("frost.unsafe.Pointer<") &
                    target.type().subtypes[1].subtypes[1].typeKind !=
                            Type.Kind.GENERIC_METHOD_PARAMETER {
                finalArgs.add(IR.Value.SIZE_OF(target.type().subtypes[1].subtypes[1]))
            }
            else if target !== null & targetType.isPointer {
                finalArgs.add(IR.Value.SIZE_OF(target.type().subtypes[1]))
            }
            else if compiler.currentMethod[0].annotations.isPointerSize {
                def pointerSize := Identifier.compile(compiler, position, "pointerSize")
                assert pointerSize !== null
                finalArgs.add(pointerSize)
            }
            else {
                compiler.error(position, "internal error: unable to determine pointer size when " +
                        "calling a @pointerSize method")
                return null
            }
        }
        var result:IR.Value?
        if dynamic {
            def mref:IR.Statement.ID
            if m.value.owner.classKind = ClassDecl.Kind.INTERFACE {
                mref := ir.add(IR.Statement.GET_INTERFACE_METHOD(position, finalTarget,
                        m.value.owner,
                        compiler.getVTableIndex(m.value) -
                            compiler.getVTable(compiler.getClass(compiler.OBJECT_TYPE)).count,
                        actualType))
            }
            else {
                mref := ir.add(IR.Statement.GET_VIRTUAL_METHOD(position, finalTarget,
                        compiler.getVTableIndex(m.value), actualType))
            }
            result := IR.Value.REF(ir.add(IR.Statement.DYNAMIC_CALL(position, IR.Value.REF(mref,
                    actualType), FixedArray<IR.Value>.from(finalArgs))), actualType.returnType)
        }
        else {
            if compiler.settings.optimizationLevel > 1 & m.value.annotations.isInline &
                    compiler.currentMethod.count < 3 {
                result := inlineCall(compiler, position, m.value,
                        FixedArray<IR.Value>.from(finalArgs))
                if result == null {
                    return null
                }
                if compiler.ir.currentBlockFinished {
                    compiler.ir.setCurrentBlock(compiler.ir.newBlock("unreachable"))
                    compiler.ir.currentBlock.forceReachable := true
                }
            }
            else {
                result := IR.Value.REF(ir.add(IR.Statement.STATIC_CALL(position, m.value,
                        FixedArray<IR.Value>.from(finalArgs))), actualType.returnType)
            }
        }
        if m.value.annotations.isNoReturn {
            Assert.compileFail(compiler, position, ASTNode.STRING(position.asPosition,
                        "returned from @noReturn method"))
        }
        if m.value.returnType != compiler.VOID_TYPE {
            var resultCast:IR.Value? := result
            if compiler.isRefCounted(actualType.returnType) {
                compiler.enclosingContexts.push(EnclosingContext.VALUE_SCOPE(resultCast))
            }
            resultCast := handleErrors(compiler, position, resultCast)
            if resultCast == null {
                return null
            }
            if m.value.methodKind != MethodDecl.Kind.INIT &
                    effectiveType.returnType != actualType.returnType {
                resultCast := compiler.cast(position, resultCast, effectiveType.returnType)
                if resultCast == null {
                    return null
                }
            }
            return compiler.coerce(position, resultCast, type)
        }
        if type != TypeContext.UNSPECIFIED {
            compiler.error(position, "\{m.value.declaration} does not return a value")
        }
        return null
    }

    @class
    method compile(compiler:Compiler, position:MethodPosition, target:IR.Value, m:String,
            args:ListView<ASTNode>, type:TypeContext):IR.Value? {
        def cl := compiler.getClass(target.type())
        if cl == null {
            return null
        }
        def s := compiler.getSymbolTable(cl)[m]
        if s == null {
            compiler.error(position, "class '\{cl.name}' does not have a member named '\{m}'")
            return null
        }
        def ref := compiler.symbolRef(position, target, s)
        return compile(compiler, position, ref, args, type)
    }

    -- isStatement is used to detect when we call a method that returns Error? without examining its
    -- return value. If isStatement, the call is top-level and therefore the return value is being
    -- discarded.
    @class
    method compile(compiler:Compiler, position:MethodPosition, m:ASTNode, args:FixedArray<ASTNode>,
            isStatement:Bit, type:TypeContext):IR.Value? {
        match m {
            when ASTNode.GENERIC_TYPE(_, name, types) {
                var resolved := compiler.tryResolveType(m)
                if resolved !== null {
                    assert !resolved.isClassLiteral
                    return compile(compiler, position, compiler.literalType(resolved), args, type)
                }
                resolved := compiler.tryResolveType(m, false)
                if resolved !== null {
                    -- It's a type, but the parameters are invalid. Force an error and bail.
                    compiler.resolve(compiler.scanner.convertType(m))
                    return null
                }
                -- not a type, might be a function call with explicit generics
                def components := name.split(".")
                var target:ASTNode
                if components.count = 1 {
                    target := ASTNode.IDENTIFIER_GENERICS(position.asPosition, name, types)
                }
                else {
                    target := ASTNode.IDENTIFIER(position.asPosition, components[0])
                    for i in 1 .. components.count - 1 {
                        target := ASTNode.DOT(position.asPosition, target, components[i])
                    }
                    target := ASTNode.DOT_GENERICS(position.asPosition, target,
                            components[components.count - 1], types)
                }
                return compile(compiler, position, target, args, isStatement, type)
            }
        }
        def cc := compiler.getChoiceCase(m)
        if cc !== null {
            return compiler.compileChoiceCaseReference(position, cc[0], cc[1], args, type)
        }
        match m {
            when ASTNode.DOT(basePos, base, name) {
                match base {
                    when ASTNode.SUPER {
                        def position := MethodPosition(basePos, compiler.currentMethodIndex)
                        var s := compiler.symbolTable[Compiler.CAPTURED_SELF_NAME]
                        if s == null {
                            s := compiler.symbolTable[Compiler.SELF_NAME]
                        }
                        if s == null {
                            return null
                        }
                        def result := Array<Type>()
                        def selfType:Type
                        match s.kind {
                            when Symbol.Kind.VARIABLE {
                                selfType := s->Variable.type
                            }
                            when Symbol.Kind.FIELD {
                                selfType := s->FieldDecl.type
                            }
                            otherwise {
                                unreachable
                            }
                        }
                        def cl := compiler.getClass(selfType)
                        if cl == null {
                            return null
                        }
                        def supertype := compiler.remapType(selfType, cl.rawSuper)
                        return compile(compiler, position, IR.Value.SUPER(supertype), name, args,
                                type)
                    }
                }
            }
        }
        def compiledM := compiler.compileMethodExpression(m, TypeContext.NON_VOID)
        if compiledM == null {
            return null
        }
        def result := compile(compiler, position, compiledM, args, type)
        if isStatement & result !== null {
            def resultType := result.type()
            if (resultType = compiler.ERROR_TYPE.nullable() |
                    (resultType.typeKind = Type.Kind.GENERIC &
                        resultType.subtypes[0].name = "frost.core.Maybe")) {
                compiler.error(position, "return value of type " +
                        "'\{resultType.name}' is unused and is outside of a 'try' block")
            }
        }
        return result
    }
}