package org.frostlang.frostc.expression

uses org.frostlang.frostc.ASTNode
uses org.frostlang.frostc.Compiler
uses org.frostlang.frostc.Compiler.AutoUnrefs
uses org.frostlang.frostc.Compiler.TypeContext
uses org.frostlang.frostc.IR
uses org.frostlang.frostc.Position
uses org.frostlang.frostc.Type

class And {
    @class
    method compile(compiler:Compiler, position:Position, left:ASTNode, right:ASTNode,
            type:TypeContext):IR.Value? {
        def ir := compiler.ir
        -- FIXME should add phis so we can avoid using a local
        def result := IR.Value.LOCAL(ir.locals.count, compiler.BIT_TYPE)
        ir.locals.add(compiler.BIT_TYPE)
        def compiledLeft:IR.Value?
        compiledLeft := compiler.compileExpression(left, TypeContext.TYPE(compiler.BIT_TYPE, false))
        if compiledLeft == null {
            return null
        }
        def ifTrue := ir.newBlock("and true")
        def ifFalse := ir.newBlock("and false")
        def merge := ir.newBlock("and merge")
        ir.add(IR.Statement.CONDITIONAL_BRANCH(position,
                compiler.extractBuiltinBit(position, compiledLeft), ifTrue, ifFalse))
        ir.setCurrentBlock(ifTrue)
        def compiledRight:IR.Value?
        {
            def unrefs := AutoUnrefs(compiler)
            compiledRight := compiler.compileExpression(right, TypeContext.TYPE(compiler.BIT_TYPE,
                    false))
            if compiledRight == null {
                return null
            }
        }
        ir.add(IR.Statement.STORE(position, compiledRight, result))
        ir.add(IR.Statement.BRANCH(position, merge))
        ir.setCurrentBlock(ifFalse)
        ir.add(IR.Statement.STORE(position, compiledLeft, result))
        ir.add(IR.Statement.BRANCH(position, merge))
        ir.setCurrentBlock(merge)
        def load := ir.add(IR.Statement.LOAD(position, result))
        return IR.Value.REF(load, compiler.BIT_TYPE)
    }

    @class
    method compileConditionalBranch(compiler:Compiler, position:Position, left:ASTNode,
            right:ASTNode, ifTrue:IR.Block.ID, ifFalse:IR.Block.ID) {
        def leftTrue := compiler.ir.newBlock("and left true")
        compiler.compileConditionalBranch(left, leftTrue, ifFalse)
        compiler.ir.setCurrentBlock(leftTrue)
        compiler.compileConditionalBranch(right, ifTrue, ifFalse)
    }
}