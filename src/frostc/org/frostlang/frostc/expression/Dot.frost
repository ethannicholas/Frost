package org.frostlang.frostc.expression

uses org.frostlang.frostc.ASTNode
uses org.frostlang.frostc.Compiler
uses org.frostlang.frostc.Compiler.TypeContext
uses org.frostlang.frostc.IR
uses org.frostlang.frostc.MethodPosition
uses org.frostlang.frostc.Symbol

class Dot {
    @class
    method compile(compiler:Compiler, position:MethodPosition, target:IR.Value,
            name:String):IR.Value? {
        def cl := compiler.getClass(target.type())
        if cl == null {
            return null
        }
        def symbol := compiler.getSymbolTable(cl)[name]
        if symbol == null | symbol.kind = Symbol.Kind.ALIAS {
            compiler.error(position,
                    "class '\{cl.name}' does not have a member named '\{name}'")
            return null
        }
        return compiler.symbolRef(position, target, symbol)
    }

    @class
    method compile(compiler:Compiler, position:MethodPosition, base:ASTNode,
            name:String):IR.Value? {
        match base {
            when ASTNode.GENERIC_TYPE {
                def resolved := compiler.resolve(compiler.scanner.convertType(base))
                if resolved == null {
                    return null
                }
                return compile(compiler, position, compiler.literalType(resolved), name)
            }
        }
        def compiledBase := compiler.compileExpression(base)
        if compiledBase == null {
            return null
        }
        return compile(compiler, position, compiledBase, name)
    }
}