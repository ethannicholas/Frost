package org.frostlang.frostc

uses org.frostlang.frostc.Compiler.Expression
uses org.frostlang.frostc.expression.Binary
uses org.frostlang.frostc.parser.Token

class LLVMBackend : Backend {
    choice Intrinsic {
        REF_THREAD_UNSAFE
        REF_THREAD_SAFE_NONCONSTANT
        REF_THREAD_SAFE
        UNREF_THREAD_UNSAFE
        UNREF_THREAD_SAFE_NONCONSTANT
        UNREF_THREAD_SAFE
        UNREF_THREAD_UNSAFE_NOCLEANUP
        UNREF_THREAD_SAFE_NONCONSTANT_NOCLEANUP
        UNREF_THREAD_SAFE_NOCLEANUP
    }

    constant NO_REFCNT := -999

    constant INT_TYPE  := "i64"

    def physicalOut:OutputStream

    var out:OutputStream

    @weak
    var compiler:Compiler?

    var cg:CodeGenerator?

    var settings:Compiler.Settings?

    def globals := MemoryOutputStream()

    def signatures := MemoryOutputStream()

    def methods := MemoryOutputStream()

    def metadata := MemoryOutputStream()

    def writtenSignatures := HashSet<String>()

    var varCount := 0

    var blockCount := 0

    def externalGlobals := IdentitySet<Code.Global>()

    def debugTypes := IdentityMap<Type, String>()

    var metadataCount := 0

    var wroteCompileUnit := false

    var fileMetadata := Array<String?>()

    var methodMetadata := Array<String?>()

    var lexicalBlockMetadata := Array<String?>()

    def debugPositions := HashMap<MethodPosition, String>()

    def stringLiterals := HashMap<String, String>()

    property boundsChecking:Bit
    function get_boundsChecking():Bit {
        return settings.safetyLevel >= 3
    }

    init(triple:String, out:OutputStream) {
        self.physicalOut := out

        try {
            out.printLine("target datalayout = \"e-m:o-i64:64-f80:128-n8:16:32:64-S128\"")
            out.printLine("target triple = \"\{triple}\"")
            out.printLine("declare \{INT_TYPE} @frostObjectAlloc(\{INT_TYPE}, \{INT_TYPE})")
            out.printLine("declare void @frostOverflow(i8*, i32)")
        }
        fail(error) {
            Console.printLine(error)
            System.exit(1)
        }
    }

    @override
    method setCompiler(compiler:Compiler) {
        self.compiler := compiler
        cg := compiler.cg
        settings := compiler.settings
    }

    function name(id:Code.Statement.ID):String {
        return "%s\{id.value}"
    }

    method nextVar():String {
        varCount += 1
        return "%tmp\{varCount}"
    }

    method nextBlock():String {
        blockCount += 1
        return "internalBlock\{blockCount}"
    }

    method nextMetadata():String {
        metadataCount += 1
        return "!\{metadataCount}"
    }

    method getFileMetadata(index:Int):String {
        try {
            while fileMetadata.count <= index {
                fileMetadata.add(null)
            }
            var meta := fileMetadata[index]
            if meta == null {
                meta := nextMetadata()
                fileMetadata[index] := meta
                metadata.printLine("\{meta} = distinct !DIFile(" +
                        "filename: \"\{compiler.files[index]}\", directory: " +
                        "\"\{System.workingDirectory()}\")")
                if !wroteCompileUnit {
                    metadata.printLine("!0 = distinct !DICompileUnit(language:DW_LANG_C89, " +
                            "producer:\"frostc\", file: \{meta}, isOptimized: " +
                            "false, runtimeVersion: 0, emissionKind: FullDebug)")
                    metadata.printLine("!llvm.dbg.cu = !{!0}")
                    def dwarfVersion := nextMetadata()
                    metadata.printLine("\{dwarfVersion} = !{i32 2, !\"Dwarf Version\", i32 4}")
                    def debugVersion := nextMetadata()
                    metadata.printLine("\{debugVersion} = !{i32 2, !\"Debug Info Version\", i32 3}")
                    metadata.printLine("!llvm.module.flags = !{\{dwarfVersion}, \{debugVersion}}")
                    wroteCompileUnit := true
                }
            }
            return meta
        }
        fail(error) {
            unreachable
        }
    }

    method getMethodMetadata(index:Int):String {
        try {
            while methodMetadata.count <= index {
                methodMetadata.add(null)
            }
            var meta := methodMetadata[index]
            if meta == null {
                def m := compiler.methods[index]
                def file := getFileMetadata(m.position.file)
                meta := nextMetadata()
                methodMetadata[index] := meta
                def t:Type
                if compiler!.hasSelfParam(m) {
                    t := compiler!.inheritedTypeWithSelf(m)
                }
                else {
                    t := compiler!.inheritedType(m)
                }
                def type := getDebugType(t)
                metadata.printLine("\{meta} = distinct !DISubprogram(name: " +
                        "\"\{m.owner.name}.\{m.name}\", file: \{file}, " +
                        "type: \{getDebugType(t)}, unit: !0, scopeLine: \{m.position.line})")
            }
            return meta
        }
        fail(error) {
            unreachable
        }
    }

    method getLexicalBlockMetadata(index:Int):String {
        try {
            while lexicalBlockMetadata.count <= index {
                lexicalBlockMetadata.add(null)
            }
            var meta := lexicalBlockMetadata[index]
            if meta == null {
                def m := compiler.currentMethod[0]
                def file := getFileMetadata(compiler.methods[index].position.file)
                def methodData := getMethodMetadata(compiler.currentMethodIndex)
                meta := nextMetadata()
                metadata.printLine("\{meta} = !DILexicalBlock(scope: \{methodData}, file: " +
                        "\{file}, line: \{m.position.line}, column: \{m.position.column})")
                lexicalBlockMetadata[index] := meta
            }
            return meta
        }
        fail(error) {
            unreachable
        }
    }

    method getDebugType(t:Type):String {
        try {
            var result := debugTypes[t]
            if result == null {
                match t.typeKind {
                    when Type.Kind.METHOD, Type.Kind.FUNCTION, Type.Kind.IMMUTABLE_METHOD,
                            Type.Kind.IMMUTABLE_FUNCTION {
                        result := nextMetadata()
                        def types := Array<String>()
                        types.add(getDebugType(t.returnType))
                        for p in t.parameterTypes {
                            types.add(getDebugType(p))
                        }
                        metadata.print("\{result} = !DISubroutineType(types: !{")
                        metadata.print(types.join(", "))
                        metadata.printLine("})")
                    }
                    when Type.Kind.BUILTIN_INT {
                        result := nextMetadata()
                        metadata.printLine("\{result} = !DIBasicType(name: \"\{t.name}\", size: " +
                                "\{t.size}, align: \{t.size}, encoding: DW_ATE_signed)")
                    }
                    when Type.Kind.BUILTIN_UINT {
                        result := nextMetadata()
                        metadata.printLine("\{result} = !DIBasicType(name: \"\{t.name}\", size: " +
                                "\{t.size}, align: \{t.size}, encoding: DW_ATE_unsigned)")
                    }
                    when Type.Kind.BUILTIN_FLOAT {
                        result := nextMetadata()
                        metadata.printLine("\{result} = !DIBasicType(name: \"\{t.name}\", size: " +
                                "\{t.size}, align: \{t.size}, encoding: DW_ATE_float)")
                    }
                    when Type.Kind.BUILTIN_BIT {
                        result := nextMetadata()
                        metadata.printLine("\{result} = !DIBasicType(name: \"\{t.name}\", size: " +
                                "1, align: 1, encoding: DW_ATE_boolean)")
                    }
                    when Type.Kind.CLASS, Type.Kind.NULLABLE {
                        -- FIXME fix this to actually contain struct info, handle values
                        result := nextMetadata()
                        metadata.printLine("\{result} = !DIDerivedType(tag: DW_TAG_pointer_type, " +
                                "baseType: null, size: \{Code.PrimitiveType.INT.size(settings)}, " +
                                "align: \{Code.PrimitiveType.INT.alignment(settings)})")
                    }
                    when Type.Kind.VOID {
                        result := "null"
                    }
                    otherwise {
                        -- FIXME handle everything else
                        result := nextMetadata()
                        metadata.printLine("\{result} = !DIDerivedType(tag: DW_TAG_pointer_type, " +
                                "baseType: null, size: \{Code.PrimitiveType.INT.size(settings)}, " +
                                "align: \{Code.PrimitiveType.INT.alignment(settings)})")
                    }
                }
                debugTypes[t] := result
            }
            return result
        }
        fail(error) {
            unreachable, error.toString
        }
    }

    method debugInfo(position:MethodPosition):String {
        try {
            if !compiler!.settings.debug {
                return ""
            }
            if position.methodIndex != -1 & compiler.currentMethod.count > 0 {
                var result := debugPositions[position]
                if result == null {
                    result := nextMetadata()
                    def scope:String
                    if position.methodIndex = compiler.currentMethodIndex {
                        scope := getMethodMetadata(position.methodIndex)
                    }
                    else {
                        scope := getLexicalBlockMetadata(position.methodIndex)
                    }
                    metadata.printLine("\{result} = !DILocation(line: \{position.line}, column: " +
                            "\{position.column}, scope: \{scope})")
                    result := ", !dbg \{result}"
                    debugPositions[position] := result
                }
                return result
            }
            return ""
        }
        fail(error) {
            unreachable
        }
    }

    method llvmType(t:Code.PrimitiveType):String {
        match t {
            when Code.PrimitiveType.INT8 {
                 return "i8"
            }
            when Code.PrimitiveType.INT16 {
                 return "i16"
            }
            when Code.PrimitiveType.INT32 {
                 return "i32"
            }
            when Code.PrimitiveType.INT64 {
                 return "i64"
            }
            when Code.PrimitiveType.INT {
                 return INT_TYPE
            }
            when Code.PrimitiveType.BIT {
                return "i1"
            }
            when Code.PrimitiveType.FLOAT32 {
                return "float"
            }
            when Code.PrimitiveType.FLOAT64 {
                return "double"
            }
            when Code.PrimitiveType.ARRAY(count, type) {
                return "[\{count} x \{llvmType(type)}]"
            }
            when Code.PrimitiveType.STRUCT(name, fields) {
                def result := MutableString("{ ")
                var separator := ""
                for f in fields {
                    result.append(separator)
                    result.append(llvmType(f.type))
                    separator := ", "
                }
                result.append(" }")
                return result.finish()
            }
            otherwise {
                unreachable, "unsupported type \{t}"
            }
        }
    }

    method llvmType(s:Code.Signature):String {
        def result := MutableString()
        if s.returnType !== null {
            result.append(llvmType(s.returnType))
        }
        else {
            result.append("void")
        }
        result.append("(")
        var separator := ""
        for p in s.parameters {
            result.append("\{separator}\{llvmType(p.type)}")
            separator := ", "
        }
        result.append(")")
        return result.finish()
    }

    method getReference(v:Code.Value):String {
        match v {
            when Code.Value.ARRAY(_, elements) {
                return "[" + elements.map(getTypedReference).join(", ") + "]"
            }
            when Code.Value.BIT(b) {
                return b.toString
            }
            when Code.Value.CHARS(s) {
                def result := MutableString('c"')
                for c in s.utf8 {
                    if c.asUInt8 >= 32 & c.asUInt8 <= 127 & c != '"' & c != "\\" {
                        result.append(c)
                    }
                    else {
                        result.append("\\\{c.asUInt8,0>2:x}")
                    }
                }
                result.append('"')
                return result.finish()
            }
            when Code.Value.CHOICE_FIELD_OFFSET(cc, index) {
                return (cg.struct(cc.owner).elementOffset(settings!,
                            CodeGenerator.CHOICE_DATA_INDEX) +
                        Code.PrimitiveType.STRUCT(cc.toString, FixedArray<Code.Slot>(
                            cc.fields.map(f => Code.Slot("",
                                self.cg.primitiveType(f))))).elementOffset(settings!,
                                    index)).toString
            }
            when Code.Value.FIELD_OFFSET(type, index) {
                return type.elementOffset(settings!, index).toString
            }
            when Code.Value.GLOBAL_POINTER(index) {
                return "ptrtoint(\{llvmType(cg.globals[index].type)}* @" + cg.globals[index].name +
                        " to \{INT_TYPE})"
            }
            when Code.Value.INT(i, _) {
                return i.toString
            }
            when Code.Value.ITABLE_OFFSET(index) {
                return ((2 + index) * settings.intSize).toString
            }
            when Code.Value.METHOD_POINTER(signature) {
                return "ptrtoint(\{llvmType(signature)}* @\{signature.name} to \{INT_TYPE})"
            }
            when Code.Value.PARAMETER(idx, _) {
                return "%param\{idx}"
            }
            when Code.Value.REAL(r64, type) {
                match type {
                    when Code.PrimitiveType.FLOAT32 {
                        -- LLVM has a bizarre representation of float. You still use a double, but
                        -- must ensure that said double is exactly representable as a float. We
                        -- convert through Real32 to ensure this.
                        def r32 := r64.asReal32.asReal64
                        return "0x\{Frost.floatToIntBits(r32):x}"
                    }
                }
                return "0x\{Frost.floatToIntBits(r64):x}"
            }
            when Code.Value.REF(r) {
                return getReference(r.value)
            }
            when Code.Value.SIZE_OF(t) {
                return t.size(settings).toString
            }
            when Code.Value.STATEMENT(id, _) {
                return name(id)
            }
            when Code.Value.STRUCT(_, args) {
                return "{ " + args.map(getTypedReference).join(", ") + " }"
            }
            when Code.Value.UNDEFINED(_) {
                return "undef"
            }
            when Code.Value.VTABLE_OFFSET(cc, index) {
                def ccType:Code.PrimitiveType
                match cc {
                    when Code.Value.GLOBAL_POINTER(idx) {
                        ccType := cg.globals[idx].type
                    }
                    otherwise {
                        unreachable
                    }
                }
                return (ccType.elementOffset(settings!, CodeGenerator.VTABLE_INDEX) +
                        index * settings.intSize).toString
            }
            otherwise {
                unreachable, "unsupported value \{v}"
            }
        }
    }

    method getTypedReference(v:Code.Value):String {
        return llvmType(v.type) + " " + getReference(v)
    }

    function getIntrinsic(s:Code.Signature):Intrinsic? {
        match s.name {
            when "frost$core$Frost$refThreadUnsafe$frost$core$Object$Q" {
                return Intrinsic.REF_THREAD_UNSAFE
            }
            when "frost$core$Frost$refThreadSafeNonConstant$frost$core$Object$Q" {
                return Intrinsic.REF_THREAD_SAFE_NONCONSTANT
            }
            when "frost$core$Frost$refThreadSafe$frost$core$Object$Q" {
                return Intrinsic.REF_THREAD_SAFE
            }
            when "frost$core$Frost$unrefThreadUnsafe$frost$core$Object$Q" {
                return Intrinsic.UNREF_THREAD_UNSAFE
            }
            when "frost$core$Frost$unrefThreadSafeNonConstant$frost$core$Object$Q" {
                return Intrinsic.UNREF_THREAD_SAFE_NONCONSTANT
            }
            when "frost$core$Frost$unrefThreadSafe$frost$core$Object$Q" {
                return Intrinsic.UNREF_THREAD_SAFE
            }
            when "frost$core$Frost$unrefThreadUnsafeNoCleanup$frost$core$Object$Q" {
                return Intrinsic.UNREF_THREAD_UNSAFE_NOCLEANUP
            }
            when "frost$core$Frost$unrefThreadSafeNonConstantNoCleanup$frost$core$Object$Q" {
                return Intrinsic.UNREF_THREAD_SAFE_NONCONSTANT_NOCLEANUP
            }
            when "frost$core$Frost$unrefThreadSafeNoCleanup$frost$core$Object$Q" {
                return Intrinsic.UNREF_THREAD_SAFE_NOCLEANUP
            }
            otherwise {
                return null
            }
        }
    }

    @override
    method writeSignature(s:Code.Signature) {
        try {
            if writtenSignatures.contains(s.name) {
                return
            }
            writtenSignatures.add(s.name)
            def intrinsic := getIntrinsic(s)
            if intrinsic !== null {
                writeIntrinsicSignature(intrinsic)
                return
            }
            signatures.print("declare ")
            if s.returnType !== null {
                signatures.print(llvmType(s.returnType))
            }
            else {
                signatures.print("void")
            }
            signatures.print(" @\{s.name}(")
            var separator := ""
            for p in s.parameters {
                signatures.print("\{separator}\{llvmType(p.type)}")
                separator := ", "
            }
            signatures.printLine(")")
        }
        fail(error) {
            unreachable, error.toString
        }
    }

    method writeCreateStruct(position:MethodPosition, id:Code.Statement.ID, type:Code.PrimitiveType,
            args:FixedArray<Code.Value>) {
        try {
            assert args.count > 0
            def type := llvmType(type)
            var current := "undef"
            for i in 0 .. args.count {
                def value := getTypedReference(args[i])
                def next:String
                if i = args.count - 1 {
                    next := name(id)
                }
                else {
                    next := nextVar()
                }
                out.printLine("\{next} = insertvalue \{type} \{current}, \{value}, \{i}")
                current := next
            }
        }
        fail(error) {
            unreachable, error.toString
        }
    }

    method writeConvert(position:MethodPosition, id:Code.Statement.ID, value:Code.Value,
            target:Code.PrimitiveType, signed:Bit) {
        try {
            def op:String
            def size1 := value.type.size(settings!)
            def size2 := target.size(settings!)
            if value.type.isFloat {
                if target.isFloat {
                    if size1 > size2 {
                        op := "fptrunc"
                    }
                    else if size1 < size2 {
                        op := "fpext"
                    }
                    else {
                        -- same LLVM type, write out a useless add 0
                        out.printLine("\{name(id)} = fadd \{getTypedReference(value)}, 0x0")
                        return
                    }
                }
                else if signed {
                    op := "fptosi"
                }
                else {
                    op := "fptoui"
                }
            }
            else if target.isFloat {
                if signed {
                    op := "sitofp"
                }
                else {
                    op := "uitofp"
                }
            }
            else {
                if size1 > size2 {
                    op := "trunc"
                }
                else if size1 < size2 {
                    if signed {
                        op := "sext"
                    }
                    else {
                        op := "zext"
                    }
                }
                else {
                    -- same LLVM type, write out a useless add 0
                    out.printLine("\{name(id)} = add \{getTypedReference(value)}, 0")
                    return
                }
            }
            out.printLine("\{name(id)} = \{op} \{getTypedReference(value)} to \{llvmType(target)}")
        }
        fail(error) {
            unreachable, error.toString
        }
    }

    method writeIntrinsicSignature(intrinsic:Intrinsic) {
        try {
            match intrinsic {
                -- we include code for all of the ref / unref methods to allow for inlining;
                -- they are called so frequently that anything we can do to reduce their
                -- overhead is worthwhile
                when Intrinsic.REF_THREAD_UNSAFE {
                    signatures.printLine("define linkonce_odr void @frost$core$Frost$refThreadUnsafe$frost$core$Object$Q_intrinsic(i64 %p) alwaysinline {")
                    signatures.printLine("    %1 = icmp eq i64 %p, 0")
                    signatures.printLine("    br i1 %1, label %end, label %nonNull")
                    signatures.printLine("    nonNull:")
                    signatures.printLine("    %2 = inttoptr i64 %p to { i64, i32 }*")
                    signatures.printLine("    %3 = getelementptr inbounds { i64, i32 }, { i64, i32 }* %2, i64 0, i32 1")
                    signatures.printLine("    %4 = load i32, i32* %3")
                    signatures.printLine("    %5 = add i32 %4, 1")
                    signatures.printLine("    store i32 %5, i32* %3")
                    signatures.printLine("    br label %end")
                    signatures.printLine("    end:")
                    signatures.printLine("    ret void")
                    signatures.printLine("}")
                }
                when Intrinsic.REF_THREAD_SAFE_NONCONSTANT {
                    signatures.printLine("define linkonce_odr void @frost$core$Frost$refThreadSafeNonConstant$frost$core$Object$Q_intrinsic(i64 %p) alwaysinline {")
                    signatures.printLine("    %1 = icmp eq i64 %p, 0")
                    signatures.printLine("    br i1 %1, label %end, label %nonNull")
                    signatures.printLine("    nonNull:")
                    signatures.printLine("    %2 = inttoptr i64 %p to { i64, i32 }*")
                    signatures.printLine("    %3 = getelementptr inbounds { i64, i32 }, { i64, i32 }* %2, i64 0, i32 1")
                    signatures.printLine("    %4 = atomicrmw add i32* %3, i32 1 monotonic")
                    signatures.printLine("    br label %end")
                    signatures.printLine("    end:")
                    signatures.printLine("    ret void")
                    signatures.printLine("}")
                }
                when Intrinsic.REF_THREAD_SAFE {
                    signatures.printLine("define linkonce_odr void @frost$core$Frost$refThreadSafe$frost$core$Object$Q_intrinsic(i64 %p) alwaysinline {")
                    signatures.printLine("    %1 = icmp eq i64 %p, 0")
                    signatures.printLine("    br i1 %1, label %end, label %nonNull")
                    signatures.printLine("    nonNull:")
                    signatures.printLine("    %2 = inttoptr i64 %p to { i64, i32 }*")
                    signatures.printLine("    %3 = getelementptr inbounds { i64, i32 }, { i64, i32 }* %2, i64 0, i32 1")
                    signatures.printLine("    %4 = load i32, i32* %3")
                    signatures.printLine("    %5 = icmp ne i32 %4, -999")
                    signatures.printLine("    br i1 %5, label %nonConstant, label %end")
                    signatures.printLine("    nonConstant:")
                    signatures.printLine("    %6 = atomicrmw add i32* %3, i32 1 monotonic")
                    signatures.printLine("    br label %end")
                    signatures.printLine("    end:")
                    signatures.printLine("    ret void")
                    signatures.printLine("}")
                }
                when Intrinsic.UNREF_THREAD_UNSAFE, Intrinsic.UNREF_THREAD_UNSAFE_NOCLEANUP {
                    def destroyMethod:String
                    def cleanup:String
                    if intrinsic = Intrinsic.UNREF_THREAD_UNSAFE {
                        destroyMethod := "frostDestroy"
                        cleanup := ""
                    }
                    else {
                        destroyMethod := "frostObjectFree"
                        cleanup := "NoCleanup"
                    }
                    if !writtenSignatures.contains(destroyMethod) {
                        signatures.printLine("declare void @\{destroyMethod}(i64)")
                        writtenSignatures.add(destroyMethod)
                    }
                    signatures.printLine("define linkonce_odr void @frost$core$Frost$unrefThreadUnsafe\{cleanup}$frost$core$Object$Q_intrinsic(i64 %p) alwaysinline {")
                    signatures.printLine("    %1 = icmp eq i64 %p, 0")
                    signatures.printLine("    br i1 %1, label %end, label %nonNull")
                    signatures.printLine("    nonNull:")
                    signatures.printLine("    %2 = inttoptr i64 %p to { i64, i32 }*")
                    signatures.printLine("    %3 = getelementptr inbounds { i64, i32 }, { i64, i32 }* %2, i64 0, i32 1")
                    signatures.printLine("    %4 = load i32, i32* %3")
                    signatures.printLine("    %5 = sub i32 %4, 1")
                    signatures.printLine("    store i32 %5, i32* %3")
                    signatures.printLine("    %6 = icmp eq i32 %5, 0")
                    signatures.printLine("    br i1 %6, label %destroy, label %end")
                    signatures.printLine("    destroy:")
                    signatures.printLine("    call void @\{destroyMethod}(i64 %p)")
                    signatures.printLine("    br label %end")
                    signatures.printLine("    end:")
                    signatures.printLine("    ret void")
                    signatures.printLine("}")
                }
                when Intrinsic.UNREF_THREAD_SAFE_NONCONSTANT,
                        Intrinsic.UNREF_THREAD_SAFE_NONCONSTANT_NOCLEANUP {
                    def destroyMethod:String
                    def cleanup:String
                    if intrinsic = Intrinsic.UNREF_THREAD_SAFE_NONCONSTANT {
                        destroyMethod := "frostDestroy"
                        cleanup := ""
                    }
                    else {
                        destroyMethod := "frostObjectFree"
                        cleanup := "NoCleanup"
                    }
                    if !writtenSignatures.contains(destroyMethod) {
                        signatures.printLine("declare void @\{destroyMethod}(i64)")
                        writtenSignatures.add(destroyMethod)
                    }
                    signatures.printLine("define linkonce_odr void @frost$core$Frost$unrefThreadSafeNonConstant\{cleanup}$frost$core$Object$Q_intrinsic(i64 %p) alwaysinline {")
                    signatures.printLine("    %1 = icmp eq i64 %p, 0")
                    signatures.printLine("    br i1 %1, label %end, label %nonNull")
                    signatures.printLine("    nonNull:")
                    signatures.printLine("    %2 = inttoptr i64 %p to { i64, i32 }*")
                    signatures.printLine("    %3 = getelementptr inbounds { i64, i32 }, { i64, i32 }* %2, i64 0, i32 1")
                    signatures.printLine("    %4 = atomicrmw sub i32* %3, i32 1 monotonic")
                    signatures.printLine("    %5 = icmp eq i32 %4, 1")
                    signatures.printLine("    br i1 %5, label %destroy, label %end")
                    signatures.printLine("    destroy:")
                    signatures.printLine("    call void @\{destroyMethod}(i64 %p)")
                    signatures.printLine("    br label %end")
                    signatures.printLine("    end:")
                    signatures.printLine("    ret void")
                    signatures.printLine("}")
                }
                when Intrinsic.UNREF_THREAD_SAFE, Intrinsic.UNREF_THREAD_SAFE_NOCLEANUP {
                    def destroyMethod:String
                    def cleanup:String
                    if intrinsic = Intrinsic.UNREF_THREAD_SAFE {
                        destroyMethod := "frostDestroy"
                        cleanup := ""
                    }
                    else {
                        destroyMethod := "frostObjectFree"
                        cleanup := "NoCleanup"
                    }
                    if !writtenSignatures.contains(destroyMethod) {
                        signatures.printLine("declare void @\{destroyMethod}(i64)")
                        writtenSignatures.add(destroyMethod)
                    }
                    signatures.printLine("define linkonce_odr void @frost$core$Frost$unrefThreadSafe\{cleanup}$frost$core$Object$Q_intrinsic(i64 %p) alwaysinline {")
                    signatures.printLine("    %1 = icmp eq i64 %p, 0")
                    signatures.printLine("    br i1 %1, label %end, label %nonNull")
                    signatures.printLine("    nonNull:")
                    signatures.printLine("    %2 = inttoptr i64 %p to { i64, i32 }*")
                    signatures.printLine("    %3 = getelementptr inbounds { i64, i32 }, { i64, i32 }* %2, i64 0, i32 1")
                    signatures.printLine("    %4 = load i32, i32* %3")
                    signatures.printLine("    %cast2 = sext i32 %4 to i64")                        
                    signatures.printLine("    %5 = icmp ne i32 %4, -999")
                    signatures.printLine("    br i1 %5, label %nonConstant, label %end")
                    signatures.printLine("    nonConstant:")
                    signatures.printLine("    %6 = atomicrmw sub i32* %3, i32 1 monotonic")
                    signatures.printLine("    %cast = sext i32 %6 to i64")                        
                    signatures.printLine("    %7 = icmp eq i32 %6, 1")
                    signatures.printLine("    br i1 %7, label %destroy, label %end")
                    signatures.printLine("    destroy:")
                    signatures.printLine("    call void @\{destroyMethod}(i64 %p)")
                    signatures.printLine("    br label %end")
                    signatures.printLine("    end:")
                    signatures.printLine("    ret void")
                    signatures.printLine("}")
                }
            }
        }
        fail(error) {
            unreachable, error.toString
        }
    }

    method writeOverflowIntrinsic(op:String, type:Code.PrimitiveType):String {
        def name := "llvm.\{op}.with.overflow.\{llvmType(type)}"
        writeSignature(Code.Signature(null,
                Code.PrimitiveType.STRUCT("Overflow", FixedArray<Code.Slot>.from(
                        [Code.Slot("value", type),
                         Code.Slot("overflow", Code.PrimitiveType.BIT)])),
                name,
                FixedArray<Code.Slot>.from([Code.Slot("p1", type), Code.Slot("p2", type)]),
                true))
        return "@\{name}"
    }

    function nowrap(wrap:Code.Wrap):String {
        return (wrap = Code.Wrap.CHECK_SIGNED).choose("nsw", "nuw")
    }

    method getStringLiteral(s:String):String {
        var result := stringLiterals[s]
        if result == null {
            varCount += 1
            result := "@s" + varCount
            def error := globals.printLine("\{result} = private constant [\{s.byteLength} x i8] " +
                    getReference(Code.Value.CHARS(s)))
            assert error == null
            stringLiterals[s] := result
        }
        return result
    }

    method writeCheckedOp(op:String, position:MethodPosition, result:Code.Statement.ID,
            left:Code.Value, right:Code.Value, wrap:Code.Wrap, out:OutputStream) {
        try {
            if wrap = Code.Wrap.UNCHECKED {
                out.printLine("\{name(result)} = \{op} \{getTypedReference(left)}, " +
                        "\{getReference(right)}\{debugInfo(position)}")
            }
            else {
                if boundsChecking {
                    def op := (wrap = Code.Wrap.CHECK_SIGNED).choose("s\{op}", "u\{op}")
                    def intrinsic := writeOverflowIntrinsic(op, left.type)
                    def tmp := nextVar()
                    def type := llvmType(left.type)
                    out.printLine("\{tmp} = call { \{type}, i1 } \{intrinsic}(" +
                            "\{getTypedReference(left)}, " +
                            "\{getTypedReference(right)})\{debugInfo(position)}")
                    def overflow := nextVar()
                    out.printLine("\{overflow} = extractvalue { \{type}, i1 } " +
                            "\{tmp}, 1")
                    def success := nextBlock()
                    def failure := nextBlock()
                    out.printLine("br i1 \{overflow}, label %\{failure}, label %\{success}")
                    out.printLine("\{failure}:")
                    def filename := compiler.files[position.file].name + Char8(0)
                    def chars := getStringLiteral(filename)
                    out.printLine("call void @frostOverflow(i8* bitcast([\{filename.byteLength} " +
                            "x i8]* \{chars} to i8*), i32 \{position.line})")
                    out.printLine("unreachable")
                    out.printLine("\{success}:")
                    out.printLine("\{name(result)} = extractvalue { \{type}, i1 } " +
                            "\{tmp}, 0")
                }
                else {
                    out.printLine("\{name(result)} = \{op} \{nowrap(wrap)} " +
                            "\{getTypedReference(left)}, \{getReference(right)}" +
                            debugInfo(position))
                }
            }
        }
        fail(error) {
            unreachable, error.toString
        }
    }

    method writeStatement(s:Code.Statement) {
        try {
            match s {
                when Code.Statement.ADDI(position, result, left, right, wrap) {
                    writeCheckedOp("add", position, result, left, right, wrap, out)
                }
                when Code.Statement.ADDF(position, result, left, right) {
                    out.printLine("\{name(result)} = fadd \{getTypedReference(left)}, " +
                            getReference(right) + debugInfo(position))
                }
                when Code.Statement.SUBI(position, result, left, right, wrap) {
                    writeCheckedOp("sub", position, result, left, right, wrap, out)
                }
                when Code.Statement.SUBF(position, result, left, right) {
                    out.printLine("\{name(result)} = fsub \{getTypedReference(left)}, " +
                            getReference(right) + debugInfo(position))
                }
                when Code.Statement.MULI(position, result, left, right, wrap) {
                    writeCheckedOp("mul", position, result, left, right, wrap, out)
                }
                when Code.Statement.MULF(position, result, left, right) {
                    out.printLine("\{name(result)} = fmul \{getTypedReference(left)}, " +
                            getReference(right) + debugInfo(position))
                }
                when Code.Statement.DIVS(position, result, left, right, checked) {
                    out.printLine("\{name(result)} = sdiv \{getTypedReference(left)}, " +
                            getReference(right) + debugInfo(position))
                }
                when Code.Statement.DIVU(position, result, left, right) {
                    out.printLine("\{name(result)} = udiv \{getTypedReference(left)}, " +
                            getReference(right) + debugInfo(position))
                }
                when Code.Statement.DIVF(position, result, left, right) {
                    out.printLine("\{name(result)} = fdiv \{getTypedReference(left)}, " +
                            getReference(right) + debugInfo(position))
                }
                when Code.Statement.REMS(position, result, left, right) {
                    out.printLine("\{name(result)} = srem \{getTypedReference(left)}, " +
                            getReference(right) + debugInfo(position))
                }
                when Code.Statement.REMU(position, result, left, right) {
                    out.printLine("\{name(result)} = urem \{getTypedReference(left)}, " +
                            getReference(right) + debugInfo(position))
                }
                when Code.Statement.ANDI(position, result, left, right) {
                    out.printLine("\{name(result)} = and \{getTypedReference(left)}, " +
                            getReference(right) + debugInfo(position))
                }
                when Code.Statement.ANDB(position, result, left, right) {
                    out.printLine("\{name(result)} = and \{getTypedReference(left)}, " +
                            getReference(right) + debugInfo(position))
                }
                when Code.Statement.ORI(position, result, left, right) {
                    out.printLine("\{name(result)} = or \{getTypedReference(left)}, " +
                            getReference(right) + debugInfo(position))
                }
                when Code.Statement.ORB(position, result, left, right) {
                    out.printLine("\{name(result)} = or \{getTypedReference(left)}, " +
                            getReference(right) + debugInfo(position))
                }
                when Code.Statement.XORI(position, result, left, right) {
                    out.printLine("\{name(result)} = xor \{getTypedReference(left)}, " +
                            getReference(right) + debugInfo(position))
                }
                when Code.Statement.XORB(position, result, left, right) {
                    out.printLine("\{name(result)} = xor \{getTypedReference(left)}, " +
                            getReference(right) + debugInfo(position))
                }
                when Code.Statement.SHRS(position, result, left, right) {
                    out.printLine("\{name(result)} = ashr \{getTypedReference(left)}, " +
                            getReference(right) + debugInfo(position))
                }
                when Code.Statement.SHRU(position, result, left, right) {
                    out.printLine("\{name(result)} = lshr \{getTypedReference(left)}, " +
                            getReference(right) + debugInfo(position))
                }
                when Code.Statement.SHL(position, result, left, right, wrap) {
                    out.printLine("\{name(result)} = shl \{getTypedReference(left)}, " +
                            getReference(right) + debugInfo(position))
                }
                when Code.Statement.EQI(position, result, left, right) {
                    out.printLine("\{name(result)} = icmp eq \{getTypedReference(left)}, " +
                            getReference(right) + debugInfo(position))
                }
                when Code.Statement.EQF(position, result, left, right) {
                    out.printLine("\{name(result)} = fcmp oeq \{getTypedReference(left)}, " +
                            getReference(right) + debugInfo(position))
                }
                when Code.Statement.NEQI(position, result, left, right) {
                    out.printLine("\{name(result)} = icmp ne \{getTypedReference(left)}, " +
                            getReference(right) + debugInfo(position))
                }
                when Code.Statement.NEQF(position, result, left, right) {
                    out.printLine("\{name(result)} = fcmp one \{getTypedReference(left)}, " +
                            getReference(right) + debugInfo(position))
                }
                when Code.Statement.GTS(position, result, left, right) {
                    out.printLine("\{name(result)} = icmp sgt \{getTypedReference(left)}, " +
                            getReference(right) + debugInfo(position))
                }
                when Code.Statement.GTU(position, result, left, right) {
                    out.printLine("\{name(result)} = icmp ugt \{getTypedReference(left)}, " +
                            getReference(right) + debugInfo(position))
                }
                when Code.Statement.GTF(position, result, left, right) {
                    out.printLine("\{name(result)} = fcmp ogt \{getTypedReference(left)}, " +
                            getReference(right) + debugInfo(position))
                }
                when Code.Statement.GES(position, result, left, right) {
                    out.printLine("\{name(result)} = icmp sge \{getTypedReference(left)}, " +
                            getReference(right) + debugInfo(position))
                }
                when Code.Statement.GEU(position, result, left, right) {
                    out.printLine("\{name(result)} = icmp uge \{getTypedReference(left)}, " +
                            getReference(right) + debugInfo(position))
                }
                when Code.Statement.GEF(position, result, left, right) {
                    out.printLine("\{name(result)} = fcmp oge \{getTypedReference(left)}, " +
                            getReference(right) + debugInfo(position))
                }
                when Code.Statement.LTS(position, result, left, right) {
                    out.printLine("\{name(result)} = icmp slt \{getTypedReference(left)}, " +
                            getReference(right) + debugInfo(position))
                }
                when Code.Statement.LTU(position, result, left, right) {
                    out.printLine("\{name(result)} = icmp ult \{getTypedReference(left)}, " +
                            getReference(right) + debugInfo(position))
                }
                when Code.Statement.LTF(position, result, left, right) {
                    out.printLine("\{name(result)} = fcmp olt \{getTypedReference(left)}, " +
                            getReference(right) + debugInfo(position))
                }
                when Code.Statement.LES(position, result, left, right) {
                    out.printLine("\{name(result)} = icmp sle \{getTypedReference(left)}, " +
                            getReference(right) + debugInfo(position))
                }
                when Code.Statement.LEU(position, result, left, right) {
                    out.printLine("\{name(result)} = icmp ule \{getTypedReference(left)}, " +
                            getReference(right) + debugInfo(position))
                }
                when Code.Statement.LEF(position, result, left, right) {
                    out.printLine("\{name(result)} = fcmp ole \{getTypedReference(left)}, " +
                            getReference(right) + debugInfo(position))
                }
                when Code.Statement.BRANCH(position, target) {
                    out.printLine("br label %\{target}\{debugInfo(position)}")
                }
                when Code.Statement.COMMENT(_, text) {
                    out.printLine("; \{text}")
                }
                when Code.Statement.CONVERTS(position, result, value, target) {
                    writeConvert(position, result, value, target, true)
                }
                when Code.Statement.CONVERTU(position, result, value, target) {
                    writeConvert(position, result, value, target, false)
                }
                when Code.Statement.CREATE_STRUCT(position, result, type, args) {
                    writeCreateStruct(position, result, type, args)
                }
                when Code.Statement.CONDITIONAL_BRANCH(position, test, ifTrue, ifFalse) {
                    out.printLine("br \{getTypedReference(test)}, label %\{ifTrue}, " +
                            "label %\{ifFalse}\{debugInfo(position)}")
                }
                when Code.Statement.DYNAMIC_CALL(position, result, returnType, m, args) {
                    def ptrCast := nextVar()
                    out.printLine("\{ptrCast} = inttoptr \{getTypedReference(m)} to i8*")
                    def methodCast := nextVar()
                    def llt := llvmType(Code.Signature(null, returnType, "<dynamic>",
                            FixedArray<Code.Slot>.from(args.map(a => Code.Slot("", a.type))),
                            false))
                    out.printLine("\{methodCast} = bitcast i8* \{ptrCast} to \{llt}*")
                    out.print("\{name(result)} = call \{llvmType(returnType)} \{methodCast}(")
                    var separator := ""
                    for a in args {
                        out.print("\{separator}\{getTypedReference(a)}")
                        separator := ", "
                    }
                    out.printLine(")\{debugInfo(position)}")
                }
                when Code.Statement.DYNAMIC_CALL_VOID(position, m, args) {
                    def ptrCast := nextVar()
                    out.printLine("\{ptrCast} = inttoptr \{getTypedReference(m)} to i8*")
                    def methodCast := nextVar()
                    def llt := llvmType(Code.Signature(null, null, "<dynamic>",
                            FixedArray<Code.Slot>.from(args.map(a => Code.Slot("", a.type))),
                            false))
                    out.printLine("\{methodCast} = bitcast i8* \{ptrCast} to \{llt}*")
                    out.print("call void \{methodCast}(")
                    var separator := ""
                    for a in args {
                        out.print("\{separator}\{getTypedReference(a)}")
                        separator := ", "
                    }
                    out.printLine(")\{debugInfo(position)}")
                }
                when Code.Statement.EXTRACT_FIELD(position, result, target, index) {
                    def targetRef := getTypedReference(target)
                    out.printLine("\{name(result)} = extractvalue \{targetRef}, \{index}" +
                            debugInfo(position))
                }
                when Code.Statement.HEAP_ALLOC(_, result, type, classConstant) {
                    out.printLine("\{name(result)} = call \{INT_TYPE} @frostObjectAlloc(" +
                            "\{INT_TYPE} \{type.size(settings)}, " +
                            "\{getTypedReference(classConstant)})")
                }
                when Code.Statement.LOAD(position, result, value, type) {
                    def cast := nextVar()
                    def llt := llvmType(type)
                    out.printLine("\{cast} = inttoptr \{INT_TYPE} \{getReference(value)} to " +
                            "\{llt}*")
                    out.printLine("\{name(result)} = load \{llt}, \{llt}* \{cast}" +
                            debugInfo(position))
                }
                when Code.Statement.NEGS(position, result, value) {
                    out.printLine("\{name(result)} = sub \{llvmType(value.type)} 0, " +
                            "\{getReference(value)}\{debugInfo(position)}")
                }
                when Code.Statement.NEGF(position, result, value) {
                    out.printLine("\{name(result)} = fsub \{llvmType(value.type)} 0x0, " +
                            "\{getReference(value)}\{debugInfo(position)}")
                }
                when Code.Statement.NOTB(position, result, value) {
                    out.printLine("\{name(result)} = xor \{getTypedReference(value)}, -1" +
                            debugInfo(position))
                }
                when Code.Statement.NOTI(position, result, value) {
                    out.printLine("\{name(result)} = xor \{getTypedReference(value)}, -1" +
                            debugInfo(position))
                }
                when Code.Statement.RETURN(position, value) {
                    if value !== null {
                        out.printLine("ret \{getTypedReference(value)}\{debugInfo(position)}")
                    }
                    else {
                        out.printLine("ret void")
                    }
                }
                when Code.Statement.STACK_ALLOC(_, result, type) {
                    def ptr := nextVar()
                    def llt := llvmType(type)
                    out.printLine("\{ptr} = alloca \{llt}")
                    out.printLine("\{name(result)} = ptrtoint \{llt}* \{ptr} to \{INT_TYPE}")
                }
                when Code.Statement.STATIC_CALL(position, result, m, args) {
                    if m.isExternal {
                        writeSignature(m)
                    }
                    assert m.returnType !== null, "STATIC_CALL to void method \{m} at \{position}"
                    out.print("\{name(result)} = call \{llvmType(m.returnType)} @\{m.name}")
                    if getIntrinsic(m) !== null {
                        out.print("_intrinsic")
                    }
                    out.print("(")
                    var separator := ""
                    for a in args {
                        out.print("\{separator}\{getTypedReference(a)}")
                        separator := ", "
                    }
                    out.printLine(")\{debugInfo(position)}")
                }
                when Code.Statement.STATIC_CALL_VOID(position, m, args) {
                    if m.isExternal {
                        writeSignature(m)
                    }
                    out.print("call void @\{m.name}")
                    if getIntrinsic(m) !== null {
                        out.print("_intrinsic")
                    }
                    out.print("(")
                    var separator := ""
                    for a in args {
                        out.print("\{separator}\{getTypedReference(a)}")
                        separator := ", "
                    }
                    out.printLine(")\{debugInfo(position)}")
                }
                when Code.Statement.STORE(position, value, dest) {
                    def cast := nextVar()
                    def llt := llvmType(value.type)
                    out.printLine("\{cast} = inttoptr \{INT_TYPE} \{getReference(dest)} to \{llt}*")
                    out.printLine("store \{getTypedReference(value)}, \{llt}* \{cast}" +
                            debugInfo(position))
                }
                when Code.Statement.SWITCH(position, value, cases, other) {
                    def type := llvmType(value.type)
                    out.printLine("switch \{type} \{getReference(value)}, label %\{other} [" +
                            cases.map(c => "\{type} \{c[0]}, label %\{c[1]}").join("\n") + "]" +
                            debugInfo(position))
                }
                when Code.Statement.UNREACHABLE(position) {
                    out.printLine("unreachable")
                }
                otherwise {
                    unreachable, "unsupported statement \{s}"
                }
            }
        }
        fail(error) {
            unreachable, error.toString
        }
    }

    method writeCode(code:Code) {
        try {
            for i in 0 .. code.blocks.count {
                def block := code.blocks[i]
                if i != 0 {
                    out.printLine("\{block.id}:")
                }
                for s in block.statements {
                    writeStatement(s)
                }
            }
        }
        fail(error) {
            unreachable, error.toString
        }
    }

    @override
    method writeMethod(m:MethodDecl?, s:Code.Signature, code:Code, linkOnce:Bit) {
        out := methods
        try {
            out.print("define ")
            if linkOnce {
                out.print("linkonce_odr ")
            }
            if s.returnType !== null {
                out.print(llvmType(s.returnType))
            }
            else {
                out.print("void")
            }
            out.print(" @\{s.name}(")
            var separator := ""
            for i in 0 .. s.parameters.count {
                out.print("\{separator}\{llvmType(s.parameters[i].type)} %param\{i}")
                separator := ", "
            }
            out.print(")")
            if m !== null {
                -*
                FIXME put this back in once function safety is in, or at least I figure out where
                the breakage is
                if m.methodKind = MethodDecl.Kind.FUNCTION {
                    out.print(" readonly")
                }
                *-
                if compiler!.settings.debug {
                    out.print(" !dbg \{getMethodMetadata(m.index)}")
                }
            }
            out.printLine(" {")
            writeCode(code)
            out.printLine("}")
            lexicalBlockMetadata.clear()
            debugPositions.clear()
        }
        fail(error) {
            unreachable, error.toString
        }
    }

    @override
    method start(cl:ClassDecl) {
        try {
            if cl.annotations.isSpecialize {
                return
            }
            cg.getClassConstant(cl)
        }
        fail(error) {
            unreachable, error.toString
        }
    }

    @override
    method end(cl:ClassDecl) {
    }

    @override
    method writeGlobal(g:Code.Global) {
        externalGlobals.add(g)
    }

    @override
    method writeGlobalValue(g:Code.Global, value:Code.Value) {
        externalGlobals.remove(g)
        try {
            if g.comment !== null {
                globals.printLine("; \{g.comment}")
            }
            globals.print("@\{g.name} = ")
            assert !g.isExternal
            if g.isPrivate {
                globals.print("private ")
            }
            if g.isLinkOnce {
                globals.print("linkonce_odr ")
            }
            if g.isUnnamedAddr {
                globals.print("unnamed_addr ")
            }
            globals.printLine("constant \{getTypedReference(value)}")
        }
        fail(error) {
            Console.printError(error)
            System.exit(1)
        }
    }

    @override
    method finish() {
        try {
            physicalOut.print(globals.finish())
            for g in externalGlobals {
                if g.comment !== null {
                    physicalOut.printLine("; \{g.comment}")
                }
                assert g.isExternal
                physicalOut.print("@\{g.name} = external ")
                if g.isPrivate {
                    physicalOut.print("private ")
                }
                if g.isLinkOnce {
                    physicalOut.print("linkonce_odr ")
                }
                if g.isUnnamedAddr {
                    physicalOut.print("unnamed_addr ")
                }
                physicalOut.printLine("constant \{llvmType(g.type)}")
            }
            physicalOut.print(signatures.finish())
            physicalOut.print(methods.finish())
            physicalOut.print(metadata.finish())
            physicalOut.close()
        }
        fail(error) {
            Console.printError(error)
            System.exit(1)
        }
    }
}