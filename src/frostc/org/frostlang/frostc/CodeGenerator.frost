package org.frostlang.frostc

uses org.frostlang.frostc.expression.Binary

@extendable
class CodeGenerator {
    constant NO_REFCNT := -999

    choice TypeClass {
        SIGNED
        UNSIGNED
        FLOAT
        BIT
        OTHER

        @class
        method from(type:Type):TypeClass {
            match type.typeKind {
                when Type.Kind.BUILTIN_INT {
                    return SIGNED
                }
                when Type.Kind.BUILTIN_UINT {
                    return UNSIGNED
                }
                when Type.Kind.BUILTIN_FLOAT {
                    return FLOAT
                }
                when Type.Kind.BUILTIN_BIT {
                    return BIT
                }
                otherwise {
                    return OTHER
                }
            }
        }
    }

    constant ITABLE_INDEX := 5

    constant VTABLE_INDEX := 6

    constant CHOICE_DATA_INDEX := 4

    constant VALUE_INDEX := 3

    @weak
    def compiler:Compiler

    def settings:Compiler.Settings

    @weak
    def backend:Backend

    var nextStatementID := 0

    var nextBlockID := 0

    def declarations := IdentityMap<MethodDecl, Code.Signature>()

    def globals := Array<Code.Global>()

    def globalIndices := IdentityMap<Code.Global, Int>()

    def classConstants := IdentityMap<ClassDecl, Code.Value>()

    def methodShims := IdentityMap<MethodDecl, (Code.Signature, Code)>()

    def strings := HashMap<String, Code.Value>()

    def currentMethod:MethodDecl?

    def ir:IR?

    def out := Array<Code.Statement>()

    def outBlocks := Array<Code.Block>()

    def block0 := Array<Code.Statement>()

    def locals := Array<Code.Statement.ID>()

    def statements := HashMap<IR.Statement.ID, Code.Statement.ID>()

    def blocks := HashMap<IR.Block.ID, Code.Block.ID>()

    def casts := HashMap<(String, Type), IR.Statement.ID>()

    var allClassConstants := false

    -- When we want to refer to a statement, we first check this map and use the value it contains,
    -- if any. We use this to handle IR statements which don't actually do anything, like casting
    -- String to Object - we just add a ref for the statement's ID to the value it was going to
    -- operate on.
    def refs := HashMap<IR.Statement.ID, Code.Value>()

    -- When we encounter a reference to a statement before the statement itself, we need to keep
    -- track of it in case it gets remapped.
    def earlyRefs := HashMap<IR.Statement.ID, Array<Code.ValueRef>>()

    def nameCache := IdentityMap<MethodDecl, String>()

    init(compiler:Compiler, backend:Backend) {
        self.compiler := compiler
        self.settings := compiler.settings
        self.backend := backend
    }

    ================================================================================================
    Returns true if this is an external method returning a struct.

    Returning structs from C functions into LLVM code is tricky. I tried it the naive and obvious
    way, and found it didn't work. Some cursory research indicated that C functions that return
    structs are at least sometimes compiled to accept a special pointer ("sret") as an extra
    parameter, and the caller is expected to know to alloca space for the return value and pass in a
    pointer to it.

    Since online sources were complaining about how poorly documented this is, there may be multiple
    struct return strategies depending on the nature of the struct, people were suggesting looking
    at the assembly code generated by Clang to figure out how one was supposed to call a given
    function, and this all varies from platform to platform, we avoid the whole mess by making it
    explicit. External functions which wish to return structs explicitly receive a pointer to the
    result structure as their first parameter.
    ================================================================================================
    function needsStructIndirection(m:MethodDecl):Bit {
        if !m.returnType.isClass {
            return false
        }
        var result:Bit
        if m.annotations.isExternal {
            match primitiveType(m.returnType) {
                when Code.PrimitiveType.STRUCT {
                    result := true
                }
                otherwise {
                    result := false
                }
            }
        }
        else {
            result := false
        }
        assert !result | (!m.annotations.isOverride & (!m.annotations.isExtendable |
                m.annotations.isClass)), "invalid struct indirection on \{m.signature}"
        return result
    }

    method getStringReference(s:String):Code.Value {
        var result := strings[s]
        if result == null {
            def cc := getClassConstant(compiler.getClass("frost.core.String")!)
            def charsIndex := globals.count
            def chars := Code.Global("chars\{charsIndex}",
                    Code.PrimitiveType.ARRAY(s.byteLength, Code.PrimitiveType.INT8), null,
                    Code.Global.UNNAMED_ADDR_FLAG || Code.Global.PRIVATE_FLAG)
            def charsRef := Code.Value.GLOBAL_POINTER(charsIndex)
            writeGlobalValue(chars, Code.Value.CHARS(s))

            def types := [
                Code.PrimitiveType.INT,   -* class *-
                Code.PrimitiveType.INT32, -* refcount *-
                Code.PrimitiveType.INT8,  -* flags *-
                Code.PrimitiveType.INT,   -* data *-
                Code.PrimitiveType.INT,   -* _length *-
                Code.PrimitiveType.INT,   -* dummy *-
                Code.PrimitiveType.INT    -* owner *-
            ]
            def stringIndex := globals.count
            def string := Code.Global("string\{stringIndex}",
                    Code.PrimitiveType.STRUCT(FixedArray<Code.PrimitiveType>.from(types)),
                    null, Code.Global.UNNAMED_ADDR_FLAG || Code.Global.PRIVATE_FLAG)
            writeGlobalValue(string, Code.Value.STRUCT(FixedArray<Code.Value>.from([
                cc,
                Code.Value.INT(NO_REFCNT.toUInt64, Code.PrimitiveType.INT32),
                Code.Value.INT(0, Code.PrimitiveType.INT8),
                Code.Value.GLOBAL_POINTER(charsIndex),
                Code.Value.INT(s.byteLength.asUInt64, Code.PrimitiveType.INT),
                Code.Value.INT(0, Code.PrimitiveType.INT),
                Code.Value.INT(0, Code.PrimitiveType.INT)
            ])))
            result := Code.Value.GLOBAL_POINTER(stringIndex)
            strings[s] := result
        }
        return result
    }

    method getITable(cl:ClassDecl):Code.Value {
        try {
            def interfaces := compiler.allInterfaces(cl.type)
            var previous := Code.Value.INT(0, Code.PrimitiveType.INT)
            for intfType in interfaces {
                def intf := compiler.getClass(intfType)
                def intfCC := getClassConstant(intf)
                def methods := compiler.interfaceMethods(cl, intfType)
                def fields := [intfCC, previous]
                fields.add(Code.Value.ARRAY(Code.PrimitiveType.INT,
                    FixedArray<Code.Value>.from(methods.map(method(m:MethodDecl):Code.Value {
                        if m.annotations.isAbstract {
                            return Code.Value.INT(0, Code.PrimitiveType.INT)
                        }
                        else {
                            return Code.Value.METHOD_POINTER(self.getMethodTableEntry(m))
                        }
                    }))
                ))
                def value := Code.Value.STRUCT(FixedArray<Code.Value>.from(fields))
                def index := globals.count
                writeGlobalValue(Code.Global(escapeName(cl.name) + "$" +
                        escapeName(intfType.name) + "$itable", value.type, null,
                        cl.isSpecialization().choose(Code.Global.LINKONCE_FLAG, 0)),
                        value)
                previous := Code.Value.GLOBAL_POINTER(index)
            }
            def index := globals.count
            var flags:Int
            if cl.external {
                flags := Code.Global.EXTERNAL_FLAG
            }
            else if cl.isSpecialization() {
                flags := Code.Global.LINKONCE_FLAG
            }
            else {
                flags := 0
            }
            return previous
        }
        fail(error) {
            unreachable
        }
    }    

    method getClassConstant(cl:ClassDecl):Code.Value {
        var result := classConstants[cl]
        if result == null {
            var vtable := compiler.getVTable(cl)
            def name:String
            if compiler.isValue(cl) {
                constant VALUE_METHOD_COUNT := 2
                assert compiler.getVTable(compiler.getClass("frost.core.Value")!).count =
                        VALUE_METHOD_COUNT
                vtable := vtable[..VALUE_METHOD_COUNT]->Array<MethodDecl>
                name := escapeName(cl.name) + "$class"
            }
            else {
                name := escapeName(cl.name) + "$class"
            }
            def types := [
                Code.PrimitiveType.INT,   -* class *-
                Code.PrimitiveType.INT32, -* refcount *-
                Code.PrimitiveType.INT8,  -* flags *-
                Code.PrimitiveType.INT,   -* name *-
                Code.PrimitiveType.INT,   -* superclass *-
                Code.PrimitiveType.INT,   -* itable *-
                Code.PrimitiveType.ARRAY(vtable.count, Code.PrimitiveType.INT)
            ]
            var flags:Int
            if cl.external {
                flags := Code.Global.EXTERNAL_FLAG
            }
            else if cl.isSpecialization() {
                flags := Code.Global.LINKONCE_FLAG
            }
            else {
                flags := 0
            }
            def cc := Code.Global(name,
                    Code.PrimitiveType.STRUCT(FixedArray<Code.PrimitiveType>.from(types)), null,
                    flags)
            def index := globals.count
            result := Code.Value.GLOBAL_POINTER(index)
            writeGlobal(cc)
            classConstants[cl] := result
            if allClassConstants | !cl.external {
                def fields := Array<Code.Value>()
                fields.add(getClassConstant(compiler.getClass("frost.core.Class")!))
                fields.add(Code.Value.INT(NO_REFCNT.toUInt64, Code.PrimitiveType.INT32))
                fields.add(Code.Value.INT(0, Code.PrimitiveType.INT8))
                fields.add(getStringReference(cl.name))
                def superPtr:String
                if cl.rawSuper !== null {
                    fields.add(getClassConstant(compiler.getClass(cl.rawSuper)!))
                }
                else {
                    fields.add(Code.Value.INT(0, Code.PrimitiveType.INT))
                }

                fields.add(getITable(cl))
                fields.add(Code.Value.ARRAY(Code.PrimitiveType.INT, FixedArray<Code.Value>.from(
                        vtable.map(m => (!m.annotations.isAbstract).choose(
                            Code.Value.METHOD_POINTER(self.getMethodTableEntry(m)),
                            Code.Value.INT(0, Code.PrimitiveType.INT))))
                ))
                writeGlobalValue(cc, Code.Value.STRUCT(FixedArray<Code.Value>.from(fields)))
            }
        }
        return result
    }

    method createMethodShim(raw:MethodDecl, effective:Type):(Code.Signature, Code) {
        try {
            def found := methodShims[raw]
            if found !== null {
                return found
            }
            assert effective.isMethod
            assert effective.subtypes.count = raw.parameters.count + 2 -- self and return
            assert raw.isInstance
            def oldRefs := refs
            refs := HashMap<IR.Statement.ID, Code.Value>()
            def oldStatements := statements
            statements := HashMap<IR.Statement.ID, Code.Statement.ID>()
            def oldBlocks := blocks
            blocks := HashMap<IR.Block.ID, Code.Block.ID>()
            def oldCasts := casts
            casts := HashMap<(String, Type), IR.Statement.ID>()
            def oldOut := out
            out := Array<Code.Statement>()
            def position := raw.methodPosition
            def indirect := needsStructIndirection(raw)
            def arguments := Array<Code.Value>()
            def effectiveReturnType:Code.PrimitiveType?
            if indirect | effective.returnType = compiler.VOID_TYPE {
                effectiveReturnType := null
            }
            else {
                effectiveReturnType := primitiveType(effective.returnType)
            }
            def parameters := Array<Code.PrimitiveType>()
            def start:Int
            if indirect {
                start := 1
                parameters.add(Code.PrimitiveType.INT)
                arguments.add(Code.Value.PARAMETER(0, Code.PrimitiveType.INT))
            }
            else {
                start := 0
            }
            for i in 0 .. effective.subtypes.count - 1 {
                parameters.add(primitiveType(effective.subtypes[i]))
            }
            if raw.annotations.isPointerSize {
                parameters.add(Code.PrimitiveType.INT)
            }
            var irId := 0
            def unrefs := Array<Code.Statement>()
            for i in 0 .. effective.subtypes.count - 1 {
                def rawType:Type
                if i = 0 {
                    rawType := raw.owner.type
                }
                else {
                    rawType := raw.parameters[i - 1].type
                }
                def p := IR.Value.PARAMETER(i + start, effective.subtypes[i])
                if rawType != effective.subtypes[i] {
                    def cast := IR.Statement.ID(irId)
                    irId += 1
                    convertCast(position, cast, p, rawType)
                    arguments.add(convertValue(IR.Value.REF(cast, rawType)))
                    if compiler.isValue(effective.subtypes[i]) & !compiler.isValue(rawType) {
                        def objectCast := IR.Statement.ID(irId)
                        irId += 1
                        convertCast(position, cast, IR.Value.REF(cast, rawType),
                                compiler.OBJECT_TYPE)
                        def variant := compiler.getRefVariant(rawType)
                        unrefs.add(Code.Statement.STATIC_CALL_VOID(position, Code.Signature(null,
                                null, "frost$core$Frost$unref\{variant}$frost$core$Object$Q",
                                FixedArray<Code.PrimitiveType>.from([Code.PrimitiveType.INT]),
                                true), FixedArray<Code.Value>.from([
                                    convertValue(IR.Value.REF(objectCast, compiler.OBJECT_TYPE))])))
                    }
                }
                else {
                    arguments.add(convertValue(p))
                }
            }
            def returnValue:Code.Value?
            if effective.returnType = compiler.VOID_TYPE | indirect {
                out.add(Code.Statement.STATIC_CALL_VOID(raw.methodPosition,
                        getSignature(raw), FixedArray<Code.Value>.from(arguments)))
                returnValue := null
            }
            else {
                def result := IR.Statement.ID(irId)
                irId += 1
                out.add(Code.Statement.STATIC_CALL(raw.methodPosition, mapId(result),
                        getSignature(raw), FixedArray<Code.Value>.from(arguments)))
                def returnCast := IR.Statement.ID(irId)
                irId += 1
                convertCast(position, returnCast, IR.Value.REF(result, raw.returnType),
                        effective.returnType)
                returnValue := convertValue(IR.Value.REF(returnCast, effective.returnType))
            }
            out.addAll(unrefs)
            out.add(Code.Statement.RETURN(position, returnValue))
            def block := Code.Block(Code.Block.ID(0), out)
            def code := Code()
            code.blocks.add(block)
            refs := oldRefs
            statements := oldStatements
            blocks := oldBlocks
            casts := oldCasts
            out := oldOut
            def shim := (Code.Signature(null, effectiveReturnType, getName(raw) + "$shim",
                    FixedArray<Code.PrimitiveType>.from(parameters), false), code)
            methodShims[raw] := shim
            return shim
        }
        fail(error) {
            unreachable
        }
    }

    method nextStatement():Code.Statement.ID {
        def result := Code.Statement.ID(nextStatementID)
        nextStatementID += 1
        return result
    }

    method mapId(id:IR.Statement.ID):Code.Statement.ID {
        var result := statements[id]
        if result == null {
            result := nextStatement()
            statements[id] := result
        }
        return result
    }

    method addRef(id:IR.Statement.ID, value:Code.Value) {
        refs[id] := value
        def early := earlyRefs[id]
        if early !== null {
            for r in early {
                r.value := value
            }
        }
    }

    method nextBlock():Code.Block.ID {
        def result := Code.Block.ID(nextBlockID)
        nextBlockID += 1
        return result
    }

    method mapId(id:IR.Block.ID):Code.Block.ID {
        var result := blocks[id]
        if result == null {
            result := nextBlock()
            blocks[id] := result
        }
        return result
    }

    method struct(cl:ClassDecl):Code.PrimitiveType {
        def types := Array<Code.PrimitiveType>()
        for f in compiler.instanceFields(cl) {
            compiler.resolve(f)
            -- we try to avoid having to calculate the size or offset of anything ourselves, so that
            -- we can function on various compilers and in both 32/64 bit mode. However, the one
            -- spot that (as far as I can tell) we can't just let the backend worry about it is in
            -- choices - we need the choice data structure to be big enough to hold any of the
            -- possible cases, so we figure out whichever case is the biggest and allocate that one.
            -- The issue, of course, is that which one is biggest depends on whether we're in 32 or
            -- 64 bit mode.
            -- Normally we know which one we're compiling for, but the one exception is bootstrap.c,
            -- which has to work in both 32 and 64 bit mode. So in that specific case, we compile in
            -- 32 bit mode, which works (even when compiled using for 64 bits) for everything but
            -- choices. So when compiling bootstrap choices, we temporarily force 64 bit mode. This
            -- isn't guaranteed to be correct - you can contrive cases where this produces the wrong
            -- results. But it gets us past the problem for now, and hopefully someone can figure
            -- out a better solution down the road.
            if f.name = ClassDecl.CHOICE_DATA_NAME {
                var size := 0
                def oldSize := settings.intSize
                if settings.isBootstrap {
                    settings.intSize := 8
                }
                for cc in cl.choiceCases {
                    size := size.max(Code.PrimitiveType.STRUCT(FixedArray<Code.PrimitiveType>(
                            cc.fields.map(primitiveType))).size(settings))
                }
                settings.intSize := oldSize
                types.add(Code.PrimitiveType.ARRAY(size, Code.PrimitiveType.INT8))
            }
            else {
                types.add(primitiveType(f.type))
            }
        }
        return Code.PrimitiveType.STRUCT(FixedArray<Code.PrimitiveType>.from(types))
    }

    function wrapperStruct(cl:ClassDecl):Code.PrimitiveType {
        def base := struct(compiler.getClass("frost.core.Object")!)
        match base {
            when Code.PrimitiveType.STRUCT(fields) {
                def finalFields := Array<Code.PrimitiveType>(fields)
                finalFields.add(struct(cl))
                return Code.PrimitiveType.STRUCT(FixedArray<Code.PrimitiveType>.from(finalFields))
            }
            otherwise {
                unreachable
            }
        }
    }

    function nullableStruct(cl:ClassDecl):Code.PrimitiveType {
        return Code.PrimitiveType.STRUCT(FixedArray<Code.PrimitiveType>.from(
                [primitiveType(cl.type), Code.PrimitiveType.BIT]))
    }

    ================================================================================================
    If this class contains only a single instance field (e.g. values like Int and Bit), returns the
    fields' primitive type. Otherwise, returns null.
    ================================================================================================
    method getSingleFieldStructType(cl:ClassDecl):Code.PrimitiveType? {
        def fields := compiler.instanceFields(cl)
        if fields.count = 1 {
            compiler.resolve(fields[0])
            return primitiveType(fields[0].type)
        }
        return null
    }

    method primitiveType(cl:ClassDecl):Code.PrimitiveType {
        def simpleType := getSingleFieldStructType(cl)
        if simpleType !== null {
            return simpleType
        }
        if compiler.isValue(cl) {
            return struct(cl)
        }
        return Code.PrimitiveType.INT
    }

    function primitiveType(type:Type):Code.PrimitiveType {
        match type.typeKind {
            when Type.Kind.BUILTIN_INT, Type.Kind.BUILTIN_UINT {
                if type = compiler.BUILTIN_INT_TYPE | type = compiler.BUILTIN_UINT_TYPE {
                    return Code.PrimitiveType.INT
                }
                match type.size {
                    when 8  { return Code.PrimitiveType.INT8  }
                    when 16 { return Code.PrimitiveType.INT16 }
                    when 32 { return Code.PrimitiveType.INT32 }
                    when 64 { return Code.PrimitiveType.INT64 }
                    otherwise { unreachable }
                }
            }
            when Type.Kind.BUILTIN_FLOAT {
                match type.size {
                    when 32 { return Code.PrimitiveType.FLOAT32 }
                    when 64 { return Code.PrimitiveType.FLOAT64 }
                }
            }
            when Type.Kind.BUILTIN_BIT {
                return Code.PrimitiveType.BIT
            }
            when Type.Kind.CLASS, Type.Kind.GENERIC {
                def cl := compiler.getClass(type)
                assert cl !== null, "unable to load class \{type}"
                return primitiveType(cl)
            }
            when Type.Kind.NULLABLE {
                def base := primitiveType(type.subtypes[0])
                if compiler.isValue(type.subtypes[0]) {
                    -- nullable value, add an 'isNull' field
                    return Code.PrimitiveType.STRUCT(FixedArray<Code.PrimitiveType>.from(
                            [base, Code.PrimitiveType.BIT]))
                }
                -- nullable object, still just a pointer
                return base
            }
            when Type.Kind.METHOD, Type.Kind.IMMUTABLE_METHOD, Type.Kind.FUNCTION,
                    Type.Kind.IMMUTABLE_FUNCTION {
                return Code.PrimitiveType.INT
            }
            when Type.Kind.GENERIC_CLASS_PARAMETER {
                return primitiveType(type.genericClassParameter.bound)
            }
            when Type.Kind.GENERIC_METHOD_PARAMETER {
                return primitiveType(type.genericMethodParameter.bound)
            }
            when Type.Kind.TUPLE {
                return primitiveType(compiler.getClass(type).type)
            }
        }
        unreachable, "unsupported type \{type}"
    }

    method convertValue(value:IR.Value):Code.Value {
        match value {
            when IR.Value.BIT(b, type) {
                return Code.Value.BIT(b)
            }
            when IR.Value.INT(i, type) {
                assert type.isBuiltinInt
                return Code.Value.INT(i, primitiveType(type))
            }
            when IR.Value.LOCAL(slot, type) {
                return Code.Value.STATEMENT(locals[slot], Code.PrimitiveType.INT)
            }
            when IR.Value.NULL(type) {
                def cl := compiler.getClass(type.subtypes[0])
                assert cl !== null
                if compiler.isValue(cl) {
                    return Code.Value.STRUCT(FixedArray<Code.Value>.from([
                        Code.Value.UNDEFINED(primitiveType(type.subtypes[0])),
                        Code.Value.BIT(false)
                    ]))
                }
                else {
                    return Code.Value.INT(0, Code.PrimitiveType.INT)
                }
            }
            when IR.Value.METHOD_POINTER(m, _) {
                return Code.Value.METHOD_POINTER(getSignature(m))
            }
            when IR.Value.PARAMETER(slot, type) {
                return Code.Value.PARAMETER(slot, primitiveType(type))
            }
            when IR.Value.REAL(f, type) {
                return Code.Value.REAL(f, primitiveType(type))
            }
            when IR.Value.REF(id, type) {
                def ref := refs[id]
                if ref !== null {
                    return ref
                }
                def s := statements[id]
                if s !== null {
                    return Code.Value.STATEMENT(s, primitiveType(type))
                }
                var list := earlyRefs[id]
                if list == null {
                    list := Array<Code.ValueRef>()
                    earlyRefs[id] := list
                }
                def valueRef := Code.ValueRef(Code.Value.STATEMENT(mapId(id), primitiveType(type)))
                list.add(valueRef)
                def result := Code.Value.REF(valueRef)
                refs[id] := result
                return result
            }
            when IR.Value.SIZE_OF(t) {
                return Code.Value.SIZE_OF(primitiveType(t))
            }
            when IR.Value.STRING(s, _) {
                return getStringReference(s)
            }
            otherwise {
                unreachable, "unsupported value \{value}"
            }
        }
    }

    function isNull(v:IR.Value):Bit {
        match v {
            when IR.Value.NULL {
                return true
            }
        }
        return false
    }

    method writeIsNull(position:MethodPosition, id:Code.Statement.ID, value:Code.Value) {
        try {
            match value.type {
                when Code.PrimitiveType.STRUCT {
                    def field := nextStatement()
                    out.add(Code.Statement.EXTRACT_FIELD(position, field, value, 1))
                    out.add(Code.Statement.NOTB(position, id, Code.Value.STATEMENT(field,
                            Code.PrimitiveType.BIT)))
                }
                otherwise {
                    out.add(Code.Statement.EQI(position, id, value,
                            Code.Value.INT(0, Code.PrimitiveType.INT)))
                }
            }
        }
        fail(error) {
            unreachable, error.toString
        }
    }

    method writeIsNonNull(position:MethodPosition, id:Code.Statement.ID, value:Code.Value) {
        try {
            match value.type {
                when Code.PrimitiveType.STRUCT {
                    out.add(Code.Statement.EXTRACT_FIELD(position, id, value, 1))
                }
                otherwise {
                    out.add(Code.Statement.NEQI(position, id, value,
                            Code.Value.INT(0, Code.PrimitiveType.INT)))
                }
            }
        }
        fail(error) {
            unreachable, error.toString
        }
    }

    method convertBinary(position:MethodPosition, result:Code.Statement.ID, rawLeft:IR.Value,
            op:Binary.Operator, rawRight:IR.Value, typeClass:TypeClass) {
        def left := convertValue(rawLeft)
        def right := convertValue(rawRight)
        match op {
            when Binary.Operator.ADD {
                match typeClass {
                    when TypeClass.SIGNED {
                        out.add(Code.Statement.ADDI(position, result, left, right,
                                Code.Wrap.CHECK_SIGNED))
                    }
                    when TypeClass.UNSIGNED {
                        out.add(Code.Statement.ADDI(position, result, left, right,
                                Code.Wrap.CHECK_UNSIGNED))
                    }
                    when TypeClass.FLOAT {
                        out.add(Code.Statement.ADDF(position, result, left, right))
                    }
                    otherwise {
                        unreachable
                    }
                }
            }
            when Binary.Operator.ADDU {
                out.add(Code.Statement.ADDI(position, result, left, right, Code.Wrap.UNCHECKED))
            }
            when Binary.Operator.SUB {
                match typeClass {
                    when TypeClass.SIGNED {
                        out.add(Code.Statement.SUBI(position, result, left, right,
                                Code.Wrap.CHECK_SIGNED))
                    }
                    when TypeClass.UNSIGNED {
                        out.add(Code.Statement.SUBI(position, result, left, right,
                                Code.Wrap.CHECK_UNSIGNED))
                    }
                    when TypeClass.FLOAT {
                        out.add(Code.Statement.SUBF(position, result, left, right))
                    }
                    otherwise {
                        unreachable
                    }
                }
            }
            when Binary.Operator.SUBU {
                out.add(Code.Statement.SUBI(position, result, left, right, Code.Wrap.UNCHECKED))
            }
            when Binary.Operator.MUL {
                match typeClass {
                    when TypeClass.SIGNED {
                        out.add(Code.Statement.MULI(position, result, left, right,
                                Code.Wrap.CHECK_SIGNED))
                    }
                    when TypeClass.UNSIGNED {
                        out.add(Code.Statement.MULI(position, result, left, right,
                                Code.Wrap.CHECK_UNSIGNED))
                    }
                    when TypeClass.FLOAT {
                        out.add(Code.Statement.MULF(position, result, left, right))
                    }
                    otherwise {
                        unreachable
                    }
                }
            }
            when Binary.Operator.MULU {
                out.add(Code.Statement.MULI(position, result, left, right, Code.Wrap.UNCHECKED))
            }
            when Binary.Operator.DIV {
                assert typeClass = TypeClass.FLOAT
                out.add(Code.Statement.DIVF(position, result, left, right))
            }
            when Binary.Operator.INTDIV {
                match typeClass {
                    when TypeClass.SIGNED {
                        out.add(Code.Statement.DIVS(position, result, left, right,
                                Code.Wrap.CHECK_SIGNED))
                    }
                    when TypeClass.UNSIGNED {
                        out.add(Code.Statement.DIVU(position, result, left, right))
                    }
                    otherwise {
                        unreachable
                    }
                }
            }
            when Binary.Operator.INTDIVU {
                match typeClass {
                    when TypeClass.SIGNED {
                        out.add(Code.Statement.DIVS(position, result, left, right,
                                Code.Wrap.UNCHECKED))
                    }
                    when TypeClass.UNSIGNED {
                        out.add(Code.Statement.DIVU(position, result, left, right))
                    }
                    otherwise {
                        unreachable
                    }
                }
            }
            when Binary.Operator.REM {
                match typeClass {
                    when TypeClass.SIGNED {
                        out.add(Code.Statement.REMS(position, result, left, right))
                    }
                    when TypeClass.UNSIGNED {
                        out.add(Code.Statement.REMU(position, result, left, right))
                    }
                    otherwise {
                        unreachable
                    }
                }
            }
            when Binary.Operator.EQ {
                match typeClass {
                    when TypeClass.SIGNED, TypeClass.UNSIGNED, TypeClass.BIT {
                        out.add(Code.Statement.EQI(position, result, left, right))
                    }
                    when TypeClass.FLOAT {
                        out.add(Code.Statement.EQF(position, result, left, right))
                    }
                    otherwise {
                        unreachable
                    }
                }
            }
            when Binary.Operator.NEQ {
                match typeClass {
                    when TypeClass.SIGNED, TypeClass.UNSIGNED, TypeClass.BIT {
                        out.add(Code.Statement.NEQI(position, result, left, right))
                    }
                    when TypeClass.FLOAT {
                        out.add(Code.Statement.NEQF(position, result, left, right))
                    }
                    otherwise {
                        unreachable
                    }
                }
            }
            when Binary.Operator.IDENTITY {
                if isNull(rawLeft) {
                    writeIsNull(position, result, right)
                    return
                }
                if isNull(rawRight) {
                    writeIsNull(position, result, left)
                    return
                }
                out.add(Code.Statement.EQI(position, result, left, right))
            }
            when Binary.Operator.NIDENTITY {
                if isNull(rawLeft) {
                    writeIsNonNull(position, result, right)
                    return
                }
                if isNull(rawRight) {
                    writeIsNonNull(position, result, left)
                    return
                }
                out.add(Code.Statement.NEQI(position, result, left, right))
            }
            when Binary.Operator.GT {
                match typeClass {
                    when TypeClass.SIGNED {
                        out.add(Code.Statement.GTS(position, result, left, right))
                    }
                    when TypeClass.UNSIGNED {
                        out.add(Code.Statement.GTU(position, result, left, right))
                    }
                    when TypeClass.FLOAT {
                        out.add(Code.Statement.GTF(position, result, left, right))
                    }
                    otherwise {
                        unreachable
                    }
                }
            }
            when Binary.Operator.LT {
                match typeClass {
                    when TypeClass.SIGNED {
                        out.add(Code.Statement.LTS(position, result, left, right))
                    }
                    when TypeClass.UNSIGNED {
                        out.add(Code.Statement.LTU(position, result, left, right))
                    }
                    when TypeClass.FLOAT {
                        out.add(Code.Statement.LTF(position, result, left, right))
                    }
                    otherwise {
                        unreachable
                    }
                }
            }
            when Binary.Operator.GTEQ {
                match typeClass {
                    when TypeClass.SIGNED {
                        out.add(Code.Statement.GES(position, result, left, right))
                    }
                    when TypeClass.UNSIGNED {
                        out.add(Code.Statement.GEU(position, result, left, right))
                    }
                    when TypeClass.FLOAT {
                        out.add(Code.Statement.GEF(position, result, left, right))
                    }
                    otherwise {
                        unreachable
                    }
                }
            }
            when Binary.Operator.LTEQ {
                match typeClass {
                    when TypeClass.SIGNED {
                        out.add(Code.Statement.LES(position, result, left, right))
                    }
                    when TypeClass.UNSIGNED {
                        out.add(Code.Statement.LEU(position, result, left, right))
                    }
                    when TypeClass.FLOAT {
                        out.add(Code.Statement.LEF(position, result, left, right))
                    }
                    otherwise {
                        unreachable
                    }
                }
            }
            when Binary.Operator.OR {
                assert typeClass = TypeClass.BIT
                out.add(Code.Statement.ORB(position, result, left, right))
            }
            when Binary.Operator.BITWISEOR {
                assert typeClass = TypeClass.SIGNED | typeClass = TypeClass.UNSIGNED
                out.add(Code.Statement.ORI(position, result, left, right))
            }
            when Binary.Operator.AND {
                assert typeClass = TypeClass.BIT
                out.add(Code.Statement.ANDB(position, result, left, right))
            }
            when Binary.Operator.BITWISEAND {
                assert typeClass = TypeClass.SIGNED | typeClass = TypeClass.UNSIGNED
                out.add(Code.Statement.ANDI(position, result, left, right))
            }
            when Binary.Operator.XOR {
                assert typeClass = TypeClass.BIT
                out.add(Code.Statement.XORB(position, result, left, right))
            }
            when Binary.Operator.BITWISEXOR {
                assert typeClass = TypeClass.SIGNED | typeClass = TypeClass.UNSIGNED
                out.add(Code.Statement.XORI(position, result, left, right))
            }
            when Binary.Operator.SHIFTLEFT {
                match typeClass {
                    when TypeClass.SIGNED {
                        out.add(Code.Statement.SHL(position, result, left, right,
                                Code.Wrap.CHECK_SIGNED))
                    }
                    when TypeClass.UNSIGNED {
                        out.add(Code.Statement.SHL(position, result, left, right,
                                Code.Wrap.CHECK_UNSIGNED))
                    }
                    otherwise {
                        unreachable
                    }
                }
            }
            when Binary.Operator.SHIFTLEFTU {
                assert typeClass = TypeClass.SIGNED | typeClass = TypeClass.UNSIGNED
                out.add(Code.Statement.SHL(position, result, left, right, Code.Wrap.UNCHECKED))
            }
            when Binary.Operator.SHIFTRIGHT {
                match typeClass {
                    when TypeClass.SIGNED {
                        out.add(Code.Statement.SHRS(position, result, left, right))
                    }
                    when TypeClass.UNSIGNED {
                        out.add(Code.Statement.SHRU(position, result, left, right))
                    }
                    otherwise {
                        unreachable
                    }
                }
            }
            otherwise {
                unreachable, "unsupported binary operator \{op}"
            }
        }
    }

    method wrapValue(position:MethodPosition, id:Code.Statement.ID, srcType:Type, value:Code.Value,
            dstType:Type) {
        try {
            def src := compiler.getClass(srcType)
            assert src !== null
            if srcType.typeKind = Type.Kind.NULLABLE {
                -- casting nullable value to nullable wrapper, need to special-case null
                def alloc := nextStatement()
                def type := primitiveType(dstType)
                block0.insert(0, Code.Statement.STACK_ALLOC(position, alloc, type))
                def isNonNull := nextStatement()
                out.add(Code.Statement.EXTRACT_FIELD(position, isNonNull, value, 1))
                def nonNullBlock := nextBlock()
                def nullBlock := nextBlock()
                def endBlock := nextBlock()
                out.add(Code.Statement.CONDITIONAL_BRANCH(position,
                        Code.Value.STATEMENT(isNonNull, Code.PrimitiveType.BIT), nonNullBlock,
                        nullBlock))
                createBlock(nonNullBlock)
                def nonNullable := nextStatement()
                out.add(Code.Statement.EXTRACT_FIELD(position, nonNullable, value, 0))
                def wrapped := nextStatement()
                wrapValue(position, wrapped, srcType.subtypes[0],
                        Code.Value.STATEMENT(nonNullable, primitiveType(srcType.subtypes[0])),
                        dstType)
                out.add(Code.Statement.STORE(position,
                        Code.Value.STATEMENT(wrapped, type),
                        Code.Value.STATEMENT(alloc, Code.PrimitiveType.INT)))
                out.add(Code.Statement.BRANCH(position, endBlock))
                createBlock(nullBlock)
                def nullValue := nextStatement()
                out.add(Code.Statement.STORE(position,
                        Code.Value.INT(0, Code.PrimitiveType.INT),
                        Code.Value.STATEMENT(alloc, Code.PrimitiveType.INT)))
                out.add(Code.Statement.BRANCH(position, endBlock))
                createBlock(endBlock)
                out.add(Code.Statement.LOAD(position,
                        id,
                        Code.Value.STATEMENT(alloc, Code.PrimitiveType.INT),
                        type))
                return
            }
            def cc := getClassConstant(src)
            def wrapper := wrapperStruct(src)
            out.add(Code.Statement.HEAP_ALLOC(position, id, wrapper, cc))
            def structPtr := nextStatement()
            def offset := Code.Value.FIELD_OFFSET(wrapper, VALUE_INDEX)
            out.add(Code.Statement.ADDI(position, structPtr, Code.Value.STATEMENT(id,
                    Code.PrimitiveType.INT), offset, Code.Wrap.UNCHECKED))
            out.add(Code.Statement.STORE(position, value,
                    Code.Value.STATEMENT(structPtr, Code.PrimitiveType.INT)))
        }
        fail(error) {
            unreachable
        }
    }

    method unwrapValue(position:MethodPosition, id:Code.Statement.ID, srcType:Type,
            value:Code.Value, dstType:Type) {
        try {
            def target := compiler.getClass(dstType)
            assert target !== null
            if dstType.typeKind = Type.Kind.NULLABLE {
                -- casting nullable wrapper to nullable value, need to special-case null
                def alloc := nextStatement()
                def type := primitiveType(dstType)
                block0.insert(0, Code.Statement.STACK_ALLOC(position, alloc, type))
                def isNonNull := nextStatement()
                out.add(Code.Statement.NEQI(position, isNonNull, value,
                        Code.Value.INT(0, Code.PrimitiveType.INT)))
                def nonNullBlock := nextBlock()
                def nullBlock := nextBlock()
                def endBlock := nextBlock()
                out.add(Code.Statement.CONDITIONAL_BRANCH(position,
                        Code.Value.STATEMENT(isNonNull, Code.PrimitiveType.BIT), nonNullBlock,
                        nullBlock))
                createBlock(nonNullBlock)
                def unwrapped := nextStatement()
                unwrapValue(position, unwrapped, srcType, value, dstType.subtypes[0])
                def nonNullValue := nextStatement()
                toNullableValue(position, nonNullValue, dstType.subtypes[0],
                        Code.Value.STATEMENT(unwrapped, primitiveType(dstType.subtypes[0])), dstType)
                out.add(Code.Statement.STORE(position,
                        Code.Value.STATEMENT(nonNullValue, type),
                        Code.Value.STATEMENT(alloc, Code.PrimitiveType.INT)))
                out.add(Code.Statement.BRANCH(position, endBlock))
                createBlock(nullBlock)
                def nullValue := nextStatement()
                out.add(Code.Statement.CREATE_STRUCT(position, nullValue,
                        Code.PrimitiveType.STRUCT(FixedArray<Code.PrimitiveType>.from([
                            primitiveType(dstType.subtypes[0]),
                            Code.PrimitiveType.BIT
                        ])),
                        FixedArray<Code.Value>.from([
                            Code.Value.UNDEFINED(primitiveType(dstType.subtypes[0])),
                            Code.Value.BIT(false)
                        ])))
                out.add(Code.Statement.STORE(position,
                        Code.Value.STATEMENT(nullValue, type),
                        Code.Value.STATEMENT(alloc, Code.PrimitiveType.INT)))
                out.add(Code.Statement.BRANCH(position, endBlock))
                createBlock(endBlock)
                out.add(Code.Statement.LOAD(position,
                        id,
                        Code.Value.STATEMENT(alloc, Code.PrimitiveType.INT),
                        type))
                return
            }
            def structPtr := nextStatement()
            def wrapper := wrapperStruct(target)
            def offset := Code.Value.FIELD_OFFSET(wrapper, VALUE_INDEX)
            out.add(Code.Statement.ADDI(position, structPtr, value, offset, Code.Wrap.UNCHECKED))
            out.add(Code.Statement.LOAD(position, id, Code.Value.STATEMENT(structPtr,
                    Code.PrimitiveType.INT), primitiveType(target)))
        }
        fail(error) {
            unreachable
        }
    }

    method toNullableValue(position:MethodPosition, id:Code.Statement.ID, srcType:Type,
            value:Code.Value, target:Type) {
        out.add(Code.Statement.CREATE_STRUCT(position, id,
                nullableStruct(compiler.getClass(srcType)),
                FixedArray<Code.Value>.from([value, Code.Value.BIT(true)])))
    }

    method toNonNullableValue(position:MethodPosition, id:Code.Statement.ID, srcType:Type,
            value:Code.Value, target:Type) {
        out.add(Code.Statement.EXTRACT_FIELD(position, id, value, 0))
    }

    method convertCast(position:MethodPosition, id:IR.Statement.ID, value:IR.Value, target:Type) {
        def src := value.type()
        if target.isBuiltinNumber {
            assert src.isBuiltinNumber
            if src.typeKind = Type.Kind.BUILTIN_INT {
                out.add(Code.Statement.CONVERTS(position, mapId(id), convertValue(value),
                        primitiveType(target)))
            }
            else {
                out.add(Code.Statement.CONVERTU(position, mapId(id), convertValue(value),
                        primitiveType(target)))
            }
            return
        }
        if src.typeKind != Type.Kind.BUILTIN_INT & src.typeKind != Type.Kind.BUILTIN_UINT {
            def srcClass := compiler.getClass(src)
            assert srcClass !== null, "class \{src} not found in cast at \{position}"
            def targetClass := compiler.getClass(target)
            assert targetClass !== null, "class \{target} not found"
            def srcValue := compiler.isValue(src)
            def targetValue := compiler.isValue(target)
            if srcValue & !targetValue {
                wrapValue(position, mapId(id), value.type(), convertValue(value), target)
                return
            }
            else if !srcValue & targetValue {
                unwrapValue(position, mapId(id), value.type(), convertValue(value), target)
                return
            }
            else if srcValue & target.typeKind = Type.Kind.NULLABLE & target.subtypes[0] = src {
                toNullableValue(position, mapId(id), value.type(), convertValue(value), target)
                return
            }
            else if targetValue & src.typeKind = Type.Kind.NULLABLE & src.subtypes[0] = target {
                toNonNullableValue(position, mapId(id), value.type(), convertValue(value), target)
                return
            }
        }
        -- else just a straight pointer cast, we don't actually have to do anything
        addRef(id, convertValue(value))
    }

    function escapeName(s:String):String {
        def result := MutableString(s.byteLength * 2)
        var current := s.start
        def end := s.end
        while current != end {
            def c := s[current]
            match c {
                when "."  { result.append("$") }
                when "?"  { result.append("$Q") }
                when "<"  { result.append("$LT") }
                when ">"  { result.append("$GT") }
                when " "  { -* do nothing *- }
                when ","  { result.append("$C") }
                when "("  { result.append("$LP") }
                when ")"  { result.append("$RP") }
                when "="  { result.append("$EQ") }
                when "&"  { result.append("$AM") }
                when "*"  { result.append("$ST") }
                when "["  { result.append("$LB") }
                when "]"  { result.append("$RB") }
                otherwise { result.append(c) }
            }
            current := s.next(current)
        }
        return result.finish()
    }

    method getName(m:MethodDecl):String {
        if m.annotations.externalName !== null & m.annotations.externalName != "" {
            return m.annotations.externalName
        }
        var result := nameCache[m]
        if result == null {
            if m.name = "main" {
                result := "frostMain"
            }
            else {
                def name := MutableString()
                name.append(escapeName(m.owner.name))
                name.append("$")
                match m.name {
                    when "+"    { name.append("$ADD") }
                    when "+&"   { name.append("$ADDU") }
                    when "-"    { name.append("$SUB") }
                    when "-&"   { name.append("$SUBU") }
                    when "*"    { name.append("$MUL") }
                    when "*&"   { name.append("$MULU") }
                    when "/"    { name.append("$DIV") }
                    when "//"   { name.append("$INTDIV") }
                    when "//&"  { name.append("$INTDIVU") }
                    when "%"    { name.append("$REM") }
                    when "^"    { name.append("$POW") }
                    when "[]"   { name.append("$IDX") }
                    when "[]:=" { name.append("$IDXEQ") }
                    when "="    { name.append("$EQ") }
                    when "!="   { name.append("$NEQ") }
                    when ">"    { name.append("$GT") }
                    when "<"    { name.append("$LT") }
                    when ">="   { name.append("$GE") }
                    when "<="   { name.append("$LE") }
                    when "|"    { name.append("$OR") }
                    when "||"   { name.append("$BOR") }
                    when "&"    { name.append("$AND") }
                    when "&&"   { name.append("$BAND") }
                    when "~"    { name.append("$XOR") }
                    when "~~"   { name.append("$BXOR") }
                    when "!"    { name.append("$NOT") }
                    when "!!"   { name.append("$BNOT") }
                    when "<<"   { name.append("$SHL") }
                    when "<<&"  { name.append("$SHLU") }
                    when ">>"   { name.append("$SHR") }
                    otherwise   { name.append(escapeName(m.name)) }
                }
                for p in m.parameters {
                    name.append("$\{escapeName(p.type.name)}")
                }
                if m.methodKind != MethodDecl.Kind.INIT & m.returnType != compiler.VOID_TYPE {
                    name.append("$R$")
                    name.append(escapeName(m.returnType.name))
                }
                result := name.finish()
            }
            nameCache[m] := result
        }
        return result
    }

    method getSignature(m:MethodDecl):Code.Signature {
        var result := declarations[m]
        if result == null {
            if !compiler.resolve(m) {
                return Code.Signature(null, null, "<error>",
                        FixedArray<Code.PrimitiveType>.from([]), true)
            }
            def parameters := Array<Code.PrimitiveType>()
            def returnType:Code.PrimitiveType?
            def declared := compiler.declaredTypeWithSelf(m, m.owner.type, false)
            if needsStructIndirection(m) {
                parameters.add(Code.PrimitiveType.INT)
                returnType := null
            }
            else {
                if declared.returnType != compiler.VOID_TYPE {
                    returnType := primitiveType(declared.returnType)
                }
                else {
                    returnType := null
                }
            }
            if compiler.hasSelfParam(m) {
                parameters.addAll(declared.parameterTypes.map(primitiveType))
            }
            else {
                parameters.addAll(declared.parameterTypes[1..].map(primitiveType))
            }
            if m.annotations.isPointerSize {
                parameters.add(Code.PrimitiveType.INT)
            }
            result := Code.Signature(m, returnType, getName(m),
                    FixedArray<Code.PrimitiveType>.from(parameters),
                    m.owner.external | m.annotations.isExternal)
            declarations[m] := result
        }
        return result
    }

    method getMethodTableEntry(m:MethodDecl):Code.Signature {
        if !compiler.resolve(m) {
            return Code.Signature(null, null, "<error>", FixedArray<Code.PrimitiveType>.from([]),
                    true)
        }
        getSignature(m)
        if compiler.hasSelfParam(m) {
            def isValue := compiler.isValue(m.owner)
            def resultName:String
            def selfType:Type
            if isValue {
                selfType := m.owner.type
            }
            else {
                selfType := compiler.OBJECT_TYPE
            }
            def declared := compiler.declaredTypeWithSelf(m, selfType, false)
            var inherited := compiler.inheritedTypeWithSelf(m, compiler.OBJECT_TYPE)
            if declared != inherited {
                def shim := createMethodShim(m, inherited)[0]
                resultName := shim.name
            }
            else {
                resultName := getName(m)
            }
            if needsStructIndirection(m) {
                def parameters := Array<Code.PrimitiveType>()
                parameters.add(Code.PrimitiveType.INT)
                parameters.addAll(inherited.parameterTypes.map(primitiveType))
                if m.annotations.isPointerSize {
                    parameters.add(Code.PrimitiveType.INT)
                }
                return Code.Signature(m, null, resultName, FixedArray<Code.PrimitiveType>.from(
                        parameters), m.owner.external)
            }
            def returnType:Code.PrimitiveType?
            if inherited.returnType != compiler.VOID_TYPE {
                returnType := primitiveType(inherited.returnType)
            }
            return Code.Signature(m, returnType, resultName,
                    FixedArray<Code.PrimitiveType>.from(inherited.parameterTypes.map(
                        primitiveType)), m.owner.external)
        }
        else {
            def parameters := Array<Code.PrimitiveType>()
            if compiler.hasSelfParam(m) {
                parameters.add(primitiveType(m.owner.type))
            }
            for p in m.parameters {
                parameters.add(primitiveType(p.type))
            }
            def returnType:Code.PrimitiveType?
            if m.returnType != compiler.VOID_TYPE {
                returnType := primitiveType(m.returnType)
            }
            else {
                returnType := null
            }
            return Code.Signature(m, returnType, getName(m),
                    FixedArray<Code.PrimitiveType>.from(parameters), m.owner.external)
        }
    }

    method convertStatement(id:IR.Statement.ID, s:IR.Statement) {
        match s {
            when IR.Statement.BINARY(position, left, op, right, type) {
                convertBinary(position, mapId(id), left, op, right,
                        TypeClass.from(left.type()))
            }
            when IR.Statement.BRANCH(position, target) {
                out.add(Code.Statement.BRANCH(position, mapId(target)))
            }
            when IR.Statement.CAST(position, value, target, _) {
                convertCast(position, id, value, target)
            }
            when IR.Statement.COMMENT(position, text) {
                out.add(Code.Statement.COMMENT(position, text))
            }
            when IR.Statement.GET_CHOICE_FIELD_POINTER(position, value, case, field) {
                def offset := Code.Value.CHOICE_FIELD_OFFSET(case, field)
                out.add(Code.Statement.ADDI(position, mapId(id), convertValue(value), offset,
                        Code.Wrap.UNCHECKED))
            }
            when IR.Statement.CONDITIONAL_BRANCH(position, value, ifTrue, ifFalse) {
                out.add(Code.Statement.CONDITIONAL_BRANCH(position, convertValue(value),
                        mapId(ifTrue), mapId(ifFalse)))
            }
            when IR.Statement.CONSTRUCT(position, cl) {
                def cc := getClassConstant(cl)
                out.add(Code.Statement.HEAP_ALLOC(position, mapId(id), struct(cl), cc))
            }
            when IR.Statement.CREATE_STRUCT(position, cl, args) {
                def finalArgs := Array<Code.Value>()
                for a in args {
                    finalArgs.add(convertValue(a))
                }
                def simpleType := getSingleFieldStructType(cl)
                if simpleType !== null {
                    -- don't actually use a struct, just use the single field type
                    assert args.count = 1
                    addRef(id, convertValue(args[0]))
                }
                else {
                    out.add(Code.Statement.CREATE_STRUCT(position, mapId(id), primitiveType(cl),
                            FixedArray<Code.Value>.from(finalArgs)))
                }
            }
            when IR.Statement.DYNAMIC_CALL(position, rawM, args) {
                def m := convertValue(rawM)
                def finalArgs := Array<Code.Value>()
                for a in args {
                    finalArgs.add(convertValue(a))
                }
                def returnType:Type
                if rawM.type().isPointer {
                    returnType := rawM.type().subtypes[1].returnType
                }
                else {
                    returnType := rawM.type().returnType
                }
                if returnType != compiler.VOID_TYPE {
                    out.add(Code.Statement.DYNAMIC_CALL(position, mapId(id),
                            primitiveType(returnType), m,
                            FixedArray<Code.Value>.from(finalArgs)))
                }
                else {
                    out.add(Code.Statement.DYNAMIC_CALL_VOID(position, m,
                            FixedArray<Code.Value>.from(finalArgs)))                    
                }
            }
            when IR.Statement.END {
                if currentMethod!.returnType == compiler.VOID_TYPE {
                    out.add(Code.Statement.RETURN(MethodPosition(), null))
                }
                else {
                    out.add(Code.Statement.UNREACHABLE(MethodPosition()))
                }
            }
            when IR.Statement.ENTER_SCOPE {
            }
            when IR.Statement.EXTRACT_FIELD(position, value, field) {
                def cl := compiler.getClass(value.type())
                if getSingleFieldStructType(cl) !== null {
                    addRef(id, convertValue(value))
                }
                else {
                    def index := compiler.getIndex(field)
                    out.add(Code.Statement.EXTRACT_FIELD(position, mapId(id), convertValue(value),
                            index))
                }
            }
            when IR.Statement.GET_FIELD_POINTER(position, value, field) {
                def index := compiler.getIndex(field)
                if index != 0 {
                    def converted := convertValue(value)
                    def offset := Code.Value.FIELD_OFFSET(struct(field.owner), index)
                    out.add(Code.Statement.ADDI(position, mapId(id), converted, offset,
                            Code.Wrap.UNCHECKED))
                }
                else {
                    addRef(id, convertValue(value))
                }
            }
            when IR.Statement.GET_VIRTUAL_METHOD(position, value, index, type) {
                def cc := getClassConstant(compiler.getClass(value.type())!)
                def cl := nextStatement()
                out.add(Code.Statement.LOAD(position, cl, convertValue(value),
                        Code.PrimitiveType.INT))
                def vtableSlot := nextStatement()
                out.add(Code.Statement.ADDI(position, vtableSlot,
                        Code.Value.STATEMENT(cl, Code.PrimitiveType.INT),
                        Code.Value.VTABLE_OFFSET(cc, index),
                        Code.Wrap.UNCHECKED))
                out.add(Code.Statement.LOAD(position, mapId(id), 
                        Code.Value.STATEMENT(vtableSlot, Code.PrimitiveType.INT),
                        Code.PrimitiveType.INT))
            }
            when IR.Statement.GET_INTERFACE_METHOD(position, value, cl, index, type) {
                def cc := getClassConstant(compiler.getClass(value.type())!)
                def ccType:Code.PrimitiveType
                match cc {
                    when Code.Value.GLOBAL_POINTER(idx) {
                        ccType := globals[idx].type
                    }
                    otherwise {
                        unreachable
                    }
                }
                def initialCl := nextStatement()
                out.add(Code.Statement.LOAD(position, initialCl, convertValue(value),
                        Code.PrimitiveType.INT))
                def itableStatement := nextStatement()
                block0.insert(0, Code.Statement.STACK_ALLOC(position, itableStatement,
                        Code.PrimitiveType.INT))
                def itable := Code.Value.STATEMENT(itableStatement, Code.PrimitiveType.INT)
                def itableSlot := nextStatement()
                out.add(Code.Statement.ADDI(position, itableSlot,
                        Code.Value.STATEMENT(initialCl, Code.PrimitiveType.INT),
                        Code.Value.FIELD_OFFSET(ccType, ITABLE_INDEX),
                        Code.Wrap.UNCHECKED))
                def initialItable := nextStatement()
                out.add(Code.Statement.LOAD(position, initialItable,
                        Code.Value.STATEMENT(itableSlot, Code.PrimitiveType.INT),
                        Code.PrimitiveType.INT))
                out.add(Code.Statement.STORE(position, Code.Value.STATEMENT(initialItable,
                        Code.PrimitiveType.INT), itable))
                def loopStart := nextBlock()
                def loopBody := nextBlock()
                def loopEnd := nextBlock()
                out.add(Code.Statement.BRANCH(position, loopStart))
                createBlock(loopStart)
                def itableLoad := nextStatement()
                out.add(Code.Statement.LOAD(position, itableLoad, itable, Code.PrimitiveType.INT))
                def clLoad := nextStatement()
                out.add(Code.Statement.LOAD(position, clLoad, Code.Value.STATEMENT(itableLoad,
                        Code.PrimitiveType.INT), Code.PrimitiveType.INT))
                def test := nextStatement()
                out.add(Code.Statement.EQI(position, test, Code.Value.STATEMENT(clLoad,
                        Code.PrimitiveType.INT), getClassConstant(cl)))
                out.add(Code.Statement.CONDITIONAL_BRANCH(position, Code.Value.STATEMENT(test,
                        Code.PrimitiveType.BIT), loopEnd, loopBody))
                createBlock(loopBody)
                def nextPtr := nextStatement()
                out.add(Code.Statement.ADDI(position, nextPtr, Code.Value.STATEMENT(itableLoad,
                        Code.PrimitiveType.INT), Code.Value.SIZE_OF(Code.PrimitiveType.INT),
                        Code.Wrap.UNCHECKED))
                def next := nextStatement()
                out.add(Code.Statement.LOAD(position, next, Code.Value.STATEMENT(nextPtr,
                        Code.PrimitiveType.INT), Code.PrimitiveType.INT))
                out.add(Code.Statement.STORE(position, Code.Value.STATEMENT(next,
                        Code.PrimitiveType.INT), itable))
                out.add(Code.Statement.BRANCH(position, loopStart))
                createBlock(loopEnd)
                def finalPtr := nextStatement()
                out.add(Code.Statement.ADDI(position, finalPtr, Code.Value.STATEMENT(itableLoad,
                        Code.PrimitiveType.INT), Code.Value.ITABLE_OFFSET(index),
                        Code.Wrap.UNCHECKED))
                out.add(Code.Statement.LOAD(position, mapId(id), Code.Value.STATEMENT(finalPtr,
                        Code.PrimitiveType.INT), Code.PrimitiveType.INT))
            }
            when IR.Statement.LOAD(position, value) {
                out.add(Code.Statement.LOAD(position, mapId(id), convertValue(value),
                        primitiveType(value.type())))
            }
            when IR.Statement.NEGATE(position, value) {
                if value.type().typeKind = Type.Kind.BUILTIN_FLOAT {
                    out.add(Code.Statement.NEGF(position, mapId(id), convertValue(value)))
                }
                else {
                    out.add(Code.Statement.NEGS(position, mapId(id), convertValue(value)))
                }
            }
            when IR.Statement.NOT(position, value) {
                if value.type().typeKind = Type.Kind.BUILTIN_BIT {
                    out.add(Code.Statement.NOTB(position, mapId(id), convertValue(value)))
                }
                else {
                    out.add(Code.Statement.NOTI(position, mapId(id), convertValue(value)))
                }
            }
            when IR.Statement.POINTER_GET(position, ptr, type) {
                out.add(Code.Statement.LOAD(position, mapId(id), convertValue(ptr),
                        primitiveType(type)))
            }
            when IR.Statement.POINTER_GET_INDEX(position, ptr, idx, type) {
                def offset := nextStatement()
                out.add(Code.Statement.MULI(position, offset, convertValue(idx),
                        Code.Value.SIZE_OF(primitiveType(type)), Code.Wrap.UNCHECKED))
                def add := nextStatement()
                out.add(Code.Statement.ADDI(position, add, convertValue(ptr),
                        Code.Value.STATEMENT(offset, Code.PrimitiveType.INT),
                        Code.Wrap.UNCHECKED))
                out.add(Code.Statement.LOAD(position, mapId(id),
                        Code.Value.STATEMENT(add, Code.PrimitiveType.INT),
                        primitiveType(type)))
            }
            when IR.Statement.POINTER_SET(position, value, ptr, type) {
                out.add(Code.Statement.STORE(position, convertValue(value), convertValue(ptr)))
            }
            when IR.Statement.POINTER_SET_INDEX(position, value, ptr, idx, type) {
                def offset := nextStatement()
                out.add(Code.Statement.MULI(position, offset, convertValue(idx),
                        Code.Value.SIZE_OF(primitiveType(type)), Code.Wrap.UNCHECKED))
                def add := nextStatement()
                out.add(Code.Statement.ADDI(position, add, convertValue(ptr),
                        Code.Value.STATEMENT(offset, Code.PrimitiveType.INT),
                        Code.Wrap.UNCHECKED))
                out.add(Code.Statement.STORE(position, convertValue(value),
                        Code.Value.STATEMENT(add, Code.PrimitiveType.INT)))
            }
            when IR.Statement.RETURN(position, value) {
                if value !== null {
                    out.add(Code.Statement.RETURN(position, convertValue(value)))
                }
                else {
                    out.add(Code.Statement.RETURN(position, null))
                }
            }
            when IR.Statement.STATIC_CALL(position, m, args) {
                if needsStructIndirection(m) {
                    def finalArgs := Array<Code.Value>()
                    def alloc := nextStatement()
                    def returnType := primitiveType(m.returnType)
                    block0.insert(0, Code.Statement.STACK_ALLOC(position, alloc, returnType))
                    finalArgs.add(Code.Value.STATEMENT(alloc, Code.PrimitiveType.INT))
                    for a in args {
                        finalArgs.add(convertValue(a))
                    }
                    out.add(Code.Statement.STATIC_CALL_VOID(position, getSignature(m),
                            FixedArray<Code.Value>.from(finalArgs)))
                    def result := mapId(id)
                    out.add(Code.Statement.LOAD(position, result,
                            Code.Value.STATEMENT(alloc, Code.PrimitiveType.INT), returnType))
                }
                else {
                    def finalArgs := Array<Code.Value>()
                    for a in args {
                        finalArgs.add(convertValue(a))
                    }
                    if m.returnType != compiler.VOID_TYPE {
                        out.add(Code.Statement.STATIC_CALL(position, mapId(id), getSignature(m),
                                FixedArray<Code.Value>.from(finalArgs)))
                    }
                    else {
                        out.add(Code.Statement.STATIC_CALL_VOID(position, getSignature(m),
                                FixedArray<Code.Value>.from(finalArgs)))
                    }
                }
            }
            when IR.Statement.STORE(position, value, ptr, _) {
                out.add(Code.Statement.STORE(position, convertValue(value), convertValue(ptr)))
            }
            when IR.Statement.SWITCH(position, value, cases, other) {
                def c := cases.map(c => (c[0], self.mapId(c[1])))
                out.add(Code.Statement.SWITCH(position, convertValue(value),
                        FixedArray<(UInt64, Code.Block.ID)>.from(c), mapId(other)))
            }
            when IR.Statement.UNREACHABLE(position) {
                out.add(Code.Statement.UNREACHABLE(position))
            }
            otherwise {
                unreachable, "unsupported statement \{s}"
            }
        }
    }

    method writeGlobal(global:Code.Global) {
        globalIndices[global] := globals.count
        globals.add(global)
        backend.writeGlobal(global)
    }

    method writeGlobalValue(global:Code.Global, value:Code.Value) {
        if globalIndices[global] == null {
            globalIndices[global] := globals.count
            globals.add(global)
        }
        backend.writeGlobalValue(global, value)
    }

    method createBlock(id:Code.Block.ID) {
        out := Array<Code.Statement>()
        outBlocks.add(Code.Block(id, out))
    }

    method convertBlock(block:IR.Block) {
        createBlock(mapId(block.id))
        if block.id.value = 0 {
            block0 := out
            for (_, _, l) in ir!.locals {
                def id := nextStatement()
                locals.add(id)
                def p := MethodPosition()
                out.add(Code.Statement.STACK_ALLOC(p, id, primitiveType(l)))
                if compiler.isRefCounted(l) {
                    out.add(Code.Statement.STORE(p,
                            Code.Value.INT(0, Code.PrimitiveType.INT),
                            Code.Value.STATEMENT(id, Code.PrimitiveType.INT)))
                }
            }        
        }
        def iter1 := block.ids.iterator
        def iter2 := block.statements.iterator
        while !iter1.done {
            convertStatement(iter1.next(), iter2.next())
        }
        casts.clear()
    }

    @pre(locals.count = 0 & statements.count = 0 & refs.count = 0 & blocks.count = 0)
    method convert(m:MethodDecl, ir:IR):Code {
        self.currentMethod := m
        self.ir := ir
        getClassConstant(m.owner)
        def result := Code()
        outBlocks := result.blocks
        ir.blocks.apply(convertBlock)
        locals.clear()
        statements.clear()
        blocks.clear()
        refs.clear()
        earlyRefs.clear()
        nextStatementID := 0
        nextBlockID := 0
        return result
    }
}