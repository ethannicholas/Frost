package org.frostlang.frostc

uses org.frostlang.frostc.Compiler.Expression
uses org.frostlang.frostc.expression.Binary
uses org.frostlang.frostc.parser.Token

@final
class LLVMCodeGenerator : CodeGenerator {
    -- FIXME remove this now that refcounting is reliable; should just be able to give constants a
    -- starting refcount of 1 and trust they'll never be destroyed
    constant NO_REFCNT := -999

    class ClassConstant : Immutable {
        def name:String
        def type:String

        init(name:String, type:String) {
            self.name := name
            self.type := type
        }
    }

    class MethodShim {
        def name:String
        def type:String

        init(name:String, type:String) {
            self.name := name
            self.type := type
        }
    }

    constant POINTER_SIZE        := 8
    constant OBJECT_FIELD_COUNT  := 2
    constant CLASS_POINTER_INDEX := 0
    constant ITABLE_INDEX        := 4
    constant VTABLE_INDEX        := 5

    constant INT_TYPE  := "i64"
    constant SIZE_TYPE := "i64"

    def physicalOut:OutputStream

    def out:OutputStream

    @weak
    def compiler:Compiler?

    def declarations := MemoryOutputStream()

    def types := MemoryOutputStream()

    def methods := MemoryOutputStream()

    def methodHeader := MemoryOutputStream()

    def shims := MemoryOutputStream()

    def strings := MemoryOutputStream()

    def metadata := MemoryOutputStream()

    def declared := HashSet<String>()

    def writtenTypes := HashSet<String>()

    def writtenWrappers := HashSet<String>()

    def classConstants := HashMap<String, ClassConstant>()

    var varCount := 0

    var labelCount := 0

    var metadataCount := 0

    var currentFileMetadata := "!error"

    var currentMethodMetadata:String?

    var lastDebugPosition := Position()

    var currentBlock := ""

    def sizes := IdentityMap<ClassDecl, Int>()

    def aligments := IdentityMap<ClassDecl, Int>()

    def choiceDataSizes := IdentityMap<ClassDecl, Int>()

    def methodShims := IdentityMap<MethodDecl, MethodShim>()

    def refs := HashMap<IR.Statement.ID, String>()

    def ir:IR

    init(triple:String, out:OutputStream) {
        self.physicalOut := out

        try {
            out.printLine("target datalayout = \"e-m:o-i64:64-f80:128-n8:16:32:64-S128\"")
            out.printLine("target triple = \"\{triple}\"")
            out.printLine("declare i8* @frostAlloc(\{SIZE_TYPE})")
            out.printLine("declare i8* @frostObjectAlloc(\{SIZE_TYPE}, %frost$core$Class*)")
            out.printLine("declare i8* @frostRealloc(i8*, \{SIZE_TYPE}, \{SIZE_TYPE})")
            out.printLine("declare void @frostFree(i8*)")
            out.printLine("declare i8* @memset(i8*, i8, \{SIZE_TYPE})")
            out.printLine("%$itable = type { %frost$core$Class*, %$itable*, [0 x i8*] }")
        }
        fail(error) {
            Console.printLine(error)
            System.exit(1)
        }
    }

    @override
    method setCompiler(compiler:Compiler) {
        self.compiler := compiler
    }

    @override
    method finish() {
        try {
            llvmType(Type.Class())
            physicalOut.print(types.finish())
            physicalOut.print(strings.finish())
            physicalOut.print(declarations.finish())
            physicalOut.print(shims.finish())
            physicalOut.print(methods.finish())
            physicalOut.print(metadata.finish())
            physicalOut.close()
        }
        fail(error) {
            Console.printLine(error)
            System.exit(1)
        }
    }

    method nextVar():String {
        varCount += 1
        return "%\{varCount}"
    }

    method nextLabel():String {
        labelCount += 1
        return "$l\{labelCount}"
    }

    method nextMetadata():String {
        metadataCount += 1
        return "!\{metadataCount}"
    }

    method createBlock(label:String, out:OutputStream) {
        try {
            out.printLine("\n\{label}:")
            currentBlock := label
        }
        fail(error) {
            unreachable, error.asString
        }
    }

    method fieldSize(t:Type):Int {
        assert t.resolved, "type \{t} was unresolved"
        if t = Type.Void() {
             -- void as the result of an error which should have been reported elsewhere
            return 1
        }
        if t.isBuiltinNumber {
            if t.name.endsWith("8") {
                return 1
            }
            if t.name.endsWith("16") {
                return 2
            }
            if t.name.endsWith("32") {
                return 4
            }
            assert t.name.endsWith("64")
            return 8
        }
        if t = Type.BuiltinBit() {
            return 1
        }
        def cl := compiler.getClass(t)
        if cl == null {
            return 0
        }
        if !compiler.isValue(cl) | cl.name = "frost.unsafe.Pointer" {
            return POINTER_SIZE
        }
        var result := 0
        for f in compiler.instanceFields(cl) {
            if f.annotations.isClass {
                continue
            }
            compiler.resolve(f)
            if f.type = Type.ChoiceData() {
                -- FIXME need to respect alignment!
                result += getChoiceDataSize(cl)
            }
            else {
                def size := fieldSize(f.type)
                def align := result % size
                if align != 0 {
                    result += size - align
                }
                assert result % size = 0
                result += size
            }
        }
        if t.typeKind = Type.Kind.NULLABLE {
            result += 1
        }
        return result
    }

    function alignment(t:Type):Int {
        if !t.isClass {
            return fieldSize(t)
        }
        def cl := compiler.getClass(t)
        assert cl !== null
        if !compiler.resolve(cl) {
            return POINTER_SIZE
        }
        if cl.name = "frost.unsafe.Pointer" | !compiler.isValue(cl) {
            return POINTER_SIZE
        }
        var cached := aligments[cl]
        if cached !== null {
            return cached
        }
        var result := 0
        for f in compiler.instanceFields(cl) {
            if !compiler.resolve(f) {
                continue
            }
            if f.type = Type.ChoiceData() {
                -- FIXME need to respect alignment!
                result := result.max(8)
            }
            else {
                result := result.max(alignment(f.type))
            }
        }
        aligments[cl] := result
        return result
    }

    method sizeOf(t:Type):Int {
        if !t.isClass {
            return fieldSize(t)
        }
        def cl := compiler.getClass(t)
        assert cl !== null
        assert cl.resolved = Compiler.Resolution.RESOLVED,
                "determining size of unresolved class \{cl.name}"
        if cl.name = "frost.unsafe.Pointer" {
            return POINTER_SIZE
        }
        var cached := sizes[cl]
        if cached !== null {
            return cached
        }
        var result := 0
        for f in compiler.instanceFields(cl) {
            if !compiler.resolve(f) {
                continue
            }
            if f.type = Type.ChoiceData() {
                -- FIXME need to respect alignment!
                result += getChoiceDataSize(cl)
            }
            else {
                def align := alignment(f.type)
                if result % align != 0 {
                    result += align - result % align
                }
                assert result % alignment(f.type) = 0, "field \{f} has alignment \{f.type} but is at offset \{result}"
                result += fieldSize(f.type)
            }
        }
        if compiler.isValue(cl) & t.typeKind = Type.Kind.NULLABLE {
            result += 1
        }
        def align := alignment(t)
        if result % align != 0 {
            result += align - result % align
        }
        sizes[cl] := result
        return result
    }

    function stride(t:Type):Int {
        return fieldSize(t)
    }

    function sizeOfWrapper(t:Type):Int {
        def cl := compiler.getClass(t)
        assert cl !== null & compiler.isValue(cl)
        var result := sizeOf(Type.Object())
        for f in compiler.instanceFields(cl) {
            compiler.resolve(f)
            if f.type = Type.ChoiceData() {
                 -- FIXME need to respect alignment!
                result += getChoiceDataSize(cl)
            }
            else {
                def size := fieldSize(f.type)
                def align := result % size
                if align != 0 {
                    result += size - align
                }
                assert result % size = 0
                result += size
            }
        }
        if t.typeKind = Type.Kind.NULLABLE {
            result += 1
        }
        return result
    }

    method getChoiceDataSize(cl:ClassDecl):Int {
        var result := choiceDataSizes[cl]
        if result == null {
            result := 0
            for entry in cl.choiceCases {
                compiler.resolve(entry)
                var current := 0
                for f in entry.fields {
                    -- FIXME need to respect alignment!
                    current += fieldSize(f)
                }
                result := result.max(current)
            }
            choiceDataSizes[cl] := result
        }
        return result
    }

    @post(compiler.currentClass.count = @pre(compiler.currentClass.count))
    method writeType(t:Type) {
        try {
            if !t.resolved {
                out.print("<unresolved type: \{t}>")
                return
            }
            if writtenTypes.contains(t.name) {
                return
            }
            writtenTypes.add(t.name)
            def cl := compiler.getClass(t)
            assert cl !== null
            assert !cl.annotations.isSpecialize
            compiler.resolve(cl)
            if cl.resolved != Compiler.Resolution.RESOLVED {
                out.print("<error resolving \{t}>")
                return
            }
            def code := MutableString("%\{escapeName(t.name)} = type { ")
            compiler.currentClass.push(cl)
            assert cl !== null
            var separator := ""
            for f in compiler.instanceFields(cl) {
                compiler.resolve(f)
                if !f.type.resolved {
                    compiler.currentClass.pop()
                    return
                }
                if f.type.isClass {
                    def fCl := compiler.getClass(f.type)
                    if fCl == null {
                        return
                    }
                    if !compiler.isValue(fCl) {
                        -- If we write the correct type definition here, we end up loading and parsing a
                        -- ton of otherwise-unused classes, for no other reason than to figure out their
                        -- type definitions (which we likely never use for anything else). Handling all
                        -- pointers as opaque i8* pointers massively reduces the number of files we need
                        -- to parse.
                        code.append("\{separator}i8*")
                        separator := ", "
                        continue
                    }
                }
                if f.type = Type.ChoiceData() {
                    code.append("\{separator}[\{getChoiceDataSize(cl)} x i8]")
                    separator := ", "
                    continue
                }
                code.append("\{separator}\{llvmType(f.type)}")
                separator := ", "
            }
            if t = Type.Class() {
                code.append(", %$itable*, [0 x i8*]")
            }
            code.append(" }")
            types.printLine(code.finish())
            if compiler.isValue(cl) {
                getWrapperClassConstant(cl)
            }
            compiler.currentClass.pop()
        }
        fail(error) {
            unreachable, error.asString
        }
        return
    }

    method writeWrapperType(t:Type) {
        try {
            if writtenWrappers.contains(t.name) {
                return
            }
            writtenWrappers.add(t.name)
            def code := MutableString("\{llvmType(t)}$wrapper = type { ")
            def object := compiler.getClass(Type.Object())
            assert object !== null
            var separator := ""
            for f in compiler.instanceFields(object) {
                compiler.resolve(f)
                code.append("\{separator}\{llvmType(f.type)}")
                separator := ", "
            }
            code.append(", \{llvmType(t)}")
            code.append(" }")
            types.printLine(code.finish())
            types.printLine("\{llvmType(t)}$nullable = type { \{llvmType(t)}, i1 }")
        }
        fail(error) {
            unreachable, error.asString
        }
    }

    function typeName(t:Type):String {
        return "%" + escapeName(t.name)
    }

    method llvmType(t:Type):String {
        if !t.resolved {
            return "<unresolved type: \{t}>"
        }
        match t.typeKind {
            when Type.Kind.VOID {
                return "void"
            }
            when Type.Kind.BUILTIN_INT, Type.Kind.BUILTIN_UINT {
                return "i\{sizeOf(t) * 8}"
            }
            when Type.Kind.BUILTIN_BIT {
                return "i1"
            }
            when Type.Kind.BUILTIN_FLOAT {
                match sizeOf(t) {
                    when 4    { return "float" }
                    when 8    { return "double" }
                    otherwise { unreachable }
                }
            }
            when Type.Kind.CLASS {
                writeType(t)
                def name := "%\{escapeName(t.name)}"
                def cl := compiler.getClass(t)
                assert cl !== null
                if !compiler.isValue(cl) {
                    return name + "*"
                }
                return name
            }
            when Type.Kind.NULLABLE {
                def cl := compiler.getClass(t)
                assert cl !== null, "unable to load \{t}"
                if compiler.isValue(cl) {
                    return nullableType(t)
                }
                return llvmType(t.subtypes[0])
            }
            when Type.Kind.GENERIC {
                if t.subtypes[0].name = "frost.unsafe.Pointer" {
                    if t.subtypes[1].isMethod {
                        return llvmMethodType(t.subtypes[1], null)
                    }
                    return llvmType(t.subtypes[1]) + "*"
                }
                def cl := compiler.getClass(t)
                if cl.isSpecialization() {
                    def name := "%\{escapeName(t.name)}"
                    def cl := compiler.getClass(t)
                    assert cl !== null
                    if !compiler.isValue(cl) {
                        return name + "*"
                    }
                    return name
                }
                return llvmType(t.subtypes[0])
            }
            when Type.Kind.GENERIC_CLASS_PARAMETER {
                return llvmType(t.genericClassParameter.bound)
            }
            when Type.Kind.GENERIC_METHOD_PARAMETER {
                return llvmType(t.genericMethodParameter.bound)
            }
            when Type.Kind.FUNCTION, Type.Kind.METHOD {
                return llvmType(Type.MutableMethod())
            }
            when Type.Kind.IMMUTABLE_FUNCTION, Type.Kind.IMMUTABLE_METHOD {
                return llvmType(Type.Method())
            }
            when Type.Kind.TUPLE {
                return llvmType(compiler.getClass(t).type)
            }
            otherwise {
                return "<unsupported type '\{t}'>"
            }
        }
    }

    ================================================================================================
    Returns the signature of a method type. Methods in Frost have two different types: normally they
    are manipulated as instances of [Method] or [MutableMethod], but sometimes we need the actual
    type signature of the underlying method. The [type()] function always returns
    `%frost.core.Method*` or `%frost.core.MutableMethod*`, whereas `methodType` returns the call
    signature of the method.
    ================================================================================================
    @pre(t.typeKind = Type.Kind.FUNCTION | t.typeKind = Type.Kind.METHOD |
            t.typeKind = Type.Kind.IMMUTABLE_FUNCTION | t.typeKind = Type.Kind.IMMUTABLE_METHOD |
            t.typeKind = Type.Kind.NULLABLE)
    method llvmMethodType(t:Type, selfType:Type?):String {
        def result := MutableString(llvmType(t.subtypes[t.subtypes.count - 1]))
        result.append(" (")
        var separator := ""
        if selfType !== null {
            result.append(llvmType(selfType))
            separator := ", "
        }
        for i in 0 .. t.subtypes.count - 1 {
            result.append(separator)
            result.append(llvmType(t.subtypes[i]))
            separator := ", "
        }
        result.append(")*")
        return result.finish()
    }

    method wrapperTypeName(t:Type):String {
        if t.typeKind = Type.Kind.NULLABLE {
            return wrapperTypeName(t.subtypes[0])
        }
        writeWrapperType(t)
        return "%\{escapeName(t.name)}$wrapper"
    }

    method wrapperType(t:Type):String {
        return wrapperTypeName(t) + "*"
    }

    method wrapperType(m:MethodDecl):String {
        def inheritedType := compiler.inheritedType(m)
        def result := MutableString()
        result.append(llvmType(inheritedType.returnType))
        result.append("(")
        assert m.isInstance()
        result.append("%\{escapeName(m.owner.name)}")
        if compiler.isValue(m.owner) {
            result.append("$wrapper")
        }
        result.append("*")
        for i in 0 .. inheritedType.subtypes.count - 1 { 
            result.append(", ")
            result.append(llvmType(inheritedType.subtypes[i]))
        }
        result.append(")*")
        return result.finish()
    }

    method nullableType(t:Type):String {
        assert t.typeKind = Type.Kind.NULLABLE, "\{t} is not nullable"
        writeWrapperType(t.subtypes[0])
        return "\{llvmType(t.subtypes[0])}$nullable"
    }

    method getITable(cl:ClassDecl):String {
        try {
            def interfaces := compiler.allInterfaces(cl.type)
            var previous := "%$itable* null"
            for intfType in interfaces {
                def intf := compiler.getClass(intfType)
                def intfCC := getClassConstant(intf)
                def methods := compiler.interfaceMethods(cl, intfType)
                def name := "@\{escapeName(cl.name)}$.\{escapeName(intf.name)}"
                def classType := llvmType(Type.Class())
                def t := "{\{classType}, %$itable*, [\{methods.count} x i8*] }"
                def intfCCCast:String
                if intfCC.type != llvmType(Type.Class()) {
                    intfCCCast := "bitcast(\{intfCC.type}* \{intfCC.name} to \{classType})"
                }
                else {
                    intfCCCast := intfCC.name
                }
                def result := MutableString("\{name} = ")
                if cl.isSpecialization() {
                    result.append("linkonce_odr ")
                }
                result.append("constant \{t} { \{classType} \{intfCCCast}, \{previous}, " +
                        "[\{methods.count} x i8*][")
                var separator := ""
                for m in methods {
                    result.append(separator)
                    separator := ", "
                    if m.annotations.isAbstract {
                        result.append("i8* null")
                    }
                    else {
                        def entry := getMethodTableEntry(m)
                        result.append("i8* bitcast(\{entry.second} \{entry.first} to i8*)")
                    }
                }
                result.append("] }\n")
                types.printLine(result.finish())
                previous := "%$itable* bitcast(\{t}* \{name} to %$itable*)"
            }
            return previous
        }
        fail(error) {
            unreachable
        }
    }

    method createMethodShim(raw:MethodDecl, effective:Type):MethodShim {
        try {
            def found := methodShims[raw]
            if found !== null {
                return found
            }
            def oldOut := out
            out := shims
            assert effective.isMethod
            assert effective.subtypes.count = raw.parameters.count + 2 -- self and return
            assert raw.isInstance()
            def unrefs := MemoryOutputStream()
            def oldVarCount := varCount
            varCount := 0
            def effectiveReturnType := effective.returnType
            def resultName := getName(raw) + "$shim"
            def resultType := MutableString(llvmType(effectiveReturnType))
            out.print("define linkonce_odr ")
            out.print("\{resultType} \{resultName}(")
            resultType.append("(")
            var separator := ""
            for i in 0 .. effective.subtypes.count - 1 {
                def pType := llvmType(effective.subtypes[i])
                resultType.append(", ")
                resultType.append(pType)
                out.print("\{separator}\{pType} %p\{i}")
                separator := ", "
            }
            resultType.append(")*")
            out.printLine(") {")
            currentBlock := "0"
            def casts := Array<String>()
            for i in 0 .. effective.subtypes.count - 1 {
                def p := "%p\{i}"
                def rawType:Type
                if i = 0 {
                    rawType := raw.owner.type
                }
                else {
                    rawType := raw.parameters[i - 1].type
                }
                if rawType != effective.subtypes[i] {
                    def cast := getCastReference(raw.position, p, effective.subtypes[i], rawType)
                    casts.add(cast)
                    if compiler.isValue(effective.subtypes[i]) & !compiler.isValue(rawType) {
                        labelCount += 1
                        def objectCast := "%objectCast\{labelCount}"
                        unrefs.printLine("\{objectCast} = bitcast \{llvmType(rawType)} \{cast} " +
                                "to %frost$core$Object*")
                        unrefs.printLine("call void @frost$core$Frost$unref$frost$core$Object$Q(" +
                                "%frost$core$Object* \{objectCast})")

                    }
                }
                else {
                    casts.add(p)
                }
            }
            def returnValue:String
            if raw.returnType != Type.Void() {
                returnValue := nextVar()
                out.print("\{returnValue} = ")
            }
            else {
                returnValue := "void"
            }
            out.print("call \{llvmType(raw.returnType)} \{getName(raw)}(")
            separator := ""
            for i in 0 .. effective.subtypes.count - 1 {
                def rawType:Type
                if i = 0 {
                    rawType := raw.owner.type
                }
                else {
                    rawType := raw.parameters[i - 1].type
                }
                out.print("\{separator}\{llvmType(rawType)} \{casts[i]}")
                separator := ", "
            }
            out.printLine(")")
            if raw.returnType != Type.Void() {
                returnValue := llvmType(effectiveReturnType) + " " +
                        getCastReference(raw.position, returnValue, raw.returnType,
                            effectiveReturnType)
            }
            out.printLine(unrefs)
            out.printLine("ret \{returnValue}")
            out.printLine("}")
            varCount := oldVarCount
            def result := MethodShim(resultName, resultType.finish())
            methodShims[raw] := result
            out := oldOut
            return result
        }
        fail(error) {
            unreachable
        }
    }

    method getWrapperITable(cl:ClassDecl):String {
        def interfaces := compiler.allInterfaces(cl.type)
        var previous := "%$itable* null"
        for intfType in interfaces {
            def intf := compiler.getClass(intfType)
            def intfCC := getClassConstant(intf)
            def methods := compiler.interfaceMethods(cl, intfType)
            def name := "@\{escapeName(cl.name)}$wrapper.\{escapeName(intf.name)}"
            def t := "{\{llvmType(Type.Class())}, %$itable*, [\{methods.count} x i8*] }"
            def intfCCCast:String
            if intfCC.type != llvmType(Type.Class()) {
                intfCCCast := "bitcast(\{intfCC.type}* \{intfCC.name} to \{llvmType(Type.Class())})"
            }
            else {
                intfCCCast := intfCC.name
            }
            def result := MutableString("\{name} = ")
            if cl.isSpecialization() {
                result.append("linkonce_odr ")
            }
            result.append("constant \{t} { \{llvmType(Type.Class())} \{intfCCCast}, \{previous}, " +
                    "[\{methods.count} x i8*][")
            var separator := ""
            for m in methods {
                result.append(separator)
                separator := ", "
                if m.annotations.isAbstract {
                    result.append("i8* null")
                }
                else {
                    def entry := getMethodTableEntry(m)
                    result.append("i8* bitcast(\{entry.second} \{entry.first} to i8*)")
                }
            }
            result.append("] }\n")
            try {
                types.printLine(result.finish())
            }
            fail(error) {
                unreachable, error.asString
            }
            previous := "%$itable* bitcast(\{t}* \{name} to %$itable*)"
        }
        return previous
    }

    ================================================================================================
    Returns true if this is an external method returning a struct.

    Returning structs from C functions into LLVM code is tricky. I tried it the naive and obvious
    way, and found it didn't work. Some cursory research indicated that C functions that return
    structs are at least sometimes compiled to accept a special pointer ("sret") as an extra
    parameter, and the caller is expected to know to alloca space for the return value and pass in a
    pointer to it.

    Since online sources were complaining about how poorly documented this is, there were
    indications that there may be multiple struct return strategies depending on the nature of
    the struct, people were suggesting looking at the assembly code generated by Clang to figure
    out how one was supposed to call a given function, and this all varies from platform to
    platform, we avoid the whole mess by making it explicit. External functions which wish to
    return structs explicitly receive a pointer to the result structure as their first parameter.
    ================================================================================================
    function needsStructIndirection(m:MethodDecl):Bit {
        if !m.returnType.isClass {
            return false
        }
        def result := m.annotations.isExternal & m.returnType.isClass &
                compiler.isValue(compiler.getClass(m.returnType))
        -- if an external method requires struct indirection, it will have a different signature
        -- than a non-external method; this means this feature doesn't play nice with overriding. We
        -- can fix this down the road with shims, but for right now just assert that a method
        -- requiring struct indirection is not an override and cannot be overridden
        assert !result | (!m.annotations.isOverride & (m.annotations.isFinal |
                m.annotations.isClass)), "invalid struct indirection on \{m.signature}"
        return result
    }

    method getMethodTableEntry(m:MethodDecl):Pair<String, String> -* name, type *- {
        if !compiler.resolve(m) {
            return Pair<String, String>("<error>", "<error>")
        }
        if m.owner.external {
            writeDeclaration(m)
        }
        def resultName:String
        def declared := compiler.declaredTypeWithSelf(m, m.owner.type, false)
        def effectiveSelf:Type
        if compiler.isValue(m.owner) {
            effectiveSelf := Type.Object()
        }
        else {
            effectiveSelf := m.owner.type
        }
        def inherited := compiler.inheritedTypeWithSelf(m, effectiveSelf)
        if declared != inherited {
            def shim := createMethodShim(m, inherited)
            resultName := shim.name
        }
        else {
            resultName := getName(m)
        }
        if needsStructIndirection(m) {
            def resultType := MutableString("void (")
            resultType.append(llvmType(inherited.subtypes[inherited.subtypes.count - 1]))
            resultType.append("*")
            for i in 0 .. inherited.subtypes.count - 1 {
                resultType.append(", ")
                resultType.append(llvmType(inherited.subtypes[i]))
            }
            resultType.append(")*")
            return Pair<String, String>(resultName, resultType.finish())
        }
        return Pair<String, String>(resultName, llvmMethodType(inherited, null))
    }

    method getClassConstant(cl:ClassDecl):ClassConstant {
        try {
            assert !cl.annotations.isSpecialize
            var result := classConstants[cl.name]
            if result == null {
                compiler.resolve(cl)
                def type:String
                if cl.external {
                    result := ClassConstant("@\{escapeName(cl.type.name)}$class",
                            "%frost$core$Class")
                    classConstants[cl.name] := result
                    types.printLine("\{result.name} = external global \{result.type}")
                    return classConstants[cl.name]
                }
                def vtable := compiler.getVTable(cl)
                result := ClassConstant("@\{escapeName(cl.type.name)}$class",
                        "{ %frost$core$Class*, \{INT_TYPE}, %frost$core$String*, " +
                        "%frost$core$Class*, %$itable*, [\{vtable.count} x i8*] }")
                classConstants[cl.name] := result
                def superPtr:String
                if cl.rawSuper !== null {
                    def superCC := getClassConstant(compiler.getClass(cl.rawSuper))
                    superPtr := "bitcast(\{superCC.type}* \{superCC.name} to %frost$core$Class*)"
                }
                else {
                    superPtr := "null"
                }
                def clConstant := getClassConstant(compiler.getClass(Type.Class()))
                def code := MutableString("\{result.name} = ")
                if cl.isSpecialization() {
                    code.append("linkonce_odr ")
                }
                code.append("constant \{result.type} { " +
                        "%frost$core$Class* bitcast(\{clConstant.type}* \{clConstant.name} to " +
                        "%frost$core$Class*), \{INT_TYPE} \{NO_REFCNT}, %frost$core$String* " +
                        getStringReference(cl.name) + ", %frost$core$Class* \{superPtr}, " +
                        "\{getITable(cl)}, [\{vtable.count} x i8*] [")
                var separator := ""
                for m in vtable {
                    code.append(separator)
                    if m.annotations.isAbstract {
                        code.append("i8* null")
                    }
                    else {
                        def entry := getMethodTableEntry(m)
                        code.append("i8* bitcast(\{entry.second} \{entry.first} to i8*)")
                    }
                    separator := ", "
                }
                code.append("] }\n")
                types.printLine(code.finish())
            }
            return result
        }
        fail(error) {
            unreachable
        }
    }

    method getWrapperClassConstant(cl:ClassDecl):ClassConstant {
        try {
            assert !cl.type.isPointer, "trying to wrap \{cl.name}"
            if !compiler.resolve(cl) {
                return ClassConstant("<error>", "<error>")
            }
            def name := "@\{escapeName(cl.name)}$wrapperclass"
            var result := classConstants[name]
            if result == null {
                if cl.external {
                    llvmType(Type.Class())
                    def type := "%frost$core$Class"
                    types.printLine("\{name} = external global \{type}")
                    result := ClassConstant(name, type)
                    classConstants[name] := result
                }
                else {
                    def value := compiler.getClass(Type.Value())
                    def valueVTable := compiler.getVTable(value)
                    result := ClassConstant("@\{escapeName(cl.name)}$wrapperclass",
                            "{ %frost$core$Class*, \{INT_TYPE}, %frost$core$String*, " +
                            "%frost$core$Class*, %$itable*, [\{valueVTable.count} x i8*] }")
                    classConstants[name] := result
                    def vtable := compiler.getVTable(cl)
                    def superCC := getClassConstant(compiler.getClass(cl.rawSuper))
                    def superCast:String
                    if superCC.type != llvmType(Type.Class()) {
                        superCast := "bitcast(\{superCC.type}* \{superCC.name} to %frost$core$Class*)"
                    }
                    else {
                        superCast := superCC.name
                    }
                    def itable := getWrapperITable(cl)
                    def clConstant := getClassConstant(compiler.getClass(Type.Class()))
                    def code := MutableString("\{result.name} = ")
                    if cl.isSpecialization() {
                        code.append("linkonce_odr ")
                    }
                    code.append("constant \{result.type} { " +
                            "%frost$core$Class* bitcast(\{clConstant.type}* \{clConstant.name} to " +
                            "%frost$core$Class*), \{INT_TYPE} \{NO_REFCNT}, %frost$core$String* " +
                            "\{getStringReference(cl.name)}, \{llvmType(Type.Class())} \{superCast}, " +
                            "\{itable}, [\{valueVTable.count} x i8*] [")
                    var separator := ""
                    for i in 0 .. valueVTable.count {
                        def m := vtable[i]
                        def entry := getMethodTableEntry(m)
                        code.append("\{separator}i8* bitcast(\{entry.second} \{entry.first} to i8*)")
                        separator := ", "
                    }
                    code.append("] }\n")
                    types.print(code.finish())
                }
            }
            return result
        }
        fail(error) {
            unreachable
        }
    }

    function escapeName(s:String):String {
        def result := MutableString(s.byteLength * 2)
        var current := s.start
        def end := s.end
        while current != end {
            def c := s[current]
            match c {
                when "."  { result.append("$") }
                when "?"  { result.append("$Q") }
                when "<"  { result.append("$LT") }
                when ">"  { result.append("$GT") }
                when " "  { -* do nothing *- }
                when ","  { result.append("$C") }
                when "("  { result.append("$LP") }
                when ")"  { result.append("$RP") }
                when "="  { result.append("$EQ") }
                when "&"  { result.append("$AM") }
                when "*"  { result.append("$ST") }
                otherwise { result.append(c) }
            }
            current := s.next(current)
        }
        return result.finish()
    }

    function getName(v:Variable):String {
        return "%\{v.name}"
    }

    function getName(m:MethodDecl):String {
        if m.name = "main" {
            return "@frostMain"
        }
        def result := MutableString("@")
        result.append(escapeName(m.owner.name))
        result.append("$")
        match m.name {
            when "+"    { result.append("$ADD") }
            when "-"    { result.append("$SUB") }
            when "*"    { result.append("$MUL") }
            when "/"    { result.append("$DIV") }
            when "//"   { result.append("$INTDIV") }
            when "%"    { result.append("$REM") }
            when "^"    { result.append("$POW") }
            when "[]"   { result.append("$IDX") }
            when "[]:=" { result.append("$IDXEQ") }
            when "="    { result.append("$EQ") }
            when "!="   { result.append("$NEQ") }
            when ">"    { result.append("$GT") }
            when "<"    { result.append("$LT") }
            when ">="   { result.append("$GE") }
            when "<="   { result.append("$LE") }
            when "|"    { result.append("$OR") }
            when "||"   { result.append("$BOR") }
            when "&"    { result.append("$AND") }
            when "&&"   { result.append("$BAND") }
            when "~"    { result.append("$XOR") }
            when "~~"   { result.append("$BXOR") }
            when "!"    { result.append("$NOT") }
            when "!!"   { result.append("$BNOT") }
            when "<<"   { result.append("$SHL") }
            when ">>"   { result.append("$SHR") }
            otherwise   { result.append(escapeName(m.name)) }
        }
        for p in m.parameters {
            result.append("$\{escapeName(p.type.name)}")
        }
        if m.methodKind != MethodDecl.Kind.INIT & m.returnType != Type.Void() {
            result.append("$R$")
            result.append(escapeName(m.returnType.name))
        }
        return result.finish()
    }

    function getName(f:FieldDecl):String {
        assert f.annotations.isClass
        return "@\{escapeName(f.owner.name)}$\{f.name}"
    }

    choice OpClass {
        SIGNED
        UNSIGNED
        FLOAT
        CLASS
    }

    function opClass(t:Type):OpClass {
        match t.typeKind {
            when Type.Kind.BUILTIN_INT {
                return OpClass.SIGNED
            }
            when Type.Kind.BUILTIN_UINT, Type.Kind.BUILTIN_BIT {
                return OpClass.UNSIGNED
            }
            when Type.Kind.BUILTIN_FLOAT {
                return OpClass.FLOAT
            }
            otherwise {
                return OpClass.CLASS
            }
        }
    }

    method wrapValue(position:Position, value:String, srcType:Type, dstType:Type,
            out:OutputStream):String {
        try {
            def src := compiler.getClass(srcType)
            assert src !== null
            if srcType.typeKind = Type.Kind.NULLABLE {
                -- casting nullable value to nullable wrapper, need to special-case null
                def testStart := currentBlock
                def isNonNull := nextVar()
                out.printLine("\{isNonNull} = extractvalue \{nullableType(srcType)} \{value}, 1" +
                        debugInfo(position))
                def nonNullLabel := nextLabel()
                def endLabel := nextLabel()
                out.printLine("br i1 \{isNonNull}, label %\{nonNullLabel}, label %\{endLabel}" +
                        debugInfo(position))
                createBlock(nonNullLabel, out)
                def unwrapped := toNonNullableValue(position, value, srcType, srcType.subtypes[0],
                        out)
                def nonNullValue := wrapValue(position, unwrapped, srcType.subtypes[0], dstType,
                        out)
                out.printLine("br label %\{endLabel}\{debugInfo(position)}")
                createBlock(endLabel, out)
                def result := nextVar()
                out.printLine("\{result} = phi \{llvmType(dstType)} [null, %\{testStart}], " +
                        "[\{nonNullValue}, %\{nonNullLabel}]")
                return result
            }
            def cc := getWrapperClassConstant(src)
            def ccCast:String
            if cc.type != "%frost$core$Class" {
                ccCast := "bitcast(\{cc.type}* \{cc.name} to %frost$core$Class*)"
            }
            else {
                ccCast := cc.name
            }
            def mallocRef := nextVar()
            out.printLine("\{mallocRef} = call i8* @frostObjectAlloc(" +
                    "i64 \{sizeOfWrapper(src.type)}, %frost$core$Class* \{ccCast})" +
                    debugInfo(position))
            def wrapperTypeName := wrapperTypeName(src.type)
            def wrapperType := wrapperType(src.type)
            def wrapperCast := nextVar()
            out.printLine("\{wrapperCast} = bitcast i8* \{mallocRef} to \{wrapperType}" +
                    debugInfo(position))
            def target := nextVar()
            out.printLine("\{target} = getelementptr \{wrapperTypeName}, " +
                    "\{wrapperType} \{wrapperCast}, i64 0, i32 2\{debugInfo(position)}")
            out.printLine("store \{llvmType(srcType)} \{value}, \{llvmType(srcType)}* \{target}" +
                    debugInfo(position))
            if wrapperType != llvmType(dstType) {
                def result := nextVar()
                out.printLine("\{result} = bitcast \{wrapperType} \{wrapperCast} to " +
                        llvmType(dstType) + debugInfo(position))
                return result
            }
            return wrapperCast
        }
        fail(error) {
            unreachable
        }
    }

    method unwrapValue(position:Position, value:String, srcType:Type, dstType:Type,
            out:OutputStream):String {
        try {
            def target := compiler.getClass(dstType)
            assert target !== null
            if dstType.typeKind = Type.Kind.NULLABLE {
                -- casting nullable wrapper to nullable value, need to special-case null
                def testStart := currentBlock
                def isNonNull := nextVar()
                out.printLine("\{isNonNull} = icmp ne \{llvmType(srcType)} \{value}, null" +
                        debugInfo(position))
                def nonNullLabel := nextLabel()
                def endLabel := nextLabel()
                out.printLine("br i1 \{isNonNull}, label %\{nonNullLabel}, label %\{endLabel}" +
                        debugInfo(position))
                createBlock(nonNullLabel, out)
                def wrapped := unwrapValue(position, value, srcType, dstType.subtypes[0], out)
                def nonNullValue := toNullableValue(position, wrapped, dstType.subtypes[0], dstType,
                        out)
                out.printLine("br label %\{endLabel}\{debugInfo(position)}")
                createBlock(endLabel, out)
                def result := nextVar()
                out.printLine("\{result} = phi \{llvmType(dstType)} " +
                        "[{ \{llvmType(dstType.subtypes[0])} undef, i1 0 }, " +
                        "%\{testStart}], [\{nonNullValue}, %\{nonNullLabel}]")
                return result
            }
            def targetType := llvmType(dstType)
            def wrapperTypeName := wrapperTypeName(dstType)
            def wrapperType := wrapperType(dstType)
            def srcCast := nextVar()
            out.printLine("\{srcCast} = bitcast \{llvmType(srcType)} \{value} to \{wrapperType}" +
                    debugInfo(position))
            def load := nextVar()
            out.printLine("\{load} = load \{wrapperTypeName}, \{wrapperType} \{srcCast}" +
                    debugInfo(position))
            def result := nextVar()
            out.printLine("\{result} = extractvalue \{wrapperTypeName} \{load}, " +
                    "\{OBJECT_FIELD_COUNT}\{debugInfo(position)}")
            return result
        }
        fail(error) {
            unreachable
        }
    }

    method toNullableValue(position:Position, value:String, srcType:Type, dstType:Type,
            out:OutputStream):String {
        try {
            def nullableType := nullableType(dstType)
            def result := nextVar()
            out.printLine("\{result} = insertvalue \{nullableType} " +
                    "{ \{llvmType(srcType)} undef, i1 true }, \{llvmType(srcType)} \{value}, 0" +
                    debugInfo(position))
            return result
        }
        fail(error) {
            unreachable
        }
    }

    method toNonNullableValue(position:Position, value:String, srcType:Type, dstType:Type,
            out:OutputStream):String {
        try {
            def result := nextVar()
            out.printLine("\{result} = extractvalue \{llvmType(srcType)} \{value}, 0" +
                    debugInfo(position))
            return result
        }
        fail(error) {
            unreachable
        }
    }

    method getCastReference(position:Position, value:String, src:Type, target:Type):String {
        def op:String
        if target.isBuiltinNumber {
            assert src.isBuiltinNumber
            def size1 := sizeOf(src)
            def size2 := sizeOf(target)
            if src.typeKind = Type.Kind.BUILTIN_FLOAT {
                if target.typeKind = Type.Kind.BUILTIN_FLOAT {
                    if size1 > size2 {
                        op := "fptrunc"
                    }
                    else if size1 < size2 {
                        op := "fpext"
                    }
                    else {
                        return value
                    }
                }
                else if target.typeKind = Type.Kind.BUILTIN_INT {
                    op := "fptosi"
                }
                else {
                    assert target.typeKind = Type.Kind.BUILTIN_UINT
                    op := "fptoui"
                }
            }
            else if target.typeKind = Type.Kind.BUILTIN_FLOAT {
                if src.typeKind = Type.Kind.BUILTIN_INT {
                    op := "sitofp"
                }
                else {
                    assert src.typeKind = Type.Kind.BUILTIN_UINT
                    op := "uitofp"
                }
            }
            else {
                if size1 > size2 {
                    op := "trunc"
                }
                else if size1 < size2 {
                    if src.typeKind = Type.Kind.BUILTIN_INT {
                        op := "sext"
                    }
                    else {
                        op := "zext"
                    }
                }
                else {
                    return value
                }
            }
        }
        else if src.isPointer | target.isPointer {
            op := "bitcast"
        }
        else {
            def srcClass := compiler.getClass(src)
            assert srcClass !== null, "class \{src} not found"
            def targetClass := compiler.getClass(target)
            assert targetClass !== null, "class \{target} not found"
            if compiler.isValue(srcClass) & !compiler.isValue(targetClass) {
                return wrapValue(position, value, src, target, out)
            }
            else if !compiler.isValue(srcClass) & compiler.isValue(targetClass) {
                return unwrapValue(position, value, src, target, out)
            }
            else if compiler.isValue(srcClass) & target.typeKind = Type.Kind.NULLABLE &
                    target.subtypes[0] = src {
                return toNullableValue(position, value, src, target, out)
            }
            else if compiler.isValue(targetClass) & src.typeKind = Type.Kind.NULLABLE &
                    src.subtypes[0] = target {
                return toNonNullableValue(position, value, src, target, out)
            }
            op := "bitcast"
        }
        def srcType := llvmType(src)
        def dstType := llvmType(target)
        if srcType = dstType {
            return value
        }
        def result := nextVar()
        try {
            out.printLine("\{result} = \{op} \{srcType} \{value} to \{dstType}" +
                    debugInfo(position))
        }
        fail(error) {
            unreachable, error.asString
        }
        return result
    }

    method getRealReference(t:Type, r64:Real64):String {
        if t.size = 32 {
            -- LLVM has a bizarre representation of float. You still use a double, but must ensure
            -- that said double is exactly representable as a float. We convert through Real32 to
            -- ensure this.
            def r32 := r64.asReal32.asReal64
            return "0x\{Frost.floatToIntBits(r32):x}"
        }
        return "0x\{Frost.floatToIntBits(r64):x}"
    }

    method getStringReference(s:String):String {
        try {
            labelCount += 1
            def chars := "@$chars\{labelCount}"
            def charsType := "[\{s.utf8.count} x i8]"
            strings.print("\{chars} = private unnamed_addr constant \{charsType} [ ")
            var separator := ""
            for c in s.utf8 {
                strings.print("\{separator}i8 \{c.asInt8}")
                separator := ", "
            }
            strings.printLine(" ]")
            labelCount += 1
            def result := "@$str\{labelCount}"
            def string := compiler.getClass(Type.StringType())
            assert string !== null
            def cc := getClassConstant(string)
            strings.printLine("\{result} = private unnamed_addr constant %frost$core$String { " +
                    "i8* bitcast(\{cc.type}* \{cc.name} to " +
                    "i8*), %frost$core$Int32 insertvalue(%frost$core$Int32 " +
                    "{ i32 undef }, i32 \{NO_REFCNT}, 0), " +
                    "%frost$core$Char8* bitcast(\{charsType}* \{chars} " +
                    "to %frost$core$Char8*), %frost$core$Int64 { i64 \{s.utf8.count} }, " +
                    "%frost$core$Int64 { i64 \{s.hash} }, i8* null }")
            return result
        }
        fail(error) {
            unreachable
        }
    }

    ================================================================================================
    In init methods, %self must be a pointer rather than a value, so that we can modify our fields.
    This returns true if our current %self is a pointer to a value.
    ================================================================================================
    function haveSelfValuePointer():Bit {
        return compiler.currentMethod[0].methodKind = MethodDecl.Kind.INIT &
                compiler.isValue(compiler.currentMethod[0].owner)
    }

    ================================================================================================
    Returns the current %self, as a pointer. For values, this pointer is only available from within
    init methods.
    ================================================================================================
    method getSelfPointer():String {
        assert compiler.currentMethod[0].methodKind = MethodDecl.Kind.INIT |
                !compiler.isValue(compiler.currentMethod[0].owner),
                "self pointer for values is only accessible from init methods " +
                "(in \{compiler.currentMethod[0].declaration})"
        return "%self"
    }

    ================================================================================================
    Returns the current %self, as a value if the current object is a value. For non-value objects
    %self is always a pointer.
    ================================================================================================
    method getSelfValue(out:OutputStream):String {
        try {
            assert compiler.currentMethod[0] !== null
            if haveSelfValuePointer() {
                def load := nextVar()
                out.printLine("\{load} = load \{llvmType(compiler.currentMethod[0].owner.type)}, " +
                        "\{llvmType(compiler.currentMethod[0].owner.type)}* \{getSelfPointer()}")
                return load
            }
            return "%self"
        }
        fail(error) {
            unreachable
        }
    }

    method getNullReference(t:Type):String {
        assert t.typeKind = Type.Kind.NULLABLE
        def cl := compiler.getClass(t.subtypes[0])
        assert cl !== null
        if compiler.isValue(cl) {
            return "{ \{llvmType(t.subtypes[0])} undef, i1 0 }"
        }
        else {
            return "null"
        }
    }

    method getChoiceFieldOffset(e:ChoiceCase, index:Int):Int {
        var result := 0
        for i in 0 .. index {
            -- FIXME need to respect alignment!
            result += fieldSize(e.fields[i])
        }
        return result
    }

    method selfType(m:MethodDecl):String {
        def result := llvmType(m.owner.type)
        if m.methodKind = MethodDecl.Kind.INIT & !result.endsWith("*") {
            return result + "*"
        }
        return result
    }

    @override
    method writeDeclaration(m:MethodDecl) {
        try {
            def name := getName(m)
            if declared.contains(name) {
                return
            }
            declared.add(name)
            declarations.print("declare ")
            def needsIndirection := needsStructIndirection(m)
            if needsIndirection {
                declarations.print("void")
            }
            else {
                declarations.print(llvmType(m.returnType))
            }
            declarations.print(" \{getName(m)}(")
            var separator := ""
            if needsIndirection {
                declarations.print("\{llvmType(m.returnType)}*")
                separator := ", "
            }
            if !m.annotations.isClass & !compiler.isValueInit(m) {
                declarations.print("\{separator}\{selfType(m)} %self")
                separator := ", "
            }
            for p in m.parameters {
                declarations.print("\{separator}\{llvmType(p.type)} %\{escapeName(p.name)}")
                separator := ", "
            }
            declarations.printLine(")")
        }
        fail(error) {
            unreachable, error.asString
        }
    }

    method getReference(v:IR.Value):String {
        match v {
            when IR.Value.BIT(value) {
                return value.asString
            }
            when IR.Value.INT(value, _) {
                return value.asString
            }
            when IR.Value.LOCAL(index, _) {
                return "%local\{index}"
            }
            when IR.Value.METHOD_POINTER(m, _) {
                if m.owner.external {
                    writeDeclaration(m)
                }
                return getName(m)
            }
            when IR.Value.NULL(type) {
                return getNullReference(type)
            }
            when IR.Value.PARAMETER(index, _) {
                return "%param\{index}"
            }
            when IR.Value.REAL(value, type) {
                return getRealReference(type, value)
            }
            when IR.Value.REF(id, _) {
                assert refs[id] !== null, "id \{id} has not been defined"
                return refs[id]
            }
            when IR.Value.STRING(s) {
                return getStringReference(s)
            }
            otherwise {
                unreachable
            }
        }
    }

    method getTypedReference(v:IR.Value):String {
        return "\{llvmType(v.type())} \{getReference(v)}"
    }

    method debugInfo(position:Position):String {
        try {
            if compiler.settings.debug & position != lastDebugPosition &
                    currentMethodMetadata !== null {
                def result := nextMetadata()
                metadata.print("\{result} = !DILocation(line: \{position.line}, column: " +
                        "\{position.column}, scope: \{currentMethodMetadata})")
                lastDebugPosition := position
                return ", !dbg \{result}"
            }
            else {
                return ""
            }
        }
        fail(error) {
            unreachable
        }
    }

    method writeIsNull(position:Position, id:IR.Statement.ID, value:IR.Value) {
        try {
            def valueRef := getTypedReference(value)
            def cl := compiler.getClass(value.type())
            def resultValue:String
            if compiler.isValue(cl) {
                if value.type().typeKind != Type.Kind.NULLABLE {
                    refs[id] := "0"
                    return
                }
                def field := nextVar()
                out.printLine("\{field} = extractvalue \{valueRef}, 1\{debugInfo(position)}")
                def result := nextVar()
                out.printLine("\{result} = xor i1 \{field}, -1\{debugInfo(position)}")
                refs[id] := result
            }
            else {
                def result := nextVar()
                out.printLine("\{result} = icmp eq \{valueRef}, null\{debugInfo(position)}")
                refs[id] := result
            }
        }
        fail(error) {
            unreachable, error.asString
        }
    }

    method writeIsNonNull(position:Position, id:IR.Statement.ID, value:IR.Value) {
        try {
            def valueRef := getTypedReference(value)
            def cl := compiler.getClass(value.type())
            if compiler.isValue(cl) {
                if value.type().typeKind != Type.Kind.NULLABLE {
                    refs[id] := "1"
                    return
                }
                def result := nextVar()
                out.printLine("\{result} = extractvalue \{valueRef}, 1\{debugInfo(position)}")
                refs[id] := result
            }
            else {
                def result := nextVar()
                out.printLine("\{result} = icmp ne \{valueRef}, null\{debugInfo(position)}")
                refs[id] := result
            }
        }
        fail(error) {
            unreachable, error.asString
        }
    }

    function isNull(v:IR.Value):Bit {
        match v {
            when IR.Value.NULL {
                return true
            }
        }
        return false
    }

    method writeBinary(position:Position, id:IR.Statement.ID, left:IR.Value, op:Binary.Operator,
            right:IR.Value, type:Type) {
        def llvmOp:String
        match opClass(left.type()) {
            when OpClass.SIGNED {
                match op {
                    when Binary.Operator.ADD        { llvmOp := "add" }
                    when Binary.Operator.SUB        { llvmOp := "sub" }
                    when Binary.Operator.MUL        { llvmOp := "mul" }
                    when Binary.Operator.INTDIV     { llvmOp := "sdiv" }
                    when Binary.Operator.REM        { llvmOp := "srem" }
                    when Binary.Operator.SHIFTLEFT  { llvmOp := "shl" }
                    when Binary.Operator.SHIFTRIGHT { llvmOp := "ashr" }
                    when Binary.Operator.BITWISEAND { llvmOp := "and" }
                    when Binary.Operator.BITWISEOR  {  llvmOp := "or" }
                    when Binary.Operator.BITWISEXOR,
                            Binary.Operator.XOR     { llvmOp := "xor" }
                    when Binary.Operator.EQ         { llvmOp := "icmp eq" }
                    when Binary.Operator.NEQ        { llvmOp := "icmp ne" }
                    when Binary.Operator.GT         { llvmOp := "icmp sgt" }
                    when Binary.Operator.LT         { llvmOp := "icmp slt" }
                    when Binary.Operator.GTEQ       { llvmOp := "icmp sge" }
                    when Binary.Operator.LTEQ       { llvmOp := "icmp sle" }
                    otherwise {
                        unreachable, "unsupported signed operator \{op}"
                    }
                }
            }
            when OpClass.UNSIGNED {
                match op {
                    when Binary.Operator.ADD        { llvmOp := "add" }
                    when Binary.Operator.SUB        { llvmOp := "sub" }
                    when Binary.Operator.MUL        { llvmOp := "mul" }
                    when Binary.Operator.INTDIV     { llvmOp := "udiv" }
                    when Binary.Operator.REM        { llvmOp := "urem" }
                    when Binary.Operator.SHIFTLEFT  { llvmOp := "shl" }
                    when Binary.Operator.SHIFTRIGHT { llvmOp := "lshr" }
                    when Binary.Operator.BITWISEAND,
                            Binary.Operator.AND     { llvmOp := "and" }
                    when Binary.Operator.BITWISEOR,
                            Binary.Operator.OR      { llvmOp := "or" }
                    when Binary.Operator.BITWISEXOR, 
                            Binary.Operator.XOR     { llvmOp := "xor" }
                    when Binary.Operator.EQ         { llvmOp := "icmp eq" }
                    when Binary.Operator.NEQ        { llvmOp := "icmp ne" }
                    when Binary.Operator.GT         { llvmOp := "icmp ugt" }
                    when Binary.Operator.LT         { llvmOp := "icmp ult" }
                    when Binary.Operator.GTEQ       { llvmOp := "icmp uge" }
                    when Binary.Operator.LTEQ       { llvmOp := "icmp ule" }
                    otherwise {
                        unreachable, "unsupported unsigned operator \{op}"
                    }
                }
            }
            when OpClass.FLOAT {
                match op {
                    when Binary.Operator.ADD  { llvmOp := "fadd" }
                    when Binary.Operator.SUB  { llvmOp := "fsub" }
                    when Binary.Operator.MUL  { llvmOp := "fmul" }
                    when Binary.Operator.DIV  { llvmOp := "fdiv" }
                    when Binary.Operator.EQ   { llvmOp := "fcmp oeq" }
                    when Binary.Operator.NEQ  { llvmOp := "fcmp one" }
                    when Binary.Operator.GT   { llvmOp := "fcmp ogt" }
                    when Binary.Operator.LT   { llvmOp := "fcmp olt" }
                    when Binary.Operator.GTEQ { llvmOp := "fcmp oge" }
                    when Binary.Operator.LTEQ { llvmOp := "fcmp ole" }
                    otherwise {
                        unreachable, "unsupported float operator \{op}"
                    }
                }
            }
            when OpClass.CLASS {
                match op {
                    when Binary.Operator.IDENTITY {
                        if isNull(left) {
                            writeIsNull(position, id, right)
                            return
                        }
                        if isNull(right) {
                            writeIsNull(position, id, left)
                            return
                        }
                        llvmOp := "icmp eq"
                    }
                    when Binary.Operator.NIDENTITY {
                        if isNull(left) {
                            writeIsNonNull(position, id, right)
                            return
                        }
                        if isNull(right) {
                            writeIsNonNull(position, id, left)
                            return
                        }
                        llvmOp := "icmp ne"
                    }
                    otherwise {
                        unreachable, "unsupported class operator \{op}"
                    }
                }
            }
        }
        def result := nextVar()
        def leftRef := getReference(left)
        def rightRef := getReference(right)
        try {
            out.printLine("\{result} = \{llvmOp} \{llvmType(left.type())} \{leftRef}, \{rightRef}" +
                    debugInfo(position))
        }
        fail(error) {
            unreachable, error.asString
        }
        refs[id] := result
    }

    method writeBranch(position:Position, target:IR.Block.ID) {
        try {
            out.printLine("br label %\{target}\{debugInfo(position)}")
        }
        fail(error) {
            unreachable, error.asString
        }
    }

    method writeCast(position:Position, id:IR.Statement.ID, value:IR.Value, target:Type) {
        refs[id] := getCastReference(position, getReference(value), value.type(), target)
    }

    method writeConditionalBranch(position:Position, test:IR.Value, ifTrue:IR.Block.ID,
                                  ifFalse:IR.Block.ID) {
        try {
            out.printLine("br \{getTypedReference(test)}, label %\{ifTrue}, " +
                    "label %\{ifFalse}\{debugInfo(position)}")
        }
        fail(error) {
            unreachable, error.asString
        }
    }

    @pre(cl.resolved = Compiler.Resolution.RESOLVED)
    method writeConstruct(position:Position, id:IR.Statement.ID, cl:ClassDecl) {
        try {
            assert !compiler.isValue(cl)
            def cc := getClassConstant(cl)
            def ccCast:String
            if cc.type != "%frost$core$Class" {
                ccCast := "bitcast(\{cc.type}* \{cc.name} to %frost$core$Class*)"
            }
            else {
                ccCast := cc.name
            }
            def callRef := nextVar()
            def target := cl.type
            out.printLine("\{callRef} = call i8* @frostObjectAlloc(i64 \{sizeOf(target)}, " +
                    "%frost$core$Class* \{ccCast})\{debugInfo(position)}")
            def result := nextVar()
            out.printLine("\{result} = bitcast i8* \{callRef} to \{llvmType(target)}" +
                    debugInfo(position))
            refs[id] := result
        }
        fail(error) {
            unreachable, error.asString
        }
    }

    method writeCreateStruct(position:Position, id:IR.Statement.ID, cl:ClassDecl,
            args:FixedArray<IR.Value>) {
        try {
            assert compiler.isValue(cl)
            assert args.count > 0
            def type := llvmType(cl.type)
            var current := "undef"
            for i in 0 .. args.count {
                def value := getTypedReference(args[i])
                def next := nextVar()
                out.printLine("\{next} = insertvalue \{type} \{current}, \{value}, \{i}")
                current := next
            }
            refs[id] := current
        }
        fail(error) {
            unreachable, error.asString
        }
    }

    method writeDynamicCall(position:Position, id:IR.Statement.ID, m:IR.Value,
            args:ListView<IR.Value>) {
        try {
            var type := m.type()
            if type.isPointer {
                type := type.subtypes[1]
            }
            def returnType := type.returnType
            if returnType != Type.Void() {
                def result := nextVar()
                out.print("\{result} = ")
                refs[id] := result
            }
            out.print("call \{llvmType(returnType)} \{getReference(m)}(")
            var separator := ""
            for a in args {
                out.print(separator)
                out.print(getTypedReference(a))
                separator := ", "
            }
            out.printLine(")\{debugInfo(position)}")
        }
        fail(error) {
            unreachable, error.asString
        }
    }

    method writeEnd() {
        try {
            if compiler.currentMethod[0].returnType = Type.Void() {
                out.printLine("ret void")
            }
            else {
                out.printLine("unreachable")
            }
        }
        fail(error) {
            unreachable, error.asString
        }
    }

    method writeExtractField(position:Position, id:IR.Statement.ID, target:IR.Value,
            field:FieldDecl) {
        try {
            var targetRef := getTypedReference(target)
            def index := compiler.getIndex(field)
            def result := nextVar()
            out.printLine("\{result} = extractvalue \{targetRef}, \{index}\{debugInfo(position)}")
            refs[id] := result
        }
        fail(error) {
            unreachable, error.asString
        }
    }

    method writeGetChoiceFieldPointer(position:Position, id:IR.Statement.ID, target:IR.Value,
            cc:ChoiceCase, index:Int) {
        try {
            def data := cc.owner.fields[1]
            assert data.name = ClassDecl.CHOICE_DATA_NAME
            def targetRef := getReference(target)
            def fieldIndex := compiler.getIndex(data)
            def dataPointer := nextVar()
            out.printLine("\{dataPointer} = getelementptr \{typeName(cc.owner.type)}, " +
                    "\{typeName(cc.owner.type)}* \{targetRef}, i64 0, i32 \{fieldIndex}" +
                    debugInfo(position))
            def size := getChoiceDataSize(cc.owner)
            def offset := nextVar()
            out.printLine("\{offset} = getelementptr [\{size} x i8], [\{size} x i8]* " +
                    "\{dataPointer}, i64 0, i64 \{getChoiceFieldOffset(cc, index)}" +
                    debugInfo(position))
            def cast := nextVar()
            out.printLine("\{cast} = bitcast i8* \{offset} to \{llvmType(cc.fields[index])}*" +
                    debugInfo(position))
            refs[id] := cast
        }
        fail(error) {
            unreachable, error.asString
        }
    }

    method writeGetFieldPointer(position:Position, id:IR.Statement.ID, target:IR.Value,
            field:FieldDecl) {
        try {
            def targetRef := getReference(target)
            def index := compiler.getIndex(field)
            def result := nextVar()
            out.printLine("\{result} = getelementptr \{typeName(target.type())}, " +
                    "\{typeName(target.type())}* \{targetRef}, i64 0, i32 \{index}" +
                    debugInfo(position))
            if compiler.isValue(field.type) {
                refs[id] := result
            }
            else {
                def cast := nextVar()
                out.printLine("\{cast} = bitcast i8** \{result} to \{llvmType(field.type)}*" +
                        debugInfo(position))
                refs[id] := cast
            }
        }
        fail(error) {
            unreachable, error.asString
        }
    }

    method writeGetInterfaceMethod(position:Position, id:IR.Statement.ID, value:IR.Value,
            cl:ClassDecl, index:Int, type:Type) {
        try {
            def methodTypeString := llvmMethodType(type, null)
            -- load class constant entry
            def entry := nextLabel()
            out.printLine("br label %\{entry}")
            createBlock(entry, out)
            def rawClassPointer := nextVar()
            out.printLine("\{rawClassPointer} = getelementptr inbounds \{typeName(cl.type)}, " +
                    "\{getTypedReference(value)}, \{SIZE_TYPE} 0, i32 \{CLASS_POINTER_INDEX}" +
                    debugInfo(position))
            def classPointer := nextVar()
            def classType := typeName(Type.Class())
            out.printLine("\{classPointer} = bitcast i8** \{rawClassPointer} to \{classType}**" +
                    debugInfo(position))
            def loadedClass := nextVar()
            out.printLine("\{loadedClass} = load \{classType}*, \{classType}** \{classPointer}" +
                    debugInfo(position))
            def itableFirst := nextVar()
            out.printLine("\{itableFirst} = getelementptr inbounds \{classType}, \{classType}* " +
                    "\{loadedClass}, \{SIZE_TYPE} 0, i32 \{ITABLE_INDEX}\{debugInfo(position)}")
            def next := nextLabel()
            out.printLine("br label %\{next}")
            def leavingEntryLabel := currentBlock
            createBlock(next, out)
            labelCount += 1
            def itableNext := "%$itable\{labelCount}"
            def itablePtrPtr := nextVar()
            def failBlock := nextLabel()
            out.printLine("\{itablePtrPtr} = phi %$itable** [ \{itableFirst}, " +
                    "%\{leavingEntryLabel}], [ \{itableNext}, %\{failBlock} ]")
            def itablePtr := nextVar()
            out.printLine("\{itablePtr} = load %$itable*, %$itable** \{itablePtrPtr}" +
                    debugInfo(position))
            def itableClassPtr := nextVar()
            out.printLine("\{itableClassPtr} = getelementptr inbounds %$itable, %$itable* " +
                    "\{itablePtr}, \{SIZE_TYPE} 0, i32 0\{debugInfo(position)}")
            def itableClass := nextVar()
            out.printLine("\{itableClass} = load \{classType}*, \{classType}** \{itableClassPtr}" +
                    debugInfo(position))
            def test := nextVar()
            def intfCC := getClassConstant(cl)
            out.printLine("\{test} = icmp eq \{classType}* bitcast(\{intfCC.type}* " +
                    "\{intfCC.name} to \{classType}*), \{itableClass}\{debugInfo(position)}")
            def success := nextLabel()
            out.printLine("br i1 \{test}, label %\{success}, label " +
                    "%\{failBlock}\{debugInfo(position)}")

            createBlock(failBlock, out)
            out.printLine("\{itableNext} = getelementptr inbounds %$itable, %$itable* " +
                    "\{itablePtr}, \{SIZE_TYPE} 0, i32 1\{debugInfo(position)}")
            out.printLine("br label %\{next}")

            createBlock(success, out)
            def methodPtrPtr := nextVar()
            out.printLine("\{methodPtrPtr} = getelementptr inbounds %$itable, %$itable* " +
                    "\{itablePtr}, \{SIZE_TYPE} 0, i32 2, i32 \{index}\{debugInfo(position)}")
            def cast := nextVar()
            out.printLine("\{cast} = bitcast i8** \{methodPtrPtr} to \{methodTypeString}*" +
                    debugInfo(position))
            def methodPtr := nextVar()
            out.printLine("\{methodPtr} = load \{methodTypeString}, \{methodTypeString}* \{cast}" +
                    debugInfo(position))
            refs[id] := methodPtr
        }
        fail(error) {
            unreachable, error.asString
        }
    }

    method writeGetVirtualMethod(position:Position, id:IR.Statement.ID, value:IR.Value, index:Int,
            type:Type) {
        try {
            def classPtrPtr := nextVar()
            out.printLine("\{classPtrPtr} = getelementptr inbounds \{typeName(value.type())}, " +
                    "\{getTypedReference(value)}, i64 0, i32 0\{debugInfo(position)}")
            def classPtr := nextVar()
            out.printLine("\{classPtr} = load i8*, i8** \{classPtrPtr}\{debugInfo(position)}")
            def cast := nextVar()
            def classType := typeName(Type.Class())
            out.printLine("\{cast} = bitcast i8* \{classPtr} to \{classType}*" +
                    debugInfo(position))
            def ptr := nextVar()
            out.printLine("\{ptr} = getelementptr inbounds \{classType}, \{classType}* \{cast}, " +
                    "i64 0, i32 \{VTABLE_INDEX}, i64 \{index}\{debugInfo(position)}")
            def load := nextVar()
            out.printLine("\{load} = load i8*, i8** \{ptr}\{debugInfo(position)}")
            def result := nextVar()
            out.printLine("\{result} = bitcast i8* \{load} to \{llvmMethodType(type, null)}" +
                    debugInfo(position))
            refs[id] := result
        }
        fail(error) {
            unreachable, error.asString
        }
    }

    method writeLoad(position:Position, id:IR.Statement.ID, ptr:IR.Value) {
        try {
            def result := nextVar()
            out.printLine("\{result} = load \{llvmType(ptr.type())}, \{llvmType(ptr.type())}* " +
                    getReference(ptr) + debugInfo(position))
            refs[id] := result
        }
        fail(error) {
            unreachable, error.asString
        }
    }

    method writeNegate(position:Position, id:IR.Statement.ID, value:IR.Value) {
        try {
            def result := nextVar()
            if value.type().typeKind = Type.Kind.BUILTIN_FLOAT {
                out.printLine("\{result} = fsub \{llvmType(value.type())} 0x0, " +
                        "\{getReference(value)}\{debugInfo(position)}")
            }
            else {
                out.printLine("\{result} = sub \{llvmType(value.type())} 0, " +
                        "\{getReference(value)}\{debugInfo(position)}")
            }
            refs[id] := result
        }
        fail(error) {
            unreachable, error.asString
        }
    }

    method writeNot(position:Position, id:IR.Statement.ID, value:IR.Value) {
        try {
            def result := nextVar()
            out.printLine("\{result} = xor \{getTypedReference(value)}, -1\{debugInfo(position)}")
            refs[id] := result
        }
        fail(error) {
            unreachable, error.asString
        }
    }

    method writePointerAlloc(position:Position, id:IR.Statement.ID, count:IR.Value, type:Type) {
        try {
            def countRef := getTypedReference(count)
            def elementSize := stride(type)
            assert elementSize > 0, "invalid size for type \{type}"
            def size := nextVar()
            out.printLine("\{size} = mul \{countRef}, \{elementSize}\{debugInfo(position)}")
            def malloc := nextVar()
            out.printLine("\{malloc} = call i8* @frostAlloc(\{SIZE_TYPE} \{size})" +
                    debugInfo(position))
            def result := nextVar()
            out.printLine("\{result} = bitcast i8* \{malloc} to \{llvmType(Type.pointerTo(type))}" +
                    debugInfo(position))
            refs[id] := result
        }
        fail(error) {
            unreachable, error.asString
        }
    }

    method writePointerDestroy(position:Position, ptr:IR.Value) {
        try {
            def ptrRef := getTypedReference(ptr)
            def cast := nextVar()
            out.printLine("\{cast} = bitcast \{ptrRef} to i8*\{debugInfo(position)}")
            out.printLine("call void @frostFree(i8* \{cast})\{debugInfo(position)}")
        }
        fail(error) {
            unreachable, error.asString
        }
    }

    method writePointerGetIndex(position:Position, id:IR.Statement.ID, ptr:IR.Value,
            index:IR.Value) {
        try {
            def base := getTypedReference(ptr)
            def indexRef := getTypedReference(index)
            def baseType := llvmType(ptr.type().subtypes[1])
            def offset := nextVar()
            out.printLine("\{offset} = getelementptr inbounds \{baseType}, " +
                    "\{base}, \{indexRef}\{debugInfo(position)}")
            def result := nextVar()
            out.printLine("\{result} = load \{baseType}, \{baseType}* \{offset}\{debugInfo(position)}")
            refs[id] := result
        }
        fail(error) {
            unreachable, error.asString
        }
    }

    method writePointerOffset(position:Position, id:IR.Statement.ID, ptr:IR.Value,
            offset:IR.Value) {
        try {
            def base := getTypedReference(ptr)
            def offsetRef := getTypedReference(offset)
            def baseType := llvmType(ptr.type().subtypes[1])
            def result := nextVar()
            out.printLine("\{result} = getelementptr inbounds \{baseType}, " +
                    "\{base}, \{offsetRef}\{debugInfo(position)}")
            refs[id] := result
        }
        fail(error) {
            unreachable, error.asString
        }
    }

    method writePointerRealloc(position:Position, id:IR.Statement.ID, ptr:IR.Value,
            oldCount:IR.Value, newCount:IR.Value) {
        try {
            def ptrRef := getTypedReference(ptr)
            def cast := nextVar()
            out.printLine("\{cast} = bitcast \{ptrRef} to i8*\{debugInfo(position)}")
            def oldCountRef := getTypedReference(oldCount)
            def newCountRef := getTypedReference(newCount)
            def elementSize := stride(ptr.type().subtypes[1])
            assert elementSize > 0, "invalid size for type \{ptr.type()}"
            def oldSize := nextVar()
            out.printLine("\{oldSize} = mul \{oldCountRef}, \{elementSize}\{debugInfo(position)}")
            def newSize := nextVar()
            out.printLine("\{newSize} = mul \{newCountRef}, \{elementSize}\{debugInfo(position)}")
            def realloc := nextVar()
            out.printLine("\{realloc} = call i8* @frostRealloc(i8* \{cast}, " +
                    "\{SIZE_TYPE} \{oldSize}, \{SIZE_TYPE} \{newSize})\{debugInfo(position)}")
            def result := nextVar()
            out.printLine("\{result} = bitcast i8* \{realloc} to \{llvmType(ptr.type())}" +
                    debugInfo(position))
            refs[id] := result
        }
        fail(error) {
            unreachable, error.asString
        }
    }

    method writePointerSetIndex(position:Position, value:IR.Value, ptr:IR.Value, index:IR.Value) {
        try {
            def base := getTypedReference(ptr)
            def indexRef := getTypedReference(index)
            def valueRef := getTypedReference(value)
            def baseType := llvmType(ptr.type().subtypes[1])
            def offset := nextVar()
            out.printLine("\{offset} = getelementptr inbounds \{baseType}, \{base}, \{indexRef}" +
                    debugInfo(position))
            out.printLine("store \{valueRef}, \{baseType}* \{offset}\{debugInfo(position)}")
        }
        fail(error) {
            unreachable, error.asString
        }
    }

    method writeReturn(position:Position, value:IR.Value?) {
        try {
            if value !== null {
                out.printLine("ret \{getTypedReference(value)}\{debugInfo(position)}")
            }
            else {
                out.printLine("ret void\{debugInfo(position)}")
            }
        }
        fail(error) {
            unreachable, error.asString
        }
    }

    method writeStaticCall(position:Position, id:IR.Statement.ID, m:MethodDecl,
            args:ListView<IR.Value>) {
        try {
            if m.owner.external {
                writeDeclaration(m)
            }
            def indirect := needsStructIndirection(m)
            def actualResultType := llvmType(m.returnType)
            var separator := ""
            def result:String?
            if indirect {
                labelCount += 1
                result := "%tmp\{labelCount}"
                methodHeader.printLine("\{result} = alloca \{actualResultType}")
                out.print("call void \{getName(m)}(\{actualResultType}* \{result}")
                separator := ", "
            }
            else if m.returnType != Type.Void() {
                result := nextVar()
                out.print("\{result} = call \{actualResultType} \{getName(m)}(")
                refs[id] := result
            }
            else {
                out.print("call void \{getName(m)}(")
            }
            for a in args {
                out.print(separator)
                out.print(getTypedReference(a))
                separator := ", "
            }
            out.printLine(")\{debugInfo(position)}")
            if indirect {
                assert result !== null
                def load := nextVar()
                out.printLine("\{load} = load \{actualResultType}, \{actualResultType}* " +
                            result)
                refs[id] := load
            }
        }
        fail(error) {
            unreachable, error.asString
        }
    }

    method writeStore(position:Position, value:IR.Value, ptr:IR.Value) {
        try {
            out.printLine("store \{getTypedReference(value)}, \{llvmType(ptr.type())}* " +
                    getReference(ptr) + debugInfo(position))
        }
        fail(error) {
            unreachable, error.asString
        }
    }

    method writeStatement(id:IR.Statement.ID, s:IR.Statement) {
        try {
            match s {
                when IR.Statement.BINARY(position, left, op, right, type) {
                    writeBinary(position, id, left, op, right, type)
                }
                when IR.Statement.BRANCH(position, target) {
                    writeBranch(position, target)
                }
                when IR.Statement.CAST(position, value, type, _) {
                    writeCast(position, id, value, type)
                }
                when IR.Statement.COMMENT(_, text) {
                    out.printLine("; \{text}")
                }
                when IR.Statement.CONDITIONAL_BRANCH(position, test, ifTrue, ifFalse) {
                    writeConditionalBranch(position, test, ifTrue, ifFalse)
                }
                when IR.Statement.CONSTRUCT(position, cl) {
                    writeConstruct(position, id, cl)
                }
                when IR.Statement.CREATE_STRUCT(position, cl, args) {
                    writeCreateStruct(position, id, cl, args)
                }
                when IR.Statement.DYNAMIC_CALL(position, m, args) {
                    writeDynamicCall(position, id, m, args)
                }
                when IR.Statement.END {
                    writeEnd()
                }
                when IR.Statement.EXTRACT_FIELD(position, target, field) {
                    writeExtractField(position, id, target, field)
                }
                when IR.Statement.GET_CHOICE_FIELD_POINTER(position, target, cc, index) {
                    writeGetChoiceFieldPointer(position, id, target, cc, index)
                }
                when IR.Statement.GET_FIELD_POINTER(position, target, field) {
                    writeGetFieldPointer(position, id, target, field)
                }
                when IR.Statement.GET_INTERFACE_METHOD(position, value, cl, index, type) {
                    writeGetInterfaceMethod(position, id, value, cl, index, type)
                }
                when IR.Statement.GET_VIRTUAL_METHOD(position, value, index, type) {
                    writeGetVirtualMethod(position, id, value, index, type)
                }
                when IR.Statement.LOAD(position, ptr) {
                    writeLoad(position, id, ptr)
                }
                when IR.Statement.NEGATE(position, value) {
                    writeNegate(position, id, value)
                }
                when IR.Statement.NOT(position, value) {
                    writeNot(position, id, value)
                }
                when IR.Statement.POINTER_ALLOC(position, count, type) {
                    writePointerAlloc(position, id, count, type)
                }
                when IR.Statement.POINTER_DESTROY(position, ptr) {
                    writePointerDestroy(position, ptr)
                }
                when IR.Statement.POINTER_GET_INDEX(position, ptr, index) {
                    writePointerGetIndex(position, id, ptr, index)
                }
                when IR.Statement.POINTER_OFFSET(position, ptr, offset) {
                    writePointerOffset(position, id, ptr, offset)
                }
                when IR.Statement.POINTER_REALLOC(position, ptr, oldCount, newCount) {
                    writePointerRealloc(position, id, ptr, oldCount, newCount)
                }
                when IR.Statement.POINTER_SET_INDEX(position, value, ptr, index) {
                    writePointerSetIndex(position, value, ptr, index)
                }
                when IR.Statement.RETURN(position, value) {
                    writeReturn(position, value)
                }
                when IR.Statement.STATIC_CALL(position, m, args) {
                    writeStaticCall(position, id, m, args)
                }
                when IR.Statement.STORE(position, value, slot) {
                    writeStore(position, value, slot)
                }
                when IR.Statement.UNREACHABLE(position) {
                    out.printLine("unreachable\{debugInfo(position)}")
                }
                otherwise {
                    unreachable, "unsupported statement \{s}"
                }
            }
        }
        fail(error) {
            unreachable, error.asString
        }
    }

    method writeIR(ir:IR) {
        try {
            for i in 0 .. ir.locals.count {
                def name := "%local\{i}"
                def type := llvmType(ir.locals[i])
                out.printLine("\{name} = alloca \{type}")
                if compiler.isRefCounted(ir.locals[i]) {
                    out.printLine("store \{type} null, \{type}* \{name}")
                }
            }
            for i in 0 .. ir.blocks.count {
                def block := ir.blocks[i]
                if i != 0 {
                    currentBlock := "\{block.id}"
                    out.printLine(currentBlock + ":")
                }
                else {
                    currentBlock := "0"
                }
                for j in 0 .. block.statements.count {
                    writeStatement(block.ids[j], block.statements[j])
                }
            }
        }
        fail(error) {
            unreachable, error.asString
        }
    }

    @override
    method write(m:MethodDecl, ir:IR) {
        try {
            out := methods
            methodHeader.clear()
            self.ir := ir
            varCount := 0
            out.print("define ")
            if m.owner.isSpecialization() {
                out.print("linkonce_odr ")
            }
            out.print("\{llvmType(m.returnType)} \{getName(m)}(")
            var separator := ""
            var index := 0
            if compiler.hasSelfParam(m) {
                out.print("\{selfType(m)} %param\{index}")
                index += 1
                separator := ", "
            }
            for p in m.parameters {
                out.print("\{separator}\{llvmType(p.type)} %param\{index}")
                index += 1
                separator := ", "
            }
            out.print(")")
            if compiler.settings.debug {
                currentMethodMetadata := nextMetadata()
                metadata.printLine("\{currentMethodMetadata} = distinct !DISubprogram(name: " +
                        "\"\{m.name}\", file: \{currentFileMetadata}, unit: !0, scopeLine: " +
                        "\{m.position.line})")
            }
            out.printLine(" {")
            out := MemoryOutputStream()
            writeIR(ir)
            methods.printLine(methodHeader)
            methods.printLine(out)
            methods.printLine("}")
        }
        fail(error) {
            unreachable, error.asString
        }
    }

    @override
    method start(cl:ClassDecl) {
        try {
            if cl.annotations.isSpecialize {
                return
            }
            if compiler.settings.debug {
                currentFileMetadata := nextMetadata()
                metadata.printLine("\{currentFileMetadata} = distinct !DIFile(" +
                        "filename: \"\{cl.source}\", directory: \"\{System.workingDirectory()}\")")
                if currentFileMetadata = "!1" {
                    metadata.printLine("!0 = distinct !DICompileUnit(language:DW_LANG_C89, " +
                            "producer:\"frostc\", file: \{currentFileMetadata}, isOptimized: " +
                            "false, runtimeVersion: 0, emissionKind: FullDebug)")
                    metadata.printLine("!llvm.dbg.cu = !{!0}")
                    def dwarfVersion := nextMetadata()
                    metadata.printLine("\{dwarfVersion} = !{i32 2, !\"Dwarf Version\", i32 4}")
                    def debugVersion := nextMetadata()
                    metadata.printLine("\{debugVersion} = !{i32 2, !\"Debug Info Version\", i32 3}")
                    metadata.printLine("!llvm.module.flags = !{\{dwarfVersion}, \{debugVersion}}")
                }
            }
            writeType(cl.type)
            getClassConstant(cl)
        }
        fail(error) {
            unreachable, error.asString
        }
    }

    @override
    method end(cl:ClassDecl) {
    }

    @override
    method cleanup() {
    }
}