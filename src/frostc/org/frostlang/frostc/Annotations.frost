package org.frostlang.frostc

@final
class Annotations {
    class Flag {
        constant PRIVATE         :Int := 1 << 1
        constant PROTECTED       :Int := 1 << 2
        constant PACKAGE         :Int := 1 << 3
        constant CLASS           :Int := 1 << 4
        constant OVERRIDE        :Int := 1 << 5
        constant EXTERNAL        :Int := 1 << 6
        constant IMPLICIT        :Int := 1 << 7
        constant FINAL           :Int := 1 << 8
        constant ABSTRACT        :Int := 1 << 9
        constant INLINE          :Int := 1 << 10
        constant SPECIALIZE      :Int := 1 << 11
        constant WEAK            :Int := 1 << 12
        constant SYNTHETIC       :Int := 1 << 13
        constant UNSAFE_IMMUTABLE:Int := 1 << 14
        constant DEFAULT         :Int := 1 << 15
        -- tags a field in a closure class which is used to represent a captured value
        constant CAPTURE         :Int := 1 << 16
        constant STUB            :Int := 1 << 17
        constant NO_RETURN       :Int := 1 << 18
    }

    choice Expression {
        PRE(String, ASTNode)
        PRE_OR(String, ASTNode)
        POST(String, ASTNode)
        POST_AND(String, ASTNode)
        PRIORITY(String, ASTNode)

        @override
        function get_asString():String {
            match self {
                when PRE(_, expr)      { return "@pre(\{expr})" }
                when PRE_OR(_, expr)   { return "@preOr(\{expr})" }
                when POST(_, expr)     { return "@post(\{expr})" }
                when POST_AND(_, expr) { return "@postAnd(\{expr})" }
                when PRIORITY(_, expr) { return "@priority(\{expr})" }
            }
            unreachable
        }
    }

    def flags:Int

    def expressions:Array<Expression>?

    property isPrivate:Bit

    property isProtected:Bit

    property isPackage:Bit

    property isClass:Bit

    property isOverride:Bit

    property isExternal:Bit

    property isImplicit:Bit

    property isFinal:Bit

    property isAbstract:Bit

    property isInline:Bit

    property isSpecialize:Bit

    property isWeak:Bit

    property isSynthetic:Bit

    property isUnsafeImmutable:Bit

    property isDefault:Bit

    property isCapture:Bit

    property isStub:Bit

    property isNoReturn:Bit

    init() {
        init(0)
    }

    init(flags:Int) {
        init(flags, null)
    }

    init(flags:Int, expressions:ListView<Expression>?) {
        self.flags := flags
        if expressions !== null {
            self.expressions := Array<Expression>(expressions!)
        }
        else {
            self.expressions := null
        }
    }

    function +(flags:Int):Annotations {
        return Annotations(self.flags + flags, expressions)
    }

    function get_isPrivate():Bit {
        return flags && Flag.PRIVATE != 0
    }

    function get_isProtected():Bit {
        return flags && Flag.PROTECTED != 0
    }

    function get_isPackage():Bit {
        return flags && Flag.PACKAGE != 0
    }

    function get_isClass():Bit {
        return flags && Flag.CLASS != 0
    }

    function get_isOverride():Bit {
        return flags && Flag.OVERRIDE != 0
    }

    function get_isExternal():Bit {
        return flags && Flag.EXTERNAL != 0
    }

    function get_isImplicit():Bit {
        return flags && Flag.IMPLICIT != 0
    }

    function get_isFinal():Bit {
        return flags && Flag.FINAL != 0
    }

    function get_isAbstract():Bit {
        return flags && Flag.ABSTRACT != 0
    }

    function get_isInline():Bit {
        return flags && Flag.INLINE != 0
    }

    function get_isSpecialize():Bit {
        return flags && Flag.SPECIALIZE != 0
    }

    function get_isWeak():Bit {
        return flags && Flag.WEAK != 0
    }

    function get_isSynthetic():Bit {
        return flags && Flag.SYNTHETIC != 0
    }

    function get_isUnsafeImmutable():Bit {
        return flags && Flag.UNSAFE_IMMUTABLE != 0
    }

    function get_isDefault():Bit {
        return flags && Flag.DEFAULT != 0
    }

    function get_isCapture():Bit {
        return flags && Flag.CAPTURE != 0
    }

    function get_isStub():Bit {
        return flags && Flag.STUB != 0
    }

    function get_isNoReturn():Bit {
        return flags && Flag.NO_RETURN != 0
    }

    @override
    function get_asString():String {
        def result := MutableString()
        if isPrivate {
            result.append("@private\n")
        }
        if isProtected {
            result.append("@protected\n")
        }
        if isPackage {
            result.append("@package\n")
        }
        if isClass {
            result.append("@class\n")
        }
        if isOverride {
            result.append("@override\n")
        }
        if isExternal {
            result.append("@external\n")
        }
        if isImplicit {
            result.append("@implicit\n")
        }
        if isFinal {
            result.append("@final\n")
        }
        if isAbstract {
            result.append("@abstract\n")
        }
        if isInline {
            result.append("@inline\n")
        }
        if isSpecialize {
            result.append("@specialize\n")
        }
        if isWeak {
            result.append("@weak\n")
        }
        if isSynthetic {
            result.append("@synthetic\n")
        }
        if isUnsafeImmutable {
            result.append("@unsafeImmutable\n")
        }
        if isDefault {
            result.append("@default\n")
        }
        if isCapture {
            result.append("@capture\n")
        }
        if isNoReturn {
            result.append("@noReturn\n")
        }
        if expressions !== null {
            for expr in expressions! {
                result.append("\{expr}\n")
            }
        }
        return result.finish()
    }
}