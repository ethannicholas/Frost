package org.frostlang.frostc

uses org.frostlang.frostc.parser.Parser
uses org.frostlang.frostc.parser.Token
uses org.frostlang.frostc.expression.And
uses org.frostlang.frostc.expression.ArrayLiteral
uses org.frostlang.frostc.expression.AtPre
uses org.frostlang.frostc.expression.AtReturn
uses org.frostlang.frostc.expression.Binary
uses org.frostlang.frostc.expression.Call
uses org.frostlang.frostc.expression.Closure
uses org.frostlang.frostc.expression.Dot
uses org.frostlang.frostc.expression.Identifier
uses org.frostlang.frostc.expression.IntLiteral
uses org.frostlang.frostc.expression.Or
uses org.frostlang.frostc.expression.Tuple
uses org.frostlang.frostc.expression.Unary
uses org.frostlang.frostc.lvalue.ChoiceFieldLValue
uses org.frostlang.frostc.lvalue.FieldLValue
uses org.frostlang.frostc.lvalue.IndexLValue
uses org.frostlang.frostc.lvalue.LValue
uses org.frostlang.frostc.lvalue.VariableLValue
uses org.frostlang.frostc.pass.Analyzer
uses org.frostlang.frostc.pass.MergeBlocks
uses org.frostlang.frostc.pass.RemoveAsserts
uses org.frostlang.frostc.pass.RemoveRefUnrefPairs
uses org.frostlang.frostc.pass.RemoveUnreachableBlocks
uses org.frostlang.frostc.statement.Assert
uses org.frostlang.frostc.statement.Assignment
uses org.frostlang.frostc.statement.Break
uses org.frostlang.frostc.statement.Continue
uses org.frostlang.frostc.statement.Do
uses org.frostlang.frostc.statement.For
uses org.frostlang.frostc.statement.If
uses org.frostlang.frostc.statement.InnerMethod
uses org.frostlang.frostc.statement.Loop
uses org.frostlang.frostc.statement.Match
uses org.frostlang.frostc.statement.Return
uses org.frostlang.frostc.statement.Try
uses org.frostlang.frostc.statement.While
uses org.frostlang.frostc.statement.Var

@final
class Compiler {
    choice Resolution {
        UNRESOLVED
        IN_PROGRESS
        RESOLVED
        RESOLVED_WITH_ERRORS
    }

    choice Message {
        ERROR(String -* path *-, Int -* line *-, Int -* column *-, String)
        WARNING(String -* path *-, Int -* line *-, Int -* column *-, String)
    }

    ================================================================================================
    Represents the expected type that an expression must resolve to.
    ================================================================================================
    choice TypeContext {
        ============================================================================================
        We have no information about the expected type, e.g. when evaluating the statement `foo()`.
        ============================================================================================
        UNSPECIFIED

        ============================================================================================
        We know the expression cannot result in void, e.g. when evaluating `foo()` in the statement
        `def x := foo()`.
        ============================================================================================
        NON_VOID

        ============================================================================================
        We know that the result has to be immutable, but not of any specific type, e.g. when
        evaluating `foo()` in the statement `const x := foo()`.
        ============================================================================================
        IMMUTABLE

        ============================================================================================
        We expect this specific type, e.g. when evaluating `foo()` in the statement
        `def x:String := foo()`. Explicit is true when the type is the result of an explicit cast to
        that type.
        ============================================================================================
        TYPE(Type, Bit -* explicit *-)

        function description():String {
            match self {
                when UNSPECIFIED {
                    return ""
                }
                when NON_VOID {
                    return ""
                }
                when IMMUTABLE {
                    return " with expected return type 'frost.core.Immutable'"
                }
                when TYPE(type, _) {
                    return " with expected return type '\{type}'"
                }
            }
            unreachable
        }
    }

    class InlineReturn {
        -- if non-null, inline call should store result into this variable
        def variable:Variable? -* FIXME use phis and kill this *-
        -- if variable is null, inline call should store result here
        def value:IR.Value?

        init(variable:Variable?) {
            self.variable := variable
        }

        @override
        function get_asString():String {
            def result := MutableString("InlineReturn<")
            if variable !== null {
                result.append("variable=\{variable}")
                if value !== null {
                    result.append(", ")
                }
            }
            if value !== null {
                result.append("value=\{value}")
            }
            result.append(">")
            return result.finish()
        }
    }

    choice EnclosingContext {
        INLINE_CONTEXT(FixedArray<IR.Value> -* params *-, Int -* first local index *-, InlineReturn,
                IR.Block.ID -* merge block *-)
        LOOP(String? -* label *-, IR.Block.ID -* break target *-, IR.Block.ID -* continue target *-)
        SCOPE
        VARIABLE_SCOPE(Variable)
        VALUE_SCOPE(IR.Value)
        TRY_SCOPE(IR.Block.ID?, Variable?)
    }

    choice Target {
        VARIABLE(Variable, IR.Value?)
        TUPLE(FixedArray<Target>)
    }

    class AutoContext {
        def compiler:Compiler

        def context:EnclosingContext

        init(compiler:Compiler, context:EnclosingContext) {
            self.compiler := compiler
            self.context := context
            compiler.enclosingContexts.push(context)
        }

        @override
        method cleanup() {
            assert compiler.enclosingContexts[0] == context,
                    "expected top level context to be \{context}, but found " +
                    compiler.enclosingContexts
            compiler.enclosingContexts.pop()
        }
    }

    class AutoUnrefs {
        def compiler:Compiler

        def depth:Int

        init(compiler:Compiler) {
            self.compiler := compiler
            self.depth := compiler.enclosingContexts.count
        }

        @override
        method cleanup() {
            while compiler.enclosingContexts.count > depth {
                def scope := compiler.enclosingContexts[0]
                match scope {
                    when EnclosingContext.VALUE_SCOPE(v) {
                        compiler.leaveScope(scope)
                        compiler.enclosingContexts.pop()
                    }
                    otherwise {
                        break
                    }
                }
            }
        }
    }

    class AutoScope {
        def compiler:Compiler

        def oldSymbolTable:SymbolTable

        def newSymbolTable:SymbolTable

        init(compiler:Compiler) {
            init(compiler, SymbolTable(compiler.symbolTable))
        }

        init(compiler:Compiler, symbolTable:SymbolTable) {
            self.compiler := compiler
            self.oldSymbolTable := compiler.symbolTable
            self.newSymbolTable := symbolTable
            compiler.symbolTable := symbolTable
            compiler.enclosingContexts.push(EnclosingContext.SCOPE)
        }

        @override
        method cleanup() {
            loop {
                def pop := compiler.enclosingContexts.pop()
                match pop {
                    when EnclosingContext.INLINE_CONTEXT {
                        break
                    }
                    when EnclosingContext.SCOPE {
                        break
                    }
                    when EnclosingContext.VARIABLE_SCOPE, EnclosingContext.VALUE_SCOPE {
                        compiler.leaveScope(pop)
                    }
                    otherwise {
                        unreachable
                    }
                }
            }
            assert compiler.symbolTable == newSymbolTable
            compiler.symbolTable := oldSymbolTable
        }
    }

    class AutoAtPreFlag {
        def compiler:Compiler

        init(compiler:Compiler) {
            self.compiler := compiler
            compiler.inAtPre := true
        }

        @override
        method cleanup() {
            assert compiler.inAtPre
            compiler.inAtPre := false
        }
    }

    class Settings : Immutable {
        def frostHome:File

        def importDirs:ImmutableArray<File>

        def optimizationLevel:Int

        def safetyLevel:Int

        def intSize:Int

        def debug:Bit

        init(frostHome:File, importDirs:Array<File>, optimizationLevel:Int, safetyLevel:Int,
                intSize:Int, debug:Bit) {
            self.frostHome := frostHome
            self.importDirs := ImmutableArray<File>(importDirs)
            self.optimizationLevel := optimizationLevel
            self.safetyLevel := safetyLevel
            self.intSize := intSize
            self.debug := debug
        }
    }

    choice Capture {
        VARIABLE(Variable)
        FIELD(FieldDecl)
        SELF
    }

    class ExpressionCoercionKey : HashKey<ExpressionCoercionKey> {
        def expr:ASTNode

        def target:Type

        init(expr:ASTNode, target:Type) {
            self.expr := expr
            self.target := target
        }

        @override
        function =(other:ExpressionCoercionKey):Bit {
            return expr == other.expr & target = other.target
        }

        @override
        function get_hash():Int {
            return Frost.addressOf(expr) ~~ target.hash
        }
    }

    class TypeCoercionKey : HashKey<TypeCoercionKey> {
        def type:Type

        def target:Type

        def permitImplicitConstruction:Bit

        init(type:Type, target:Type, permitImplicitConstruction:Bit) {
            self.type := type
            self.target := target
            self.permitImplicitConstruction := permitImplicitConstruction
        }

        @override
        function =(other:TypeCoercionKey):Bit {
            return type == other.type & target = other.target &
                    permitImplicitConstruction = other.permitImplicitConstruction
        }

        @override
        function get_hash():Int {
            def result := type.hash ~~ target.hash
            if permitImplicitConstruction {
                return !!result
            }
            return result
        }
    }

    class BinaryKey : HashKey<BinaryKey> {
        def left:ASTNode

        def op:Binary.Operator

        def right:ASTNode

        init(left:ASTNode, op:Binary.Operator, right:ASTNode) {
            self.left := left
            self.op := op
            self.right := right
        }

        @override
        function =(other:BinaryKey):Bit {
            return left == other.left & op = other.op & right == other.right
        }

        @override
        function get_hash():Int {
            return Frost.addressOf(left) ~~ Frost.addressOf(right)
        }
    }

    constant NEW_POINTER_NAME := "frost.unsafe.Pointer"

    constant WEAK_NAME := "frost.core.Weak"
    
    constant ARRAY_NAME := "frost.collections.Array"

    constant IMMUTABLE_ARRAY_NAME := "frost.collections.ImmutableArray"

    constant RANGE_NAME := "frost.core.Range"
    
    constant STEPPED_RANGE_NAME := "frost.core.SteppedRange"
    
    constant SELF_NAME := "self"
    
    def VOID_TYPE := Type("void", Type.Kind.VOID, Position(), true)

    def NULL_TYPE := Type("null", Type.Kind.NULL, Position(), true)
    
    def OBJECT_TYPE := Type("frost.core.Object", Type.Kind.CLASS, Position(), true)

    def ANY_TYPE := Type("frost.core.Object?", Type.Kind.NULLABLE, Position(), [OBJECT_TYPE], true)

    def CLASS_TYPE := Type("frost.core.Class", Type.Kind.CLASS, Position(), true)

    def IMMUTABLE_TYPE := Type("frost.core.Immutable", Type.Kind.CLASS, Position(), true)

    def VALUE_TYPE := Type("frost.core.Value", Type.Kind.CLASS, Position(), true)

    def STRING_TYPE := Type("frost.core.String", Type.Kind.CLASS, Position(), true)

    def ERROR_TYPE := Type("frost.core.Error", Type.Kind.CLASS, Position(), true)
    
    def REGULAR_EXPRESSION_TYPE := Type("frost.core.RegularExpression", Type.Kind.CLASS, Position(),
            true)

    def BUILTIN_INT_TYPE := Type("builtin_int", Type.Kind.BUILTIN_INT, 64)

    def BUILTIN_INT8_TYPE := Type("builtin_int8", Type.Kind.BUILTIN_INT, 8)

    def BUILTIN_INT16_TYPE := Type("builtin_int16", Type.Kind.BUILTIN_INT, 16)

    def BUILTIN_INT32_TYPE := Type("builtin_int32", Type.Kind.BUILTIN_INT, 32)

    def BUILTIN_INT64_TYPE := Type("builtin_int64", Type.Kind.BUILTIN_INT, 64)

    def BUILTIN_UINT_TYPE := Type("builtin_uint", Type.Kind.BUILTIN_UINT, 64)

    def BUILTIN_UINT8_TYPE := Type("builtin_uint8", Type.Kind.BUILTIN_UINT, 8)

    def BUILTIN_UINT16_TYPE := Type("builtin_uint16", Type.Kind.BUILTIN_UINT, 16)

    def BUILTIN_UINT32_TYPE := Type("builtin_uint32", Type.Kind.BUILTIN_UINT, 32)

    def BUILTIN_UINT64_TYPE := Type("builtin_uint64", Type.Kind.BUILTIN_UINT, 64)

    def BUILTIN_FLOAT32_TYPE := Type("builtin_float32", Type.Kind.BUILTIN_FLOAT, 32)
    
    def BUILTIN_FLOAT64_TYPE := Type("builtin_float64", Type.Kind.BUILTIN_FLOAT, 64)

    def INT8_TYPE := Type("frost.core.Int8", Type.Kind.CLASS, Position(), true)

    def INT16_TYPE := Type("frost.core.Int16", Type.Kind.CLASS, Position(), true)

    def INT32_TYPE := Type("frost.core.Int32", Type.Kind.CLASS, Position(), true)

    def INT64_TYPE := Type("frost.core.Int64", Type.Kind.CLASS, Position(), true)

    def INT_TYPE := Type("frost.core.Int", Type.Kind.CLASS, Position(), true)

    def UINT8_TYPE := Type("frost.core.UInt8", Type.Kind.CLASS, Position(), true)

    def UINT16_TYPE := Type("frost.core.UInt16", Type.Kind.CLASS, Position(), true)

    def UINT32_TYPE := Type("frost.core.UInt32", Type.Kind.CLASS, Position(), true)

    def UINT64_TYPE := Type("frost.core.UInt64", Type.Kind.CLASS, Position(), true)

    def UINT_TYPE := Type("frost.core.UInt", Type.Kind.CLASS, Position(), true)

    def REAL32_TYPE := Type("frost.core.Real32", Type.Kind.CLASS, Position(), true)

    def REAL64_TYPE := Type("frost.core.Real64", Type.Kind.CLASS, Position(), true)

    def CHAR8_TYPE := Type("frost.core.Char8", Type.Kind.CLASS, Position(), true)

    def CHAR16_TYPE := Type("frost.core.Char16", Type.Kind.CLASS, Position(), true)

    def CHAR32_TYPE := Type("frost.core.Char32", Type.Kind.CLASS, Position(), true)

    def BIT_TYPE := Type("frost.core.Bit", Type.Kind.CLASS, Position(), true)

    def BIT_LITERAL_TYPE := Type("$bit_literal", Type.Kind.BIT_LITERAL, Position(), true)

    def BUILTIN_BIT_TYPE := Type("builtin_bit", Type.Kind.BUILTIN_BIT, Position(), true)

    def ITERATOR_TYPE := Type("frost.collections.Iterator", Type.Kind.CLASS, Position(), true)

    def ITERABLE_TYPE := Type("frost.collections.Iterable", Type.Kind.CLASS, Position(), true)
    
    def FROST_TYPE := Type("frost.core.Frost", Type.Kind.CLASS, Position(), true)
    
    def METHOD_TYPE := Type("frost.core.Method", Type.Kind.CLASS, Position(), true)
    
    def MUTABLE_METHOD_TYPE := Type("frost.core.MutableMethod", Type.Kind.CLASS, Position(), true)

    def RANGE_TYPE := Type("frost.core.Range", Type.Kind.CLASS, Position(), true)
    
    def STEPPED_RANGE_TYPE := Type("frost.core.SteppedRange", Type.Kind.CLASS, Position(), true)

    def WEAK_TYPE := Type("frost.core.Weak", Type.Kind.CLASS, Position(), true)

    def NEW_POINTER_TYPE := Type("frost.unsafe.Pointer", Type.Kind.CLASS, Position(), true)

    def ARRAY_TYPE := Type("frost.collections.Array", Type.Kind.CLASS, Position(), true)

    def IMMUTABLE_ARRAY_TYPE := Type("frost.collections.ImmutableArray", Type.Kind.CLASS,
            Position(), true)

    def CHOICE_DATA_TYPE := Type("<choice data>", Type.Kind.INVALID, Position(), true)
    
    def INVALID_TYPE := Type("<invalid>", Type.Kind.INVALID, Position(), true)

    -- name of the field in which we store captured "self"
    constant CAPTURED_SELF_NAME := "$self"

    -- within closures, 'self' is normally interpreted as the captured $self object. $force_self is
    -- always a reference to the actual 'self' - in a closure, this will be the closure object
    -- itself.
    constant FORCE_SELF_NAME := "$force_self"
    
    constant NONNULLABLE_TO_NULLABLE_CAST_COST := 1
    
    constant NULLABLE_TO_NONNULLABLE_CAST_COST := 2

    def settings:Settings

    def parser:Parser

    def scanner:Scanner

    def root:SymbolTable

    var compiling:ClassDecl? := null

    var compilationQueue := Array<ClassDecl>()

    def files := Array<File>()

    def methods := Array<MethodDecl>()

    @private
    def scans := HashMap<File, Array<ClassDecl>>()

    @private
    def classes := HashMap<String, ClassDecl>()

    @private
    def currentClass := Stack<ClassDecl>()

    @private
    def currentMethod := Stack<MethodDecl>()

    @private
    var ir := IR()

    @private
    var symbolTable:SymbolTable

    @private
    var methodSymbolTable:SymbolTable

    def cg:CodeGenerator

    @private
    def backend:Backend?

    @private
    var errorQueue:MessageQueue<Message>

    @private
    var enclosingContexts := Stack<EnclosingContext>()

    @private
    var errorCount := 0

    @private
    var closureCount := 0

    @private
    var tempCount := 0

    @private
    var existenceCache := HashMap<File, Bit>()

    @private
    var reportErrors := true

    @private
    def pendingClasses := Array<ClassDecl>()

    @private
    var inAtPre := false

    @private
    var resolvingFieldType := false

    -- local variable in which to store the return value, for postcondition purposes, or null to
    -- just do a straight return
    @private
    var returnVar:Variable?

    -- current block to which @pre(...) expressions should be added. This is not necessarily the
    -- method entry, because expressions can cause new blocks to be added.
    @private
    var atPreBlock:IR.Block.ID? := null

    -- block to which we should jump to begin evaluating postconditions. The postcondition block
    -- will handle returning from the method.
    @private
    var postconditionEntryBlock:IR.Block.ID? := null

    -- block to which postconditions are being compiled. This is not necessarily the postcondition
    -- entry block, because expressions can cause new blocks to be added.
    @private
    var postconditionCurrentBlock:IR.Block.ID? := null

    -- MethodDecl is the method *containing* the closure, not the closure itself
    @private
    def captures := Stack<Pair<MethodDecl, Map<String, Capture>>>()

    @private
    var writeCode := true

    @private
    var inFieldCleanup := false

    @private
    def expressionCoercionCosts := HashMap<ExpressionCoercionKey, Pair<Type, Int>>()

    @private
    def typeCoercionCosts := HashMap<TypeCoercionKey, Pair<Type, Int>>()

    @private
    def binaryTypes := HashMap<BinaryKey, Array<Type>?>()

    -- Sometimes we need to resolve an untyped lambda against several different types, such as when
    -- calling an overloaded method which can take different types of functions. If, say, the lambda
    -- only successfully resolves for one particular type of function, then we know the type of
    -- lambda we're dealing with. But if it fails for *all* of them, it could be that the lambda
    -- simply contains an error. So we keep track of all of the types we attempted to resolve a
    -- given lambda as for error reporting purposes.
    @private
    def lambdaTypes := IdentityMap<ASTNode, HashSet<Type>>()

    init(errorQueue:MessageQueue<Message>, backend:Backend?, settings:Settings) {
        self.settings := settings
        self.scanner := Scanner(self)
        self.root := SymbolTable(self)
        self.parser := Parser(errorQueue)
        self.symbolTable := root
        if backend !== null {
            self.cg := CodeGenerator(self, backend)
            self.backend := backend
        }
        self.errorQueue := errorQueue
        root.add(BUILTIN_BIT_TYPE)
        root.add(BUILTIN_INT_TYPE)
        root.add(BUILTIN_INT8_TYPE)
        root.add(BUILTIN_INT16_TYPE)
        root.add(BUILTIN_INT32_TYPE)
        root.add(BUILTIN_INT64_TYPE)
        root.add(BUILTIN_UINT_TYPE)
        root.add(BUILTIN_UINT8_TYPE)
        root.add(BUILTIN_UINT16_TYPE)
        root.add(BUILTIN_UINT32_TYPE)
        root.add(BUILTIN_UINT64_TYPE)
        root.add(BUILTIN_FLOAT32_TYPE)
        root.add(BUILTIN_FLOAT64_TYPE)
        root.add(Alias("Real", REAL64_TYPE))
        addAlias("frost.collections.Array")
        addAlias("frost.collections.Collection")
        addAlias("frost.collections.CollectionView")
        addAlias("frost.collections.CollectionWriter")
        addAlias("frost.collections.HashKey")
        addAlias("frost.collections.HashSet")
        addAlias("frost.collections.IdentityMap")
        addAlias("frost.collections.IdentitySet")
        addAlias("frost.collections.ImmutableArray")
        addAlias("frost.collections.Iterable")
        addAlias("frost.collections.Iterator")
        addAlias("frost.collections.List")
        addAlias("frost.collections.ListView")
        addAlias("frost.collections.ListWriter")
        addAlias("frost.collections.HashMap")
        addAlias("frost.collections.Map")
        addAlias("frost.collections.MapView")
        addAlias("frost.collections.MapWriter")
        addAlias("frost.collections.SpecializedArray")
        addAlias("frost.collections.Stack")
        addAlias("frost.core.Class")
        addAlias("frost.core.Bit")
        addAlias("frost.core.Char8")
        addAlias("frost.core.Char16")
        addAlias("frost.core.Char32")
        addAlias("frost.core.Comparable")
        addAlias("frost.core.Equatable")
        addAlias("frost.core.Error")
        addAlias("frost.core.Formattable")
        addAlias("frost.core.Int8")
        addAlias("frost.core.Int16")
        addAlias("frost.core.Int32")
        addAlias("frost.core.Int64")
        addAlias("frost.core.Int")
        addAlias("frost.core.Immutable")
        addAlias("frost.core.Maybe")
        addAlias("frost.core.Method")
        addAlias("frost.core.MutableString")
        addAlias("frost.core.Object")
        addAlias("frost.core.Frost")
        addAlias("frost.core.Range")
        addAlias("frost.core.Real32")
        addAlias("frost.core.Real64")
        addAlias("frost.core.RegularExpression")
        addAlias("frost.core.SimpleRange")
        addAlias("frost.core.SteppedRange")
        addAlias("frost.core.String")
        addAlias("frost.core.System")
        addAlias("frost.core.UInt8")
        addAlias("frost.core.UInt16")
        addAlias("frost.core.UInt32")
        addAlias("frost.core.UInt64")
        addAlias("frost.core.UInt")
        addAlias("frost.core.Value")
        addAlias("frost.core.Weak")
        addAlias("frost.math.MersenneTwister")
        addAlias("frost.math.Random")
        addAlias("frost.math.XorShift128Plus")
        addAlias("frost.io.Console")
        addAlias("frost.io.File")
        addAlias("frost.io.IndentedOutputStream")
        addAlias("frost.io.InputStream")
        addAlias("frost.io.LineNumberInputStream")
        addAlias("frost.io.MemoryInputStream")
        addAlias("frost.io.MemoryOutputStream")
        addAlias("frost.io.OutputStream")
        addAlias("frost.io.PushbackInputStream")
        addAlias("frost.threads.Lock")
        addAlias("frost.threads.MessageQueue")
        addAlias("frost.threads.Notifier")
        addAlias("frost.threads.ScopedLock")
        addAlias("frost.threads.Thread")
        addAlias("frost.time.Timer")
        addAlias("frost.json.JSON")
        addAlias("frost.json.JSONParser")
        if backend !== null {
            backend.setCompiler(self)
        }
    }

    @private
    method addAlias(name:String) {
        root.add(Alias(name[name.next(name.lastIndexOf(".")!)..],
                Type(name, Type.Kind.CLASS, Position(), true)))
    }

    method isRefCounted(type:Type):Bit {
        if !type.isClass {
            return false
        }
        return !isValue(type)
    }

    property currentMethodIndex:Int
    function get_currentMethodIndex():Int {
        return currentMethod[0].index
    }

    ================================================================================================
    Attempts to locate a class with the given, possibly not-fully-qualified, class name. Returns
    null and does not report any errors on failure.
    ================================================================================================
    @post(currentClass.count = @pre(currentClass.count))
    method tryResolveClass(name:String):ClassDecl? {
        def current:ClassDecl?
        if currentClass.count > 0 {
            current := currentClass[0]
        }
        else {
            current := null
        }
        if current !== null {
            var result := current.classResolutionCache[name]
            if result !== null {
                return result.value
            }
            def alias := current.aliases[name]
            if alias !== null {
                result := ClassDecl.Resolution(getClass(alias))
                current.classResolutionCache[name] := result
                return result.value
            }
        }
        var result := getClass(name)
        if current !== null {
            if result == null {
                def idx := current.name.lastIndexOf(".")
                if idx !== null {
                    result := getClass(current.name[...idx] + name)
                }
            }
            if result == null {
                result := getClass(current.name + "." + name)
            }
            if result == null & current.owner !== null {
                currentClass.push(current.owner!)
                result := tryResolveClass(name)
                currentClass.pop()
            }
        }
        if result == null {
            def rootAlias := root[name]
            if rootAlias !== null & rootAlias.kind = Symbol.Kind.ALIAS {
                result := getClass(rootAlias->Alias.type)
            }
        }
        if result == null {
            def index := name.lastIndexOf(".")
            if index !== null {
                -- could be an inner class name; see if we can locate an enclosing class
                def parent := tryResolveClass(name[..index])
                if parent !== null {
                    result := getClass(parent.name + name[index..])
                }
            }
        }
        if current !== null {
            current.classResolutionCache[name] := ClassDecl.Resolution(result)
        }
        return result
    }

    function typeParameters(type:Type):ListView<Type> {
        match type.typeKind {
            when Type.Kind.GENERIC_CLASS_PARAMETER {
                return typeParameters(type.genericClassParameter!.bound)
            }
            when Type.Kind.GENERIC_METHOD_PARAMETER {
                return typeParameters(type.genericMethodParameter!.bound)
            }
            when Type.Kind.GENERIC {
                assert type.subtypes.count >= 2
                return type.subtypes[1..]
            }
            when Type.Kind.NULLABLE {
                return typeParameters(type.subtypes[0])
            }
            otherwise {
                return []
            }
        }
    }

    ================================================================================================
    Verifies that a type uses the correct number and kind of generic arguments for the class it
    refers to. Reports error(s) and returns false if the type is not valid.
    ================================================================================================
    method checkGenericArguments(position:Position, cl:ClassDecl, type:Type):Bit {
        if !resolve(cl) {
            assert errorCount > 0
            return false
        }
        assert type.resolved
        def expectedCount := cl.parameters.count
        def foundTypes := typeParameters(type)
        def foundCount := foundTypes.count
        if expectedCount != foundCount {
            error(position, "'\{cl.name}' expected \{expectedCount} generic " +
                    "argument\{expectedCount = 1:|s}, but found \{foundCount}")
            return false
        }
        def object := OBJECT_TYPE
        for i in 0 .. expectedCount {
            def bound := cl.parameters[i].bound
            if bound = object | (bound.typeKind = Type.Kind.NULLABLE & bound.subtypes[0] = object) {
                continue
            }
            if coercionCost(foundTypes[i], remapType(type, bound)) == null {
                error(position, "generic argument '\{cl.name}.\{cl.parameters[i].name}' must be " +
                        "of type '\{cl.parameters[i].bound}', but found '\{foundTypes[i]}'")
                return false
            }
        }
        return true
    }

    @post(@return == null & (errorCount > 0 | !reportErrors) | (@return !== null & @return.resolved))
    method resolve(type:Type, checkArguments:Bit):Type? {
        if type.resolved {
            return type
        }
        match type.typeKind {
            when Type.Kind.CLASS {
                def resolved := tryResolveClass(type.name)
                if resolved !== null {
                    def result := resolved.type
                    if result !== null & checkArguments &
                            !checkGenericArguments(type.position, resolved, result) {
                        return null
                    }
                    return result
                }
                def s := symbolTable[type.name]
                if s !== null {
                    match s.kind {
                        when Symbol.Kind.ALIAS {
                            return resolve(s->Alias.type, checkArguments)
                        }
                        when Symbol.Kind.GENERIC_CLASS_PARAMETER {
                            def gp := s->ClassDecl.GenericParameter
                            return Type(gp)
                        }
                        when Symbol.Kind.GENERIC_METHOD_PARAMETER {
                            def gp := s->MethodDecl.GenericParameter
                            return Type(gp)
                        }
                        when Symbol.Kind.TYPE {
                            return s->Type
                        }
                    }
                }
                error(type.position, "unknown type '\{type}'")
                return null
            }
            when Type.Kind.NULLABLE {
                assert type.subtypes.count = 1
                def subtypes := Array<Type>()
                def sub := resolve(type.subtypes[0])
                if sub == null {
                    return null
                }
                subtypes.add(sub)
                return Type(subtypes[0].name + "?", Type.Kind.NULLABLE, type.position, subtypes,
                        true)
            }
            when Type.Kind.GENERIC {
                assert type.subtypes.count >= 2
                def base := resolve(type.subtypes[0], false)
                if base == null {
                    return null
                }
                def args := Array<Type>()
                for i in 1 .. type.subtypes.count {
                    def resolved := resolve(type.subtypes[i])
                    if resolved == null {
                        return null
                    }
                    args.add(resolved)
                }
                def result := Type.generic(base, args)
                def cl := getClass(result.subtypes[0])
                if cl !== null & checkArguments &
                        !checkGenericArguments(type.position, cl, result) {
                    return null
                }
                return result
            }
            when Type.Kind.METHOD, Type.Kind.FUNCTION, Type.Kind.IMMUTABLE_METHOD,
                    Type.Kind.IMMUTABLE_FUNCTION {
                def params := Array<Type>()
                for i in 0 .. type.parameterCount {
                    def resolved := resolve(type.parameterType(i))
                    if resolved == null {
                        return null
                    }
                    params.add(resolved)
                }
                def returnType := resolve(type.returnType)
                if returnType == null {
                    return null
                }
                return Type.methodType(self, type.position, type.typeKind, params, returnType, 0)
            }
            when Type.Kind.TUPLE {
                assert type.subtypes.count >= 2, "invalid tuple type \{type}"
                def args := Array<Type>()
                for a in type.subtypes {
                    def resolved := resolve(a)
                    if resolved == null {
                        return null
                    }
                    args.add(resolved)
                }
                return Type.tuple(args)
            }
            otherwise {
                unreachable
            }
        }
    }

    method resolve(type:Type):Type? {
        return resolve(type, true)
    }

    method addAllSupertypes(cl:ClassDecl, set:HashSet<String>) {
        if set.contains(cl.name) {
            return
        }
        set.add(cl.name)
        resolve(cl)
        if cl.rawSuper !== null {
            def superclass := getClass(cl.rawSuper)
            if superclass !== null {
                addAllSupertypes(superclass, set)
            }
        }
        for intfType in cl.rawInterfaces {
            def intf := getClass(intfType)
            if intf !== null {
                addAllSupertypes(intf, set)
            }
        }
    }

    @pre(cl.classKind = ClassDecl.Kind.CHOICE)
    method createChoiceEqualsIfNeeded(cl:ClassDecl) {
        def equatable := getClass("frost.core.Equatable")!
        for cc in cl.choiceCases {
            assert cc.resolved != Resolution.UNRESOLVED
            if cc.resolved != Resolution.RESOLVED {
                return
            }
            for f in cc.fields {
                if findType(f, equatable) == null {
                    return
                }
            }
        }
        -- every field of every choice is equatable, make the choice equatable
        cl.declaredSupers.add(Type.generic(equatable.type, [cl.type]))
        def parameters := Array<MethodDecl.Parameter>()
        parameters.add(MethodDecl.Parameter("other", cl.type))
        def p := cl.position
        def whens := Array<ASTNode>()
        for cc in cl.choiceCases {
            var test:ASTNode := ASTNode.BIT(p, true)
            def params1 := Array<ASTNode>()
            def params2 := Array<ASTNode>()
            for i in 0 .. cc.fields.count {
                def name := "field\{i}"
                params1.add(ASTNode.IDENTIFIER(p, name + "_1"))
                params2.add(ASTNode.IDENTIFIER(p, name + "_2"))
                def value1 := ASTNode.IDENTIFIER(p, name + "_1")
                def value2 := ASTNode.IDENTIFIER(p, name + "_2")
                def currentTest:ASTNode
                if cc.fields[i].typeKind = Type.Kind.NULLABLE {
                    currentTest := ASTNode.CALL(p, ASTNode.DOT(p, ASTNode.DOT(p, ASTNode.DOT(p,
                            ASTNode.IDENTIFIER(p, "frost"), "core"), "Frost"), "equal"),
                            FixedArray<ASTNode>.from([value1, value2]))
                }
                else {
                    currentTest := ASTNode.BINARY(p, value1, Binary.Operator.EQ, value2)
                }
                if i > 0 {
                    test := ASTNode.BINARY(p, test, Binary.Operator.AND, currentTest)
                }
                else {
                    test := currentTest
                }
            }
            def when2 := ASTNode.WHEN(p, FixedArray<ASTNode>.from([ASTNode.CALL(p,
                    ASTNode.IDENTIFIER(p, cc.name), FixedArray<ASTNode>.from(params2))]),
                    FixedArray<ASTNode>.from([ASTNode.RETURN(p, test)]))
            def match2 := ASTNode.MATCH(p, ASTNode.IDENTIFIER(p, "other"),
                FixedArray<ASTNode>.from([when2]),
                FixedArray<ASTNode>.from([ASTNode.RETURN(p, ASTNode.BIT(p, false))]))
            whens.add(ASTNode.WHEN(p, FixedArray<ASTNode>.from([ASTNode.CALL(p,
                    ASTNode.IDENTIFIER(p, cc.name), FixedArray<ASTNode>.from(params1))]),
                    FixedArray<ASTNode>.from([match2])))
        }
        def body := Array<ASTNode>()
        body.add(ASTNode.MATCH(p, ASTNode.SELF(p), FixedArray<ASTNode>.from(whens),
                FixedArray<ASTNode>.from([ASTNode.UNREACHABLE(p, null)])))
        def eq := MethodDecl(cl, p, methods.count, null,
                Annotations(Annotations.Flag.OVERRIDE || Annotations.Flag.SYNTHETIC),
                MethodDecl.Kind.FUNCTION, "=", null, parameters, BIT_TYPE,
                FixedArray<ASTNode>.from(body))
        methods.add(eq)
        cl.methods.add(eq)
    }

    @pre(cl.classKind = ClassDecl.Kind.CHOICE)
    method createChoiceHashIfNeeded(cl:ClassDecl) {
        def key := getClass("frost.collections.HashKey")!
        for cc in cl.choiceCases {
            assert cc.resolved != Resolution.UNRESOLVED
            if cc.resolved != Resolution.RESOLVED {
                return
            }
            for f in cc.fields {
                if findType(f, key) == null {
                    return
                }
            }
        }
        -- every field of every choice is a key, make the choice a key
        cl.declaredSupers.add(Type.generic(key.type, [cl.type]))
        def p := cl.position
        def whens := Array<ASTNode>()
        for i in 0 .. cl.choiceCases.count {
            def cc := cl.choiceCases[i]
            var statement := ASTNode.INT(p, cl.name.hash.asUInt64 * (i + 1).asUInt64)
            def params := Array<ASTNode>()
            for i in 0 .. cc.fields.count {
                def name := "field\{i}"
                params.add(ASTNode.IDENTIFIER(p, name))
                var value := ASTNode.IDENTIFIER(p, name)
                if cc.fields[i].typeKind = Type.Kind.NULLABLE {
                    value := ASTNode.CALL(p, ASTNode.DOT(p, ASTNode.DOT(p, ASTNode.DOT(p,
                            ASTNode.IDENTIFIER(p, "frost"), "core"), "Frost"), "hash"),
                            FixedArray<ASTNode>.from([value]))
                }
                else {
                    value := ASTNode.DOT(p, ASTNode.IDENTIFIER(p, name), "hash")
                }
                statement := ASTNode.BINARY(p, statement, Binary.Operator.BITWISEXOR, value)
            }
            statement := ASTNode.RETURN(p, statement)
            whens.add(ASTNode.WHEN(p, FixedArray<ASTNode>.from([ASTNode.CALL(p,
                    ASTNode.IDENTIFIER(p, cc.name), FixedArray<ASTNode>.from(params))]),
                    FixedArray<ASTNode>.from([statement])))
        }
        def body := Array<ASTNode>()
        body.add(ASTNode.MATCH(p, ASTNode.SELF(p), FixedArray<ASTNode>.from(whens),
                FixedArray<ASTNode>.from([ASTNode.UNREACHABLE(p, null)])))
        def hash := MethodDecl(cl, p, methods.count, null,
                Annotations(Annotations.Flag.OVERRIDE || Annotations.Flag.SYNTHETIC),
                MethodDecl.Kind.FUNCTION, "get_hash", null, [], INT_TYPE,
                FixedArray<ASTNode>.from(body))
        methods.add(hash)
        cl.methods.add(hash)
    }

    @pre(cl.classKind = ClassDecl.Kind.CHOICE)
    method createChoiceAsStringIfNeeded(cl:ClassDecl) {
        for m in cl.methods {
            if m.name = "get_asString" & m.parameters.count = 0 {
                def returnType := resolve(m.returnType)
                if returnType !== null & returnType = STRING_TYPE {
                    return
                }
            }
        }
        def p := cl.position
        def whens := Array<ASTNode>()
        for cc in cl.choiceCases {
            var statement := ASTNode.STRING(p, cc.name)
            def params := Array<ASTNode>()
            var separator := "("
            for i in 0 .. cc.fields.count {
                def name := "field\{i}"
                params.add(ASTNode.IDENTIFIER(p, name))
                statement := ASTNode.BINARY(p, statement, Binary.Operator.ADD,
                        ASTNode.STRING(p, separator))
                separator := ", "
                var value := ASTNode.IDENTIFIER(p, name)
                if cc.fields[i].typeKind = Type.Kind.NULLABLE {
                    value := ASTNode.CALL(p, ASTNode.DOT(p, ASTNode.DOT(p, ASTNode.DOT(p,
                            ASTNode.IDENTIFIER(p, "frost"), "core"), "Frost"), "string"),
                            FixedArray<ASTNode>.from([value]))
                }
                statement := ASTNode.BINARY(p, statement, Binary.Operator.ADD, value)
            }
            if cc.fields.count > 0 {
                statement := ASTNode.BINARY(p, statement, Binary.Operator.ADD,
                        ASTNode.STRING(p, ")"))
            }
            statement := ASTNode.RETURN(p, statement)
            whens.add(ASTNode.WHEN(p, FixedArray<ASTNode>.from([ASTNode.CALL(p,
                    ASTNode.IDENTIFIER(p, cc.name), FixedArray<ASTNode>.from(params))]),
                    FixedArray<ASTNode>.from([statement])))
        }
        def body := Array<ASTNode>()
        body.add(ASTNode.MATCH(p, ASTNode.SELF(p), FixedArray<ASTNode>.from(whens),
                FixedArray<ASTNode>.from([ASTNode.UNREACHABLE(p, null)])))
        def asString := MethodDecl(cl, p, methods.count, null,
                Annotations(Annotations.Flag.OVERRIDE || Annotations.Flag.SYNTHETIC),
                MethodDecl.Kind.FUNCTION, "get_asString", null, [], STRING_TYPE,
                FixedArray<ASTNode>.from(body))
        methods.add(asString)
        cl.methods.add(asString)
    }

    @pre(cl.classKind = ClassDecl.Kind.CHOICE)
    method choiceSuper(cl:ClassDecl):Type {
        var value := true
        for case in cl.choiceCases {
            if case.fields.count > 0 {
                value := false
                for f in case.fields {
                    if f.nonnullable() != cl.type & !isImmutable(f) {
                        return OBJECT_TYPE
                    }
                }
            }
        }
        if value {
            return VALUE_TYPE
        }
        return IMMUTABLE_TYPE
    }

    @post(currentClass.count = @pre(currentClass.count) &
            (@return | errorCount > 0 | !reportErrors))
    method resolve(cl:ClassDecl):Bit {
        if cl.resolved = Resolution.UNRESOLVED {
            cl.resolved := Resolution.IN_PROGRESS
            currentClass.push(cl)
            def auto := AutoScope(self, cl.symbolTable)
            for p in cl.parameters {
                def resolved := resolve(p.bound, false)
                if resolved !== null {
                    p.bound := resolved
                }
                else {
                    cl.resolved := Resolution.RESOLVED_WITH_ERRORS
                    assert currentClass[0] == cl
                    currentClass.pop()
                    return false
                }
            }
            for cc in cl.choiceCases {
                resolve(cc)
            }
            if cl.classKind = ClassDecl.Kind.CHOICE {
                createChoiceEqualsIfNeeded(cl)
                createChoiceHashIfNeeded(cl)
                createChoiceAsStringIfNeeded(cl)
            }
            def supertypes := HashSet<String>()
            for rawS in cl.declaredSupers {
                def resolvedType := resolve(rawS, false)
                if resolvedType == null {
                    cl.resolved := Resolution.RESOLVED_WITH_ERRORS
                    assert currentClass[0] == cl
                    currentClass.pop()
                    return false
                }
                def s := resolve(resolvedType, false)
                if s !== null {
                    def sClass := getClass(s)
                    if sClass !== null {
                        resolve(sClass)
                        addAllSupertypes(sClass, supertypes)
                        if sClass.classKind = ClassDecl.Kind.CLASS {
                            if cl.classKind = ClassDecl.Kind.INTERFACE {
                                error(rawS.position, "interface '\{cl.name}' cannot extend class " +
                                        "'\{s.name}'")
                            }
                            if cl.rawSuper == null {
                                cl.rawSuper := s
                                if cl.rawInterfaces.count > 0 {
                                    error(rawS.position, "superclass '\{s}' of class " +
                                            "'\{cl.name}' must be listed before any " +
                                            "superinterfaces")
                                }
                            }
                            else {
                                error(rawS.position, "class '\{cl.name}' has more than one " +
                                        "superclass")
                            }
                        }
                        else {
                            assert sClass.classKind = ClassDecl.Kind.INTERFACE
                            cl.rawInterfaces.add(s)
                        }
                    }
                    else {
                        cl.resolved := Resolution.RESOLVED_WITH_ERRORS
                        assert currentClass[0] == cl
                        currentClass.pop()
                        return false
                    }
                }
                else {
                    cl.resolved := Resolution.RESOLVED_WITH_ERRORS
                    assert currentClass[0] == cl
                    currentClass.pop()
                    return false
                }
            }
            if cl.rawSuper == null & cl.name != "frost.core.Object" {
                if cl.classKind = ClassDecl.Kind.CHOICE {
                    cl.rawSuper := choiceSuper(cl)
                }
                else {
                    cl.rawSuper := OBJECT_TYPE
                }
            }
            if cl.rawSuper !== null & !cl.annotations.isFinal &
                    cl.rawSuper.name = "frost.core.Value" {
                cl.annotations.flags ||= Annotations.Flag.FINAL
                for m in cl.methods {
                    m.annotations.flags ||= Annotations.Flag.FINAL
                    if m.body !== null & scanner.shouldInline(m.annotations, m.body) {
                        m.annotations.flags ||= Annotations.Flag.INLINE
                    }
                }
            }
            if supertypes.contains(cl.name) {
                error(cl.position, "circular inheritance; '\{cl.name}' inherits from itself")
                cl.resolved := Resolution.RESOLVED_WITH_ERRORS
            }
            if cl.resolved = Resolution.IN_PROGRESS {
                cl.resolved := Resolution.RESOLVED
            }
            if cl.rawSuper !== null {
                def superclass := getClass(cl.rawSuper)
                if superclass !== null & !cl.annotations.isStub {
                    checkGenericArguments(cl.position, superclass, cl.rawSuper)
                }
            }
            for intf in cl.rawInterfaces {
                def intfclass := getClass(intf)
                if intfclass !== null & !cl.annotations.isStub {
                    checkGenericArguments(cl.position, intfclass, intf)
                }
            }
            for p in cl.parameters {
                def cl := getClass(p.bound)
                if cl !== null & !cl.annotations.isStub {
                    checkGenericArguments(cl.position, cl, p.bound)
                }
            }
            currentClass.pop()
        }
        return cl.resolved != Resolution.RESOLVED_WITH_ERRORS
    }

    @post(currentClass.count = @pre(currentClass.count))
    method resolve(m:MethodDecl):Bit {
        if m.resolved != Resolution.UNRESOLVED {
            return m.resolved = Resolution.RESOLVED
        }
        m.resolved := Resolution.IN_PROGRESS
        resolve(m.owner)
        currentClass.push(m.owner)
        def symbols := AutoScope(self, SymbolTable(m.owner.symbolTable))
        if m.genericParameters !== null {
            for p in m.genericParameters {
                symbolTable.add(Type(p), p.name)
                def resolved := resolve(p.bound, false)
                if resolved !== null {
                    p.bound := resolved
                }
                else {
                    m.resolved := Resolution.RESOLVED_WITH_ERRORS
                }
            }
        }
        for p in m.parameters {
            def resolved := resolve(p.type)
            if resolved !== null {
                p.type := resolved
            }
            else {
                m.resolved := Resolution.RESOLVED_WITH_ERRORS
            }
        }
        if m.methodKind = MethodDecl.Kind.INIT {
            if isValue(m.owner) {
                m.returnType := m.owner.typeWithParameters()
            }
        }
        else {
            def resolved := resolve(m.returnType)
            if resolved !== null {
                m.returnType := resolved
            }
            else {
                m.resolved := Resolution.RESOLVED_WITH_ERRORS
            }
        }
        if m.resolved = Resolution.IN_PROGRESS {
            m.resolved := Resolution.RESOLVED
        }
        if !m.owner.external {
            def overridden := getOverriddenMethod(m)
            if overridden !== null {
                if !m.annotations.isOverride {
                    error(m.position, "\{m.declaration} overrides \{overridden.declaration}, " +
                            "but is not marked @override")
                }
                if m.methodKind = MethodDecl.Kind.METHOD &
                        overridden.methodKind = MethodDecl.Kind.FUNCTION {
                    error(m.position, "\{m.declaration} overrides \{overridden.declaration}, " +
                            "but methods cannot override functions")
                }
            }
            else if m.annotations.isOverride {
                error(m.position, "\{m.declaration} is marked @override, but no matching " +
                        "method exists among its ancestors")
            }
        }
        currentClass.pop()
        return m.resolved = Resolution.RESOLVED
    }

    @post(f.type != VOID_TYPE & f.type.resolved | errorCount > 0 | !reportErrors)
    method determineRawType(f:FieldDecl) {
        currentClass.push(f.owner)
        def auto := AutoScope(self, getSymbolTable(f.owner))
        if f.type != VOID_TYPE {
            def resolved := resolve(f.type)
            if resolved !== null {
                f.type := resolved
            }
            else {
                assert errorCount > 0
            }
            currentClass.pop()
            return
        }
        if f.rawValue == null {
            error(f.position, "field has neither a type nor a value")
            currentClass.pop()
            return
        }
        def old := resolvingFieldType
        resolvingFieldType := true
        def preferred := preferredType(f.rawValue)
        resolvingFieldType := false
        if preferred == null {
            -- report error
            if compileExpression(f.rawValue) !== null {
                error(f.position, "type of field '\{f.name}' was not specified and could not be " +
                        "determined")
            }
            currentClass.pop()
            return
        }
        f.type := preferred
        currentClass.pop()
    }

    @post(@return | errorCount > 0 | !reportErrors)
    method resolve(f:FieldDecl):Bit {
        if f.resolved = Resolution.IN_PROGRESS {
            error(f.position,
                    "encounted a circular dependency in the value of field \{f.name}")
            f.resolved := Resolution.RESOLVED_WITH_ERRORS
        }
        else if f.resolved = Resolution.UNRESOLVED {
            f.resolved := Resolution.IN_PROGRESS
            if f.owner.classKind != ClassDecl.Kind.INTERFACE {
                -- we need to mark that we are in an instance context so 'self' works. Since the
                -- class is guaranteed to have at least one init method, we just pretend we're in
                -- one of those.
                def firstInit:MethodDecl? := null
                for m in f.owner.methods {
                    if m.methodKind = MethodDecl.Kind.INIT {
                        firstInit := m
                        break
                    }
                }
                assert firstInit !== null | errorCount > 0,
                        "class \{f.owner.name} has no init methods"
                if firstInit == null {
                    f.resolved := Resolution.RESOLVED_WITH_ERRORS
                    return false
                }
                currentMethod.push(firstInit)
                determineRawType(f)
                currentMethod.pop()
            }
            else {
                def old := currentMethod
                currentMethod := Stack<MethodDecl>()
                determineRawType(f)
                currentMethod := old
            }
            if f.type != VOID_TYPE & f.type.resolved {
                f.resolved := Resolution.RESOLVED
            }
            else {
                f.resolved := Resolution.RESOLVED_WITH_ERRORS
            }
            if f.annotations.isWeak & f.type != VOID_TYPE {
                f.type := Type.WeakOf(self, f.type)
            }
        }
        return f.resolved = Resolution.RESOLVED
    }

    @post(currentClass.count = @pre(currentClass.count))
    method resolve(c:ChoiceCase) {
        if c.resolved != Resolution.UNRESOLVED {
            return
        }
        if c.fields.count = 0 {
            c.resolved := Resolution.RESOLVED
            createChoiceCaseInit(c)
            return
        }
        c.resolved := Resolution.IN_PROGRESS
        currentClass.push(c.owner)
        def auto := AutoScope(self, c.owner.symbolTable)
        for i in 0 .. c.fields.count {
            def resolved := resolve(c.fields[i])
            if resolved !== null {
                c.fields[i] := resolved
            }
            else {
                c.fields[i] := INVALID_TYPE
                c.resolved := Resolution.RESOLVED_WITH_ERRORS
            }
        }
        if c.resolved = Resolution.IN_PROGRESS {
            c.resolved := Resolution.RESOLVED
        }
        createChoiceCaseInit(c)
        currentClass.pop()
    }

    method isValue(cl:ClassDecl):Bit {
        if !resolve(cl) {
            return false
        }
        return cl.rawSuper !== null & cl.rawSuper.name = "frost.core.Value"
    }

    method isValue(t:Type):Bit {
        if !t.isClass {
            return true
        }
        def cl := getClass(t)
        if cl == null {
            return false
        }
        return isValue(cl)
    }

    method isImmutable(cl:ClassDecl):Bit {
        if !resolve(cl) {
            return false
        }
        if cl.name = "frost.core.Immutable" {
            return true
        }
        if cl.rawSuper !== null {
            def superclass := getClass(cl.rawSuper)
            if superclass == null {
                return false
            }
            return isImmutable(superclass)
        }
        return false
    }

    method isImmutable(t:Type):Bit {
        if !t.isClass | t.isClassLiteral {
            return true
        }
        def cl := getClass(t)
        if cl == null {
            return false
        }
        return isImmutable(cl)
    }

    method instanceFields(cl:ClassDecl):Array<FieldDecl> {
        def result := Array<FieldDecl>()
        if resolve(cl) {
            if !isValue(cl) & cl.rawSuper !== null {
                def s := getClass(cl.rawSuper)
                if s !== null {
                    result.addAll(instanceFields(s))
                }
            }
            for f in cl.fields {
                if !f.annotations.isClass & f.fieldKind != FieldDecl.Kind.PROPERTY {
                    result.add(f)
                }
            }
        }
        else {
        }
        return result
    }

    method exists(f:File):Bit {
        var result := existenceCache[f]
        if result == null {
            result := f.exists()
            existenceCache[f] := result
        }
        return result
    }

    ================================================================================================
    Attempts to load the class with the given fully-qualified name. Returns null on failure, without
    reporting an error.
    ================================================================================================
    method getClass(fullName:String):ClassDecl? {
        var result := classes[fullName]
        if result == null {
            var suffix1 := fullName.replace(".", "/") + ".stub"
            var suffix2 := fullName.replace(".", "/") + ".frost"
            var found := false
            for dir in settings.importDirs {
                var f := dir.resolve(suffix1)
                if exists(f) {
                    found := true
                    scan(f)
                    result := classes[fullName]
                    break
                }
                f := dir.resolve(suffix2)
                if exists(f) {
                    found := true
                    scan(f)
                    result := classes[fullName]
                    break
                }
            }
        }
        if result == null {
            def index := fullName.lastIndexOf(".")
            if index !== null {
                def parent := getClass(fullName[..index])
                if parent !== null {
                    result := classes[fullName]
                }
            }
        }
        return result
    }

    method getClass(position:Position, fullName:String):ClassDecl? {
        var result := classes[fullName]
        if result == null {
            def suffix1 := fullName.replace(".", "/") + ".stub"
            def suffix2 := fullName.replace(".", "/") + ".frost"
            var found := false
            for dir in settings.importDirs {
                var f := dir.resolve(suffix1)
                if exists(f) {
                    found := true
                    def oldErrorCount := errorCount
                    scan(f)
                    result := classes[fullName]
                    if result == null & errorCount = oldErrorCount {
                        error(Position(files.count, 1, 1),
                                "expected file '\{f}' to contain a class named '\{fullName}'")
                        files.add(f)
                    }
                    break
                }
                f := dir.resolve(suffix2)
                if exists(f) {
                    found := true
                    def oldErrorCount := errorCount
                    scan(f)
                    result := classes[fullName]
                    if result == null & errorCount = oldErrorCount {
                        error(Position(files.count, 1, 1),
                                "expected file '\{f}' to contain a class named '\{fullName}'")
                        files.add(f)
                    }
                }
            }
            if !found {
                error(position, "no file named \{suffix2} in any import path " +
                        "(\{settings.importDirs})")
            }
        }
        return result
    }

    ================================================================================================
    Given a requested type (e.g. `Foo<String, Int64>`), returns the actual type that the class
    should be specialized to. The actual type collapses all non-Value types down to their type
    bounds, since they're all just pointers and can be treated equivalently. This would likely
    result in `Foo<Object?, Int64>` in this case.
    ================================================================================================
    method specializedType(cl:ClassDecl, type:Type):Type {
        if type.typeKind = Type.Kind.CLASS {
            return type
        }
        assert type.typeKind = Type.Kind.GENERIC
        def args := Array<Type>()
        for i in 0 .. type.subtypes.count - 1 {
            if isValue(type.subtypes[i + 1]) {
                args.add(type.subtypes[i + 1])
            }
            else {
                args.add(cl.parameters[i].bound)
            }
        }
        return Type.generic(cl.type, args)
    }

    ================================================================================================
    Specializes a generic type to a particular set of type arguments. Specializing a type is similar
    to instantiating a C++ template, in that we create a copy of the code for each different set of
    type arguments.

    Or more precisely, we determine the widest set of types which can be used for each given
    specialization (see [specializedType]), and then re-use that (with different generic arguments)
    to fulfill matching requests.

    As a concrete example, suppose we have `class Foo<T, U> { ... }`, and we request
    `Foo<String, Int64>`. Since `String` is just a pointer and the `Foo` class has to be written as
    if `T` were an `Object?` anyway, it really doesn't matter whether the class is instantiated to
    use `String` or `File` or whatever else as a type parameter. So we can specialize `T` against
    the bound of `T`, in this case `Object?`.

    But `Int64` is a `Value`, not a pointer. We actually end up producing different code to handle
    `Int64` vs., say, `Int8`, so it matters that we are using this particular type. `Value` types
    (including nullable `Value`s) have to remain as-is. So we actually end up specializing
    `Foo<String, Int64>` into an instance of `Foo<Object?, Int64>`, and this class will be reused by
    any other compatible specializations of the `Foo` class.

    To make this class actually handle the `<String, Int>` types, the specialization is still
    generic (over `<T:Object?, U:Int64>`), and we can then specify its actual types as generic
    parameters. The resulting specialization has name `Foo<frost.core.Object?, frost.core.Int64>`,
    and so we end up with type name `Foo<frost.core.Object?, frost.core.Int64><frost.core.String,
    frost.core.Int64>`. This name is internal use only and this "doubly generic" syntax cannot
    actually be used in Frost source code. The inclusion of the `U:Int64` generic parameter is of
    course not strictly necessary, since `Int64` cannot be subclassed, but it simplifies things to
    always have the same number of generic parameters.

    FIXME: As a future optimization, we could probably worry only about the *size* of the Values and
    not their specific identities.
    ================================================================================================
    @post(currentClass.count = @pre(currentClass.count))
    method specialize(cl:ClassDecl, rawType:Type):ClassDecl {
        if !resolve(cl) {
            return cl
        }
        def type := specializedType(cl, resolve(rawType)!.nonnullable())
        if type.typeKind = Type.Kind.CLASS {
            return cl
        }
        def result:ClassDecl? := classes[type.name]
        if result == null {
            currentClass.push(cl)
            --def parameters := cl.parameters.combine<Type, ClassDecl.GenericParameter>(type,
              --      (p1:ClassDecl.GenericParameter, p2:Type) => ClassDecl.GenericParameter(p1.position, p1.owner, p1.name, p2))
            --Console.printLine("parameters: \{parameters}")
            def annotations := Annotations((cl.annotations.flags || Annotations.Flag.SYNTHETIC) &&
                    !!Annotations.Flag.SPECIALIZE)
            def supertypes := Array<Type>()
            supertypes.add(remapType(type, cl.rawSuper))
            for intf in cl.rawInterfaces {
                supertypes.add(remapType(type, intf))
            }
            result := ClassDecl(cl.source, cl.position, cl.aliases, cl.doccomment, annotations,
                    cl.classKind, type, supertypes, [],
                    cl.symbolTable.parents[0])
            for i in 0 .. cl.parameters.count {
                result.symbolTable.add(Alias(cl.parameters[i].name, type.subtypes[i + 1]))
            }
            result.external := false
            for m in cl.methods {
                resolve(m)
                def generics:Array<MethodDecl.GenericParameter>?
                if m.genericParameters !== null {
                    for p in m.genericParameters {
                        generics.add(MethodDecl.GenericParameter(p.position, p.owner, p.name,
                                remapType(type, p.bound)))
                    }
                }
                def parameters := m.parameters.map(p => MethodDecl.Parameter(p.name,
                        self.remapType(type, p.type)))
                def clone := MethodDecl(result, m.position, methods.count, m.doccomment,
                        m.annotations, m.methodKind, m.name, generics, parameters,
                        remapType(type, m.returnType), m.body)
                methods.add(clone)
                result.methods.add(clone)
                result.symbolTable.add(clone)
            }
            for f in cl.fields {
                resolve(f)
                def clone := FieldDecl(result, f.position, f.doccomment, f.annotations, f.fieldKind,
                        f.name, remapType(type, f.type), f.rawValue)
                result.fields.add(clone)
                result.symbolTable.add(clone)
            }
            classes[result.name] := result
            resolve(result)
            compilationQueue.add(result)
            currentClass.pop()
            resolve(result)
        }
        return result
    }

    method getClass(type:Type):ClassDecl? {
        var result:ClassDecl?
        match type.typeKind {
            when Type.Kind.CLASS {
                result := getClass(type.position, type.name)
            }
            when Type.Kind.GENERIC {
                if type.subtypes[0] = CLASS_TYPE {
                    return getClass(type.subtypes[1])
                }
                result := getClass(type.subtypes[0])
            }
            when Type.Kind.NULLABLE {
                result := getClass(type.subtypes[0])
            }
            when Type.Kind.GENERIC_CLASS_PARAMETER {
                return getClass(type.genericClassParameter.bound)
            }
            when Type.Kind.GENERIC_METHOD_PARAMETER {
                return getClass(type.genericMethodParameter.bound)
            }
            when Type.Kind.METHOD, Type.Kind.FUNCTION {
                return getClass(MUTABLE_METHOD_TYPE)
            }
            when Type.Kind.IMMUTABLE_METHOD, Type.Kind.IMMUTABLE_FUNCTION {
                return getClass(METHOD_TYPE)
            }
            when Type.Kind.TUPLE {
                var isKey := true
                var isEquatable := true
                def equatable := getClass("frost.core.Equatable")
                assert equatable !== null
                def key := getClass("frost.collections.HashKey")
                assert key !== null
                for t in type.subtypes {
                    if isEquatable & findType(t, equatable) == null {
                        isEquatable := false
                    }
                    if isKey & findType(t, key) == null {
                        isKey := false
                    }
                }
                if isKey {
                    return getClass(Type("frost.core.KeyTuple\{type.subtypes.count}",
                            Type.Kind.CLASS, Position(), true))
                }
                if isEquatable {
                    return getClass(Type("frost.core.EquatableTuple\{type.subtypes.count}",
                            Type.Kind.CLASS, Position(), true))
                }
                return getClass(Type("frost.core.Tuple\{type.subtypes.count}", Type.Kind.CLASS,
                        Position(), true))
            }
            otherwise {
                error(type.position, "type '\{type}' is not a class")
                return null
            }
        }
        if result !== null & result.annotations.isSpecialize {
            result := specialize(result, type)
        }
        return result
    }

    method allInterfaces(t:Type):HashSet<Type> {
        def result := HashSet<Type>()
        def cl := getClass(t)
        if cl !== null & resolve(cl) {
            if cl.resolved = Resolution.RESOLVED {
                if cl.rawSuper !== null {
                    result.addAll(allInterfaces(remapType(t, cl.rawSuper)))
                }
                for intf in cl.rawInterfaces {
                    result.addAll(allInterfaces(remapType(t, intf)))
                }
                if cl.classKind = ClassDecl.Kind.INTERFACE {
                    result.add(t)
                }
            }
        }
        return result
    }

    function signatureMatch(t1:Type, t2:Type):Bit {
        assert t1.isMethod
        assert t2.isMethod
        if t1.subtypes.count != t2.subtypes.count {
            return false
        }
        for i in 0 .. t1.subtypes.count {
            if t1.subtypes[i] != t2.subtypes[i] {
                return false
            }
        }
        return true
    }

    method findMethod(owner:Type, name:String, methodType:Type, checkInterfaces:Bit):MethodDecl? {
        def cl := getClass(owner)
        if cl == null {
            return null
        }
        if !resolve(cl) {
            return null
        }
        for test in cl.methods {
            if test.name = name {
                resolve(test)
                if signatureMatch(remapType(owner, declaredType(test)), methodType) {
                    return test
                }
            }
        }
        for raw in cl.rawInterfaces {
            def result := findMethod(remapType(owner, raw), name, methodType, checkInterfaces)
            if result !== null & (checkInterfaces | cl.classKind = ClassDecl.Kind.INTERFACE |
                    result.body !== null) {
                return result
            }
        }
        if cl.rawSuper !== null {
            return findMethod(remapType(owner, cl.rawSuper), name, methodType, checkInterfaces)
        }
        return null
    }

    function getOverriddenMethod(m:MethodDecl):MethodDecl? {
        if m.overrideKnown {
            return m.overridden
        }
        if m.methodKind = MethodDecl.Kind.INIT {
            m.overrideKnown := true
            return null
        }
        resolve(m)
        def methodType := declaredType(m)
        def owner := m.owner.typeWithParameters()
        for raw in m.owner.rawInterfaces {
            def result := findMethod(remapType(owner, raw), m.name, methodType, true)
            if result !== null {
                m.overrideKnown := true
                m.overridden := result
                return result
            }
        }
        resolve(m.owner)
        if m.owner.rawSuper !== null {
            def result := findMethod(remapType(owner, m.owner.rawSuper), m.name, methodType, true)
            m.overrideKnown := true
            m.overridden := result
            return result
        }
        m.overrideKnown := true
        return null
    }

    method interfaceMethods(cl:ClassDecl, intf:Type):Array<MethodDecl> {
        def intfClass := getClass(intf)
        assert intfClass !== null
        def result := Array<MethodDecl>()
        for m in intfClass.methods {
            if m.annotations.isClass {
                continue
            }
            def found := findMethod(cl.type, m.name, remapType(intf, inheritedType(m)), false)
            if found !== null {
                result.add(found)
            }
            else if m.body !== null {
                result.add(m)
            }
            else {
                error(cl.position, "class '\{cl.name}' does not implement interface " +
                        m.declaration)
            }
        }
        return result
    }

    method checkInterfaceMethods() {
        def cl := currentClass[0]
        for intf in allInterfaces(cl.type) {
            interfaceMethods(cl, intf)
        }
    }

    method getSymbolTable(cl:ClassDecl):SymbolTable {
        if !cl.symbolTableResolved {
            cl.symbolTableResolved := true
            if resolve(cl) {
                if cl.rawSuper !== null {
                    def superCl := getClass(cl.rawSuper)
                    if superCl !== null {
                        cl.symbolTable.parents.add(getSymbolTable(superCl))
                    }
                }
                for rawIntf in cl.rawInterfaces {
                    def intf := getClass(rawIntf)
                    if intf !== null {
                        cl.symbolTable.parents.add(getSymbolTable(intf))
                    }
                }
                if cl.owner !== null {
                    --cl.symbolTable.parents.add(getSymbolTable(cl.owner))
                }
            }
        }
        return cl.symbolTable
    }

    @post(currentClass.count = @pre(currentClass.count))
    method getVTable(cl:ClassDecl):Array<MethodDecl> {
        if cl.virtualMethods.count = 0 {
            resolve(cl)
            currentClass.push(cl) -- FIXME Auto
            if cl.rawSuper !== null {
                def superCl := getClass(cl.rawSuper)
                if superCl == null {
                    currentClass.pop()
                    return cl.virtualMethods
                }
                cl.virtualMethods.addAll(getVTable(superCl))
            }
            for derived in cl.methods {
                resolve(derived)
                if derived.methodKind = MethodDecl.Kind.INIT | derived.annotations.isClass {
                    continue
                }
                var found := false
                for i in 0 .. cl.virtualMethods.count {
                    def base := cl.virtualMethods[i]
                    resolve(base)
                    def overridden := getOverriddenMethod(derived)
                    if overridden !== null & (overridden == base |
                                overridden == getOverriddenMethod(base)) {
                        found := true
                        cl.virtualMethods[i] := derived
                        break
                    }
                }
                if !found {
                    cl.virtualMethods.add(derived)
                }
            }
            def intfs := allInterfaces(cl.type)
            -- check if there are any abstract methods with default interface method
            -- implementations
            for i in 0 .. cl.virtualMethods.count {
                def m := cl.virtualMethods[i]
                if m.annotations.isAbstract {
                    for intf in cl.rawInterfaces {
                        def resolved := resolve(intf)
                        if resolved !== null {
                            def found := findMethod(resolved, m.name, m.type(self), true)
                            if found !== null {
                                cl.virtualMethods[i] := found
                                break
                            }
                        }
                    }
                }
            }
            currentClass.pop()
        }
        return cl.virtualMethods
    }

    ================================================================================================
    Return the concrete version of a type appearing in the context of another type. For instance,
    if we reference `Array<T>` from within the type `Array<String>`, we are really referring to
    `Array<String>`.
    ================================================================================================
    method remapType(context:Type, raw:Type):Type {
        if context.isClassLiteral {
            return remapType(context.subtypes[1], raw)
        }
        match raw.typeKind {
            when Type.Kind.CLASS, Type.Kind.BUILTIN_INT, Type.Kind.BUILTIN_UINT,
                    Type.Kind.BUILTIN_BIT {
                return raw
            }
        }
        match context.typeKind {
            when Type.Kind.NULLABLE {
                assert context.subtypes.count = 1
                return remapType(context.subtypes[0], raw)
            }
            when Type.Kind.GENERIC {
                assert context.subtypes.count >= 2
                def typeMap := HashMap<String, Type>()
                def base := context.subtypes[0]
                def cl := tryResolveClass(base.name)
                assert cl !== null
                for i in 1 .. context.subtypes.count {
                    typeMap[cl.name + "." + cl.parameters[i - 1].name] := context.subtypes[i]
                }
                return raw.remap(self, typeMap)
            }
            when Type.Kind.GENERIC_METHOD_PARAMETER {
                return remapType(context.genericMethodParameter.bound, raw)
            }
            when Type.Kind.TUPLE {
                def typeMap := HashMap<String, Type>()
                def base := context.subtypes[0]
                def cl := getClass(context)
                assert cl !== null
                for i in 0 .. context.subtypes.count {
                    typeMap[cl.name + "." + cl.parameters[i].name] := context.subtypes[i]
                }
                return raw.remap(self, typeMap)
            }
            otherwise {
                return raw
            }
        }
    }

    function preferredType(type:Type):Type {
        if type.typeKind = Type.Kind.INT_LITERAL {
            return INT_TYPE
        }
        if type.typeKind = Type.Kind.REAL_LITERAL {
            return REAL64_TYPE
        }
        if type = BIT_LITERAL_TYPE {
            return BIT_TYPE
        }
        if type.typeKind = Type.Kind.NULL {
            return ANY_TYPE
        }
        return type
    }

    method preferredType(expr:ASTNode):Type? {
        match expr {
            when ASTNode.ARRAY {
                def possible := possibleTypes(expr)
                if possible == null {
                    return null
                }
                assert possible.first.name.startsWith("frost.collections.Array<")
                return possible.first
            }
            when ASTNode.BIT {
                return BIT_TYPE
            }
            when ASTNode.INT {
                return INT_TYPE
            }
            when ASTNode.UNARY(position, op, operand) {
                return Unary.preferredType(self, position, op, operand)
            }
            when ASTNode.REAL {
                return REAL64_TYPE
            }
            when ASTNode.STRING {
                return STRING_TYPE
            }
        }
        def possible := possibleTypes(expr)
        if possible == null {
            return null
        }
        if possible.count = 1 {
            return possible.iterator.next()
        }
        def best := Array<Type>()
        def bestCost := Int.MAX
        var foundInt := false
        for t in possible {
            if t = INT_TYPE {
                foundInt := true
            }
            def cost := coercionCost(expr, t)
            assert cost !== null
            if cost.second < bestCost {
                bestCost := cost.second
                best.clear()
            }
            if cost.second = bestCost {
                best.add(t)
            }
        }
        assert best.count != 0
        if best.count = 1 {
            return best[0]
        }
        if foundInt {
            return INT_TYPE
        }
        return null
    }

    function coercionCostUnresolvedParameters(a:Type, b:Type):Int? {
        if a = b {
            return 0
        }
        if b.typeKind = Type.Kind.GENERIC_METHOD_PARAMETER {
            return 0
        }
        if a.typeKind = b.typeKind & a.hasSubtypes & b.hasSubtypes &
                a.subtypes.count = b.subtypes.count {
            var total := 0
            for i in 0 .. a.subtypes.count {
                def cost := coercionCostUnresolvedParameters(a.subtypes[i], b.subtypes[i])
                if cost == null {
                    return null
                }
                total += cost
            }
            return total
        }
        return null
    }

    method coercionCost(type:Type, target:Type):Pair<Type, Int>? {
        return coercionCost(type, target, true)
    }

    @pre(target.resolved)
    method coercionCost(type:Type, target:Type, permitImplicitConstruction:Bit):Pair<Type, Int>? {
        def key := TypeCoercionKey(type, target, permitImplicitConstruction)
        var cached := typeCoercionCosts[key]
        if cached !== null {
            if cached.second = -1 {
                return null
            }
            return cached
        }
        def result := computeCoercionCost(type, target, permitImplicitConstruction)
        if result == null {
            typeCoercionCosts[key] := Pair<Type, Int>(VOID_TYPE, -1)
        }
        return result
    }

    method computeCoercionCost(type:Type, target:Type,
            permitImplicitConstruction:Bit):Pair<Type, Int>? {
        assert type.resolved, "unresolved type '\{type}'"
        assert target.resolved, "unresolved type '\{target}'"
        if type = target {
            return Pair<Type, Int>(target, 0)
        }
        if type = VOID_TYPE {
            return null
        }
        if type.typeKind = Type.Kind.NULL {
            if target.typeKind = Type.Kind.NULLABLE {
                return Pair<Type, Int>(target, 0)
            }
            return null
        }
        if type.typeKind = Type.Kind.NULLABLE & target.typeKind != Type.Kind.NULLABLE {
            def result := coercionCost(type.subtypes[0], target)
            if result == null {
                return null
            }
            return Pair<Type, Int>(result.first, result.second + NULLABLE_TO_NONNULLABLE_CAST_COST)
        }
        match target.typeKind {
            when Type.Kind.NULLABLE {
                def result := coercionCost(type, target.subtypes[0])
                if result == null {
                    return null
                }
                return Pair<Type, Int>(result.first,
                        result.second + NONNULLABLE_TO_NULLABLE_CAST_COST)
            }
            when Type.Kind.GENERIC_CLASS_PARAMETER {
                return null
            }
            when Type.Kind.GENERIC_METHOD_PARAMETER {
                return null
            }
            when Type.Kind.CLASS {
                if type.typeKind = Type.Kind.GENERIC {
                    return coercionCost(type.subtypes[0], target)
                }
            }
            when Type.Kind.GENERIC {
                if type.typeKind = Type.Kind.GENERIC & type.subtypes[0] = target.subtypes[0] {
                    -- generic casts normally have to be exact, but we make an exception for
                    -- unresolved method parameters
                    def result := coercionCostUnresolvedParameters(type, target)
                    if result !== null {
                        return Pair<Type, Int>(type, result)
                    }
                    return null
                }
                -- FIXME super hacky
                if type.typeKind = Type.Kind.TUPLE &
                        target.subtypes[0].name = "frost.core.Equatable" &
                        target.subtypes[1] = type {
                    def cl := getClass(type)
                    if cl !== null & (cl.name.startsWith("frost.core.EquatableTuple") |
                            cl.name.startsWith("frost.core.KeyTuple")) {
                        return Pair<Type, Int>(type, 0)
                    }
                }
                if type.typeKind = Type.Kind.TUPLE &
                        target.subtypes[0].name = "frost.collections.HashKey" &
                        target.subtypes[1] = type {
                    def cl := getClass(type)
                    if cl !== null & cl.name.startsWith("frost.core.KeyTuple") {
                        return Pair<Type, Int>(type, 0)
                    }
                }
            }
        }
        if type.isMethod {
            if target.isMethod {
                if type.subtypes.count != target.subtypes.count {
                    return null
                }
                var total := 0
                def srcFunction:Bit
                def srcMutable:Bit
                match type.typeKind {
                    when Type.Kind.METHOD {
                        srcFunction := false
                        srcMutable := true
                    }
                    when Type.Kind.FUNCTION {
                        srcFunction := true
                        srcMutable := true
                    }
                    when Type.Kind.IMMUTABLE_METHOD {
                        srcFunction := false
                        srcMutable := false
                    }
                    when Type.Kind.IMMUTABLE_FUNCTION {
                        srcFunction := true
                        srcMutable := false
                    }
                }
                def targetFunction:Bit
                def targetMutable:Bit
                match target.typeKind {
                    when Type.Kind.METHOD {
                        targetFunction := false
                        targetMutable := true
                    }
                    when Type.Kind.FUNCTION {
                        targetFunction := true
                        targetMutable := true
                    }
                    when Type.Kind.IMMUTABLE_METHOD {
                        targetFunction := false
                        targetMutable := false
                    }
                    when Type.Kind.IMMUTABLE_FUNCTION {
                        targetFunction := true
                        targetMutable := false
                    }
                }
                if targetFunction & !srcFunction {
                    return null
                }
                if !targetMutable & srcMutable {
                    return null
                }
                if targetFunction != srcFunction {
                    total += 1
                }
                if targetMutable != srcMutable {
                    total += 1
                }
                for i in 0 .. type.parameterCount {
                    def cost := coercionCost(target.subtypes[i], type.subtypes[i])
                    if cost == null {
                        return null
                    }
                    total += cost.second
                }
                def cost := coercionCost(type.returnType, target.returnType)
                if cost == null {
                    return null
                }
                total += cost.second
                return Pair<Type, Int>(target, total)
            }
            if type.typeKind = Type.Kind.IMMUTABLE_METHOD |
                    type.typeKind = Type.Kind.IMMUTABLE_FUNCTION {
                def result := coercionCost(METHOD_TYPE, target)
                if result !== null {
                    return result
                }
            }
            return coercionCost(MUTABLE_METHOD_TYPE, target)
        }
        match type.typeKind {
            when Type.Kind.BUILTIN_BIT {
                return coercionCost(BIT_TYPE, target)
            }
            when Type.Kind.GENERIC_CLASS_PARAMETER {
                return coercionCost(type.genericClassParameter.bound, target)
            }
            when Type.Kind.GENERIC_METHOD_PARAMETER {
                return coercionCost(type.genericMethodParameter.bound, target)
            }
            when Type.Kind.TUPLE {
                if target.name = "frost.core.Tuple\{type.subtypes.count}" |
                        target.name = "frost.core.KeyTuple\{type.subtypes.count}" |
                        target.name = "frost.core.EquatableTuple\{type.subtypes.count}" {
                    return Pair<Type, Int>(target, 1)
                }
            }
        }
        if !target.isClass {
            return null
        }
        def targetCl := getClass(target)
        if targetCl == null {
            return null
        }
        if permitImplicitConstruction {
            for m in getImplicitInits(targetCl) {
                resolve(m)
                if type = m.parameters[0].type {
                    -- FIXME I don't remember where this 6 came from. Figure this out, and if
                    -- it's necessary figure out what the right value is for it and use a named
                    -- constant.
                    return Pair<Type, Int>(target, 6->Int - m.priority)
                }
            }
        }
        if !type.isClass {
            return null
        }
        def cl := getClass(type)
        if cl == null {
            return null
        }
        resolve(cl)
        if cl.resolved != Resolution.RESOLVED_WITH_ERRORS {
            if cl.rawSuper !== null {
                def cost := coercionCost(remapType(type, remapType(type, cl.rawSuper)), target)
                if cost !== null {
                    return Pair<Type, Int>(cost.first, cost.second + 1)
                }
            }
            for intf in cl.rawInterfaces {
                def cost := coercionCost(remapType(type, remapType(type, intf)), target)
                if cost !== null {
                    return Pair<Type, Int>(cost.first, cost.second + 1)
                }
            }
        }
        return null
    }

    method coercionCost(type:Type, target:TypeContext):Pair<Type, Int>? {
        match target {
            when TypeContext.UNSPECIFIED {
                return Pair<Type, Int>(type, 0)
            }
            when TypeContext.NON_VOID {
                if type = VOID_TYPE {
                    return null
                }
                return Pair<Type, Int>(type, 0)
            }
            when TypeContext.IMMUTABLE {
                if isImmutable(type) {
                    return Pair<Type, Int>(type, 0)
                }
                return null
            }
            when TypeContext.TYPE(t, _) {
                return coercionCost(type, t)
            }
        }
        unreachable
    }

    method coercionCost(types:CollectionView<Type>, target:Type):Pair<Type, Int>? {
        def best := Pair<Type, Int>(VOID_TYPE, Int.MAX)
        for t in types {
            def cost := coercionCost(t, target)
            if cost !== null & cost.second < best.second {
                best := cost
            }
        }
        if best.second != Int.MAX {
            return best
        }
        return null
    }

    function isClassContext():Bit {
        return currentMethod[0].annotations.isClass
    }

    function symbolType(target:Type?, s:Symbol):Array<Type>? {
        return symbolType(target, s, null)
    }

    function symbolType(target:Type?, s:Symbol,
            genericArguments:FixedArray<ASTNode>?):Array<Type>? {
        def result := Array<Type>()
        def resolvedArguments:Array<Type>?
        if genericArguments !== null {
            resolvedArguments := Array<Type>()
            for p in genericArguments {
                def resolved := resolve(scanner.convertType(p))
                if resolved == null {
                    return null
                }
                resolvedArguments.add(resolved)
            }
        }
        match s.kind {
            when Symbol.Kind.ALIAS {
                result.add(Type.ClassLiteral(self, resolve(s->Alias.type)))
            }
            when Symbol.Kind.CHOICE_CASE {
                def cc := s->ChoiceCase
                if cc.fields.count > 0 {
                    result.add(Type.methodType(self, s.position, Type.Kind.IMMUTABLE_FUNCTION,
                            cc.fields, cc.owner.type, 0))
                }
                else {
                    result.add(cc.owner.type)
                }
            }
            when Symbol.Kind.FIELD {
                def f := s->FieldDecl
                if resolve(f) {
                    def type:Type
                    if f.annotations.isWeak {
                        type := f.type.subtypes[1]
                    }
                    else {
                        type := f.type
                    }
                    if target !== null {
                        def found := findType(target, f.owner)
                        result.add(remapType(found, type))
                    }
                    else {
                        result.add(type)
                    }
                }
                else {
                    return null
                }
            }
            when Symbol.Kind.METHOD {
                def m := s->MethodDecl
                if !resolve(m) {
                    return null
                }
                if target !== null {
                    result.add(Type(MethodRef(self, target, m, resolvedArguments)))
                }
                else {
                    def implicitTarget:Type
                    if isClassContext() {
                        implicitTarget := Type.ClassLiteral(self, currentClass[0].type)
                    }
                    else {
                        implicitTarget := currentClass[0].type
                    }
                    result.add(Type(MethodRef(self, implicitTarget, m, resolvedArguments)))
                }
            }
            when Symbol.Kind.METHODS {
                for m in s->Methods.methods {
                    if genericArguments !== null & (m.genericParameters == null |
                            genericArguments.count != m.genericParameters.count) {
                        continue
                    }
                    if resolve(m) {
                        if m.annotations.isClass {
                            result.add(Type(MethodRef(self, Type.ClassLiteral(self, m.owner.type),
                                    m, resolvedArguments)))
                        }
                        else if target !== null {
                            result.add(Type(MethodRef(self, target, m, resolvedArguments)))
                        }
                        else {
                            def implicitTarget:Type
                            if isClassContext() {
                                implicitTarget := Type.ClassLiteral(self, currentClass[0].type)
                            }
                            else {
                                implicitTarget := currentClass[0].type
                            }
                            result.add(Type(MethodRef(self, implicitTarget, m,
                                    resolvedArguments)))
                        }
                    }
                }
            }
            when Symbol.Kind.VARIABLE {
                result.add(s->Variable.type)
            }
            otherwise {
                unreachable
            }
        }
        return result    
    }

    method identifierType(name:String):Array<Type>? {
        return identifierType(name, null)
    }

    method identifierType(name:String, genericArguments:FixedArray<ASTNode>?):Array<Type>? {
        def s := symbolTable[name]
        if s !== null {
            return symbolType(null, s, genericArguments)
        }
        def cl := tryResolveClass(name)
        if cl !== null {
            def result := Array<Type>()
            result.add(Type.ClassLiteral(self, cl.type))
            return result
        }
        return null
    }

    method getText(value:ASTNode):String? {
        match value {
            when ASTNode.DOT(_, base, name) {
                def baseText := getText(base)
                if baseText == null {
                    return null
                }
                return "\{baseText}.\{name}"
            }
            when ASTNode.IDENTIFIER(_, name) {
                return name
            }
            otherwise {
                return null
            }
        }
    }

    ================================================================================================
    If `value` represents a valid type, returns the corresponding [Type]. Otherwise returns `null`
    without reporting an error.
    ================================================================================================
    method tryResolveType(value:ASTNode):Type? {
        return tryResolveType(value, true)
    }

    ================================================================================================
    As [tryResolveType(ASTNode)], but allows the validity check for generic arguments to be
    disabled.
    ================================================================================================
    @post(errorCount = @pre(errorCount))
    method tryResolveType(value:ASTNode, checkGenericArguments:Bit):Type? {
        match value {
            when ASTNode.IDENTIFIER(position, text) {
                return tryResolveType(ASTNode.TYPE(position, text), checkGenericArguments)
            }
            when ASTNode.DOT(position, base, name) {
                def text := getText(base)
                if text !== null {
                    return tryResolveType(ASTNode.TYPE(position, "\{text}.\{name}"),
                            checkGenericArguments)
                }
                return null
            }
            when ASTNode.DOT_GENERICS(position, base, name, types) {
                def text := getText(base)
                if text !== null {
                    return tryResolveType(ASTNode.GENERIC_TYPE(position, "\{text}.\{name}", types),
                            checkGenericArguments)
                }
                return null
            }
        }
        def old := reportErrors
        reportErrors := false
        def result := resolve(scanner.convertType(value), checkGenericArguments)
        reportErrors := old
        return result
    }

    method rangePreferredType(start:ASTNode?, end:ASTNode?, step:ASTNode?):Type? {
        if step !== null {
            def pref := preferredType(step)
            if pref == null {
                return null
            }
            if pref.isReal {
                if start !== null & end !== null {
                    return Type.SteppedRangeOf(self, pref, pref)
                }
                return Type.SteppedRangeOf(self, pref.nullable(), pref)
            }
        }
        var endpointType:Type? := null
        if start !== null {
            def endpointType:Type
            def pref1:Type?
            match start {
                when ASTNode.STRING {
                    -- must be a char literal
                    if end !== null {
                        -- not sure if it's 8, 16, or 32 bits - try to match the type of the
                        -- other endpoint
                        def pref2 := preferredType(end)
                        if pref2 !== null & pref2.isChar {
                            pref1 := pref2
                        }
                        else {
                            pref1 := CHAR32_TYPE
                        }
                    }
                    else {
                        pref1 := CHAR32_TYPE
                    }
                }
                otherwise {
                    pref1 := preferredType(start)
                }
            }
            if pref1 == null {
                return null
            }
            if end !== null {
                def pref2:Type?
                match end {
                    when ASTNode.STRING {
                        if pref1.isChar {
                            -- not sure if it's 8, 16, or 32 bits - try to match the type of the
                            -- other endpoint
                            pref2 := pref1
                        }
                        else {
                            pref2 := CHAR32_TYPE
                        }
                    }
                    otherwise {
                        pref2 := preferredType(end)
                    }
                }
                if pref2 == null {
                    return null
                }
                endpointType := pref1.union(self, pref2)
            }
            else {
                endpointType := pref1.nullable()
            }
            if step !== null {
                return Type.SteppedRangeOf(self, endpointType)
            }
            return Type.RangeOf(self, endpointType)
        }
        else if end !== null {
            def pref:Type?
            match end {
                when ASTNode.STRING {
                    pref := CHAR32_TYPE
                }
                otherwise {
                    pref := preferredType(end)
                }
            }
            if pref == null {
                return null
            }
            if step !== null {
                return Type.SteppedRangeOf(self, pref)
            }
            return Type.RangeOf(self, pref)
        }
        if step !== null {
            return Type.SteppedRangeOf(self, INT_TYPE.nullable())
        }
        return Type.RangeOf(self, INT_TYPE.nullable())
    }

    ================================================================================================
    Returns the size in bits of the smallest Char type that can this codepoint.
    ================================================================================================
    function smallestCharSize(char:Char32):Int {
        def v := char.asInt32
        if v <= 255 {
            return 8
        }
        if v <= 65535 {
            return 16
        }
        return 32
    }

    function isTuple(cl:ClassDecl):Bit {
        return cl.name.startsWith("frost.core.Tuple") | cl.name.startsWith("frost.core.KeyTuple") |
                cl.name.startsWith("frost.core.EquatableTuple")
    }

    function binaryType(position:Position, left:ASTNode, op:Binary.Operator,
            right:ASTNode):Array<Type>? {
        def key := BinaryKey(left, op, right)
        if binaryTypes.contains(key) {
            return binaryTypes[key]
        }
        def result := Binary.binaryType(self, left, op, right)
        binaryTypes[key] := result
        return result
    }

    ================================================================================================
    Returns the types we should consider this expression to potentially be when evaluating method
    calls and field accesses against it. This is not always (nor could it reasonably be) an
    exhaustive list.

    This method does not generate errors for the expression in question, but may generate other
    one-time errors (for instance, it may be unable to load a class or resolve a field).
    ================================================================================================
    method possibleTypes(value:ASTNode):CollectionView<Type>? {
        match value {
            when ASTNode.ARRAY(_, elements) {
                def result := Array<Type>()
                if elements.count != 0 {
                    var union := preferredType(elements[0])
                    if union !== null {
                        for i in 1 .. elements.count {
                            def type := preferredType(elements[i])
                            if type == null {
                                result.add(Type.ArrayOf(self, ANY_TYPE))
                                return result
                            }
                            union := union.union(self, type)
                        }
                        result.add(Type.ArrayOf(self, union))
                        if isImmutable(union) {
                            result.add(Type.ImmutableArrayOf(self, union))
                        }
                        return result
                    }
                }
                result.add(Type.ArrayOf(self, ANY_TYPE))
                return result
            }
            when ASTNode.AT_PRE(_, expr) {
                return possibleTypes(expr)
            }
            when ASTNode.AT_RETURN {
                return [currentMethod[0].returnType]
            }
            when ASTNode.BINARY(position, left, op, right) {
                return binaryType(position, left, op, right)
            }
            when ASTNode.BIT {
                return [BIT_TYPE, BUILTIN_BIT_TYPE]
            }
            when ASTNode.CALL(_, m, args) {
                return Call.possibleTypes(self, m, args)
            }
            when ASTNode.DOT(position, base, name) {
                def type := tryResolveType(value)
                if type !== null {
                    def result := Array<Type>() -- FIXME literal
                    result.add(Type.ClassLiteral(self, type))
                    return result
                }
                def result:Array<Type>? := null
                def baseTypes := possibleTypes(base)
                if baseTypes == null {
                    return null
                }
                for t in baseTypes {
                    def list := Dot.dotTypes(self, t, name)
                    if list !== null {
                        if result == null {
                            result := Array<Type>()
                        }
                        result.addAll(list)
                    }
                }
                return result
            }
            when ASTNode.DOT_GENERICS(position, base, name, genericArguments) {
                def t := tryResolveType(value)
                if t !== null {
                    return [Type.ClassLiteral(self, t)]
                }
                def result:Array<Type>? := null
                def baseTypes := possibleTypes(base)
                if baseTypes == null {
                    return null
                }
                for t in baseTypes {
                    def list := Dot.dotTypes(self, t, name, genericArguments)
                    if list !== null {
                        if result == null {
                            result := Array<Type>()
                        }
                        result.addAll(list)
                    }
                }
                return result
            }
            when ASTNode.GENERIC_TYPE(position, name, types) {
                def resolved := tryResolveType(value)
                if resolved !== null {
                    assert !resolved.isClassLiteral
                    return [Type.ClassLiteral(self, resolved)]
                }
                -- not a type, might be a function call with explicit generics
                def components := name.split(".")
                var effective:ASTNode
                if components.count = 1 {
                    effective := ASTNode.IDENTIFIER_GENERICS(position, name, types)
                }
                else {
                    effective := ASTNode.IDENTIFIER(position, components[0])
                    for i in 1 .. components.count - 1 {
                        effective := ASTNode.DOT(position, effective, components[i])
                    }
                    effective := ASTNode.DOT_GENERICS(position, effective,
                            components[components.count - 1], types)
                }
                return possibleTypes(effective)
            }
            when ASTNode.IDENTIFIER(_, name) {
                return identifierType(name)
            }
            when ASTNode.IDENTIFIER_GENERICS(_, name, types) {
                return identifierType(name, types)
            }
            when ASTNode.INT(_, value) {
                def result := Array<Type>()
                def signedValue := value.asInt64
                if signedValue >= Int8.MIN.asInt64 & signedValue <= Int8.MAX.asInt64 {
                    result.add(BUILTIN_INT8_TYPE)
                    result.add(INT8_TYPE)
                }
                if signedValue >= Int16.MIN.asInt64 & signedValue <= Int16.MAX.asInt64 {
                    result.add(BUILTIN_INT16_TYPE)
                    result.add(INT16_TYPE)
                }
                if signedValue >= Int32.MIN.asInt64 & signedValue <= Int32.MAX.asInt64 {
                    result.add(BUILTIN_INT32_TYPE)
                    result.add(INT32_TYPE)
                }
                result.add(BUILTIN_INT64_TYPE)
                result.add(INT64_TYPE)
                result.add(INT_TYPE)
                result.add(UINT_TYPE)
                if value >= UInt8.MIN.asUInt64 & value <= UInt8.MAX.asUInt64 {
                    result.add(BUILTIN_UINT8_TYPE)
                    result.add(UINT8_TYPE)
                }
                if value >= UInt16.MIN.asUInt64 & value <= UInt16.MAX.asUInt64 {
                    result.add(BUILTIN_UINT16_TYPE)
                    result.add(UINT16_TYPE)
                }
                if value >= UInt32.MIN.asUInt64 & value <= UInt32.MAX.asUInt64 {
                    result.add(BUILTIN_UINT32_TYPE)
                    result.add(UINT32_TYPE)
                }
                result.add(BUILTIN_UINT64_TYPE)
                result.add(UINT64_TYPE)
                result.add(REAL32_TYPE)
                result.add(REAL64_TYPE)
                return result
            }
            when ASTNode.IR_WRAPPER(_, node) {
                return [node.type()]
            }
            when ASTNode.METHOD(position, _, _, kind, _, _, parameters, returnType, _) {
                def result := Closure.methodType(self, position, kind, parameters, returnType,
                        resolvingFieldType)
                if result == null {
                    return null
                }
                return [result]
            }
            when ASTNode.NULL {
                return [ANY_TYPE]
            }
            when ASTNode.UNARY(position, op, operand) {
                return Unary.possibleTypes(self, position, op, operand)
            }
            when ASTNode.RANGE(_, start, _, end, step) {
                def result := rangePreferredType(start, end, step)
                if result == null {
                    return null
                }
                return [result]
            }
            when ASTNode.REAL {
                return [BUILTIN_FLOAT32_TYPE, BUILTIN_FLOAT64_TYPE, REAL32_TYPE, REAL64_TYPE]
            }
            when ASTNode.REGEX {
                return [REGULAR_EXPRESSION_TYPE]
            }
            when ASTNode.SELF {
                var s := symbolTable[CAPTURED_SELF_NAME]
                if s == null {
                    s := symbolTable[SELF_NAME]
                }
                if s == null {
                    return null
                }
                return symbolType(null, s)
            }
            when ASTNode.SUPER {
                var s := symbolTable[CAPTURED_SELF_NAME]
                if s == null {
                    s := symbolTable[SELF_NAME]
                }
                if s == null {
                    return null
                }
                def result := Array<Type>()
                def type:Type
                match s.kind {
                    when Symbol.Kind.VARIABLE {
                        type := s->Variable.type
                    }
                    when Symbol.Kind.FIELD {
                        type := s->FieldDecl.type
                    }
                    otherwise {
                        unreachable
                    }
                }
                def cl := getClass(type)
                if !resolve(cl) {
                    return null
                }
                result.add(remapType(type, cl.rawSuper))
                return result
            }
            when ASTNode.STRING(_, text) {
                def result := Array<Type>()
                result.add(STRING_TYPE)
                if text.length = 1 {
                    def size := smallestCharSize(text[0])
                    if size = 8 {
                        result.add(CHAR8_TYPE)
                    }
                    if size <= 16 {
                        result.add(CHAR16_TYPE)
                    }
                    result.add(CHAR32_TYPE)
                }
                return result
            }
            when ASTNode.TUPLE(_, args) {
                return Tuple.possibleTypes(self, args)
            }
            when ASTNode.TYPE {
                def resolved := tryResolveType(value)
                if resolved !== null {
                    assert !resolved.isClassLiteral
                    return [Type.ClassLiteral(self, resolved)]
                }
                return null
            }
            when ASTNode.TYPED_LAMBDA(position, parameters, body) {
                def parameterTypes := Array<Type>()
                for p in parameters {
                    match p {
                        when ASTNode.PARAMETER(_, _, type) {
                            def resolved := tryResolveType(type)
                            if resolved == null {
                                return null
                            }
                            parameterTypes.add(resolved)
                        }
                    }
                }
                def lambdaType := Closure.typedLambdaType(self, parameters, body,
                        TypeContext.NON_VOID)
                if lambdaType == null {
                    return null
                }
                return [lambdaType]
            }
            when ASTNode.UNTYPED_LAMBDA {
                return null
            }
            otherwise {
                unreachable, "unsupported possibleType: \{value}:\{value.position()}"
            }
        }
        unreachable
    }

    method binaryCost(left:ASTNode, op:Binary.Operator, right:ASTNode,
            type:TypeContext):Pair<Type, Int>? {
        if op = Binary.Operator.CAST {
            def target := tryResolveType(right)
            if target == null {
                return null
            }
            if coercionCost(left, target) == null {
                if target.isBuiltinNumber {
                    def leftType := preferredType(left)
                    if leftType == null | !leftType.isBuiltinNumber {
                        return null
                    }
                }
                else {
                    return null
                }
            }
            return coercionCost(target, type)
        }
        def result := Binary.findOverloadedOperator(self, left, op, right, type)
        if result !== null {
            return Pair<Type, Int>(result.first[0].returnType, result.second)
        }
        def preferred := preferredType(ASTNode.BINARY(left.position(), left, op, right))
        if preferred !== null {
            return coercionCost(preferred, type)
        }
        return null
    }

    method rangeCoercionCost(start:ASTNode?, end:ASTNode?, step:ASTNode?,
            target:Type):Pair<Type, Int>? {
        if target.typeKind = Type.Kind.NULLABLE {
            def result := rangeCoercionCost(start, end, step, target.nonnullable())
            if result == null {
                return null
            }
            return Pair<Type, Int>(result.first, result.second + 1)
        }
        if target.typeKind = Type.Kind.GENERIC {
            if target.subtypes[0].name = RANGE_NAME & target.subtypes.count = 2 |
                    target.subtypes[0].name = STEPPED_RANGE_NAME & target.subtypes.count = 3 {
                var cost := 0
                if start !== null {
                    def startCost := coercionCost(start, target.subtypes[1])
                    if startCost == null {
                        return null
                    }
                    cost += startCost.second
                }
                else if target.subtypes[1].typeKind != Type.Kind.NULLABLE {
                    return null
                }
                if end !== null {
                    def endCost := coercionCost(end, target.subtypes[1])
                    if endCost == null {
                        return null
                    }
                    cost += endCost.second
                }
                else if target.subtypes[1].typeKind != Type.Kind.NULLABLE {
                    return null
                }
                if target.subtypes[0].name = RANGE_NAME {
                    if step !== null {
                        return null
                    }
                }
                else {
                    if step == null {
                        return null
                    }
                    def stepCost := coercionCost(step, target.subtypes[2])
                    if stepCost == null {
                        return null
                    }
                    cost += stepCost.second
                }
                return Pair<Type, Int>(target, cost)
            }
        }
        def type := preferredType(ASTNode.RANGE(Position(), start, true, end, step))
        if type == null {
            return null
        }
        return coercionCost(type, target)
    }

    method arrayCoercionCost(position:Position, elements:FixedArray<ASTNode>,
            target:Type):Pair<Type, Int>? {
        def t := getListType(target)
        if t == null {
            def p := preferredType(ASTNode.ARRAY(position, elements))
            if p == null {
                return null
            }
            return coercionCost(p, target)
        }
        if t.first {
            return coercionCost(Type.ArrayOf(self, t.second), target)
        }
        else {
            return coercionCost(Type.ImmutableArrayOf(self, t.second), target)
        }
    }

    @pre(target.resolved)
    method computeCoercionCost(expr:ASTNode, target:Type):Pair<Type, Int>? {
        match expr {
            when ASTNode.ARRAY(position, elements) {
                return arrayCoercionCost(position, elements, target)
            }
            when ASTNode.AT_PRE(_, expr) {
                return coercionCost(expr, target)
            }
            when ASTNode.AT_RETURN {
                return coercionCost(currentMethod[0].returnType, target)
            }
            when ASTNode.BINARY(_, left, op, right) {
                match op {
                    when Binary.Operator.CAST {
                        def types := possibleTypes(expr)
                        if types == null {
                            return null
                        }
                        return coercionCost(types, target)
                    }
                    when Binary.Operator.IDENTITY, Binary.Operator.NIDENTITY {
                        return coercionCost(BIT_TYPE, target)
                    }
                    otherwise {
                        return binaryCost(left, op, right, TypeContext.TYPE(target, false))
                    }
                }
            }
            when ASTNode.BIT {
                def result := coercionCost(BIT_TYPE, target)
                if result !== null {
                    return result
                }
                return coercionCost(BUILTIN_BIT_TYPE, target)
            }
            when ASTNode.CALL(_, m, args) {
                return Call.coercionCost(self, m, args, target)
            }
            when ASTNode.DOT, ASTNode.DOT_GENERICS {
                def types := possibleTypes(expr)
                if types == null {
                    return null
                }
                return coercionCost(types, target)
            }
            when ASTNode.IDENTIFIER(_, name) {
                def types := identifierType(name)
                if types == null {
                    return null
                }
                return coercionCost(types, target)
            }
            when ASTNode.IDENTIFIER_GENERICS(_, name, genericArguments) {
                def types := identifierType(name, genericArguments)
                if types == null {
                    return null
                }
                return coercionCost(types, target)
            }
            when ASTNode.INT(_, value) {
                if (target.typeKind = Type.Kind.BUILTIN_INT &
                        IntLiteral.requiredSize(value.asInt64) <= target.size) |
                        (target.typeKind = Type.Kind.BUILTIN_UINT &
                        IntLiteral.requiredSize(value) <= target.size) {
                    return Pair<Type, Int>(target, 0)
                }
                if target.typeKind = Type.Kind.BUILTIN_FLOAT {
                    return Pair<Type, Int>(target, 1)
                }
                if target.isNumber {
                    def cl := getClass(target)
                    assert cl !== null, "could not load class \{target} at \{currentClass[0].name}:\{expr.position()}"
                    def initMethod := cl.methods[0]
                    assert initMethod.methodKind = MethodDecl.Kind.INIT
                    assert initMethod.annotations.isImplicit
                    -- FIXME figure out where this 2 came from and whether it's the right value,
                    -- make it a constant if it's necessary
                    return Pair<Type, Int>(target, 2->Int - initMethod.priority)
                }
                def preferred := preferredType(expr)
                assert preferred !== null
                return coercionCost(preferred, target)
            }
            when ASTNode.IR_WRAPPER(_, ir) {
                return coercionCost(ir.type(), target)
            }
            when ASTNode.METHOD(position, _, _, kind, _, _, parameters, returnType, _) {
                def paramTypes := Array<Type>()
                for p in parameters { -- FIXME map
                    match p {
                        when ASTNode.PARAMETER(_, _, type) {
                            def resolved := tryResolveType(type)
                            if resolved == null {
                                return null
                            }
                            paramTypes.add(resolved)
                        }
                        otherwise {
                            unreachable
                        }
                    }
                }
                def resolvedReturnType:Type
                if returnType !== null {
                    resolvedReturnType := tryResolveType(returnType)
                    if resolvedReturnType == null {
                        return null
                    }
                }
                else {
                    resolvedReturnType := VOID_TYPE
                }
                def typeKind:Type.Kind
                -- we don't actually know whether the method has any captures yet (it might turn
                -- out to be mutable), but we assume it's immutable here and let it error later if
                -- that turns out to be a problem
                if kind = MethodDecl.Kind.FUNCTION {
                    typeKind := Type.Kind.IMMUTABLE_FUNCTION
                }
                else {
                    assert kind = MethodDecl.Kind.METHOD
                    typeKind := Type.Kind.IMMUTABLE_METHOD
                }
                return coercionCost(Type.methodType(self, position, typeKind, paramTypes,
                        resolvedReturnType, 0), target)
            }
            when ASTNode.NULL {
                if target.typeKind = Type.Kind.NULLABLE {
                    return Pair<Type, Int>(target, 0)
                }
                return null
            }
            when ASTNode.RANGE(_, start, _, end, step) {
                return rangeCoercionCost(start, end, step, target)
            }
            when ASTNode.REAL {
                if (target.typeKind = Type.Kind.BUILTIN_FLOAT) {
                    return Pair<Type, Int>(target, 0)
                }
                if target.isReal {
                    return Pair<Type, Int>(target, 1)
                }
                def preferred := preferredType(expr)
                assert preferred !== null
                return coercionCost(preferred, target)
            }
            when ASTNode.REGEX {
                return coercionCost(REGULAR_EXPRESSION_TYPE, target)
            }
            when ASTNode.SELF {
                return coercionCost(currentClass[0].typeWithParameters(), target)
            }
            when ASTNode.STRING(_, text) {
                if target.isChar & text.length = 1 {
                    def size := smallestCharSize(text[0])
                    def targetSize:Int
                    match target {
                        when CHAR8_TYPE  { targetSize := 8 }
                        when CHAR16_TYPE { targetSize := 16 }
                        when CHAR32_TYPE { targetSize := 32 }
                    }
                    if targetSize >= size {
                        return Pair<Type, Int>(target, 1)
                    }
                    return null
                }
                if target == VALUE_TYPE & text.length = 1 {
                    return Pair<Type, Int>(target, 1)
                }
                return coercionCost(STRING_TYPE, target)
            }
            when ASTNode.TUPLE(_, args) {
                return Tuple.coercionCost(self, args, target)
            }
            when ASTNode.TYPED_LAMBDA(_, parameters, body) {
                return Closure.typedLambdaCoercionCost(self, parameters, body, target)
            }
            when ASTNode.UNARY(position, op, operand) {
                return Unary.coercionCost(self, position, op, operand, target)
            }
            when ASTNode.UNTYPED_LAMBDA(_, parameters, body) {
                return Closure.untypedLambdaCoercionCost(self, parameters, body, target)
            }
            otherwise {
                unreachable
            }
        }
    }

    ================================================================================================
    Returns the cost of coercing the expression to the specified type, along with the actual type
    that will result (which is generally `target`, but may be a different type if `target` had
    unspecified method generic parameters).
    ================================================================================================
    @pre(target.resolved)
    method coercionCost(expr:ASTNode, target:Type):Pair<Type, Int>? {
        def key := ExpressionCoercionKey(expr, target)
        var cached := expressionCoercionCosts[key]
        if cached !== null {
            if cached.second = -1 {
                return null
            }
            return cached
        }
        def result := computeCoercionCost(expr, target)
        if result == null {
            expressionCoercionCosts[key] := Pair<Type, Int>(VOID_TYPE, -1)
        }
        return result
    }

    method coercionCost(expr:ASTNode, target:TypeContext):Pair<Type, Int>? {
        match target {
            when TypeContext.UNSPECIFIED, TypeContext.NON_VOID {
                return coercionCost(expr, ANY_TYPE)
            }
            when TypeContext.TYPE(type, _) {
                return coercionCost(expr, type)
            }
            when TypeContext.IMMUTABLE {
                return coercionCost(expr, IMMUTABLE_TYPE)
            }
            otherwise {
                unreachable
            }
        }
    }

    method canCast(type:Type, target:Type):Bit {
        if type.isPointer & (target.isPointer | target.nonnullable().isMethod) {
            return true
        }
        if coercionCost(type, target) !== null {
            return true
        }
        if type.isBuiltinNumber & target.isBuiltinNumber {
            return true
        }
        if type.typeKind = Type.Kind.GENERIC_CLASS_PARAMETER {
            return canCast(type.genericClassParameter.bound, target)
        }
        if type.typeKind = Type.Kind.GENERIC_METHOD_PARAMETER {
            return canCast(type.genericMethodParameter.bound, target)
        }
        if type.typeKind = Type.Kind.INVALID {
            return false
        }
        if type.isClass & target.isClass {
            def cl := getClass(type)
            if cl == null {
                return false
            }
            if cl.classKind = ClassDecl.Kind.INTERFACE {
                return true
            }
        }
        return coercionCost(target, type, false) !== null
    }

    -- FIXME figure out how to handle list comparisons
    function equal(a:Array<Type>, b:Array<Type>):Bit {
        if a.count != b.count {
            return false
        }
        for i in 0 .. a.count {
            if a[i] != b[i] {
                return false
            }
        }
        return true
    }

    method createChoiceCaseInit(entry:ChoiceCase) {
        def cl := entry.owner
        assert entry.resolved != Resolution.UNRESOLVED
        if entry.resolved != Resolution.RESOLVED {
            return
        }
        outer: for m in cl.methods {
            if m.methodKind != MethodDecl.Kind.INIT |
                    m.parameters.count != entry.fields.count + 1->Int {
                continue
            }
            assert m.parameters[0].type = INT_TYPE
            for i in 0 .. entry.fields.count {
                if entry.fields[i] != m.parameters[i + 1].type {
                    continue outer
                }
            }
            entry.initMethod := m
            return
        }
        -- need a synthetic init for this particular combination of parameters
        def parameters := Array<MethodDecl.Parameter>()
        parameters.add(MethodDecl.Parameter("rv", INT_TYPE))
        def statements := Array<ASTNode>()
        statements.add(ASTNode.BINARY(cl.position,
                ASTNode.IDENTIFIER(cl.position, ClassDecl.TAG_NAME),
                Binary.Operator.ASSIGNMENT, ASTNode.IDENTIFIER(cl.position, "rv")))
        for i in 0 .. entry.fields.count {
            parameters.add(MethodDecl.Parameter("f\{i}", entry.fields[i]))
            statements.add(ASTNode.BINARY(cl.position,
                    ASTNode.CHOICE_FIELD_REFERENCE(cl.position,
                        ASTNode.SELF(cl.position),
                        entry,
                        i),
                    Binary.Operator.ASSIGNMENT,
                    ASTNode.IDENTIFIER(cl.position, "f\{i}")))
        }
        def synthetic := MethodDecl(cl, cl.position, methods.count, null,
                Annotations(Annotations.Flag.SYNTHETIC), MethodDecl.Kind.INIT, "init", null,
                parameters, VOID_TYPE, FixedArray<ASTNode>.from(statements))
        methods.add(synthetic)
        entry.initMethod := synthetic
        cl.methods.add(synthetic)
        cl.symbolTable.add(synthetic)
    }

    function declaredType(m:MethodDecl):Type {
        resolve(m)
        def parameters := Array<Type>() -- FIXME use map
        for p in m.parameters {
            parameters.add(p.type)
        }
        def immutable := m.annotations.isClass | isImmutable(m.owner)
        def kind:Type.Kind
        if m.methodKind = MethodDecl.Kind.FUNCTION {
            if immutable {
                kind := Type.Kind.IMMUTABLE_FUNCTION
            }
            else {
                kind := Type.Kind.FUNCTION
            }
        }
        else {
            if immutable {
                kind := Type.Kind.IMMUTABLE_METHOD
            }
            else {
                kind := Type.Kind.METHOD
            }
        }
        return Type.methodType(self, m.position, kind, parameters, m.returnType, m.priority)
    }

    function declaredTypeWithSelf(m:MethodDecl, selfType:Type, forceImmutable:Bit):Type {
        resolve(m)
        def parameters := Array<Type>()
        parameters.add(selfType)
        for p in m.parameters {
            parameters.add(p.type)
        }
        def immutable := forceImmutable | m.annotations.isClass | isImmutable(m.owner)
        def kind:Type.Kind
        if m.methodKind = MethodDecl.Kind.FUNCTION {
            if immutable {
                kind := Type.Kind.IMMUTABLE_FUNCTION
            }
            else {
                kind := Type.Kind.FUNCTION
            }
        }
        else {
            if immutable {
                kind := Type.Kind.IMMUTABLE_METHOD
            }
            else {
                kind := Type.Kind.METHOD
            }
        }
        return Type.methodType(self, m.position, kind, parameters, m.returnType, m.priority)
    }

    function inheritedType(m:MethodDecl):Type {
        def inherited := getOverriddenMethod(m)
        if inherited == null {
            return declaredType(m)
        }
        return inheritedType(inherited)
    }

    function inheritedTypeWithSelf(m:MethodDecl):Type {
        return inheritedTypeWithSelf(m, m.owner.type)
    }

    function inheritedTypeWithSelf(m:MethodDecl, selfType:Type):Type {
        def inherited := getOverriddenMethod(m)
        if inherited == null {
            return declaredTypeWithSelf(m, selfType, false)
        }
        return inheritedTypeWithSelf(inherited, selfType)
    }

    function literalType(t:Type):IR.Value {
        return IR.Value.TYPE(t, Type.ClassLiteral(self, t))
    }

    method createChoiceCleanup(m:MethodDecl) {
        if m.owner.rawSuper = VALUE_TYPE {
            return
        }
        def cl := m.owner
        def statements := Array<ASTNode>()
        def value := ASTNode.SELF(cl.position)
        def whens := Array<ASTNode>()
        for e in cl.choiceCases {
            resolve(e)
            if errorCount != 0 {
                return
            }
            def tests := Array<ASTNode>()
            def fields := Array<ASTNode>()
            for i in 0 .. e.fields.count {
                fields.add(ASTNode.IDENTIFIER(cl.position, "_f\{i}"))
            }
            tests.add(ASTNode.CALL(cl.position, ASTNode.IDENTIFIER(cl.position, e.name),
                    FixedArray<ASTNode>.from(fields)))
            def unrefs := Array<ASTNode>()
            for i in 0 .. e.fields.count {
                if isRefCounted(e.fields[i]) {
                    def p := Position()
                    def name := "unref" + getUnrefVariant(e.fields[i])
                    def unref := ASTNode.DOT(p, ASTNode.DOT(p, ASTNode.DOT(p,
                            ASTNode.IDENTIFIER(p, "frost"), "core"), "Frost"), name)
                    unrefs.add(ASTNode.CALL(Position(), unref,
                            FixedArray<ASTNode>.from([fields[i]])))
                }
            }
            whens.add(ASTNode.WHEN(cl.position, FixedArray<ASTNode>.from(tests),
                    FixedArray<ASTNode>.from(unrefs)))
        }
        statements.add(ASTNode.MATCH(cl.position, value, FixedArray<ASTNode>.from(whens),
                null))
        m.body := FixedArray<ASTNode>.from(statements)
    }

    method checkAccessModifierCount(position:Position, a:Annotations) {
        var count := 0
        if a.isPrivate {
            count += 1
        }
        if a.isProtected {
            count += 1
        }
        if a.isPackage {
            count += 1
        }
        if count > 1 {
            error(position, "conflicting access modifier annotations")
        }
    }

    method checkAnnotations(m:MethodDecl) {
        method disallow(compiler:Compiler -* FIXME capture this *-, m:MethodDecl -* FIXME capture this *-, flag:Int, name:String) {
            if m.annotations.flags && flag != 0 {
                compiler.error(m.position, "methods may not be annotated with '\{name}'")
            }
        }
        disallow(self, m, Annotations.Flag.SPECIALIZE,       "@specialize")
        disallow(self, m, Annotations.Flag.WEAK,             "@weak")
        disallow(self, m, Annotations.Flag.UNSAFE_IMMUTABLE, "@unsafeImmutable")
        if m.methodKind = MethodDecl.Kind.INIT {
            if m.annotations.isExternal {
                error(m.position, "init methods may not be annotated with '@external'")
            }
            if m.annotations.isClass {
                error(m.position, "init methods may not be annotated with '@class'")
            }
            if m.annotations.isAbstract {
                error(m.position, "init methods may not be annotated with '@abstract'")
            }
            if m.annotations.isOverride {
                error(m.position, "init methods may not be annotated with '@override'")
            }
        }
        if m.annotations.isExternal & m.body !== null {
            error(m.position, "methods annotated with '@external' may not have a body")
        }
        if m.annotations.isAbstract & m.body !== null {
            error(m.position, "methods annotated with '@abstract' may not have a body")
        }
        if m.annotations.isOverride & m.annotations.isClass {
            error(m.position, "class methods may not be annotated with '@override'")
        }
        if m.annotations.isNoReturn {
            if m.methodKind = MethodDecl.Kind.FUNCTION {
                error(m.position, "functions may not be annotated with '@noReturn'")
            }
            if m.returnType != VOID_TYPE {
                error(m.position, "method is annotated '@noReturn', but has a return type")
            }
        }
        if !m.owner.annotations.isStub {
            if !m.annotations.isAbstract & !m.annotations.isExternal & m.body == null {
                error(m.position, "expected non-abstract method '\{m.name}' to have a body")
            }
            if m.annotations.isDefault {
                if m.owner.classKind != ClassDecl.Kind.INTERFACE {
                    error(m.position, "annotation '@default' may only appear on interface methods")
                }
                if m.body == null {
                    error(m.position, "expected '@default' method '\{m.name}' to have a body")
                }
            }
            else if m.methodKind != MethodDecl.Kind.INIT &
                    m.owner.classKind = ClassDecl.Kind.INTERFACE &
                    !m.annotations.isClass & m.body !== null {
                error(m.position, "non-abstract interface method '\{m.name}' must be annotated " +
                        "with '@default'")
                m.annotations += Annotations.Flag.DEFAULT
            }
        }
        checkAccessModifierCount(m.position, m.annotations)
    }

    method getIndex(f:FieldDecl):Int {
        def fields := instanceFields(f.owner)
        for i in 0 .. fields.count {
            if fields[i] == f {
                return i
            }
        }
        unreachable, "can't find field \{f} in \{f.owner.name} : \{fields}"
    }

    method capture(position:MethodPosition, v:Variable) {
        if v.name = SELF_NAME {
            for c in captures {
                c.second[SELF_NAME] := Capture.SELF
                if !c.first.annotations.isCapture {
                    return
                }
            }
        }
        for c in captures {
            if v.varKind = Variable.Kind.VAR {
                error(position, "closure cannot capture 'var \{v}'; use 'def' instead")
                break
            }
            c.second[v.name] := Capture.VARIABLE(v)
            if v.owner == c.first {
                break
            }
        }
    }

    method capture(position:MethodPosition, f:FieldDecl) {
        for c in captures {
            c.second[f.name] := Capture.FIELD(f)
            if f.owner == c.first.owner {
                break
            }
        }
    }

    @post(@return !== null | errorCount > 0 | !reportErrors)
    method symbolRef(position:MethodPosition, target:IR.Value?, s:Symbol):IR.Value? {
        match s.kind {
            when Symbol.Kind.ALIAS {
                def type := resolve(s->Alias.type)
                if type !== null {
                    return literalType(type)
                }
                return null
            }
            when Symbol.Kind.METHOD {
                return IR.Value.METHOD(target, s->MethodDecl, s->MethodDecl.type(self))
            }
            when Symbol.Kind.METHODS {
                return IR.Value.METHODS(target, s->Methods.methods, INVALID_TYPE)
            }
            when Symbol.Kind.VARIABLE {
                def v := s->Variable
                if v.owner !== null & v.owner !== currentMethod[0] {
                    capture(position, v)
                }
                match v.storage {
                    when Variable.Storage.LOCAL(slot) {
                        def result := ir.add(IR.Statement.LOAD(position,
                                IR.Value.LOCAL(slot, v.type)))
                        return IR.Value.REF(result, v.type)
                    }
                    when Variable.Storage.PARAMETER(index) {
                        def inline := getInlineContext()
                        if inline !== null {
                            match inline {
                                when EnclosingContext.INLINE_CONTEXT(params, _, _, _) {
                                    return params[index]
                                }
                                otherwise {
                                    unreachable
                                }
                            }
                        }
                        else {
                            assert s->Variable.type.resolved
                            return IR.Value.PARAMETER(index, s->Variable.type)
                        }
                    }
                    otherwise {
                        unreachable
                    }
                }
            }
            when Symbol.Kind.FIELD {
                def f := s->FieldDecl
                if resolve(f) {
                    if target !== null {
                        match target {
                            when IR.Value.TYPE {
                                if !f.annotations.isClass {
                                    error(position, "instance field '\{f.name}' cannot be " +
                                            "accessed from a class context")
                                    return null
                                }
                            }
                        }
                    }
                    if f.annotations.isCapture {
                        capture(position, f)
                    }
                    return FieldLValue(self, position, target, f).compileLoad()
                }
                return null
            }
            when Symbol.Kind.CHOICE_CASE {
                -- this handles the zero-argument case; choice cases with arguments are handled in
                -- Call.compile()
                def cc := s->ChoiceCase
                if cc.fields.count > 0 {
                    error(position, "choice '\{s}' requires \{cc.fields.count} " +
                            "argument\{cc.fields.count = 1:|s}, but found 0")
                    return null
                }
                resolve(cc)
                def inits := getSymbolTable(cc.owner)["init"]
                assert inits !== null
                def args := [ASTNode.INT(position.asPosition, cc.tag.asUInt64)]
                if isValue(cc.owner) {
                    return Call.compile(self, position, symbolRef(position, null, inits), args,
                            TypeContext.UNSPECIFIED)
                }
                else {
                    def construct := ir.add(IR.Statement.CONSTRUCT(position, cc.owner))
                    def constructRef := IR.Value.REF(construct, cc.owner.type)
                    enclosingContexts.push(EnclosingContext.VALUE_SCOPE(constructRef))
                    Call.compile(self, position, symbolRef(position, constructRef, inits), args,
                            TypeContext.UNSPECIFIED)
                    return constructRef
                }
            }
            when Symbol.Kind.GENERIC_CLASS_PARAMETER, Symbol.Kind.GENERIC_METHOD_PARAMETER {
                error(position, "generic parameter '\{s.name}' is not an expression")
                return null
            }
            otherwise {
                unreachable, "unsupported symbol kind: \{s}"
            }
        }
        unreachable
    }

    method isValueInit(m:MethodDecl):Bit {
        return m.methodKind = MethodDecl.Kind.INIT & isValue(m.owner)
    }

    method implicitInit(position:MethodPosition, value:IR.Value, m:MethodDecl):IR.Value {
        def coerced := coerce(position, value, m.parameters[0].type)
        assert coerced !== null
        def intrinsic := Call.compileIntrinsic(self, position, null, MethodRef(self, m.owner.type,
                m), [ASTNode.IR_WRAPPER(position.asPosition, coerced)])
        if intrinsic.first {
            return intrinsic.second
        }
        def cl := m.owner
        assert isValue(cl), "can't implicit init \{cl.name} using \{m.declaration}:\{m.position} " +
                "at \{files[position.file]}:\{position} because it is not a value"
        def result := ir.add(IR.Statement.STATIC_CALL(position, m,
                FixedArray<IR.Value>.from([coerced])))
        return IR.Value.REF(result, m.owner.type)
    }

    ================================================================================================
    Creates an object which represents a method reference, such as `Int.+` (which has a `null`
    `target`) or 1.+ (which has a `target` of `1`).
    ================================================================================================
    method createMethodObject(position:MethodPosition, target:IR.Value?, m:MethodDecl):IR.Value? {
        if !resolve(m) {
            return null
        }
        def effectiveType:Type
        def irType:Type
        if target !== null & !target.type().isClassLiteral {
            -- we're taking a reference which has a fixed 'self' parameter, as in '1.+'. Easiest way
            -- to do this is compile the closure 'x => 1.+(x)'. (Well, it's not actually a lambda,
            -- because it can be a method and return void, but you get the point)
            assert !m.annotations.isClass
            def old := enclosingContexts
            -- keep TRY_SCOPE from affecting effective return type
            enclosingContexts := Stack<EnclosingContext>()
            effectiveType := MethodRef(self, target.type(), m).effectiveType
            enclosingContexts := old
            tempCount += 1
            def dummyName := "$dummy\{tempCount}"
            compileDeclaration(position, ASTNode.IDENTIFIER(position.asPosition, dummyName),
                    ASTNode.IR_WRAPPER(position.asPosition, target), Variable.Kind.DEF)
            def parameters := Array<ASTNode>()
            def arguments := Array<ASTNode>()
            for i in 0 .. m.parameters.count {
                def name := "param\{i}"
                parameters.add(ASTNode.PARAMETER(position.asPosition, name,
                        ASTNode.IR_WRAPPER(m.position,
                            literalType(effectiveType.parameterType(i)))))
                arguments.add(ASTNode.IDENTIFIER(position.asPosition, name))
            }
            def call := ASTNode.CALL(position.asPosition,
                    ASTNode.DOT(position.asPosition, ASTNode.IDENTIFIER(position.asPosition,
                    dummyName), m.name), FixedArray<ASTNode>.from(arguments))
            def statement:ASTNode
            if effectiveType.returnType != VOID_TYPE {
                statement := ASTNode.RETURN(position.asPosition, call)
            }
            else {
                statement := call
            }
            return Closure.compile(self, position, m.methodKind,
                    FixedArray<ASTNode>.from(parameters),
                    ASTNode.IR_WRAPPER(position.asPosition, literalType(effectiveType.returnType)),
                    FixedArray<ASTNode>.from([statement]), TypeContext.UNSPECIFIED)
        }
        else {
            if m.annotations.isClass {
                effectiveType := m.type(self)
                irType := Type.pointerTo(self, m.type(self))
            }
            else {
                effectiveType := declaredTypeWithSelf(m, m.owner.type, isClassContext())
                irType := Type.pointerTo(self, declaredTypeWithSelf(m, m.owner.type, false))
            }
        }
        def args := Array<ASTNode>()
        args.add(ASTNode.IR_WRAPPER(position.asPosition, extractBuiltinInt(position,
                IR.Value.METHOD_POINTER(m, irType))))
        args.add(ASTNode.NULL(position.asPosition))
        return cast(position, Call.compile(self, position, literalType(METHOD_TYPE), args,
                TypeContext.UNSPECIFIED), effectiveType)
    }

    function explainCoerceFailure(m:MethodRef, target:Type):String {
        if m.parameterCount != target.parameterCount {
            return "wrong parameter count"
        }
        for i in 0 .. m.parameterCount {
            if coercionCost(target.parameterType(i), m.parameterType(i)) == null {
                return "parameter \{i + 1} cannot be converted from '\{target.parameterType(i)}' " +
                        "to '\{m.parameterType(i)}'"
            }
        }
        if coercionCost(m.returnType, target.returnType) == null {
            return "return type '\{m.returnType}' cannot be converted to '\{target.returnType}'"
        }
        if m.value.methodKind = MethodDecl.Kind.METHOD & (target.typeKind = Type.Kind.FUNCTION |
                target.typeKind = Type.Kind.IMMUTABLE_FUNCTION) {
            return "cannot use a method where a function is expected"
        }
        return "<internal error>"
    }

    @pre(value.type().isMethod & target.isMethod)
    method methodCast(position:MethodPosition, value:IR.Value, target:Type,
            explicit:Bit):IR.Value? {
        def src := value.type()
        if src = target {
            return value
        }
        assert src.subtypes.count = target.subtypes.count
        var diff := false
        for i in 0 .. src.subtypes.count {
            if isValue(src.subtypes[i]) != isValue(target.subtypes[i]) {
                diff := true
                break
            }
        }
        if !diff {
            return IR.Value.REF(ir.add(IR.Statement.CAST(position, value, target, explicit)),
                    target)
        }
        def kind:MethodDecl.Kind
        match target.typeKind {
            when Type.Kind.IMMUTABLE_FUNCTION, Type.Kind.FUNCTION {
                kind := MethodDecl.Kind.FUNCTION
            }
            otherwise {
                kind := MethodDecl.Kind.METHOD
            }
        }
        def rawParams := Array<ASTNode>()
        def callParams := Array<ASTNode>()
        def basePos := position.asPosition
        for i in 0 .. src.parameterCount {
            def name := "param\{i}"
            rawParams.add(ASTNode.PARAMETER(basePos, name, ASTNode.IR_WRAPPER(basePos,
                    literalType(target.subtypes[i]))))
            callParams.add(ASTNode.BINARY(basePos, ASTNode.IDENTIFIER(basePos, name),
                    Binary.Operator.IMPLICIT_CAST, ASTNode.IR_WRAPPER(basePos,
                        literalType(src.subtypes[i]))))
        }
        tempCount += 1
        def methodCapture := ASTNode.IDENTIFIER(basePos, "$method\{tempCount}")
        compileDeclaration(position, methodCapture, ASTNode.IR_WRAPPER(basePos, value),
                Variable.Kind.DEF)
        def c := ASTNode.CALL(basePos, methodCapture, FixedArray<ASTNode>.from(callParams))
        def body:Array<ASTNode>
        if target.returnType != VOID_TYPE {
            body := [ASTNode.RETURN(basePos, ASTNode.BINARY(basePos, c,
                    Binary.Operator.IMPLICIT_CAST,
                    ASTNode.IR_WRAPPER(basePos, literalType(target.returnType))))]
        }
        else {
            body := [c]
        }
        return Closure.compile(self, position, kind, FixedArray<ASTNode>.from(rawParams),
                ASTNode.IR_WRAPPER(basePos, literalType(target.returnType)),
                FixedArray<ASTNode>.from(body), TypeContext.TYPE(target, false))
    }

    @pre(target != VOID_TYPE)
    method coerce(position:MethodPosition, value:IR.Value?, target:Type):IR.Value? {
        return coerce(position, value, target, false)
    }

    method getImplicitInits(cl:ClassDecl):Array<MethodDecl> {
        var result := cl.implicitInits
        if result == null {
            def inits := getSymbolTable(cl)["init"]
            assert inits !== null
            match inits.kind {
                when Symbol.Kind.METHOD {
                    def m := inits->MethodDecl
                    if m.annotations.isImplicit {
                        result := [m]
                    }
                    else {
                        result := []
                    }
                }
                when Symbol.Kind.METHODS {
                    result := []
                    for m in inits->Methods.methods {
                        if m.annotations.isImplicit {
                            result.add(m)
                        }
                    }
                }
            }
            cl.implicitInits := result
        }
        return result
    }

    ================================================================================================
    Coerces a value to a different type, returning a new value representing the converted type (or
    report an error and return `null` if no such coercion is possible). "Coerce", in Frost's
    lexicon, means to perform a typecast which can be performed implicitly, without being explicitly
    specified by the user. This includes things like widenining conversions or converting a literal
    to any of the types it can legally represent.

    Even though coercion by definition always could have been implicit, explicit coercion can happen
    when delegating from an explicit cast (i.e. a cast in which it *would have been possible* to
    coerce will be handled as coercion with an 'explicit' parameter of true).
    ================================================================================================
    @pre(target != VOID_TYPE)
    method coerce(position:MethodPosition, value:IR.Value?, target:Type, explicit:Bit):IR.Value? {
        if value == null {
            return null
        }
        def srcType := value.type()
        if srcType = target {
            return value
        }
        match value {
            when IR.Value.METHOD(rawTarget, m, _) {
                def finalTarget:IR.Value?
                if rawTarget == null & !isClassContext() & !m.annotations.isClass {
                    finalTarget := compileSelf(position, false)
                }
                else {
                    finalTarget := rawTarget
                }
                def result := createMethodObject(position, finalTarget, m)
                if coercionCost(result.type(), target) == null {
                    error(position, "expected '\{target}', but found '\{result.type()}'")
                    return null
                }
                return coerce(position, result, target, explicit)
            }
            when IR.Value.METHODS(targetObj, methods, _) {
                def best := Array<MethodDecl>()
                var bestCost := Int.MAX
                for m in methods {
                    if resolve(m) {
                        def o:Object? := targetObj
                        def targetType:Type
                        if targetObj !== null {
                            targetType := targetObj.type()
                        }
                        else {
                            targetType := m.owner.type
                        }
                        def ref := MethodRef(self, targetType, m)
                        def cost := coercionCost(ref.effectiveType, target)
                        if cost !== null {
                            if cost.second < bestCost {
                                best.clear()
                                bestCost := cost.second
                            }
                            if cost.second = bestCost {
                                best.add(m)
                            }
                        }
                    }
                }
                if best.count = 1 {
                    return coerce(position, IR.Value.METHOD(targetObj, best[0], best[0].type(self)),
                            target, explicit)
                }
                if best.count > 1 {
                    error(position, "ambiguous method reference")
                    return null
                }
                def msg := MutableString("reference to method '\{methods[0].name}' cannot be " +
                        "used as type '\{target}'. None of the following methods match this type:")
                for m in methods {
                    def ref := MethodRef(self, targetObj.type(), m)
                    msg.append("\n    \{m.declaration}:\{m.position} (" +
                            explainCoerceFailure(ref, target) + ")")
                }
                error(position, msg.finish())
                return null
            }
        }
        if coercionCost(srcType, target) !== null {
            if target.isMethod & srcType.isMethod {
                return methodCast(position, value, target, explicit)
            }
            def cl := getClass(target)
            if cl == null {
                return null
            }
            def implicitInits := getImplicitInits(cl)
            if implicitInits.count = 1 {
                def m := implicitInits[0]
                if resolve(m) & coercionCost(srcType, m.parameters[0].type) !== null {
                    return coerce(position, implicitInit(position, value, m), target)
                }
            }
            else if implicitInits.count > 1 {
                def args := Array<ASTNode>()
                args.add(ASTNode.IR_WRAPPER(position.asPosition, value))
                def best := Call.findBestMethod(self, position, null, implicitInits, args,
                        TypeContext.UNSPECIFIED)
                if best !== null {
                    if best.first.count = 1 {
                        return coerce(position, implicitInit(position, value,
                                best.first[0].value), target)
                    }
                    unreachable, "ambiguous implicit init"
                }
            }
            assert srcType.isClass
            -- FIXME add explicit check back in when null safety becomes an error instead of a
            -- warning
            if -*explicit & *- settings.safetyLevel >= 3 & value.type().isNullable &
                    !target.isNullable & target.typeKind != Type.Kind.GENERIC_CLASS_PARAMETER &
                    target.typeKind != Type.Kind.GENERIC_METHOD_PARAMETER {
                def basePos := position.asPosition
                Assert.compile(self, position, ASTNode.BINARY(basePos,
                        ASTNode.IR_WRAPPER(basePos, value), Binary.Operator.NIDENTITY,
                        ASTNode.NULL(basePos)), ASTNode.STRING(basePos,
                                "unexpected null reference casting \{value.type()} to \{target}"))
            }
            if canRewriteType(value, target) {
                return rewriteType(value, target)
            }
            def result := IR.Value.REF(ir.add(IR.Statement.CAST(position, value, target, explicit)),
                    target)
            if !isRefCounted(srcType) & isRefCounted(target) {
                enclosingContexts.push(EnclosingContext.VALUE_SCOPE(result))
            }
            return result
        }
        error(position, "expected '\{target}', but found '\{srcType}'")
        return null
    }

    method coerce(position:MethodPosition, value:IR.Value?, type:TypeContext):IR.Value? {
        if value == null {
            return value
        }
        match type {
            when TypeContext.UNSPECIFIED, TypeContext.NON_VOID {
                return value
            }
            when TypeContext.IMMUTABLE {
                if isImmutable(value.type()) {
                    return value
                }
                error(position, "expected 'frost.core.Immutable', but found '\{value.type()}'")
                return null
            }
            when TypeContext.TYPE(t, explicit) {
                return coerce(position, value, t, explicit)
            }
            otherwise {
                unreachable
            }
        }
    }

    method cast(position:MethodPosition, value:IR.Value?, target:Type):IR.Value? {
        return cast(position, value, target, false)
    }

    function canRewriteType(v:IR.Value, target:Type):Bit {
        def srcType := v.type()
        if srcType.typeKind = Type.Kind.GENERIC {
            return (target.typeKind = Type.Kind.CLASS & srcType.subtypes[0] = target) |
                    (target.typeKind = Type.Kind.GENERIC &
                    srcType.subtypes[0] = target.subtypes[0])
        }
        return srcType.typeKind = Type.Kind.CLASS & target.typeKind = Type.Kind.GENERIC &
                target.subtypes[0] = srcType
    }

    ================================================================================================
    Casts a value to a different type, returning a new value representing the converted type (or
    report an error and return `null` if no such cast is possible). "Cast", in Frost's lexicon,
    means to perform a typecast which has been explicitly specified by the user, as in the
    expression `object->String`.
    ================================================================================================
    @pre(target != VOID_TYPE & target.resolved)
    method cast(position:MethodPosition, value:IR.Value?, target:Type, explicit:Bit):IR.Value? {
        if value == null {
            return null
        }
        def valueType := value.type()
        if valueType = target {
            return value
        }
        if coercionCost(value.type(), target) !== null {
            return coerce(position, value, TypeContext.TYPE(target, true))
        }
        if target.isMethod {
            if valueType.isMethod {
                return methodCast(position, value, target, true)
            } 
            if valueType.name != "frost.core.Method" &
                    valueType.name != "frost.core.MutableMethod" {
                error(position, "non-method objects may not be cast to methods")
            }
        }
        if explicit & !canCast(value.type(), target) {
            error(position, "value of type '\{value.type()}' cannot possibly be an instance of " +
                    "'\{target}'")
        }
        if canRewriteType(value, target) {
            return rewriteType(value, target)
        }
        def result := IR.Value.REF(ir.add(IR.Statement.CAST(position, value, target, true)), target)
        if !isRefCounted(value.type()) & isRefCounted(target) {
            enclosingContexts.push(EnclosingContext.VALUE_SCOPE(result))
        }
        return result
    }

    ================================================================================================
    Rewrites the type of a value. This is distinct from a typecast, in that it never actually causes
    any code to be generated. This is used for situations where the "real" underlying type of the
    object is the same, but we need a different Frost type to reflect it (e.g. List<T> vs.
    List<Object>).
    ================================================================================================
    method rewriteType(v:IR.Value, t:Type):IR.Value {
        match v {
            when IR.Value.PARAMETER(idx, _) {
                return IR.Value.PARAMETER(idx, t)
            }
            when IR.Value.REF(s, _) {
                return IR.Value.REF(s, t)
            }
            otherwise {
                unreachable, "cannot rewrite \{v}->\{t}"
            }
        }
    }

    ================================================================================================
    Converts an object to a different type using the appropriate `as` property. Reports an error and
    returns `null` if no such conversion is possible.
    ================================================================================================
    method convert(value:IR.Value?, target:Type):IR.Value? {
        if value == null {
            return value
        }
        if value.type() = target {
            return value
        }
        def simpleName := target.name[target.name.next(target.name.lastIndexOf("."))..]
        return Call.compile(self, MethodPosition(currentMethod[0].position, currentMethodIndex),
                value, "get_as\{simpleName}", [], TypeContext.TYPE(target, false))
    }

    method getVTableIndex(m:MethodDecl):Int {
        def vtable := getVTable(m.owner)
        for i in 0 .. vtable.count {
            if vtable[i] == m {
                return i
            }
        }
        unreachable, "could not find \{m.declaration} in vtable for \{m.owner.name}"
    }

    function unwrap(type:Type):Type {
        match type.typeKind {
            when Type.Kind.NULLABLE {
                return unwrap(type.subtypes[0])
            }
            when Type.Kind.GENERIC_CLASS_PARAMETER {
                return unwrap(type.genericClassParameter!.bound)
            }
            when Type.Kind.GENERIC_METHOD_PARAMETER {
                return unwrap(type.genericMethodParameter!.bound)
            }
            otherwise {
                return type
            }
        }
    }

    -- See Frost.frost for an explanation of the various variants
    method getRefVariant(rawType:Type):String {
        def type := unwrap(rawType)
        if canCast(type, IMMUTABLE_TYPE) {
            if canCast(type, STRING_TYPE) | canCast(type, CLASS_TYPE) {
                return "ThreadSafe"
            }
            else {
                return "ThreadSafeNonConstant"
            }
        }
        else {
            return "ThreadUnsafe"
        }
    }

    method hasNontrivialCleanup(cl:ClassDecl):Bit {
        if cl.hasNontrivialCleanup == null {
            resolve(cl)
            def cleanup := getVTable(cl)[1]
            assert cleanup.name = "cleanup"
            if cleanup.body !== null & cleanup.body.count > 0 {
                cl.hasNontrivialCleanup := true
                return true
            }
            for f in cl.fields {
                resolve(f)
                if isRefCounted(f.type) {
                    cl.hasNontrivialCleanup := true
                    return true
                }
            }
            if cl.rawSuper !== null {
                def s := getClass(remapType(cl.type, cl.rawSuper))
                if s !== null {
                    return hasNontrivialCleanup(s)
                }
            }
            cl.hasNontrivialCleanup := false
            return false
        }
        return cl.hasNontrivialCleanup
    }

    method getUnrefVariant(rawType:Type):String {
        -- See Frost.frost for an explanation of the various variants
        def type := unwrap(rawType)
        def result := getRefVariant(type)
        def cl := getClass(type)
        if cl !== null & cl.annotations.isFinal & !hasNontrivialCleanup(cl) {
            Console.printLine("no cleanup for \{rawType}")
            return result + "NoCleanup"
        }
        return result
    }

    method compileRef(v:IR.Value) {
        match v {
            when IR.Value.NULL {
                return
            }
        }
        def args := Array<ASTNode>()
        args.add(ASTNode.IR_WRAPPER(currentMethod[0].position, v))
        def name := "ref" + getRefVariant(v.type())
        Call.compile(self, MethodPosition(currentMethod[0].position, currentMethodIndex),
                literalType(FROST_TYPE), name, args, TypeContext.UNSPECIFIED)
    }

    @pre(isRefCounted(v.type()))
    method compileUnref(v:IR.Value) {
--        def f := v.asString = "REF($102:frost.collections.Array<frost.collections.Array.T>)"
--        ir.add(IR.Statement.COMMENT( MethodPosition(currentMethod[0].position, currentMethodIndex), "compile unref \{v.asString} \{f}"))
--        assert !f
        match v {
            when IR.Value.NULL {
                return
            }
        }
        def args := Array<ASTNode>()
        args.add(ASTNode.IR_WRAPPER(currentMethod[0].position, v))
        def name := "unref" + getUnrefVariant(v.type())
        Call.compile(self, MethodPosition(currentMethod[0].position, currentMethodIndex),
                literalType(FROST_TYPE), name, args, TypeContext.UNSPECIFIED)
    }

    @pre(type.isNumber)
    function numberSize(type:Type):Int {
        def cl := getClass(type)
        assert cl !== null
        def value := cl.fields.filter(f => f.name = "value")[0]
        resolve(value)
        assert value.type.isBuiltinNumber
        return value.type.size
    }

    function binaryType(leftType:Type, rightType:Type, signMatters:Bit, promote32:Bit):Type {
        def leftSize := numberSize(leftType)
        def rightSize := numberSize(rightType)
        if leftType.isReal | rightType.isReal {
            if leftSize = 64 | rightSize = 64 {
                return REAL64_TYPE
            }
            return REAL32_TYPE
        }
        if leftType.isSigned = rightType.isSigned | !signMatters {
            def leftPromoted:Type
            def rightPromoted:Type
            if promote32 {
--                leftPromoted := max32(leftType)
--                rightPromoted := max32(rightType)
                unreachable
            }
            else {
                leftPromoted := leftType
                rightPromoted := rightType
            }
            if leftPromoted = rightPromoted {
                return leftPromoted
            }
            if numberSize(leftPromoted) > numberSize(rightPromoted) {
                return leftPromoted
            }
            return rightPromoted
        }
        else if leftSize = 8 & rightSize = 8 {
            if promote32 {
                return INT32_TYPE
            }
            else {
                return INT16_TYPE
            }
        }
        else if leftSize <= 16 & rightSize <= 16 {
            return INT32_TYPE
        }
        else if leftSize <= 32 & rightSize <= 32 {
            return INT64_TYPE
        }
        else if leftSize < 64 | rightSize < 64 {
            if leftType = INT_TYPE | rightType = INT_TYPE {
                return INT_TYPE
            }
            return INT64_TYPE
        }
        else {
            unreachable
        }
    }

    @pre(methods.count > 1)
    method reportAmbiguousMatch(position:Position, methods:Array<MethodRef>, args:ListView<ASTNode>,
            type:TypeContext) {
        def msg := MutableString("call to '\{methods[0].value.name}' is ambiguous. The following " +
                "methods are equally good matches:")
        for m in methods.sort((a, b) => a.value.position > b.value.position) {
            msg.append("\n    \{m.value.declaration} (\{m.value.owner.source.name}:" +
                    "\{m.value.position})")
        }
        error(position, msg.finish())
    }

    ================================================================================================
    Returns the type under which a particular class was inherited. For instance,
    `HashMap<String, File>` inherits `MapView` under the type `MapView<String, File>`.
    ================================================================================================
    method findType(start:Type, target:ClassDecl):Type? {
        if !start.isClass {
            return null
        }
        if start.typeKind = Type.Kind.GENERIC_CLASS_PARAMETER {
            return findType(start.genericClassParameter.bound, target)
        }
        def startClass := getClass(start)
        if startClass == null {
            return null
        }
        if startClass == target {
            return start.nonnullable()
        }
        -- FIXME uncomment assert startClass.name != target.name, "duplicate class: \{startClass.name}"
        if startClass.rawSuper !== null {
            def result := findType(remapType(start, startClass.rawSuper),
                    target)
            if result !== null {
                return result
            }
        }
        for intf in startClass.rawInterfaces {
            def result := findType(remapType(start, intf), target)
            if result !== null {
                return result
            }
        }
        return null
    }

    function findType(start:CollectionView<Type>, target:ClassDecl):Type? {
        for t in start {
            def result := findType(t, target)
            if result !== null {
                return result
            }
        }
        return null
    }

    ================================================================================================
    If `t` is a type to which an array literal can be coerced, returns whether or not the resulting
    collection should be mutable and the element type.
    ================================================================================================
    function getListType(t:Type):Pair<Bit, Type>? {
        if t.typeKind = Type.Kind.NULLABLE {
            return getListType(t.subtypes[0])
        }
        if t.typeKind = Type.Kind.GENERIC {
            if t.subtypes.count != 2 {
                return null
            }
            def mutable:Bit
            match t.subtypes[0].name {
                when "frost.collections.Array" {
                    mutable := true
                }
                when "frost.collections.List" {
                    mutable := !isImmutable(t.subtypes[1])
                }
                when "frost.collections.ListView" {
                    mutable := !isImmutable(t.subtypes[1])
                }
                when "frost.collections.ListWriter" {
                    mutable :=!isImmutable(t.subtypes[1])
                }
                when "frost.collections.Collection" {
                    mutable := !isImmutable(t.subtypes[1])
                }
                when "frost.collections.CollectionView" {
                    mutable := !isImmutable(t.subtypes[1])
                }
                when "frost.collections.CollectionWriter" {
                    mutable := true
                }
                when "frost.collections.ImmutableArray" {
                    mutable := false
                }
                when "frost.collections.Iterable" {
                    mutable := !isImmutable(t.subtypes[1])
                }
                otherwise {
                    return null
                }
            }
            return Pair<Bit, Type>(mutable, t.subtypes[1])
        }
        match t.name {
            when "frost.core.Object", "frost.core.Immutable" {
                return Pair<Bit, Type>(false, ANY_TYPE)
            }
            otherwise {
                return null
            }
        }
    }

    method compileChoiceCaseReference(position:MethodPosition, owner:Type, cc:ChoiceCase,
            args:FixedArray<ASTNode>, type:TypeContext):IR.Value? {
        resolve(cc)
        def initMethod := cc.initMethod
        if initMethod == null {
            return null
        }
        resolve(initMethod)
        if args.count != cc.fields.count {
            error(position, "'\{cc}' expected \{cc.fields.count} argument" +
                    "\{cc.fields.count = 1:|s}, but found \{args.count}")
            return null
        }
        def finalArgs := Array<ASTNode>()
        finalArgs.add(ASTNode.INT(position.asPosition, cc.tag.asUInt64))
        finalArgs.addAll(args)
        if isValue(cc.owner) {
            return coerce(position, Call.compile(self, position,
                    symbolRef(position, null, initMethod), finalArgs, TypeContext.UNSPECIFIED),
                    type)
        }
        else {
            def construct := ir.add(IR.Statement.CONSTRUCT(position, cc.owner))
            def constructRef := IR.Value.REF(construct, owner)
            enclosingContexts.push(EnclosingContext.VALUE_SCOPE(constructRef))
            Call.compile(self, position, symbolRef(position, constructRef, initMethod), finalArgs,
                    TypeContext.UNSPECIFIED)
            return coerce(position, constructRef, type)
        }
    }

    ================================================================================================
    If `node` is a reference to a [ChoiceCase], returns it. Otherwise, returns `null` without
    reporting an error.
    ================================================================================================
    method getChoiceCase(node:ASTNode):Pair<Type, ChoiceCase>? {
        match node {
            when ASTNode.IDENTIFIER(_, text) {
                if currentClass[0].classKind = ClassDecl.Kind.CHOICE {
                    def s := getSymbolTable(currentClass[0])[text]
                    if s !== null & s.kind = Symbol.Kind.CHOICE_CASE {
                        return Pair<Type, ChoiceCase>(currentClass[0].type, s->ChoiceCase)
                    }
                }
            }
            when ASTNode.DOT(_, base, text) {
                def baseType := preferredType(base)
                if baseType !== null & baseType.isClassLiteral {
                    def cl := getClass(baseType.subtypes[1])
                    if cl !== null & cl.classKind = ClassDecl.Kind.CHOICE {
                        def s := getSymbolTable(cl)[text]
                        if s !== null & s.kind = Symbol.Kind.CHOICE_CASE {
                            return Pair<Type, ChoiceCase>(baseType.subtypes[1], s->ChoiceCase)
                        }
                    }
                }
            }
        }
        return null
    }

    method compileCast(position:MethodPosition, value:ASTNode, rawTarget:Type,
            explicit:Bit):IR.Value? {
        def index := rawTarget.name.lastIndexOf(".")
        if rawTarget.typeKind = Type.Kind.CLASS & index !== null {
            -- we have a dotted name which might not be entirely a type - for example we might have
            -- 'o->String.length'. This is obviously meant to be a cast to String followed by a
            -- call to get_length(), but syntactically it could just as easily be a cast to a class
            -- named String.length. We need to disambiguate these cases here.
            def old := reportErrors
            reportErrors := false
            def type := resolve(rawTarget)
            reportErrors := old
            if type == null {
                def base := compileCast(position, value,
                        Type(rawTarget.name[..index], Type.Kind.CLASS, position.asPosition),
                        explicit)
                if base == null {
                    return null
                }
                return Dot.compile(self, position, base,
                        rawTarget.name[rawTarget.name.next(index)..])
            }
        }
        def target := resolve(rawTarget)
        if target == null {
            return null
        }
        if coercionCost(value, target) !== null {
            return compileExpression(value, TypeContext.TYPE(target, true))
        }
        return cast(position, compileExpression(value, TypeContext.NON_VOID), target, explicit)
    }

    function isNull(v:IR.Value):Bit {
        match v {
            when IR.Value.NULL {
                return true
            }
        }
        return false
    }

    @pre(op = Binary.Operator.IDENTITY | op = Binary.Operator.NIDENTITY)
    method compileIdentityComparison(position:MethodPosition, left:ASTNode, op:Binary.Operator,
            right:ASTNode, type:TypeContext):IR.Value? {
        def compiledLeft := compileExpression(left, TypeContext.NON_VOID)
        if compiledLeft == null {
            return null
        }
        def compiledRight := compileExpression(right, TypeContext.NON_VOID)
        if compiledRight == null {
            return null
        }
        if compiledLeft.type().typeKind != Type.Kind.NULLABLE & isNull(compiledRight) {
            if op = Binary.Operator.IDENTITY {
                return coerce(position, coerce(position, IR.Value.BIT(false, BUILTIN_BIT_TYPE),
                        TypeContext.TYPE(BIT_TYPE, false)), type)
            }
            return coerce(position, coerce(position, IR.Value.BIT(true, BUILTIN_BIT_TYPE),
                    TypeContext.TYPE(BIT_TYPE, false)), type)
        }
        if compiledRight.type().typeKind != Type.Kind.NULLABLE & isNull(compiledLeft) {
            if op = Binary.Operator.IDENTITY {
                return coerce(position, coerce(position, IR.Value.BIT(false, BUILTIN_BIT_TYPE),
                        TypeContext.TYPE(BIT_TYPE, false)), type)
            }
            return coerce(position, coerce(position, IR.Value.BIT(true, BUILTIN_BIT_TYPE),
                    TypeContext.TYPE(BIT_TYPE, false)), type)
        }
        if coercionCost(compiledLeft.type(), compiledRight.type()) == null &
                coercionCost(compiledRight.type(), compiledLeft.type()) == null {
            error(position, "'\{op.asString}' cannot compare dissimilar types " +
                    "'\{compiledLeft.type()}' and '\{compiledRight.type()}'")
            return null
        }
        if isValue(compiledLeft.type()) & !isNull(compiledRight) |
                isValue(compiledRight.type()) & !isNull(compiledLeft) {
            error(position, "'\{op.asString}' cannot operate on value types")
            return null
        }
        def builtinBit := ir.add(IR.Statement.BINARY(position, compiledLeft, op, compiledRight,
                BUILTIN_BIT_TYPE))
        def bit := coerce(position, IR.Value.REF(builtinBit, BUILTIN_BIT_TYPE),
                TypeContext.TYPE(BIT_TYPE, false))
        return coerce(position, bit, type)
    }

    method compileNull(position:MethodPosition, type:TypeContext):IR.Value? {
        match type {
            when TypeContext.TYPE(t, _) {
                if t.typeKind != Type.Kind.NULLABLE {
                    error(position, "expected '\{t}', but found 'null'")
                }
                return IR.Value.NULL(t)
            }
            otherwise {
                return IR.Value.NULL(ANY_TYPE)
            }
        }
    }

    method compileRange(position:MethodPosition, start:ASTNode?, inclusive:Bit, end:ASTNode?,
            step:ASTNode?, type:TypeContext):IR.Value? {
        var endpointContext := TypeContext.NON_VOID
        var endpointType:Type? := null
        var stepContext := TypeContext.NON_VOID
        match type {
            when TypeContext.TYPE(t, explicit) {
                if t.typeKind = Type.Kind.GENERIC & t.subtypes.count = 2 &
                        t.subtypes[0].name = RANGE_NAME {
                    if step !== null {
                        error(position, "expected '\{t}', but found '\{STEPPED_RANGE_NAME}'")
                        return null
                    }
                    endpointContext := TypeContext.TYPE(t.subtypes[1], explicit)
                    endpointType := t.subtypes[1]
                }
                else if t.typeKind = Type.Kind.GENERIC & t.subtypes.count = 3 &
                        t.subtypes[0].name = STEPPED_RANGE_NAME {
                    if step == null {
                        error(position, "expected '\{t}', but found '\{RANGE_NAME}'")
                        return null
                    }
                    endpointContext := TypeContext.TYPE(t.subtypes[1], explicit)
                    endpointType := t.subtypes[1]
                    stepContext := TypeContext.TYPE(t.subtypes[2], explicit)
                }
            }
        }
        if endpointContext = TypeContext.NON_VOID {
            if start !== null {
                match start {
                    when ASTNode.STRING {
                        endpointContext := TypeContext.TYPE(CHAR32_TYPE, false)
                    }
                }
            }
            if end !== null {
                match end {
                    when ASTNode.STRING {
                        endpointContext := TypeContext.TYPE(CHAR32_TYPE, false)
                    }
                }
            }
        }
        def compiledStart:IR.Value?
        if start !== null {
            compiledStart := compileExpression(start, endpointContext)
            if compiledStart == null {
                return null
            }
        }
        else {
            compiledStart := null
        }
        def compiledEnd:IR.Value?
        if end !== null {
            compiledEnd := compileExpression(end, endpointContext)
            if compiledEnd == null {
                return null
            }
        }
        else {
            compiledEnd := null
        }
        if endpointType == null {
            if compiledStart !== null {
                if compiledEnd !== null {
                    endpointType := compiledStart.type().union(self, compiledEnd.type())
                    if endpointType.name = "frost.core.Value" {
                        error(position, "range endpoint type mismatch: '\{compiledStart}', " +
                                "'\{compiledEnd}'")
                    }
                }
                else {
                    endpointType := compiledStart.type().nullable()
                }
            }
            else if compiledEnd !== null {
                endpointType := compiledEnd.type().nullable()
            }
            else {
                endpointType := INT_TYPE.nullable()
            }
        }
        def cl := getClass(endpointType)
        if cl == null {
            return null
        }
        if !isValue(cl) {
            if compiledStart !== null {
                if compiledEnd !== null {
                    error(position, "range endpoints must be value types, but found " +
                            "'\{compiledStart.type()}', '\{compiledEnd.type()}'")
                }
                else {
                    error(position, "range endpoints must be value types, but found " +
                            "'\{compiledStart.type()}'")
                }
            }
            else {
                error(position, "range endpoints must be value types, but found " +
                        "'\{compiledEnd.type()}'")
            }
            return null
        }
        if compiledStart == null {
            if !endpointType.isNullable {
                error(position, "non-nullable range requires both endpoints to be specified")
                return null
            }
            compiledStart := IR.Value.NULL(endpointType)
        }
        if compiledEnd == null {
            if !endpointType.isNullable {
                error(position, "non-nullable range requires both endpoints to be specified")
                return null
            }
            compiledEnd := IR.Value.NULL(endpointType)
        }
        def basePos := position.asPosition
        if step !== null {
            if stepContext = TypeContext.NON_VOID & endpointType.isNumber {
                def p := possibleTypes(step)
                if p !== null {
                    for t in p {
                        if t = endpointType {
                            stepContext := TypeContext.TYPE(endpointType, false)
                            break
                        }
                    }
                }
            }
            def compiledStep := compileExpression(step, stepContext)
            if compiledStep == null {
                return null
            }
            def args := Array<ASTNode>()
            args.add(ASTNode.IR_WRAPPER(basePos, compiledStart))
            args.add(ASTNode.IR_WRAPPER(basePos, compiledEnd))
            args.add(ASTNode.IR_WRAPPER(step.position(), compiledStep))
            args.add(ASTNode.BIT(basePos, inclusive))
            return Call.compile(self, position, literalType(Type.SteppedRangeOf(self,
                    endpointType, compiledStep.type())), args, type)
        }
        else {
            def args := Array<ASTNode>()
            args.add(ASTNode.IR_WRAPPER(basePos, compiledStart))
            args.add(ASTNode.IR_WRAPPER(basePos, compiledEnd))
            args.add(ASTNode.BIT(basePos, inclusive))
            return Call.compile(self, position, literalType(Type.RangeOf(self, endpointType)),
                    args, type)
        }
    }

    method compileReal(position:MethodPosition, value:Real64, type:TypeContext):IR.Value? {
        match type {
            when TypeContext.TYPE(t, _) {
                if t.typeKind = Type.Kind.BUILTIN_FLOAT {
                    return IR.Value.REAL(value, t)
                }
                if t.isReal {
                    def args := Array<ASTNode>()
                    args.add(ASTNode.REAL(position.asPosition, value))
                    return Call.compile(self, position, literalType(t), args, type)
                }
            }
        }
        return coerce(position, compileReal(position, value,
                TypeContext.TYPE(REAL64_TYPE, false)), type)
    }

    method compileRegex(position:MethodPosition, text:String):IR.Value? {
        return Call.compile(self, position, literalType(REGULAR_EXPRESSION_TYPE),
                [ASTNode.STRING(position.asPosition, text)],
                TypeContext.UNSPECIFIED)
    }

    method compileSelf(position:MethodPosition, explicit:Bit):IR.Value? {
        if captures.count > 0 {
            for c in captures {
                c.second[SELF_NAME] := Capture.SELF
            }
            var cl := captures[0].first.owner
            while cl.annotations.isSynthetic {
                assert cl.owner !== null
                cl := cl.owner
            }
            return IR.Value.REF(IR.Statement.ID(-1), cl.type)
        }
        if explicit {
            def s := symbolTable[CAPTURED_SELF_NAME]
            if s !== null {
                def actualSelf := symbolTable[SELF_NAME]
                assert actualSelf !== null, "no 'self' in symboltable"
                return symbolRef(position, symbolRef(position, null, actualSelf), s)
            }
        }
        if currentMethod[0].annotations.isClass {
            error(position, "cannot reference 'self' from a @class context")
            return null
        }
        def s := symbolTable[SELF_NAME]
        assert s !== null, "no 'self' in symboltable at \{position}"
        return symbolRef(position, null, s)
    }

    method typeMatch(value:IR.Value?, type:TypeContext):Bit {
        if value == null {
            return true
        }
        match type {
            when TypeContext.UNSPECIFIED, TypeContext.NON_VOID {
                return true
            }
            when TypeContext.IMMUTABLE {
                return isImmutable(value.type())
            }
            when TypeContext.TYPE(t, _) {
                return value.type() = t
            }
            otherwise {
                unreachable
            }
        }
    }

    method genericMethodRef(raw:IR.Value, rawTypes:FixedArray<ASTNode>):IR.Value? {
        def resolvedTypes := Array<Type>()
        for t in rawTypes {
            def resolved := resolve(scanner.convertType(t))
            if resolved == null {
                return null
            }
            resolvedTypes.add(resolved)
        }
        match raw {
            when IR.Value.METHOD(target, m, _) {
                return IR.Value.GENERIC_METHOD(target, m, FixedArray<Type>.from(resolvedTypes))
            }
            when IR.Value.METHODS(target, m, _) {
                return IR.Value.GENERIC_METHODS(target, m, FixedArray<Type>.from(resolvedTypes))
            }
        }
        return raw
    }

    ================================================================================================
    Compiles an expression without fully resolving method references. That is,
    `compileMethodExpression` on `Console.printLine` returns an IR.Value.METHOD, whereas fully
    resolving this expression using `compileExpression` will result in an actual `ImmutableMethod`
    object constructor.
    ================================================================================================
    @post(typeMatch(@return, type) & (@return !== null | errorCount > 0 | !reportErrors))
    method compileMethodExpression(expr:ASTNode, type:TypeContext):IR.Value? {
        def position := MethodPosition(expr.position(), currentMethodIndex)
        match expr {
            when ASTNode.ARRAY(_, elements) {
                return ArrayLiteral.compile(self, position, elements, type)
            }
            when ASTNode.AT_PRE(_, expr) {
                return AtPre.compile(self, position, expr, type)
            }
            when ASTNode.AT_RETURN {
                return AtReturn.compile(self, position, type)
            }
            when ASTNode.BINARY(_, left, op, right) {
                return Binary.compile(self, position, left, op, right, type)
            }
            when ASTNode.BIT(_, value) {
                match type {
                    when TypeContext.TYPE(t, _) {
                        if t = BUILTIN_BIT_TYPE {
                            return IR.Value.BIT(value, BUILTIN_BIT_TYPE)
                        }
                    }
                }
                return coerce(position,
                        coerce(position, IR.Value.BIT(value, BUILTIN_BIT_TYPE), BIT_TYPE),
                        type)
            }
            when ASTNode.CALL(_, m, args) {
                return Call.compile(self, position, m, args, false, type)
            }
            when ASTNode.DOT(_, base, name) {
                def t := tryResolveType(expr)
                if t !== null {
                    return coerce(position, literalType(t), type)
                }
                return coerce(position, Dot.compile(self, position, base, name), type)
            }
            when ASTNode.DOT_GENERICS(_, base, name, types) {
                def t := tryResolveType(expr)
                if t !== null {
                    return coerce(position, literalType(t), type)
                }
                def dot := Dot.compile(self, position, base, name)
                if dot == null {
                    return null
                }
                return coerce(position, genericMethodRef(dot, types), type)
            }
            when ASTNode.IDENTIFIER(_, name) {
                return coerce(position, Identifier.compile(self, position, name), type)
            }
            when ASTNode.IDENTIFIER_GENERICS(_, name, types) {
                def identifier := Identifier.compile(self, position, name)
                if identifier == null {
                    return null
                }
                return coerce(position, genericMethodRef(identifier, types), type)
            }
            when ASTNode.INT(_, value) {
                return IntLiteral.compile(self, position, value, type)
            }
            when ASTNode.IR_WRAPPER(_, value) {
                return coerce(position, value, type)
            }
            when ASTNode.METHOD(_, _, _, kind, _, _, parameters, returnType, body) {
                return Closure.compile(self, position, kind, parameters, returnType, body, type)
            }
            when ASTNode.NULL(_) {
                return compileNull(position, type)
            }
            when ASTNode.UNARY(_, op, operand) {
                return Unary.compile(self, position, op, operand, type)
            }
            when ASTNode.RANGE(_, start, inclusive, end, step) {
                return compileRange(position, start, inclusive, end, step, type)
            }
            when ASTNode.REAL(_, value) {
                return compileReal(position, value, type)
            }
            when ASTNode.REGEX(_, text) {
                return compileRegex(position, text)
            }
            when ASTNode.SELF(_) {
                return coerce(position, compileSelf(position, true), type)
            }
            when ASTNode.SUPER(_) {
                error(position, "'super' may not appear in this context")
                return null
            }
            when ASTNode.STRING(_, text) {
                match type {
                    when TypeContext.TYPE(t, _) {
                        def basePos := position.asPosition
                        if text.length = 1 {
                            if t.isChar {
                                return compileExpression(ASTNode.CALL(basePos,
                                        ASTNode.IR_WRAPPER(basePos, literalType(t)),
                                        FixedArray<ASTNode>.from([ASTNode.INT(basePos,
                                            text[0].asUInt64)])))
                            }
                            if t = VALUE_TYPE {
                                return coerce(position, compileExpression(ASTNode.CALL(basePos,
                                        ASTNode.IR_WRAPPER(basePos, literalType(CHAR32_TYPE)),
                                        FixedArray<ASTNode>.from([ASTNode.INT(basePos,
                                            text[0].asUInt64)]))), t)
                            }
                        }
                    }
                }
                return coerce(position, IR.Value.STRING(text, STRING_TYPE), type)
            }
            when ASTNode.TUPLE(_, args) {
                return Tuple.compile(self, position, args, type)
            }
            when ASTNode.TYPE, ASTNode.GENERIC_TYPE {
                def type := resolve(scanner.convertType(expr))
                if type == null {
                    return null
                }
                return literalType(type)
            }
            when ASTNode.TYPED_LAMBDA(_, parameters, body) {
                return Closure.compileTypedLambda(self, position, parameters, body, type)
            }
            when ASTNode.UNTYPED_LAMBDA(_, parameters, body) {
                return Closure.compileUntypedLambda(self, position, parameters, body, type)
            }
            otherwise {
                unreachable
            }
        }
    }

    @post(typeMatch(@return, type) & (@return !== null | errorCount > 0 | !reportErrors))
    method compileExpression(expr:ASTNode, type:TypeContext):IR.Value? {
        def unresolved := compileMethodExpression(expr, type)
        if unresolved == null {
            return null
        }
        def position := MethodPosition(expr.position(), currentMethodIndex)
        match unresolved {
            when IR.Value.METHOD(target, m, _) {
                return coerce(position, createMethodObject(position, target, m), type)
            }
            when IR.Value.METHODS(target, methods, _) {
                match type {
                    when TypeContext.TYPE(t, _) {
                        if !t.nonnullable().isMethod {
                            error(position, "ambiguous method reference")
                        }
                        def best := Array<MethodDecl>()
                        var bestCost := Int.MAX
                        for m in methods {
                            if resolve(m) {
                                def cost := coercionCost(m.type(self), t)
                                if cost !== null {
                                    if cost.second < bestCost {
                                        bestCost := cost.second
                                        best.clear()
                                    }
                                    if cost.second = bestCost {
                                        best.add(m)
                                    }
                                }
                            }
                        }
                        if best.count = 1 {
                            return compileExpression(ASTNode.IR_WRAPPER(position.asPosition,
                                    IR.Value.METHOD(target, best[0], best[0].type(self))), type)
                        }
                        if best.count = 0 {
                            error(position, "no method '\{methods[0].name}' matching " +
                                    "expected type '\{t}'")
                            return null
                        }
                    }
                }
                def msg := MutableString("ambiguous reference to method '\{methods[0].name}'. " +
                        "The following methods are equally good matches:")
                for m in methods.sort((a, b) => a.position > b.position) {
                    msg.append("\n    \{m.declaration} (\{m.owner.source.name}:\{m.position})")
                }
                error(position, msg.finish())
                return null
            }
            otherwise {
                return unresolved
            }
        }
    }

    method compileExpression(expr:ASTNode):IR.Value? {
        return compileExpression(expr, TypeContext.UNSPECIFIED)
    }

    ================================================================================================
    Logically equivalent to evaluating test and then compiling `branch test, ifTrue, ifFalse`, but
    handles AND and OR expressions in fashion which is both simpler and more amenable to analysis.
    ================================================================================================
    method compileConditionalBranch(test:ASTNode, ifTrue:IR.Block.ID, ifFalse:IR.Block.ID) {
        match test {
            when ASTNode.BINARY(position, left, op, right) {
                if coercionCost(left, BIT_TYPE) !== null {
                    match op {
                        when Binary.Operator.AND {
                            And.compileConditionalBranch(self, left, right, ifTrue, ifFalse)
                            return
                        }
                        when Binary.Operator.OR {
                            Or.compileConditionalBranch(self, left, right, ifTrue, ifFalse)
                            return
                        }
                    }
                }
            }
        }
        def position := MethodPosition(test.position(), currentMethodIndex)
        def testBit:IR.Value
        {
            def unrefs := AutoUnrefs(self)
            def compiledTest := compileExpression(test, TypeContext.TYPE(BIT_TYPE, false))
            if compiledTest == null {
                return
            }
            testBit := extractBuiltinBit(position, compiledTest)
        }
        ir.add(IR.Statement.CONDITIONAL_BRANCH(position, testBit, ifTrue, ifFalse))
    }

    @pre(owner.name = context.name & owner.parameters.count = context.parameters.count)
    method compileConditionalBranchInContext(expr:ASTNode, ifTrue:IR.Block.ID, ifFalse:IR.Block.ID,
            owner:MethodDecl, context:MethodDecl) {
        def symbols := AutoScope(self)
        for i in 0 .. owner.parameters.count {
            symbolTable.add(symbols.oldSymbolTable[context.parameters[i].name],
                    owner.parameters[i].name)
        }
        compileConditionalBranch(expr, ifTrue, ifFalse)
    }

    method findAndLeaveToLoopScope(position:Position, label:String?):EnclosingContext? {
        for c in enclosingContexts {
            match c {
                when EnclosingContext.LOOP(loopLabel, _, _) {
                    if label == null | loopLabel !== null & label = loopLabel {
                        return c
                    }
                }
            }
            leaveScope(c)
        }
        if label == null {
            error(position, "not in a loop")
        }
        else {
            error(position, "not in a loop labeled '\{label}'")
        }
        return null
    }

    function getTryScope():Pair<IR.Block.ID?, Variable?>? {
        for c in enclosingContexts {
            match c {
                when EnclosingContext.TRY_SCOPE(failBlock, errorVar) {
                    return Pair<IR.Block.ID?, Variable?>(failBlock, errorVar)
                }
                when EnclosingContext.INLINE_CONTEXT {
                    return null
                }
            }
        }
        return null
    }

    method leaveTryScope() {
        for c in enclosingContexts {
            match c {
                when EnclosingContext.TRY_SCOPE {
                    return
                }
            }
            leaveScope(c)
        }
        unreachable
    }

    @pre(bit.type() = BIT_TYPE)
    method extractBuiltinBit(position:MethodPosition, bit:IR.Value):IR.Value {
        def result := ir.add(IR.Statement.EXTRACT_FIELD(position, bit,
                getSymbolTable(getClass(BIT_TYPE))["value"]->FieldDecl))
        return IR.Value.REF(result, BUILTIN_BIT_TYPE)
    }

    method extractBuiltinInt(position:MethodPosition, int:IR.Value):IR.Value {
        def cl := getClass(int.type())
        assert cl !== null
        def field := getSymbolTable(cl)["value"]->FieldDecl?
        assert field !== null, "no 'value' field in \{int}:\{int.type()}"
        resolve(field)
        def result := ir.add(IR.Statement.EXTRACT_FIELD(position, int, field))
        return IR.Value.REF(result, field.type)
    }

    method compileTarget(t:ASTNode, kind:Variable.Kind,
            rawValue:ASTNode?, valueType:Type?):Target? {
        match t {
            when ASTNode.IDENTIFIER(basePos, name) {
                -- no type, infer from value
                def position := MethodPosition(basePos, currentMethodIndex)
                def value:IR.Value?
                def type:Type
                if rawValue !== null {
                    var preferred := preferredType(rawValue)
                    if preferred == null {
                        value := compileExpression(rawValue, TypeContext.NON_VOID)
                        if value == null {
                            return null
                        }
                        preferred := value.type()
                    }
                    else {
                        value := compileExpression(rawValue, TypeContext.TYPE(preferred, false))
                    }
                    if value == null {
                        return null
                    }
                    type := value.type()
                }
                else if valueType !== null {
                    type := valueType
                }
                else {
                    error(position, "declaration has neither a type nor a value")
                    return null
                }
                def v := Variable(basePos, kind, name, type,
                        Variable.Storage.LOCAL(ir.locals.count))
                v.owner := currentMethod[0]
                if isRefCounted(v.type) {
                    ir.add(IR.Statement.STORE(position, IR.Value.NULL(v.type.nullable()),
                            IR.Value.LOCAL(ir.locals.count, v.type)))
                }
                ir.locals.add(v.type)
                symbolTable.add(v)
                return Target.VARIABLE(v, value)
            }
            when ASTNode.TUPLE_TARGET(_, targets) {
                def finalType:Type? := null
                def compiledTuple:IR.Value?
                if rawValue !== null {
                    compiledTuple := compileExpression(rawValue, TypeContext.NON_VOID)
                    finalType := compiledTuple.type()
                }
                else if valueType !== null {
                    finalType := valueType
                }
                if finalType !== null & finalType.nonnullable().typeKind = Type.Kind.TUPLE {
                    def result := Array<Target>()
                    def valueTypes := finalType.nonnullable().subtypes
                    if valueTypes.count != targets.count {
                        error(t.position(), "cannot assign \{targets.count}-element tuple to " +
                                "\{valueTypes.count}-element target")
                        return null
                    }
                    for i in 0 .. targets.count {
                        def target:Target?
                        if compiledTuple !== null {
                            def basePos := rawValue.position()
                            def position := MethodPosition(basePos, currentMethodIndex)
                            def field := ASTNode.IR_WRAPPER(basePos, cast(position, 
                                    Dot.compile(self, position, compiledTuple, "f\{i}"),
                                    compiledTuple.type().subtypes[i]))
                            assert field !== null
                            target := compileTarget(targets[i], kind, field, null)
                        }
                        else {
                            target := compileTarget(targets[i], kind, null, valueType.subtypes[i])
                        }
                        if target == null {
                            return null
                        }
                        result.add(target)
                    }
                    return Target.TUPLE(FixedArray<Target>.from(result))
                }
                error(t.position(), "cannot use a tuple target without a tuple value")
                return null
            }
            when ASTNode.TYPED_IDENTIFIER(basePos, name, rawType) {
                def position := MethodPosition(basePos, currentMethodIndex)
                def type := resolve(scanner.convertType(rawType))
                if type == null {
                    return null
                }
                def value:IR.Value?
                if rawValue !== null {
                    value := compileExpression(rawValue, TypeContext.TYPE(type, false))
                    if value == null {
                        return null
                    }
                }
                else {
                    value := null
                }
                def v := Variable(basePos, kind, name, type,
                        Variable.Storage.LOCAL(ir.locals.count))
                v.owner := currentMethod[0]
                if isRefCounted(v.type) {
                    ir.add(IR.Statement.STORE(position, IR.Value.NULL(v.type.nullable()),
                            IR.Value.LOCAL(ir.locals.count, v.type)))
                }
                ir.locals.add(v.type)
                symbolTable.add(v)
                return Target.VARIABLE(v, value)
            }
            otherwise {
                error(t.position(), "not a valid assignment target")
                return null
            }
        }
    }

    method createScopes(target:Target) {
        match target {
            when Target.VARIABLE(v, _) {
                if isRefCounted(v.type) {
                    enclosingContexts.push(EnclosingContext.VARIABLE_SCOPE(v))
                }
            }
            when Target.TUPLE(targets) {
                targets.apply(self.createScopes)
            }
            otherwise {
                assert false
            }
        }
    }

    method initializeTarget(target:Target) {
        match target {
            when Target.VARIABLE(v, value) {
                if value !== null {
                    VariableLValue(self, MethodPosition(v.position, currentMethodIndex),
                            v).compileStore(value)
                }
            }
            when Target.TUPLE(targets) {
                targets.apply(self.initializeTarget)
            }
            otherwise {
                assert false
            }
        }
    }

    method compileStore(position:MethodPosition, target:Target, value:IR.Value) {
        match target {
            when Target.VARIABLE(v, _) {
                VariableLValue(self, position, v).compileStore(value)
            }
            when Target.TUPLE(targets) {
                def type := value.type().nonnullable()
                if type.typeKind = Type.Kind.TUPLE & type.subtypes.count = targets.count {
                    for i in 0 .. targets.count {
                        compileStore(position, targets[i], cast(position, Dot.compile(self,
                                position, value, "f\{i}"), type.subtypes[i]))
                    }
                }
                else {
                    error(position, "cannot store '\{value.type()}' into a tuple with " +
                            "\{targets.count} elements")
                }
            }
            otherwise {
                assert false
            }
        }
    }

    method compileDeclaration(position:MethodPosition, target:ASTNode, value:ASTNode?,
            varKind:Variable.Kind) {
        def compiledTarget:Target?
        {
            def unrefs := AutoUnrefs(self)
            compiledTarget := compileTarget(target, varKind, value, null)
            if compiledTarget == null {
                return
            }
            initializeTarget(compiledTarget)
        }
        createScopes(compiledTarget)
    }

    method leaveScope(c:EnclosingContext) {
        if ir.currentBlockFinished {
            -- we've already left the scope by other means; cleanup will have happened there
            return
        }
        match c {
            when EnclosingContext.VARIABLE_SCOPE(v) {
                def ref := symbolRef(MethodPosition(v.position, currentMethodIndex), null, v)
                assert ref !== null
                compileUnref(ref)
                match v.storage {
                    when Variable.Storage.LOCAL(slot) {
                        ir.add(IR.Statement.STORE(MethodPosition(v.position, currentMethodIndex),
                                IR.Value.NULL(v.type.nullable()),
                                IR.Value.LOCAL(slot, v.type.nullable())))
                    }
                    otherwise {
                        unreachable
                    }
                }
            }
            when EnclosingContext.VALUE_SCOPE(v) {
                compileUnref(v)
            }
        }
    }

    method leaveAllScopes() {
        for c in enclosingContexts {
            match c {
                when EnclosingContext.INLINE_CONTEXT {
                    return
                }
            }
            leaveScope(c)
        }
    }

    @post(symbolTable == @pre(symbolTable))
    method compileStatement(s:ASTNode) {
        if ir.currentBlockFinished {
            error(s.position(), "unreachable")
            return
        }
        match s {
            when ASTNode.UNREACHABLE {
            }
            otherwise {
                ir.currentBlock.containsExplicitCode := true
            }
        }
        def position := MethodPosition(s.position(), currentMethodIndex)
        if position.file >= 0 {
            ir.add(IR.Statement.COMMENT(position, "\{files[position.file].name}:\{position.line}"))
        }
        else {
            ir.add(IR.Statement.COMMENT(position, "<no location>"))
        }
        def unrefs := AutoUnrefs(self)
        match s {
            when ASTNode.ASSERT(_, test, msg) {
                Assert.compile(self, position, test, msg)
            }
            when ASTNode.BINARY(_, left, op, right) {
                Assignment.compile(self, position, left, op, right)
            }
            when ASTNode.BLOCK(_, statements) {
                def symbols := AutoScope(self)
                for stmt in statements {
                    def finished := ir.currentBlockFinished
                    compileStatement(stmt)
                    if finished {
                        assert errorCount > 0
                        break
                    }
                }
            }
            when ASTNode.BREAK(_, label) {
                Break.compile(self, position, label)
            }
            when ASTNode.CALL(_, m, args) {
                Call.compile(self, position, m, args, true, TypeContext.UNSPECIFIED)
            }
            when ASTNode.CONTINUE(_, label) {
                Continue.compile(self, position, label)
            }
            when ASTNode.DO(_, label, statements, test) {
                Do.compile(self, position, label, statements, test)
            }
            when ASTNode.FOR(_, label, target, list, statements) {
                For.compile(self, position, label, target, list, statements)
            }
            when ASTNode.IDENTIFIER(_, _) {
                error(position, "expected a statement")
            }
            when ASTNode.IF(_, test, ifTrue, ifFalse) {
                If.compile(self, position, test, ifTrue, ifFalse)
            }
            when ASTNode.LOOP(_, label, statements) {
                Loop.compile(self, position, label, statements)
            }
            when ASTNode.MATCH(_, value, whens, other) {
                Match.compile(self, position, value, whens, other)
            }
            when ASTNode.METHOD(_, _, _, kind, name, _, parameters, returnType, body) {
                InnerMethod.compile(self, position, kind, name, parameters, returnType, body)
            }
            when ASTNode.RETURN(_, value) {
                Return.compile(self, position, value)
            }
            when ASTNode.UNREACHABLE(_, message) {
                Assert.compileFail(self, position, message)
            }
            when ASTNode.TRY(_, block, error, failBlock) {
                Try.compile(self, position, block, error, failBlock)
            }
            when ASTNode.VAR(_, kind, decls) {
                Var.compile(self, position, kind, decls)
            }
            when ASTNode.WHILE(_, label, test, statements) {
                While.compile(self, position, label, test, statements)
            }
            otherwise {
                error(position, "not a statement")
            }
        }
    }

    method hasSelfParam(m:MethodDecl):Bit {
        if m.annotations.isClass {
            return false
        }
        if m.methodKind != MethodDecl.Kind.INIT {
            return true
        }
        return !isValue(m.owner)
    }

    function callsSelfInit(body:FixedArray<ASTNode>):Bit {
        if body.count = 0 {
            return false
        }
        for s in body {
            match s {
                when ASTNode.CALL(_, target, _) {
                    match target {
                        when ASTNode.IDENTIFIER(_, text) {
                            if text = "init" {
                                return true
                            }
                        }
                        when ASTNode.DOT(_, base, text) {
                            if text = "init" {
                                match base {
                                    when ASTNode.SELF {
                                        return true
                                    }
                                }
                            }
                        }
                    }
                }
            }
        }
        return false
    }

    function callsSuperInit(body:FixedArray<ASTNode>):Bit {
        if body.count = 0 {
            return false
        }
        for s in body {
            match s {
                when ASTNode.CALL(_, target, _) {
                    match target {
                        when ASTNode.DOT(_, base, text) {
                            if text = "init" {
                                match base {
                                    when ASTNode.SUPER {
                                        return true
                                    }
                                }
                            }
                        }
                    }
                }
            }
        }
        return false

    }

    ================================================================================================
    Compiles an expression (which was found attached to `owner`) for use within `context`. The
    expression may reference parameters of `owner`, and these references will be interpreted as if
    they refer to the corresponding parameters of `context`. For instance, if we have two methods:

        @pre(param.count() > 0)
        method check(param:Array<Object>)

    and:

        @override
        method check(arr:Array<Object>)

    where the second method overrides the first, we need to attach the precondition expression to
    both methods. Since the second `check` method does not have a parameter named `param`, we need
    to use `compileExpressionInContext` to be able to compile the expression correctly.
    ================================================================================================
    @pre(owner.name = context.name & owner.parameters.count = context.parameters.count)
    method compileExpressionInContext(expr:ASTNode, type:TypeContext, owner:MethodDecl,
            context:MethodDecl):IR.Value? {
        def symbols := AutoScope(self)
        for i in 0 .. owner.parameters.count {
            symbolTable.add(symbols.oldSymbolTable[context.parameters[i].name],
                    owner.parameters[i].name)
        }
        return compileExpression(expr, type)
    }

    method compilePreconditions() {
        def m := currentMethod[0]
        var start:IR.Block.ID? := null
        var failBlock:IR.Block.ID? := null
        var current := m
        loop {
            var havePre := false
            if current.annotations.expressions !== null {
                for ann in current.annotations.expressions {
                    match ann {
                        when Annotations.Expression.PRE(_, expr) {
                            if current == m {
                                if m.overridden !== null {
                                    error(expr.position(), "cannot use '@pre' in a method which " +
                                            "overrides another method; did you mean '@preOr'?")
                                }
                                if havePre {
                                    error(expr.position(), "found more than one precondition")
                                }
                            }
                            havePre := true
                            if start == null {
                                start := ir.newBlock("@pre success")
                            }
                            failBlock := ir.newBlock("@pre fail")
                            compileConditionalBranchInContext(expr, start, failBlock, current, m)
                            ir.setCurrentBlock(failBlock)
                        }
                        when Annotations.Expression.PRE_OR(_, expr) {
                            if current == m {
                                if m.overridden == null {
                                    error(expr.position(), "cannot use '@preOr' in a method " +
                                            "which does not override another method; did you " +
                                            "mean '@pre'?")
                                }
                                if havePre {
                                    error(expr.position(), "found more than one precondition")
                                }
                            }
                            havePre := true
                            if start == null {
                                start := ir.newBlock("@preOr success")
                            }
                            failBlock := ir.newBlock("@preOr fail")
                            compileConditionalBranchInContext(expr, start, failBlock, current, m)
                            ir.setCurrentBlock(failBlock)
                        }
                    }
                }
            }
            if current.overridden == null {
                break
            }
            current := current.overridden
        }
        if failBlock !== null {
            Assert.compileFail(self, MethodPosition(m.position, m.index),
                    ASTNode.STRING(m.position, "precondition failure for \{m.declaration}"))
            assert start !== null
            ir.setCurrentBlock(start)
        }
    }

    method compilePostcondition(compiling:MethodDecl, postconditionOwner:MethodDecl,
            expr:ASTNode, successFail:Array<IR.Block.ID?>) {
        if postconditionEntryBlock == null {
            postconditionEntryBlock := ir.newBlock("postcondition entry")
            postconditionCurrentBlock := postconditionEntryBlock
        }
        if returnVar == null & compiling.returnType != VOID_TYPE  {
            returnVar := Variable(compiling.position, Variable.Kind.DEF, "$return",
                    compiling.returnType, Variable.Storage.LOCAL(ir.locals.count))
            ir.locals.add(returnVar.type)
        }
        ir.setCurrentBlock(postconditionCurrentBlock)
        def value := compileExpressionInContext(expr,
                TypeContext.TYPE(BIT_TYPE, false), postconditionOwner, compiling)
        if value == null {
            return
        }
        successFail[0] := ir.newBlock("postcondition success")
        if successFail[1] == null {
            successFail[1] := ir.newBlock("postcondition fail")
            def old := ir.currentBlock.id
            ir.setCurrentBlock(successFail[1])
            Assert.compileFail(self, MethodPosition(compiling.position, currentMethodIndex),
                    ASTNode.STRING(compiling.position,
                        "postcondition failure for \{compiling.declaration}"))
            ir.setCurrentBlock(old)
        }
        def position := MethodPosition(compiling.position, currentMethodIndex)
        ir.add(IR.Statement.CONDITIONAL_BRANCH(position, extractBuiltinBit(position, value),
                successFail[0], successFail[1]))
        ir.setCurrentBlock(successFail[0])
        postconditionCurrentBlock := ir.currentBlock.id
    }

    @post(!ir.currentBlockFinished)
    method compilePostconditions() {
        def m := currentMethod[0]
        atPreBlock := ir.currentBlock.id
        def successFail:Array<IR.Block.ID?> := [null, null]
        var current := m
        var havePost := false
        loop {
            if current.annotations.expressions !== null {
                for ann in current.annotations.expressions {
                    match ann {
                        when Annotations.Expression.POST(_, expr) {
                            if current == m {
                                if m.overridden !== null {
                                    error(expr.position(), "cannot use '@post' in a method which " +
                                            "overrides another method; did you mean '@postAnd'?")
                                }
                                if havePost {
                                    error(expr.position(), "found more than one postcondition")
                                }
                            }
                            havePost := true
                            compilePostcondition(m, current, expr, successFail)
                        }
                        when Annotations.Expression.POST_AND(_, expr) {
                            assert !ir.currentBlockFinished
                            if current == m {
                                if m.overridden == null {
                                    error(expr.position(), "cannot use '@postAnd' in a method " +
                                            "which does not override another method; did you " +
                                            "mean '@post'?")
                                }
                                if havePost {
                                    error(expr.position(), "found more than one postcondition")
                                }
                            }
                            havePost := true
                            compilePostcondition(m, current, expr, successFail)
                        }
                    }
                }
            }
            if current.overridden == null {
                break
            }
            current := current.overridden
        }
        if havePost {
            def position := MethodPosition(m.position, m.index)
            def returnValue:IR.Value? := null
            if returnVar !== null {
                def returnSlot:Int
                match returnVar.storage {
                    when Variable.Storage.LOCAL(slot) {
                        returnSlot := slot
                    }
                }
                returnValue := IR.Value.REF(ir.add(IR.Statement.LOAD(position,
                        IR.Value.LOCAL(returnSlot, returnVar.type))),
                        returnVar.type)
            }
            def oldReturnVar := returnVar
            returnVar := null
            def oldPostconditionEntryBlock := postconditionEntryBlock
            postconditionEntryBlock := null
            if returnValue !== null {
                Return.compile(self, position, ASTNode.IR_WRAPPER(m.position, returnValue), false)
            }
            else {
                Return.compile(self, position, null)
            }
            returnVar := oldReturnVar
            postconditionEntryBlock := oldPostconditionEntryBlock
            ir.setCurrentBlock(atPreBlock)
        }
        atPreBlock := null
    }

    -- to avoid calling super.init for a few common classes we know for sure will never do anything
    -- interesting in their init methods. This is especially important for Value classes, which
    -- would have to be wrapped in order to perform super.init calls.
    function hasTrivialInit(cl:ClassDecl?):Bit {
        -- FIXME should be able to roll this into match below
        if cl == null {
            return true
        }
        match cl.name {
            when "frost.core.Object", "frost.core.Immutable", "frost.core.Value" {
                return true
            }
            otherwise {
                return false
            }
        }
    }

    method compile(m:MethodDecl) {
        compile(m, null)
    }

    function hasPostconditions(m:MethodDecl):Bit {
        if m.annotations.expressions !== null {
            for ann in m.annotations.expressions {
                match ann {
                    when Annotations.Expression.POST, Annotations.Expression.POST_AND {
                        return true
                    }
                }
            }
        }
        return false
    }

    method optimize(ir:IR, analysis:Analyzer) {
        if settings.safetyLevel < 2 {
            RemoveAsserts().process(ir, analysis)
        }
        if settings.optimizationLevel > 0 {
            var changed:Bit
            do {
                changed := false
                changed |= RemoveUnreachableBlocks().process(ir, analysis)
                changed |= MergeBlocks().process(ir, analysis)
                changed |= RemoveRefUnrefPairs().process(ir, analysis)
            }
            while changed
        }
    }

    function getInlineContext():EnclosingContext? {
        for c in enclosingContexts {
            match c {
                when EnclosingContext.INLINE_CONTEXT {
                    return c
                }
            }
        }
        return null
    }

    method compile(m:MethodDecl, enclosingContext:SymbolTable?) {
        if !resolve(m) {
            return
        }
        expressionCoercionCosts.clear()
        binaryTypes.clear()
        currentMethod.push(m)
        if m.owner.classKind = ClassDecl.Kind.CHOICE & m.name = "cleanup" {
            createChoiceCleanup(m)
        }
        if m.body !== null {
            def oldAtPreBlock := atPreBlock
            def oldPostconditionEntryBlock := postconditionEntryBlock
            def oldPostconditionCurrentBlock := postconditionCurrentBlock
            def oldIR := ir
            if getInlineContext() == null {
                ir := IR()
            }
            atPreBlock := ir.currentBlock.id
            postconditionEntryBlock := null
            postconditionCurrentBlock := null
            returnVar := null
            {
                def auto := AutoScope(self)
                methodSymbolTable := symbolTable
                if enclosingContext !== null {
                    symbolTable.parents.add(enclosingContext)
                }
                if m.genericParameters !== null {
                    m.genericParameters.apply(symbolTable.add)
                }
                if m.name = "main" {
                    if m.methodKind != MethodDecl.Kind.METHOD {
                        error(m.position, "'main' must be a method")
                    }
                    if m.returnType != VOID_TYPE {
                        error(m.position, "'main' must not have a return type")
                    }
                    if !m.annotations.isClass {
                        error(m.position, "'main' must be declared @class")
                    }
                    def required := "frost.collections.ListView<frost.core.String>"
                    if m.parameters.count > 1 |
                            (m.parameters.count = 1 & m.parameters[0].type.name != required) {
                        error(m.position, "'main' must have either zero parameters or one " +
                                "parameter of type '\{required}'")
                    }
                }
                var index := 0
                if hasSelfParam(m) {
                    def selfParam := Variable(m.position, Variable.Kind.DEF, SELF_NAME,
                            m.owner.typeWithParameters(), Variable.Storage.PARAMETER(index))
                    index += 1
                    selfParam.owner := m
                    symbolTable.add(selfParam)
                }
                else if !m.annotations.isClass {
                    def selfVar := Variable(m.position, Variable.Kind.DEF, SELF_NAME,
                            m.owner.typeWithParameters(), Variable.Storage.LOCAL(ir.locals.count))
                    selfVar.owner := m
                    ir.locals.add(selfVar.type)
                    symbolTable.add(selfVar)
                }
                if m.methodKind = MethodDecl.Kind.INIT {
                    if !callsSelfInit(m.body) {
                        -- initialize instance fields
                        def unrefs := AutoUnrefs(self)
                        for f in m.owner.fields {
                            if f.rawValue !== null & !f.annotations.isClass {
                                def p := f.rawValue.position()
                                compileStatement(ASTNode.BINARY(p,
                                        ASTNode.DOT(p, ASTNode.SELF(p), f.name),
                                        Binary.Operator.ASSIGNMENT, f.rawValue))
                            }
                        }
                        if !callsSuperInit(m.body) & m.owner.rawSuper !== null &
                                !hasTrivialInit(getClass(m.owner.rawSuper)) {
                            def p := m.position
                            compileStatement(ASTNode.CALL(p, ASTNode.DOT(p, ASTNode.SUPER(p),
                                    "init"), FixedArray<ASTNode>() -* FIXME literal *-))
                        }
                    }
                }
                for p in m.parameters {
                    def v := Variable(m.position, Variable.Kind.DEF, p.name, p.type,
                            Variable.Storage.PARAMETER(index))
                    v.owner := m
                    symbolTable.add(v)
                    index += 1
                }
                if m.annotations.isPointerSize {
                    def v := Variable(m.position, Variable.Kind.DEF, "pointerSize",
                            BUILTIN_INT_TYPE, Variable.Storage.PARAMETER(index))
                    v.owner := m
                    symbolTable.add(v)
                    index += 1
                }
                if settings.safetyLevel >= 3 {
                    compilePreconditions()
                    compilePostconditions()
                }
                for s in m.body {
                    compileStatement(s)
                }
                if !ir.currentBlockFinished {
                    def position := MethodPosition(m.position, m.index)
                    if m.returnType = VOID_TYPE | m.methodKind = MethodDecl.Kind.INIT {
                        Return.compile(self, position, null)
                    }
                    else if getInlineContext() == null {
                        def endBlock := ir.newBlock("end")
                        ir.add(IR.Statement.BRANCH(position, endBlock))
                        ir.setCurrentBlock(endBlock)
                        ir.add(IR.Statement.END)
                    }
                }
            }
            if writeCode & errorCount = 0 {
                def analyzer := Analyzer(self, m, ir)
                analyzer.analyze()
                optimize(ir, analyzer)
                backend.writeMethod(m, cg.getSignature(m), cg.convert(m, ir),
                        m.owner.isSpecialization())
            }
            ir := oldIR
        }
        else {
            backend.writeSignature(cg.getSignature(m))
        }
        currentMethod.pop()
    }

    method markNonExternal(cl:ClassDecl) {
        cl.external := false
        for inner in cl.classes {
            markNonExternal(inner)
        }
    }

    method checkImmutable(cl:ClassDecl) {
        if !cl.annotations.isUnsafeImmutable & isImmutable(cl) {
            for f in cl.fields {
                resolve(f)
                if f.fieldKind = FieldDecl.Kind.VAR {
                    error(f.position, "immutable class '\{cl.name}' cannot contain a 'var'")
                }
                else if !isImmutable(f.type) & f.fieldKind != FieldDecl.Kind.PROPERTY {
                    error(f.position, "immutable class '\{cl.name}' cannot contain mutable field " +
                            "'\{f.name}' of type '\{f.type}'")
                }
            }
        }
    }

    method checkValue(cl:ClassDecl) {
        if false & isValue(cl) {
            for f in cl.fields {
                resolve(f)
                if f.type.isClass {
                    if !isValue(getClass(f.type)) {
                        error(f.position, "value class '\{cl.name}' cannot contain non-value " +
                                "field '\{f.name}' of type '\{f.type}'")
                    }
                }
            }
        }
    }

    method checkAnnotations(cl:ClassDecl) {
        method disallow(flag:Int, name:String) {
            if cl.annotations.flags && flag != 0 {
                self.error(cl.position, "classes may not be annotated with '\{name}'")
            }
        }
        disallow(Annotations.Flag.PROTECTED, "@protected")
        disallow(Annotations.Flag.CLASS,     "@class")
        disallow(Annotations.Flag.OVERRIDE,  "@override")
        disallow(Annotations.Flag.EXTERNAL,  "@external")
        disallow(Annotations.Flag.IMPLICIT,  "@implicit")
        disallow(Annotations.Flag.INLINE,    "@inline")
        disallow(Annotations.Flag.WEAK,      "@weak")
        disallow(Annotations.Flag.DEFAULT,   "@default")
        disallow(Annotations.Flag.NO_RETURN, "@noReturn")
        if cl.annotations.expressions !== null {
            for expr in cl.annotations.expressions {
                match expr {
                    when Annotations.Expression.PRE {
                        error(cl.position, "classes may not be annotated with '@pre'")
                    }
                    when Annotations.Expression.POST {
                        error(cl.position, "classes may not be annotated with '@post'")
                    }
                    when Annotations.Expression.PRE_OR {
                        error(cl.position, "classes may not be annotated with '@preOr'")
                    }
                    when Annotations.Expression.POST_AND {
                        error(cl.position, "classes may not be annotated with '@postAnd'")
                    }
                }
            }
        }
        checkAccessModifierCount(cl.position, cl.annotations)
    }

    method checkAnnotations(f:FieldDecl) {
        method disallow(flag:Int, name:String) {
            if f.annotations.flags && flag != 0 {
                self.error(f.position, "fields may not be annotated with '\{name}'")
            }
        }
        disallow(Annotations.Flag.OVERRIDE,         "@override")
        disallow(Annotations.Flag.EXTERNAL,         "@external")
        disallow(Annotations.Flag.IMPLICIT,         "@implicit")
        disallow(Annotations.Flag.ABSTRACT,         "@abstract")
        disallow(Annotations.Flag.INLINE,           "@inline")
        disallow(Annotations.Flag.SPECIALIZE,       "@specialize")
        disallow(Annotations.Flag.UNSAFE_IMMUTABLE, "@unsafeImmutable")
        disallow(Annotations.Flag.DEFAULT,          "@default")
        disallow(Annotations.Flag.NO_RETURN, "@noReturn")
        if f.annotations.expressions !== null {
            for expr in f.annotations.expressions {
                match expr {
                    when Annotations.Expression.PRE {
                        error(f.position, "fields may not be annotated with '@pre'")
                    }
                    when Annotations.Expression.POST {
                        error(f.position, "fields may not be annotated with '@post'")
                    }
                    when Annotations.Expression.PRE_OR {
                        error(f.position, "fields may not be annotated with '@preOr'")
                    }
                    when Annotations.Expression.POST_AND {
                        error(f.position, "fields may not be annotated with '@postAnd'")
                    }
                }
            }
        }
        if f.resolved = Resolution.RESOLVED {
            if f.annotations.isClass & !isImmutable(f.type) {
                error(f.position, "only immutable fields may be annotated with '@class'")
            }
            if f.annotations.isClass & f.fieldKind = FieldDecl.Kind.VAR {
                error(f.position, "'var' fields may not be annotated with '@class'")
            }
        }
        checkAccessModifierCount(f.position, f.annotations)
    }

    @post(currentClass.count = @pre(currentClass.count))
    method compile(cl:ClassDecl) {
        currentClass.push(cl)
        checkAnnotations(cl)
        resolve(cl)
        if cl.resolved != Resolution.RESOLVED {
            currentClass.pop()
            return
        }
        if cl.annotations.isSpecialize {
            backend.start(cl)
            backend.end(cl)
            currentClass.pop()
            return
        }
        def auto := AutoScope(self, getSymbolTable(cl))
        checkImmutable(cl)
        checkValue(cl)
        checkInterfaceMethods()
        var started := false
        for f in cl.fields {
            resolve(f)
            checkAnnotations(f)
        }
        for m in cl.methods {
            resolve(m)
        }
        if errorCount = 0 {
            backend.start(cl)
            started := true
        }
        for m in cl.methods {
            checkAnnotations(m)
            compile(m)
        }
        if started {
            backend.end(cl)
        }
        currentClass.pop()

        if compilationQueue.count > 0 {
            def next := compilationQueue[0]
            compilationQueue.removeIndex(0)
            compile(next)
        }
        assert compilationQueue.count = 0
    }

    method scan(file:File):Array<ClassDecl> {
        try {
            def path := file.absolute()
            return scan(path, file.readFully())
        }
        fail(err) {
            files.add(file)
            error(Position(files.count, 1, 1), err.message)
            return []
        }
    }

    method scan(path:File, text:String):Array<ClassDecl> {
        var result := scans[path]
        if result == null {
            parser.start(path, files.count, text)
            files.add(path)
            def parsed := parser.file()
            if parsed !== null {
                result := scanner.scan(path, parsed)
                for cl in result {
                    classes[cl.name] := cl
                }
            }
            else {
                result := Array<ClassDecl>()
            }
            scans[path] := result
        }
        return result
    }

    method compile(file:File) {
        try {
            compile(file.absolute(), file.readFully())
        }
        fail(err) {
            error(Position(files.count, 1, 1), err.message)
        }
    }

    method compile(path:File, text:String) {
        for cl in scan(path, text) {
            compile(cl)
        }
    }

    method error(pos:Position, msg:String) {
        if reportErrors {
            errorCount += 1
            def path:String
            if pos.file >= 0 & pos.file < files.count {
                path := files[pos.file].name
            }
            else {
                path := "<internal>"
            }
            errorQueue.post(Message.ERROR(path, pos.line, pos.column, msg))
        }
    }

    method error(pos:MethodPosition, msg:String) {
        error(pos.asPosition, msg)
    }

    method warn(pos:Position, msg:String) {
        if reportErrors {
            def path:String
            if pos.file >= 0 {
                path := files[pos.file].name
            }
            else {
                path := "<internal>"
            }
            errorQueue.post(Message.WARNING(path, pos.line, pos.column, msg))
        }
    }

    method warn(pos:MethodPosition, msg:String) {
        warn(pos.asPosition, msg)
    }

    method finish() {
        while pendingClasses.count > 0 {
            def cl := pendingClasses.removeIndex(pendingClasses.count - 1)
            compile(cl)
        }
        for decl in cg.declarations.values.filter(decl => decl.isExternal) {
            backend.writeSignature(decl)
        }
        for (signature, code) in cg.methodShims.values {
            backend.writeMethod(null, signature, code, true)
        }
        backend.finish()
    }

    ------------------------------------------------------------------------------------------------

    choice Format {
        LLVM
        EXECUTABLE
        OBJECT
        C
        HTML
        STUB
        RUN
    }

    class Arguments {
        @private
        def args:ListView<String>

        @private
        def index := 0

        property done:Bit

        init(args:ListView<String>) {
            self.args := args
        }

        function get_done():Bit {
            return index = args.count
        }

        method next():String {
            assert !done
            index += 1
            return args[index - 1]
        }

        method next(label:String):String {
            if done {
                Console.printErrorLine("expected \{label} after '\{args[args.count - 1]}'")
                System.exit(1)
            }
            return next()
        }
    }

    @class
    method toObject(clang:File, llvm:File, dest:File, preserveTemporaries:Bit,
            settings:Compiler.Settings):File {
        def args := Array<String>() -- FIXME literal
        args.add(llvm.path)
        args.add("-m64")
        args.add("-fPIC")
        args.add("-c")
        if settings.debug {
            args.add("-g")
        }
        args.add("-O\{settings.optimizationLevel}")
        args.add("-o")
        args.add(dest.path)
        def p:System.Process
        try {
            p := System.exec(clang.path, args)
            -- FIXME shouldn't have to use unsafeStart here
            def t1 := Thread.unsafeStart(method() {
                try {
                    p.standardOutput().sendTo(Console.outputStream())
                }
                fail(error) {
                    Console.printLine(error)
                    System.exit(1)
                }
            })
            def t2 := Thread.unsafeStart(method() {
                try {
                    p.standardError().sendTo(Console.errorStream())
                }
                fail(error) {
                    Console.printLine(error)
                    System.exit(1)
                }
            })
            t1.waitFor()
            t2.waitFor()
        }
        fail(error) {
            Console.printErrorLine(error)
            System.exit(1)
        }
        def exitCode := p.waitFor()
        if !preserveTemporaries {
            try {
                llvm.delete()
            }
            fail(error) {
                Console.printErrorLine(error)
                System.exit(1)
            }
        }
        if exitCode != 0 {
            System.exit(1)
        }
        return dest
    }

    @class
    method toExecutable(clang:File, libraryPaths:Array<File>, libraries:Array<String>, llvm:File,
            dest:File, preserveTemporaries:Bit, settings:Compiler.Settings):File {
        def args := Array<String>() -- FIXME literal
        args.add(llvm.path)
        args.add("-L\{Config.frostLibDir()}")
        args.add("-lfrost")
        args.add("-lm")
        args.add("-lpthread")
        args.addAll(libraryPaths.map(p => "-L" + p))
        args.addAll(libraries.map(l => "-l" + l))
        def icuLibs := Config.icuLibraries().split(";")
        for lib in icuLibs {
            def libFile := File(lib)
            args.add("-L" + libFile.parent!)
            var simpleName := libFile.simpleName
            assert simpleName.startsWith("lib")
            simpleName := simpleName[3..]
            args.add("-l" + simpleName)
        }
        args.add("-m64")
        args.add("-fPIC")
        if settings.debug {
            args.add("-g")
        }
        args.add("-O\{settings.optimizationLevel}")
        args.add("-Wno-override-module")
        args.add("-o")
        args.add(dest.path)
        def p:System.Process
        try {
            p := System.exec(clang.path, args)
            Console.printError(p.standardOutput().readFully())
            Console.printError(p.standardError().readFully())
        }
        fail(error) {
            Console.printErrorLine(error)
            System.exit(1)
        }
        def exitCode := p.waitFor()
        if !preserveTemporaries {
            try {
                llvm.delete()
            }
            fail(error) {
                Console.printErrorLine(error)
                System.exit(1)
            }
        }
        if exitCode != 0 {
            System.exit(1)
        }
        return dest
    }

    @class
    method printUsage(out:OutputStream) {
        try {
            out.printLine("Usage: frostc [options] <sources>")
            out.printLine()
            out.printLine("Source filenames must end in '.frost'.")
            out.printLine()
            out.printLine("Options:")
            out.printLine("  -o <path>    output path")
        }
        fail(error) {
            unreachable
        }
    }

    @class
    method run(rawArgs:ListView<String>):Bit {
        def args := Arguments(rawArgs)
        def sources := Array<File>()
        def imports := Array<File>()
        def libraryPaths := Array<File>()
        def libraries := Array<String>()
        var outFile:File? := null
        var optimizationLevel := 3
        var safetyLevel := 3
        var intSize := 8
        var format:Format? := null
        var root:String? := null
        var preserveTemporaries := true
        var debug := true
        while !args.done {
            def a := args.next()
            match a {
                when "--fuzz" {
                    try {
                        def path := File("/tmp/fuzz.frost")
                        Console.inputStream().sendTo(path.openOutputStream())
                        sources.add(path)
                    }
                    fail(error) {
                        Console.printErrorLine(error)
                        System.exit(1)
                    }
                }
                when "-o" {
                    if outFile !== null {
                        Console.printErrorLine("'-o' may only be specified once")
                        System.exit(1)
                    }
                    outFile := File(args.next("a filename"))
                    try {
                        outFile.parent!.createDirectories()
                    }
                    fail(error) {
                        Console.printErrorLine(error)
                        System.exit(1)
                    }
                }
                when "-O" {
                    def level := args.next("a number from 0-3")
                    var parsed := level.asInt
                    if parsed == null | parsed > 3 | parsed < 0 {
                        Console.printErrorLine("expected a number from 0-3 after '-O'")
                        System.exit(1)
                    }
                    optimizationLevel := parsed
                }
                when "-S" {
                    def level := args.next("a number from 0-3")
                    def parsed := level.asInt
                    if parsed == null | parsed > 3 | parsed < 0 {
                        Console.printErrorLine("expected a number from 0-3 after '-S'")
                        System.exit(1)
                    }
                    safetyLevel := parsed
                }
                when "-m" {
                    def bits := args.next("32 or 64")
                    def parsed := bits.asInt
                    if parsed == null | (parsed != 32 & parsed != 64) {
                        Console.printErrorLine("expected '32' or '64' after '-m'")
                        System.exit(1)
                    }
                    intSize := parsed // 8
                }
                when "-f" {
                    if format !== null {
                        Console.printErrorLine("'-f' may only be specified once")
                        System.exit(1)
                    }
                    def f := args.next("an output format")
                    match f {
                        when "exe"  { format := Format.EXECUTABLE }
                        when "o"    { format := Format.OBJECT }
                        when "ll"   { format := Format.LLVM }
                        when "c"    { format := Format.C }
                        when "html" { format := Format.HTML }
                        when "stub" { format := Format.STUB }
                        when "run"  { format := Format.RUN }
                        otherwise {
                            Console.printErrorLine("unsupported output format '\{f}'")
                            System.exit(1)
                        }
                    }
                }
                when "-I" {
                    imports.add(File(args.next("a path to an import directory")))
                }
                when "-L" {
                    libraryPaths.add(File(args.next("a path to a library directory")))
                }
                when "-l" {
                    libraries.add(args.next("a library name"))
                }
                when "--root" {
                    root := args.next("a path")
                }
                otherwise {
                    if a.endsWith(".frost") {
                        def f := File(a)
                        sources.add(f)
                    }
                    else {
                        Console.printErrorLine("unrecognized argument '\{a}'")
                        System.exit(1)
                    }
                }
            }
        }
        if format == null | format != Format.STUB {
            imports.add(File(Config.frostLibDir()).resolve("stubs"))
        }
        def frostHome := File(Config.frostSourceDir())
        imports.add(frostHome)
        def clang := File("/usr/bin/clang")
        if sources.count = 0 {
            Console.printErrorLine("no input files specified")
            System.exit(1)
        }
        if format == null {
            format := Format.EXECUTABLE
        }
        if outFile == null & format != Format.RUN {
            if sources.count = 1 {
                def extension:String
                match format {
                    when Format.EXECUTABLE { extension := "" }
                    when Format.OBJECT     { extension := ".o" }
                    when Format.LLVM       { extension := ".ll" }
                    when Format.C          { extension := ".c" }
                    when Format.HTML       { extension := ".html" }
                    when Format.STUB       { extension := ".stub" }
                    otherwise {
                        Console.printErrorLine("output format requires a '-o' output to be " +
                                "specified")
                        System.exit(1)
                    }
                }
                outFile := sources[0].withExtension(extension)
            }
            else if format = Format.HTML {
                Console.printErrorLine("format 'html' requires exactly one input file")
                System.exit(1)
            }
            else {
                Console.printErrorLine("multiple input files specified, must use '-o' to specify " +
                        "output file")
                System.exit(1)
            }
        }
        var errorCount := 0
        var warningCount := 0
        def settings := Compiler.Settings(frostHome, imports, optimizationLevel, safetyLevel,
                intSize, debug)
        {
            def backend:Backend? := null
            try {
                match format {
                    when Format.LLVM {
                        backend := LLVMBackend(Config.llvmTriple(), outFile.openOutputStream())
                    }
                    when Format.EXECUTABLE, Format.OBJECT {
                        backend := LLVMBackend(Config.llvmTriple(),
                                outFile.withExtension(".ll").openOutputStream())
                    }
                    when Format.C {
                        backend := CBackend(outFile.openOutputStream())
                    }
                    when Format.STUB {
                        backend := StubBackend(outFile.openOutputStream())
                    }
                    when Format.RUN {
                        backend := Interpreter()
                    }
                }
            }
            fail(error) {
                Console.printErrorLine(error)
                System.exit(1)
            }
            def errorQueue := MessageQueue<Compiler.Message>()
            def compiler := Compiler(errorQueue, backend, settings)
            if format = Format.RUN {
                compiler.cg.allClassConstants := true
            }
            if format = Format.HTML {
                if root == null {
                    root := "."
                }
                HTMLProcessor(compiler).process(sources[0], outFile, root)
                return true
            }
            if root !== null {
                Console.printErrorLine("--root requires 'html' output format")
                System.exit(1)
            }
            for s in sources {
                for cl in compiler.scan(s) {
                    compiler.markNonExternal(cl)
                }
            }
            for s in sources {
                compiler.compile(s)
            }
            compiler.finish()
            if format = Format.RUN {
                backend->Interpreter.run()
                return true
            }
            while errorQueue.hasMessage() {
                def error := errorQueue.getMessage()
                -- FIXME stderr
                match error {
                    when Compiler.Message.ERROR(file, line, column, message) {
                        errorCount += 1
                        Console.printLine("\{file}:\{line}:\{column}: error: \{message}")
                    }
                    when Compiler.Message.WARNING(file, line, column, message) {
                        warningCount += 1
                        Console.printLine("\{file}:\{line}:\{column}: warning: \{message}")
                    }
                }
            }
        }
        if warningCount = 1 {
            -- FIXME stderr
            Console.printLine("1 warning")
        }
        else if warningCount > 0 {
            -- FIXME stderr
            Console.printLine("\{warningCount} warnings")
        }
        if errorCount = 0 {
            match format {
                when Format.EXECUTABLE {
                    toExecutable(clang, libraryPaths, libraries, outFile.withExtension(".ll"),
                            outFile, preserveTemporaries, settings)
                }
                when Format.OBJECT {
                    toObject(clang, outFile.withExtension(".ll"), outFile, preserveTemporaries,
                            settings)
                }
            }
        }
        else {
            if errorCount = 1 {
                -- FIXME stderr
                Console.printLine("1 error")
            }
            else {
                -- FIXME stderr
                Console.printLine("\{errorCount} errors")
            }
        }
        return errorCount = 0
    }
}
