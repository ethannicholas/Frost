package org.frostlang.frostc

uses org.frostlang.frostc.parser.Parser
uses org.frostlang.frostc.parser.Token
uses org.frostlang.frostc.expression.And
uses org.frostlang.frostc.expression.ArrayLiteral
uses org.frostlang.frostc.expression.AtPre
uses org.frostlang.frostc.expression.AtReturn
uses org.frostlang.frostc.expression.Binary
uses org.frostlang.frostc.expression.Call
uses org.frostlang.frostc.expression.Closure
uses org.frostlang.frostc.expression.Dot
uses org.frostlang.frostc.expression.Identifier
uses org.frostlang.frostc.expression.IntLiteral
uses org.frostlang.frostc.expression.Or
uses org.frostlang.frostc.expression.Tuple
uses org.frostlang.frostc.expression.Unary
uses org.frostlang.frostc.lvalue.ChoiceFieldLValue
uses org.frostlang.frostc.lvalue.FieldLValue
uses org.frostlang.frostc.lvalue.IndexLValue
uses org.frostlang.frostc.lvalue.LValue
uses org.frostlang.frostc.lvalue.VariableLValue
uses org.frostlang.frostc.statement.Assert
uses org.frostlang.frostc.statement.Assignment
uses org.frostlang.frostc.statement.Break
uses org.frostlang.frostc.statement.Continue
uses org.frostlang.frostc.statement.Do
uses org.frostlang.frostc.statement.For
uses org.frostlang.frostc.statement.If
uses org.frostlang.frostc.statement.InnerMethod
uses org.frostlang.frostc.statement.Loop
uses org.frostlang.frostc.statement.Match
uses org.frostlang.frostc.statement.Return
uses org.frostlang.frostc.statement.Try
uses org.frostlang.frostc.statement.While
uses org.frostlang.frostc.statement.Var

@final
class Compiler {
    choice Resolution {
        UNRESOLVED
        IN_PROGRESS
        RESOLVED
        RESOLVED_WITH_ERRORS

        @override
        function get_asString():String {
            match self {
                when UNRESOLVED {
                    return "UNRESOLVED"
                }
                when IN_PROGRESS {
                    return "IN_PROGRESS"
                }
                when RESOLVED {
                    return "RESOLVED"
                }
                when RESOLVED_WITH_ERRORS {
                    return "RESOLVED_WITH_ERRORS"
                }
            }
            unreachable
        }
    }

    choice Message {
        ERROR(File, Position, String)
        WARNING(File, Position, String)
    }

    ================================================================================================
    Represents the expected type that an expression must resolve to.
    ================================================================================================
    choice TypeContext {
        ============================================================================================
        We have no information about the expected type, e.g. when evaluating the statement `foo()`.
        ============================================================================================
        UNSPECIFIED

        ============================================================================================
        We know the expression cannot result in void, e.g. when evaluating `foo()` in the statement
        `def x := foo()`.
        ============================================================================================
        NON_VOID

        ============================================================================================
        We know that the result has to be immutable, but not of any specific type, e.g. when
        evaluating `foo()` in the statement `const x := foo()`.
        ============================================================================================
        IMMUTABLE

        ============================================================================================
        We expect this specific type, e.g. when evaluating `foo()` in the statement
        `def x:String := foo()`. Explicit is true when the type is the result of an explicit cast to
        that type.
        ============================================================================================
        TYPE(Type, Bit -* explicit *-)

        function description():String {
            match self {
                when UNSPECIFIED {
                    return ""
                }
                when NON_VOID {
                    return ""
                }
                when IMMUTABLE {
                    return " with expected return type 'frost.core.Immutable'"
                }
                when TYPE(type, _) {
                    return " with expected return type '\{type}'"
                }
            }
            unreachable
        }

        @override
        function get_asString():String {
            match self {
                when UNSPECIFIED {
                    return "UNSPECIFIED"
                }
                when NON_VOID {
                    return "NON_VOID"
                }
                when IMMUTABLE {
                    return "IMMUTABLE"
                }
                when TYPE(type, _) {
                    return "TYPE(\{type})"
                }
            }
            unreachable
        }
    }

    choice EnclosingContext {
        LOOP(String? -* label *-, IR.Block.ID -* break target *-, IR.Block.ID -* continue target *-)
        SCOPE
        VARIABLE_SCOPE(Variable)
        VALUE_SCOPE(IR.Value)
        TRY_SCOPE(IR.Block.ID?, Variable?)

        @override
        function get_asString():String {
            match self {
                when LOOP(label, breakTarget, continueTarget) {
                    if label !== null {
                        return "LOOP(\{label}, \{breakTarget}, \{continueTarget})"
                    }
                    return "LOOP(<null>, \{breakTarget}, \{continueTarget})"
                }
                when SCOPE {
                    return "SCOPE"
                }
                when VARIABLE_SCOPE(v) {
                    return "VARIABLE_SCOPE(\{v})"
                }
                when VALUE_SCOPE(v) {
                    return "VALUE_SCOPE(\{v})"
                }
                when TRY_SCOPE(block, v) {
                    return "TRY_SCOPE(\{(block !== null).choose(block.asString, "<null>")}, " +
                            "\{(v !== null).choose(v.asString, "<null>")})"
                }
            }
            unreachable
        }
    }

    choice Target {
        VARIABLE(Variable, IR.Value?)
        TUPLE(FixedArray<Target>)
    }

    class AutoContext {
        def compiler:Compiler

        def context:EnclosingContext

        init(compiler:Compiler, context:EnclosingContext) {
            self.compiler := compiler
            self.context := context
            compiler.enclosingContexts.push(context)
        }

        @override
        method cleanup() {
            assert compiler.enclosingContexts[0] == context,
                    "expected top level context to be \{context}, but found " +
                    compiler.enclosingContexts
            compiler.enclosingContexts.pop()
        }
    }

    class AutoUnrefs {
        def compiler:Compiler

        def depth:Int

        init(compiler:Compiler) {
            self.compiler := compiler
            self.depth := compiler.enclosingContexts.count
        }

        @override
        method cleanup() {
            while compiler.enclosingContexts.count > depth {
                def scope := compiler.enclosingContexts[0]
                match scope {
                    when EnclosingContext.VALUE_SCOPE(v) {
                        compiler.leaveScope(scope)
                        compiler.enclosingContexts.pop()
                    }
                    otherwise {
                        break
                    }
                }
            }
        }
    }

    class AutoScope {
        def compiler:Compiler

        def oldSymbolTable:SymbolTable

        def newSymbolTable:SymbolTable

        init(compiler:Compiler) {
            init(compiler, SymbolTable(compiler.symbolTable))
        }

        init(compiler:Compiler, symbolTable:SymbolTable) {
            self.compiler := compiler
            self.oldSymbolTable := compiler.symbolTable
            self.newSymbolTable := symbolTable
            compiler.symbolTable := symbolTable
            compiler.enclosingContexts.push(EnclosingContext.SCOPE)
        }

        @override
        method cleanup() {
            loop {
                def pop := compiler.enclosingContexts.pop()
                match pop {
                    when EnclosingContext.SCOPE {
                        break
                    }
                    when EnclosingContext.VARIABLE_SCOPE, EnclosingContext.VALUE_SCOPE {
                        compiler.leaveScope(pop)
                    }
                    otherwise {
                        unreachable
                    }
                }
            }
            assert compiler.symbolTable == newSymbolTable
            compiler.symbolTable := oldSymbolTable
        }
    }

    class AutoAtPreFlag {
        def compiler:Compiler

        init(compiler:Compiler) {
            self.compiler := compiler
            compiler.inAtPre := true
        }

        @override
        method cleanup() {
            assert compiler.inAtPre
            compiler.inAtPre := false
        }
    }

    class Settings : Immutable {
        def frostHome:File

        def importDirs:ImmutableArray<File>

        def optimizationLevel:Int

        def safetyLevel:Int

        def debug:Bit

        init(frostHome:File, importDirs:ListView<File>, optimizationLevel:Int, safetyLevel:Int,
             debug:Bit) {
            self.frostHome := frostHome
            self.importDirs := ImmutableArray<File>(importDirs)
            self.optimizationLevel := optimizationLevel
            self.safetyLevel := safetyLevel
            self.debug := debug
        }
    }

    choice Capture {
        VARIABLE(Variable)
        FIELD(FieldDecl)
        SELF
    }

    class CoercionKey : Key<CoercionKey> {
        def expr:ASTNode

        def target:Type

        init(expr:ASTNode, target:Type) {
            self.expr := expr
            self.target := target
        }

        @override
        function =(other:CoercionKey):Bit {
            return expr == other.expr & target = other.target
        }

        @override
        function get_hash():Int {
            return Frost.addressOf(expr) ~~ target.hash
        }
    }

    class BinaryKey : Key<BinaryKey> {
        def left:ASTNode

        def op:Binary.Operator

        def right:ASTNode

        init(left:ASTNode, op:Binary.Operator, right:ASTNode) {
            self.left := left
            self.op := op
            self.right := right
        }

        @override
        function =(other:BinaryKey):Bit {
            return left == other.left & op = other.op & right == other.right
        }

        @override
        function get_hash():Int {
            return Frost.addressOf(left) ~~ Frost.addressOf(right)
        }
    }

    constant POINTER_NAME := "frost.unsafe.Pointer"
    
    constant WEAK_NAME := "frost.core.Weak"
    
    constant ARRAY_NAME := "frost.collections.Array"

    constant IMMUTABLE_ARRAY_NAME := "frost.collections.ImmutableArray"

    constant RANGE_NAME := "frost.core.Range"
    
    constant STEPPED_RANGE_NAME := "frost.core.SteppedRange"
    
    constant SELF_NAME := "self"
    
    -- name of the field in which we store captured "self"
    constant CAPTURED_SELF_NAME := "$self"

    -- within closures, 'self' is normally interpreted as the captured $self object. $force_self is
    -- always a reference to the actual 'self' - in a closure, this will be the closure object
    -- itself.
    constant FORCE_SELF_NAME := "$force_self"
    
    constant NONNULLABLE_TO_NULLABLE_CAST_COST := 1
    
    constant NULLABLE_TO_NONNULLABLE_CAST_COST := 2

    def settings:Settings

    def parser:Parser

    def scanner:Scanner

    def root:SymbolTable

    var compiling:ClassDecl? := null

    var compilationQueue := Array<ClassDecl>()

    @private
    def scans := HashMap<File, ListView<ClassDecl>>()

    @private
    def classes := HashMap<String, ClassDecl>()

    @private
    def currentClass := Stack<ClassDecl>()

    @private
    def currentMethod := Stack<MethodDecl>()

    @private
    var ir := IR()

    @private
    var symbolTable:SymbolTable

    @private
    var methodSymbolTable:SymbolTable

    @private
    def codeGenerator:CodeGenerator

    @private
    var errorQueue:MessageQueue<Message>

    @private
    var enclosingContexts := Stack<EnclosingContext>()

    @private
    var errorCount := 0

    @private
    var closureCount := 0

    @private
    var existenceCache := HashMap<File, Bit>()

    @private
    var reportErrors := true

    @private
    def pendingClasses := Array<ClassDecl>()

    @private
    var inAtPre := false

    -- local variable in which to store the return value, for postcondition purposes, or null to
    -- just do a straight return
    @private
    var returnVar:Variable?

    -- current block to which @pre(...) expressions should be added. This is not necessarily the
    -- method entry, because expressions can cause new blocks to be added.
    @private
    var atPreBlock:IR.Block.ID? := null

    -- block to which we should jump to begin evaluating postconditions. The postcondition block
    -- will handle returning from the method.
    @private
    var postconditionEntryBlock:IR.Block.ID? := null

    -- block to which postconditions are being compiled. This is not necessarily the postcondition
    -- entry block, because expressions can cause new blocks to be added.
    @private
    var postconditionCurrentBlock:IR.Block.ID? := null

    -- MethodDecl is the method *containing* the closure, not the closure itself
    @private
    def captures := Stack<Pair<MethodDecl, Map<String, Capture>>>()

    @private
    var writeCode := true

    @private
    var inFieldCleanup := false

    @private
    def coercionCosts := HashMap<CoercionKey, Pair<Type, Int>>()

    @private
    def binaryTypes := HashMap<BinaryKey, ListView<Type>?>()

    -- Sometimes we need to resolve an untyped lambda against several different types, such as when
    -- calling an overloaded method which can take different types of functions. If, say, the lambda
    -- only successfully resolves for one particular type of function, then we know the type of
    -- lambda we're dealing with. But if it fails for *all* of them, it could be that the lambda
    -- simply contains an error. So we keep track of all of the types we attempted to resolve a
    -- given lambda as for error reporting purposes.
    @private
    def lambdaTypes := IdentityMap<ASTNode, HashSet<Type>>()

    init(errorQueue:MessageQueue<Message>, codeGenerator:CodeGenerator, settings:Settings) {
        self.settings := settings
        self.scanner := Scanner(self)
        self.root := SymbolTable(self)
        self.parser := Parser(errorQueue)
        self.symbolTable := root
        self.codeGenerator := codeGenerator
        self.errorQueue := errorQueue
        codeGenerator.setCompiler(self)
        root.add(Type("builtin_bit", Type.Kind.BUILTIN_BIT, 1))
        root.add(Type.BuiltinInt8())
        root.add(Type.BuiltinInt16())
        root.add(Type.BuiltinInt32())
        root.add(Type.BuiltinInt64())
        root.add(Type.BuiltinUInt8())
        root.add(Type.BuiltinUInt16())
        root.add(Type.BuiltinUInt32())
        root.add(Type.BuiltinUInt64())
        root.add(Type.BuiltinFloat32())
        root.add(Type.BuiltinFloat64())
        root.add(Alias("Int", Type.Int64()))
        root.add(Alias("UInt", Type.UInt64()))
        root.add(Alias("Real", Type.Real64()))
        addAlias("frost.collections.Array")
        addAlias("frost.collections.Collection")
        addAlias("frost.collections.CollectionView")
        addAlias("frost.collections.CollectionWriter")
        addAlias("frost.collections.HashSet")
        addAlias("frost.collections.IdentityMap")
        addAlias("frost.collections.ImmutableArray")
        addAlias("frost.collections.Iterable")
        addAlias("frost.collections.Iterator")
        addAlias("frost.collections.Key")
        addAlias("frost.collections.List")
        addAlias("frost.collections.ListView")
        addAlias("frost.collections.ListWriter")
        addAlias("frost.collections.HashMap")
        addAlias("frost.collections.Map")
        addAlias("frost.collections.MapView")
        addAlias("frost.collections.MapWriter")
        addAlias("frost.collections.SpecializedArray")
        addAlias("frost.collections.Stack")
        addAlias("frost.core.Class")
        addAlias("frost.core.Bit")
        addAlias("frost.core.Char8")
        addAlias("frost.core.Char16")
        addAlias("frost.core.Char32")
        addAlias("frost.core.Comparable")
        addAlias("frost.core.Equatable")
        addAlias("frost.core.Error")
        addAlias("frost.core.Formattable")
        addAlias("frost.core.Int8")
        addAlias("frost.core.Int16")
        addAlias("frost.core.Int32")
        addAlias("frost.core.Int64")
        addAlias("frost.core.Immutable")
        addAlias("frost.core.Maybe")
        addAlias("frost.core.Method")
        addAlias("frost.core.MutableString")
        addAlias("frost.core.Object")
        addAlias("frost.core.Frost")
        addAlias("frost.core.Range")
        addAlias("frost.core.Real32")
        addAlias("frost.core.Real64")
        addAlias("frost.core.RegularExpression")
        addAlias("frost.core.SimpleRange")
        addAlias("frost.core.SteppedRange")
        addAlias("frost.core.String")
        addAlias("frost.core.System")
        addAlias("frost.core.UInt8")
        addAlias("frost.core.UInt16")
        addAlias("frost.core.UInt32")
        addAlias("frost.core.UInt64")
        addAlias("frost.core.Value")
        addAlias("frost.core.Weak")
        addAlias("frost.math.MersenneTwister")
        addAlias("frost.math.Random")
        addAlias("frost.math.XorShift128Plus")
        addAlias("frost.io.Console")
        addAlias("frost.io.File")
        addAlias("frost.io.IndentedOutputStream")
        addAlias("frost.io.InputStream")
        addAlias("frost.io.LineNumberInputStream")
        addAlias("frost.io.MemoryInputStream")
        addAlias("frost.io.MemoryOutputStream")
        addAlias("frost.io.OutputStream")
        addAlias("frost.io.PushbackInputStream")
        addAlias("frost.threads.Lock")
        addAlias("frost.threads.MessageQueue")
        addAlias("frost.threads.Notifier")
        addAlias("frost.threads.ScopedLock")
        addAlias("frost.threads.Thread")
        addAlias("frost.json.JSON")
        addAlias("frost.json.JSONParser")
    }

    @private
    method addAlias(name:String) {
        root.add(Alias(name[name.next(name.lastIndexOf("."))..],
                Type(name, Type.Kind.CLASS, Position(), true)))
    }

    method isRefCounted(type:Type):Bit {
        if !type.isClass {
            return false
        }
        return !isValue(type)
    }

    ================================================================================================
    Attempts to locate a class with the given, possibly not-fully-qualified, class name. Returns
    null and does not report any errors on failure.
    ================================================================================================
    @post(currentClass.count = @pre(currentClass.count) & errorCount = @pre(errorCount))
    method tryResolveClass(name:String):ClassDecl? {
        def current:ClassDecl?
        if currentClass.count > 0 {
            current := currentClass[0]
        }
        else {
            current := null
        }
        if current !== null {
            var result := current.classResolutionCache[name]
            if result !== null {
                return result.value
            }
            def alias := current.aliases[name]
            if alias !== null {
                result := ClassDecl.Resolution(getClass(alias))
                current.classResolutionCache[name] := result
                return result.value
            }
        }
        var result := getClass(name)
        if current !== null {
            if result == null {
                def idx := current.name.lastIndexOf(".")
                if idx !== null {
                    result := getClass(current.name[...idx] + name)
                }
            }
            if result == null {
                result := getClass(current.name + "." + name)
            }
            if result == null & current.owner !== null {
                currentClass.push(current.owner)
                result := tryResolveClass(name)
                currentClass.pop()
            }
        }
        if result == null {
            def rootAlias := root[name]
            if rootAlias !== null & rootAlias.kind = Symbol.Kind.ALIAS {
                result := getClass(rootAlias->Alias.type)
            }
        }
        if result == null {
            def index := name.lastIndexOf(".")
            if index !== null {
                -- could be an inner class name; see if we can locate an enclosing class
                def parent := tryResolveClass(name[..index])
                if parent !== null {
                    result := getClass(parent.name + name[index..])
                }
            }
        }
        if current !== null {
            current.classResolutionCache[name] := ClassDecl.Resolution(result)
        }
        return result
    }

    function typeParameters(type:Type):ListView<Type> {
        match type.typeKind {
            when Type.Kind.GENERIC_CLASS_PARAMETER {
                return typeParameters(type.genericClassParameter.bound)
            }
            when Type.Kind.GENERIC_METHOD_PARAMETER {
                return typeParameters(type.genericMethodParameter.bound)
            }
            when Type.Kind.GENERIC {
                assert type.subtypes.count >= 2
                return type.subtypes[1..]
            }
            when Type.Kind.NULLABLE {
                return typeParameters(type.subtypes[0])
            }
            otherwise {
                return Array<Type>()
            }
        }
    }

    ================================================================================================
    Verifies that a type uses the correct number and kind of generic arguments for the class it
    refers to. Reports error(s) and returns false if the type is not valid.
    ================================================================================================
    method checkGenericArguments(position:Position, cl:ClassDecl, type:Type):Bit {
        if !resolve(cl) {
            assert errorCount > 0
            return false
        }
        assert type.resolved
        def expectedCount := cl.parameters.count
        def foundTypes := typeParameters(type)
        def foundCount := foundTypes.count
        if expectedCount != foundCount {
            error(position, "'\{cl.name}' expected \{expectedCount} generic " +
                    "argument\{expectedCount = 1:|s}, but found \{foundCount}")
            return false
        }
        def object := Type.Object()
        for i in 0 .. expectedCount {
            def bound := cl.parameters[i].bound
            if bound = object | (bound.typeKind = Type.Kind.NULLABLE & bound.subtypes[0] = object) {
                continue
            }
            if coercionCost(foundTypes[i], remapType(type, bound)) == null {
                error(position, "generic argument '\{cl.name}.\{cl.parameters[i].name}' must be " +
                        "of type '\{cl.parameters[i].bound}', but found '\{foundTypes[i]}'")
                return false
            }
        }
        return true
    }

    @post(@return == null & (errorCount > 0 | !reportErrors) | (@return !== null & @return.resolved))
    method resolve(type:Type, checkArguments:Bit):Type? {
        if type.resolved {
            return type
        }
        match type.typeKind {
            when Type.Kind.CLASS {
                def resolved := tryResolveClass(type.name)
                if resolved !== null {
                    def result := resolved.type
                    if result !== null & checkArguments &
                            !checkGenericArguments(type.position, resolved, result) {
                        return null
                    }
                    return result
                }
                def s := symbolTable[type.name]
                if s !== null {
                    match s.kind {
                        when Symbol.Kind.ALIAS {
                            return resolve(s->Alias.type, checkArguments)
                        }
                        when Symbol.Kind.GENERIC_CLASS_PARAMETER {
                            def gp := s->ClassDecl.GenericParameter
                            return Type(gp)
                        }
                        when Symbol.Kind.GENERIC_METHOD_PARAMETER {
                            def gp := s->MethodDecl.GenericParameter
                            return Type(gp)
                        }
                        when Symbol.Kind.TYPE {
                            return s->Type
                        }
                    }
                }
                error(type.position, "unknown type '\{type}'")
                return null
            }
            when Type.Kind.NULLABLE {
                assert type.subtypes.count = 1
                def subtypes := Array<Type>()
                def sub := resolve(type.subtypes[0])
                if sub == null {
                    return null
                }
                subtypes.add(sub)
                return Type(subtypes[0].name + "?", Type.Kind.NULLABLE, type.position, subtypes,
                        true)
            }
            when Type.Kind.GENERIC {
                assert type.subtypes.count >= 2
                def base := resolve(type.subtypes[0], false)
                if base == null {
                    return null
                }
                def args := Array<Type>()
                for i in 1 .. type.subtypes.count {
                    def resolved := resolve(type.subtypes[i])
                    if resolved == null {
                        return null
                    }
                    args.add(resolved)
                }
                def result := Type.generic(base, args)
                def cl := getClass(result.subtypes[0])
                if cl !== null & checkArguments &
                        !checkGenericArguments(type.position, cl, result) {
                    return null
                }
                return result
            }
            when Type.Kind.METHOD, Type.Kind.FUNCTION, Type.Kind.IMMUTABLE_METHOD,
                    Type.Kind.IMMUTABLE_FUNCTION {
                def params := Array<Type>()
                for i in 0 .. type.parameterCount {
                    def resolved := resolve(type.parameterType(i))
                    if resolved == null {
                        return null
                    }
                    params.add(resolved)
                }
                def returnType := resolve(type.returnType)
                if returnType == null {
                    return null
                }
                return Type.methodType(type.position, type.typeKind, params, returnType, 0)
            }
            when Type.Kind.TUPLE {
                assert type.subtypes.count >= 2, "invalid tuple type \{type}"
                def args := Array<Type>()
                for a in type.subtypes {
                    def resolved := resolve(a)
                    if resolved == null {
                        return null
                    }
                    args.add(resolved)
                }
                return Type.tuple(args)
            }
            otherwise {
                unreachable
            }
        }
    }

    method resolve(type:Type):Type? {
        return resolve(type, true)
    }

    method addAllSupertypes(cl:ClassDecl, set:HashSet<String>) {
        if set.contains(cl.name) {
            return
        }
        set.add(cl.name)
        resolve(cl)
        if cl.rawSuper !== null {
            def superclass := getClass(cl.rawSuper)
            if superclass !== null {
                addAllSupertypes(superclass, set)
            }
        }
        for intfType in cl.rawInterfaces {
            def intf := getClass(intfType)
            if intf !== null {
                addAllSupertypes(intf, set)
            }
        }
    }

    @pre(cl.classKind = ClassDecl.Kind.CHOICE)
    method createChoiceEqualsIfNeeded(cl:ClassDecl) {
        def equatable := getClass("frost.core.Equatable")
        assert equatable !== null
        for cc in cl.choiceCases {
            assert cc.resolved != Resolution.UNRESOLVED
            if cc.resolved != Resolution.RESOLVED {
                return
            }
            for f in cc.fields {
                if findType(f, equatable) == null {
                    return
                }
            }
        }
        -- every field of every choice is equatable, make the choice equatable
        cl.declaredSupers.add(Type.generic(equatable.type, [cl.type]))
        def parameters := Array<MethodDecl.Parameter>()
        parameters.add(MethodDecl.Parameter("other", cl.type))
        def p := cl.position
        def body := Array<ASTNode>()
        body.add(ASTNode.IF(p, ASTNode.BINARY(p, ASTNode.DOT(p, ASTNode.SELF(p), "$rawValue"),
                Binary.Operator.NEQ, ASTNode.DOT(p, ASTNode.IDENTIFIER(p, "other"), "$rawValue")),
                FixedArray<ASTNode>.from([ASTNode.RETURN(p, ASTNode.BIT(p, false))]), null))
        body.add(ASTNode.RETURN(p, ASTNode.BIT(p, true)))
        def eq := MethodDecl(cl, p, null, Annotations(Annotations.Flag.OVERRIDE ||
                    Annotations.Flag.SYNTHETIC),
                MethodDecl.Kind.FUNCTION, "=", null, parameters, Type.Bit(),
                FixedArray<ASTNode>.from(body))
        cl.methods.add(eq)
    }

    @pre(cl.classKind = ClassDecl.Kind.CHOICE)
    method choiceSuper(cl:ClassDecl):Type {
        for case in cl.choiceCases {
            for f in case.fields {
                if f.nonnullable() != cl.type & !isImmutable(f) {
                    return Type.Object()
                }
            }
        }
        return Type.Immutable()
    }

    @post(currentClass.count = @pre(currentClass.count) &
            (@return | errorCount > 0 | !reportErrors))
    method resolve(cl:ClassDecl):Bit {
        if cl.resolved = Resolution.UNRESOLVED {
            cl.resolved := Resolution.IN_PROGRESS
            currentClass.push(cl)
            def auto := AutoScope(self, cl.symbolTable)
            for p in cl.parameters {
                def resolved := resolve(p.bound, false)
                if resolved !== null {
                    p.bound := resolved
                }
                else {
                    cl.resolved := Resolution.RESOLVED_WITH_ERRORS
                    assert currentClass[0] == cl
                    currentClass.pop()
                    return false
                }
            }
            for cc in cl.choiceCases {
                resolve(cc)
            }
            if cl.classKind = ClassDecl.Kind.CHOICE {
                createChoiceEqualsIfNeeded(cl)
            }
            def supertypes := HashSet<String>()
            for rawS in cl.declaredSupers {
                def resolvedType := resolve(rawS, false)
                if resolvedType == null {
                    cl.resolved := Resolution.RESOLVED_WITH_ERRORS
                    assert currentClass[0] == cl
                    currentClass.pop()
                    return false
                }
                def s := resolve(resolvedType, false)
                if s !== null {
                    def sClass := getClass(s)
                    if sClass !== null {
                        resolve(sClass)
                        addAllSupertypes(sClass, supertypes)
                        if sClass.classKind = ClassDecl.Kind.CLASS {
                            if cl.classKind = ClassDecl.Kind.INTERFACE {
                                error(s.position, "interface '\{cl.name}' cannot extend class " +
                                        "'\{s.name}'")
                            }
                            if cl.rawSuper == null {
                                cl.rawSuper := s
                                if cl.rawInterfaces.count > 0 {
                                    error(s.position, "superclass '\{s}' of class '\{cl.name}' must be " +
                                            "listed before any superinterfaces")
                                }
                            }
                            else {
                                error(s.position, "class '\{cl.name}' has more than one superclass")
                            }
                        }
                        else {
                            assert sClass.classKind = ClassDecl.Kind.INTERFACE
                            cl.rawInterfaces.add(s)
                        }
                    }
                    else {
                        cl.resolved := Resolution.RESOLVED_WITH_ERRORS
                        assert currentClass[0] == cl
                        currentClass.pop()
                        return false
                    }
                }
                else {
                    cl.resolved := Resolution.RESOLVED_WITH_ERRORS
                    assert currentClass[0] == cl
                    currentClass.pop()
                    return false
                }
            }
            if cl.rawSuper == null & cl.name != "frost.core.Object" {
                if cl.classKind = ClassDecl.Kind.CHOICE {
                    cl.rawSuper := choiceSuper(cl)
                }
                else {
                    cl.rawSuper := Type.Object()
                }
            }
            if cl.rawSuper !== null & !cl.annotations.isFinal &
                    cl.rawSuper.name = "frost.core.Value" {
                cl.annotations.flags ||= Annotations.Flag.FINAL
                for m in cl.methods {
                    m.annotations.flags ||= Annotations.Flag.FINAL
                    if scanner.shouldInline(m.annotations, m.body) {
                        m.annotations.flags ||= Annotations.Flag.INLINE
                    }
                }
            }
            if supertypes.contains(cl.name) {
                error(cl.position, "circular inheritance; '\{cl.name}' inherits from itself")
                cl.resolved := Resolution.RESOLVED_WITH_ERRORS
            }
            if cl.resolved = Resolution.IN_PROGRESS {
                cl.resolved := Resolution.RESOLVED
            }
            if cl.rawSuper !== null {
                def superclass := getClass(cl.rawSuper)
                if superclass !== null {
                    checkGenericArguments(cl.position, superclass, cl.rawSuper)
                }
            }
            for intf in cl.rawInterfaces {
                def intfclass := getClass(intf)
                if intfclass !== null {
                    checkGenericArguments(cl.position, intfclass, intf)
                }
            }
            for p in cl.parameters {
                def cl := getClass(p.bound)
                if cl !== null {
                    checkGenericArguments(cl.position, cl, p.bound)
                }
            }
            currentClass.pop()
        }
        return cl.resolved != Resolution.RESOLVED_WITH_ERRORS
    }

    @post(currentClass.count = @pre(currentClass.count))
    method resolve(m:MethodDecl):Bit {
        if m.resolved != Resolution.UNRESOLVED {
            return m.resolved = Resolution.RESOLVED
        }
        m.resolved := Resolution.IN_PROGRESS
        resolve(m.owner)
        currentClass.push(m.owner)
        def symbols := AutoScope(self, SymbolTable(m.owner.symbolTable))
        if m.genericParameters !== null {
            for p in m.genericParameters {
                symbolTable.add(Type(p), p.name)
                def resolved := resolve(p.bound, false)
                if resolved !== null {
                    p.bound := resolved
                }
                else {
                    m.resolved := Resolution.RESOLVED_WITH_ERRORS
                }
            }
        }
        for p in m.parameters {
            def resolved := resolve(p.type)
            if resolved !== null {
                p.type := resolved
            }
            else {
                m.resolved := Resolution.RESOLVED_WITH_ERRORS
            }
        }
        if m.methodKind = MethodDecl.Kind.INIT {
            if isValue(m.owner) {
                m.returnType := m.owner.type
            }
        }
        else {
            def resolved := resolve(m.returnType)
            if resolved !== null {
                m.returnType := resolved
            }
            else {
                m.resolved := Resolution.RESOLVED_WITH_ERRORS
            }
        }
        if m.resolved = Resolution.IN_PROGRESS {
            m.resolved := Resolution.RESOLVED
        }
        if !m.owner.external {
            def overridden := getOverriddenMethod(m)
            if overridden !== null {
                if !m.annotations.isOverride {
                    error(m.position, "\{m.declaration} overrides \{overridden.declaration}, " +
                            "but is not marked @override")
                }
                if m.methodKind = MethodDecl.Kind.METHOD &
                        overridden.methodKind = MethodDecl.Kind.FUNCTION {
                    error(m.position, "\{m.declaration} overrides \{overridden.declaration}, " +
                            "but methods cannot override functions")
                }
            }
            else if m.annotations.isOverride {
                error(m.position, "\{m.declaration} is marked @override, but no matching " +
                        "method exists among its ancestors")
            }
        }
        currentClass.pop()
        return m.resolved = Resolution.RESOLVED
    }

    @post(f.type != Type.Void() & f.type.resolved | errorCount > 0 | !reportErrors)
    method determineRawType(f:FieldDecl) {
        currentClass.push(f.owner)
        def auto := AutoScope(self, getSymbolTable(f.owner))
        if f.type != Type.Void() {
            def resolved := resolve(f.type)
            if resolved !== null {
                f.type := resolved
            }
            else {
                assert errorCount > 0
            }
            currentClass.pop()
            return
        }
        if f.rawValue == null {
            error(f.position, "field has neither a type nor a value")
            currentClass.pop()
            return
        }
        def preferred := preferredType(f.rawValue)
        if preferred == null {
            -- report error
            if compileExpression(f.rawValue) !== null {
                error(f.position, "type of field '\{f.name}' was not specified and could not be " +
                        "determined")
            }
            currentClass.pop()
            return
        }
        f.type := preferred
        currentClass.pop()
    }

    @post(@return | errorCount > 0 | !reportErrors)
    method resolve(f:FieldDecl):Bit {
        if f.resolved = Resolution.IN_PROGRESS {
            error(f.position,
                    "encounted a circular dependency in the value of field \{f.name}")
            f.resolved := Resolution.RESOLVED_WITH_ERRORS
        }
        else if f.resolved = Resolution.UNRESOLVED {
            f.resolved := Resolution.IN_PROGRESS
            if f.owner.classKind != ClassDecl.Kind.INTERFACE {
                -- we need to mark that we are in an instance context so 'self' works. Since the
                -- class is guaranteed to have at least one init method, we just pretend we're in
                -- one of those.
                def firstInit:MethodDecl? := null
                for m in f.owner.methods {
                    if m.methodKind = MethodDecl.Kind.INIT {
                        firstInit := m
                        break
                    }
                }
                assert firstInit !== null | errorCount > 0,
                        "class \{f.owner.name} has no init methods"
                if firstInit == null {
                    f.resolved := Resolution.RESOLVED_WITH_ERRORS
                    return false
                }
                currentMethod.push(firstInit)
                determineRawType(f)
                currentMethod.pop()
            }
            else {
                def old := currentMethod
                currentMethod := Stack<MethodDecl>()
                determineRawType(f)
                currentMethod := old
            }
            if f.type != Type.Void() & f.type.resolved {
                f.resolved := Resolution.RESOLVED
            }
            else {
                f.resolved := Resolution.RESOLVED_WITH_ERRORS
            }
            if f.annotations.isWeak & f.type != Type.Void() {
                f.type := Type.WeakOf(f.type)
            }
        }
        return f.resolved = Resolution.RESOLVED
    }

    @post(currentClass.count = @pre(currentClass.count))
    method resolve(c:ChoiceCase) {
        if c.resolved != Resolution.UNRESOLVED {
            return
        }
        if c.fields.count = 0 {
            c.resolved := Resolution.RESOLVED
            createChoiceCaseInit(c)
            return
        }
        c.resolved := Resolution.IN_PROGRESS
        currentClass.push(c.owner)
        def auto := AutoScope(self, c.owner.symbolTable)
        for i in 0 .. c.fields.count {
            def resolved := resolve(c.fields[i])
            if resolved !== null {
                c.fields[i] := resolved
            }
            else {
                c.fields[i] := Type.Invalid()
                c.resolved := Resolution.RESOLVED_WITH_ERRORS
            }
        }
        if c.resolved = Resolution.IN_PROGRESS {
            c.resolved := Resolution.RESOLVED
        }
        createChoiceCaseInit(c)
        currentClass.pop()
    }

    method isValue(cl:ClassDecl?):Bit {
        if !resolve(cl) {
            return false
        }
        return cl.rawSuper !== null & cl.rawSuper.name = "frost.core.Value"
    }

    method isValue(t:Type):Bit {
        if !t.isClass {
            return true
        }
        def cl := getClass(t)
        if cl == null {
            return false
        }
        return isValue(cl)
    }

    method isImmutable(cl:ClassDecl):Bit {
        if !resolve(cl) {
            return false
        }
        if cl.name = "frost.core.Immutable" {
            return true
        }
        if cl.rawSuper !== null {
            def superclass := getClass(cl.rawSuper)
            if superclass == null {
                return false
            }
            return isImmutable(superclass)
        }
        return false
    }

    method isImmutable(t:Type):Bit {
        if !t.isClass | t.isClassLiteral {
            return true
        }
--        if t.isPointer {
--            return isImmutable(t.subtypes[1])
--        }
        def cl := getClass(t)
        if cl == null {
            return false
        }
        return isImmutable(cl)
    }

    method instanceFields(cl:ClassDecl):ListView<FieldDecl> {
        def result := Array<FieldDecl>()
        if resolve(cl) {
            if !isValue(cl) & cl.rawSuper !== null {
                def s := getClass(cl.rawSuper)
                if s !== null {
                    result.addAll(instanceFields(s))
                }
            }
            for f in cl.fields {
                if !f.annotations.isClass & f.fieldKind != FieldDecl.Kind.PROPERTY {
                    result.add(f)
                }
            }
        }
        else {
        }
        return result
    }

    method exists(f:File):Bit {
        var result := existenceCache[f]
        if result == null {
            result := f.exists()
            existenceCache[f] := result
        }
        return result
    }

    ================================================================================================
    Attempts to load the class with the given fully-qualified name. Returns null on failure, without
    reporting an error.
    ================================================================================================
    method getClass(fullName:String):ClassDecl? {
        var result := classes[fullName]
        if result == null {
            var suffix1 := fullName.replace(".", "/") + ".stub"
            var suffix2 := fullName.replace(".", "/") + ".frost"
            var found := false
            for dir in settings.importDirs {
                var f := dir.resolve(suffix1)
                if exists(f) {
                    found := true
                    scan(f)
                    result := classes[fullName]
                    break
                }
                f := dir.resolve(suffix2)
                if exists(f) {
                    found := true
                    scan(f)
                    result := classes[fullName]
                    break
                }
            }
        }
        if result == null {
            def index := fullName.lastIndexOf(".")
            if index !== null {
                def parent := getClass(fullName[..index])
                if parent !== null {
                    result := classes[fullName]
                }
            }
        }
        return result
    }

    method getClass(position:Position, fullName:String):ClassDecl? {
        var result := classes[fullName]
        if result == null {
            def suffix1 := fullName.replace(".", "/") + ".stub"
            def suffix2 := fullName.replace(".", "/") + ".frost"
            var found := false
            for dir in settings.importDirs {
                var f := dir.resolve(suffix1)
                if exists(f) {
                    found := true
                    def oldErrorCount := errorCount
                    scan(f)
                    result := classes[fullName]
                    if result == null & errorCount = oldErrorCount {
                        error(f, Position(1, 1),
                                "expected file '\{f}' to contain a class named '\{fullName}'")
                    }
                    break
                }
                f := dir.resolve(suffix2)
                if exists(f) {
                    found := true
                    def oldErrorCount := errorCount
                    scan(f)
                    result := classes[fullName]
                    if result == null & errorCount = oldErrorCount {
                        error(f, Position(1, 1),
                                "expected file '\{f}' to contain a class named '\{fullName}'")
                    }
                }
            }
            if !found {
                error(position, "no file named \{suffix2} in any import path " +
                        "(\{settings.importDirs})")
            }
        }
        return result
    }

    ================================================================================================
    Given a requested type (e.g. `Foo<String, Int64>`), returns the actual type that the class
    should be specialized to. The actual type collapses all non-Value types down to their type
    bounds, since they're all just pointers and can be treated equivalently. This would likely
    result in `Foo<Object?, Int64>` in this case.
    ================================================================================================
    method specializedType(cl:ClassDecl, type:Type):Type {
        if type.typeKind = Type.Kind.CLASS {
            return type
        }
        assert type.typeKind = Type.Kind.GENERIC
        def args := Array<Type>()
        for i in 0 .. type.subtypes.count - 1 {
            if isValue(type.subtypes[i + 1]) {
                args.add(type.subtypes[i + 1])
            }
            else {
                args.add(cl.parameters[i].bound)
            }
        }
        return Type.generic(cl.type, args)
    }

    ================================================================================================
    Specializes a generic type to a particular set of type arguments. Specializing a type is similar
    to instantiating a C++ template, in that we create a copy of the code for each different set of
    type arguments.

    Or more precisely, we determine the widest set of types which can be used for each given
    specialization (see [specializedType]), and then re-use that (with different generic arguments)
    to fulfill matching requests.

    As a concrete example, suppose we have `class Foo<T, U> { ... }`, and we request
    `Foo<String, Int64>`. Since `String` is just a pointer and the `Foo` class has to be written as if
    `T` were an `Object?` anyway, it really doesn't matter whether the class is instantiated to use
    `String` or `File` or whatever else as a type parameter. So we can specialize `T` against the
    the bound of `T`, in this case `Object?`.

    But `Int64` is a `Value`, not a pointer. We actually end up producing different code to handle
    `Int64` vs., say, `Int8`, so it matters that we are using this particular type. `Value` types
    (including nullable `Value`s) have to remain as-is. So we actually end up specializing
    `Foo<String, Int64>` into an instance of `Foo<Object?, Int64>`, and this class will be reused by
    any other compatible specializations of the `Foo` class.

    To make this class actually handle the `<String, Int>` types, the specialization is still
    generic (over `<T:Object?, U:Int64>`), and we can then specify its actual types as generic
    parameters. The resulting specialization has name `Foo<frost.core.Object?, frost.core.Int64>`,
    and so we end up with type name `Foo<frost.core.Object?, frost.core.Int64><frost.core.String,
    frost.core.Int64>`. This name is internal use only and this "doubly generic" syntax cannot
    actually be used in Frost source code. The inclusion of the `U:Int64` generic parameter is of
    course not strictly necessary, since `Int64` cannot be subclassed, but it simplifies things to
    always have the same number of generic parameters.

    FIXME: As a future optimization, we could probably worry only about the *size* of the Values and
    not their specific identities.
    ================================================================================================
    @post(currentClass.count = @pre(currentClass.count))
    method specialize(cl:ClassDecl, rawType:Type):ClassDecl {
        if !resolve(cl) {
            return cl
        }
        def type := specializedType(cl, resolve(rawType).nonnullable())
        if type.typeKind = Type.Kind.CLASS {
            return cl
        }
        def result:ClassDecl? := classes[type.name]
        if result == null {
            currentClass.push(cl)
            --def parameters := cl.parameters.combine<Type, ClassDecl.GenericParameter>(type,
              --      (p1:ClassDecl.GenericParameter, p2:Type) => ClassDecl.GenericParameter(p1.position, p1.owner, p1.name, p2))
            --Console.printLine("parameters: \{parameters}")
            def annotations := Annotations((cl.annotations.flags || Annotations.Flag.SYNTHETIC) &&
                    !!Annotations.Flag.SPECIALIZE)
            def supertypes := Array<Type>()
            supertypes.add(remapType(type, cl.rawSuper))
            for intf in cl.rawInterfaces {
                supertypes.add(remapType(type, intf))
            }
            result := ClassDecl(cl.source, cl.position, cl.aliases, cl.doccomment, annotations,
                    cl.classKind, type, supertypes, [],
                    cl.symbolTable.parents[0])
            for i in 0 .. cl.parameters.count {
                result.symbolTable.add(Alias(cl.parameters[i].name, type.subtypes[i + 1]))
            }
            result.external := false
            for m in cl.methods {
                resolve(m)
                def generics:Array<MethodDecl.GenericParameter>?
                if m.genericParameters !== null {
                    for p in m.genericParameters {
                        generics.add(MethodDecl.GenericParameter(p.position, p.owner, p.name,
                                remapType(type, p.bound)))
                    }
                }
                def parameters := m.parameters.map(
                        p => MethodDecl.Parameter(p.name, self.remapType(type, p.type)))
                def clone := MethodDecl(result, m.position, m.doccomment, m.annotations,
                        m.methodKind, m.name, generics, parameters, remapType(type, m.returnType),
                        m.body)
                result.methods.add(clone)
                result.symbolTable.add(clone)
            }
            for f in cl.fields {
                resolve(f)
                def clone := FieldDecl(result, f.position, f.doccomment, f.annotations, f.fieldKind,
                        f.name, remapType(type, f.type), f.rawValue)
                result.fields.add(clone)
                result.symbolTable.add(clone)
            }
            classes[result.name] := result
            resolve(result)
            compilationQueue.add(result)
            currentClass.pop()
            resolve(result)
        }
        return result
    }

    method getClass(type:Type):ClassDecl? {
        var result:ClassDecl?
        match type.typeKind {
            when Type.Kind.CLASS {
                result := getClass(type.position, type.name)
            }
            when Type.Kind.GENERIC {
                if type.subtypes[0] = Type.Class() {
                    return getClass(type.subtypes[1])
                }
                result := getClass(type.subtypes[0])
            }
            when Type.Kind.NULLABLE {
                result := getClass(type.subtypes[0])
            }
            when Type.Kind.GENERIC_CLASS_PARAMETER {
                return getClass(type.genericClassParameter.bound)
            }
            when Type.Kind.GENERIC_METHOD_PARAMETER {
                return getClass(type.genericMethodParameter.bound)
            }
            when Type.Kind.METHOD, Type.Kind.FUNCTION {
                return getClass(Type.MutableMethod())
            }
            when Type.Kind.IMMUTABLE_METHOD, Type.Kind.IMMUTABLE_FUNCTION {
                return getClass(Type.Method())
            }
            when Type.Kind.TUPLE {
                var isKey := true
                var isEquatable := true
                def equatable := getClass("frost.core.Equatable")
                assert equatable !== null
                def key := getClass("frost.collections.Key")
                assert key !== null
                for t in type.subtypes {
                    if isEquatable & findType(t, equatable) == null {
                        isEquatable := false
                    }
                    if isKey & findType(t, key) == null {
                        isKey := false
                    }
                }
                if isKey {
                    return getClass(Type("frost.core.KeyTuple\{type.subtypes.count}",
                            Type.Kind.CLASS, Position(), true))
                }
                if isEquatable {
                    return getClass(Type("frost.core.EquatableTuple\{type.subtypes.count}",
                            Type.Kind.CLASS, Position(), true))
                }
                return getClass(Type("frost.core.Tuple\{type.subtypes.count}", Type.Kind.CLASS,
                        Position(), true))
            }
            otherwise {
                error(type.position, "type '\{type}' is not a class")
                return null
            }
        }
        if result !== null & result.annotations.isSpecialize {
            result := specialize(result, type)
        }
        return result
    }

    method allInterfaces(t:Type):HashSet<Type> {
        def result := HashSet<Type>()
        def cl := getClass(t)
        if cl !== null & resolve(cl) {
            if cl.resolved = Resolution.RESOLVED {
                if cl.rawSuper !== null {
                    result.addAll(allInterfaces(remapType(t, cl.rawSuper)))
                }
                for intf in cl.rawInterfaces {
                    result.addAll(allInterfaces(remapType(t, intf)))
                }
                if cl.classKind = ClassDecl.Kind.INTERFACE {
                    result.add(t)
                }
            }
        }
        return result
    }

    function signatureMatch(t1:Type, t2:Type):Bit {
        assert t1.isMethod
        assert t2.isMethod
        if t1.subtypes.count != t2.subtypes.count {
            return false
        }
        for i in 0 .. t1.subtypes.count {
            if t1.subtypes[i] != t2.subtypes[i] {
                return false
            }
        }
        return true
    }

    method findMethod(owner:Type, name:String, methodType:Type, checkInterfaces:Bit):MethodDecl? {
        def cl := getClass(owner)
        if cl == null {
            return null
        }
        if !resolve(cl) {
            return null
        }
        for test in cl.methods {
            if test.name = name {
                resolve(test)
                if signatureMatch(remapType(owner, declaredType(test)), methodType) {
                    return test
                }
            }
        }
        for raw in cl.rawInterfaces {
            def result := findMethod(remapType(owner, raw), name, methodType, checkInterfaces)
            if result !== null & (checkInterfaces | cl.classKind = ClassDecl.Kind.INTERFACE |
                    result.body !== null) {
                return result
            }
        }
        if cl.rawSuper !== null {
            return findMethod(remapType(owner, cl.rawSuper), name, methodType, checkInterfaces)
        }
        return null
    }

    function getOverriddenMethod(m:MethodDecl):MethodDecl? {
        if m.overrideKnown {
            return m.overridden
        }
        if m.methodKind = MethodDecl.Kind.INIT {
            m.overrideKnown := true
            return null
        }
        resolve(m)
        def methodType := declaredType(m)
        def owner := m.owner.typeWithParameters()
        for raw in m.owner.rawInterfaces {
            def result := findMethod(remapType(owner, raw), m.name, methodType, true)
            if result !== null {
                m.overrideKnown := true
                m.overridden := result
                return result
            }
        }
        resolve(m.owner)
        if m.owner.rawSuper !== null {
            def result := findMethod(remapType(owner, m.owner.rawSuper), m.name, methodType, true)
            m.overrideKnown := true
            m.overridden := result
            return result
        }
        m.overrideKnown := true
        return null
    }

    method interfaceMethods(cl:ClassDecl, intf:Type):ListView<MethodDecl> {
        def intfClass := getClass(intf)
        assert intfClass !== null
        def result := Array<MethodDecl>()
        for m in intfClass.methods {
            if m.annotations.isClass {
                continue
            }
            def found := findMethod(cl.type, m.name, remapType(intf, inheritedType(m)), false)
            if found !== null {
                result.add(found)
            }
            else if m.body !== null {
                result.add(m)
            }
            else {
                error(cl.position, "class '\{cl.name}' does not implement interface " +
                        m.declaration)
            }
        }
        return result
    }

    method checkInterfaceMethods() {
        def cl := currentClass[0]
        for intf in allInterfaces(cl.type) {
            interfaceMethods(cl, intf)
        }
    }

    method getSymbolTable(cl:ClassDecl):SymbolTable {
        if !cl.symbolTableResolved {
            cl.symbolTableResolved := true
            if resolve(cl) {
                if cl.rawSuper !== null {
                    def superCl := getClass(cl.rawSuper)
                    if superCl !== null {
                        cl.symbolTable.parents.add(getSymbolTable(superCl))
                    }
                }
                for rawIntf in cl.rawInterfaces {
                    def intf := getClass(rawIntf)
                    if intf !== null {
                        cl.symbolTable.parents.add(getSymbolTable(intf))
                    }
                }
                if cl.owner !== null {
                    --cl.symbolTable.parents.add(getSymbolTable(cl.owner))
                }
            }
        }
        return cl.symbolTable
    }

    @post(currentClass.count = @pre(currentClass.count))
    method getVTable(cl:ClassDecl):ListView<MethodDecl> {
        if cl.virtualMethods.count = 0 {
            resolve(cl)
            currentClass.push(cl) -- FIXME Auto
            if cl.rawSuper !== null {
                def superCl := getClass(cl.rawSuper)
                if superCl == null {
                    currentClass.pop()
                    return cl.virtualMethods
                }
                cl.virtualMethods.addAll(getVTable(superCl))
            }
            for derived in cl.methods {
                resolve(derived)
                if derived.methodKind = MethodDecl.Kind.INIT | derived.annotations.isClass {
                    continue
                }
                var found := false
                for i in 0 .. cl.virtualMethods.count {
                    def base := cl.virtualMethods[i]
                    resolve(base)
                    def overridden := getOverriddenMethod(derived)
                    if overridden !== null & (overridden == base |
                                overridden == getOverriddenMethod(base)) {
                        found := true
                        cl.virtualMethods[i] := derived
                        break
                    }
                }
                if !found {
                    cl.virtualMethods.add(derived)
                }
            }
            currentClass.pop()
        }
        return cl.virtualMethods
    }

    method remapType(context:Type, raw:Type):Type {
        if context.isClassLiteral {
            return remapType(context.subtypes[1], raw)
        }
        match raw.typeKind {
            when Type.Kind.CLASS, Type.Kind.BUILTIN_INT, Type.Kind.BUILTIN_UINT,
                    Type.Kind.BUILTIN_BIT {
                return raw
            }
        }
        match context.typeKind {
            when Type.Kind.NULLABLE {
                assert context.subtypes.count = 1
                return remapType(context.subtypes[0], raw)
            }
            when Type.Kind.GENERIC {
                assert context.subtypes.count >= 2
                def typeMap := HashMap<String, Type>()
                def base := context.subtypes[0]
                def cl := tryResolveClass(base.name)
                assert cl !== null
                for i in 1 .. context.subtypes.count {
                    typeMap[cl.name + "." + cl.parameters[i - 1].name] := context.subtypes[i]
                }
                return raw.remap(typeMap)
            }
            when Type.Kind.GENERIC_METHOD_PARAMETER {
                return remapType(context.genericMethodParameter.bound, raw)
            }
            when Type.Kind.TUPLE {
                def typeMap := HashMap<String, Type>()
                def base := context.subtypes[0]
                def cl := getClass(context)
                assert cl !== null
                for i in 0 .. context.subtypes.count {
                    typeMap[cl.name + "." + cl.parameters[i].name] := context.subtypes[i]
                }
                return raw.remap(typeMap)
            }
            otherwise {
                return raw
            }
        }
    }

    function preferredType(type:Type):Type {
        if type.typeKind = Type.Kind.INT_LITERAL {
            return Type.Int64()
        }
        if type.typeKind = Type.Kind.REAL_LITERAL {
            return Type.Real64()
        }
        if type = Type.BitLiteral() {
            return Type.Bit()
        }
        if type.typeKind = Type.Kind.NULL {
            return Type.Any()
        }
        return type
    }

    method preferredType(expr:ASTNode):Type? {
        match expr {
            when ASTNode.BIT {
                return Type.Bit()
            }
            when ASTNode.INT {
                return Type.Int64()
            }
            when ASTNode.UNARY(_, op, base) {
                def baseType := preferredType(base)
                if baseType !== null {
                    def p := expr.position()
                     -- fake target, just used for matching
                    def target := IR.Value.REF(IR.Statement.ID(-1), baseType)
                    return preferredType(ASTNode.CALL(p,
                            ASTNode.DOT(p, ASTNode.IR_WRAPPER(p, target), op.asString),
                            FixedArray<ASTNode>()))
                }
            }
            when ASTNode.REAL {
                return Type.Real64()
            }
            when ASTNode.STRING {
                return Type.StringType()
            }
        }
        def possible := possibleTypes(expr)
        if possible == null {
            return null
        }
        if possible.count = 1 {
            return possible.iterator.next()
        }
        def best := Array<Type>()
        def bestCost := Int.MAX
        var foundInt := false
        for t in possible {
            if t = Type.Int64() {
                foundInt := true
            }
            def cost := coercionCost(expr, t)
            assert cost !== null
            if cost.second < bestCost {
                bestCost := cost.second
                best.clear()
            }
            if cost.second = bestCost {
                best.add(t)
            }
        }
        assert best.count != 0
        if best.count = 1 {
            return best[0]
        }
        if foundInt {
            return Type.Int64()
        }
        return null
    }

    function coercionCostUnresolvedParameters(a:Type, b:Type):Int? {
        if a = b {
            return 0
        }
        if b.typeKind = Type.Kind.GENERIC_METHOD_PARAMETER {
            return 0
        }
        if a.typeKind = b.typeKind & a.hasSubtypes & b.hasSubtypes &
                a.subtypes.count = b.subtypes.count {
            var total := 0
            for i in 0 .. a.subtypes.count {
                def cost := coercionCostUnresolvedParameters(a.subtypes[i], b.subtypes[i])
                if cost == null {
                    return null
                }
                total += cost
            }
            return total
        }
        return null
    }

    method coercionCost(type:Type, target:Type):Pair<Type, Int>? {
        assert type.resolved, "unresolved type '\{type}'"
        assert target.resolved, "unresolved type '\{target}'"
        if type = target {
            return Pair<Type, Int>(target, 0)
        }
        if type = Type.Void() {
            return null
        }
        if type.typeKind = Type.Kind.NULL {
            if target.typeKind = Type.Kind.NULLABLE {
                return Pair<Type, Int>(target, 0)
            }
            return null
        }
        if type.typeKind = Type.Kind.NULLABLE & target.typeKind != Type.Kind.NULLABLE {
            def result := coercionCost(type.subtypes[0], target)
            if result == null {
                return null
            }
            return Pair<Type, Int>(result.first, result.second + NULLABLE_TO_NONNULLABLE_CAST_COST)
        }
        match target.typeKind {
            when Type.Kind.NULLABLE {
                def result := coercionCost(type, target.subtypes[0])
                if result == null {
                    return null
                }
                return Pair<Type, Int>(result.first,
                        result.second + NONNULLABLE_TO_NULLABLE_CAST_COST)
            }
            when Type.Kind.GENERIC_CLASS_PARAMETER {
                return null
            }
            when Type.Kind.GENERIC_METHOD_PARAMETER {
                def raw := coercionCost(type, target.genericMethodParameter.bound)
                if raw == null {
                    return null
                }
                return Pair<Type, Int>(type, raw.second)
            }
            when Type.Kind.CLASS {
                if type.typeKind = Type.Kind.GENERIC {
                    return coercionCost(type.subtypes[0], target)
                }
            }
            when Type.Kind.GENERIC {
                if type.typeKind = Type.Kind.GENERIC & type.subtypes[0] = target.subtypes[0] {
                    -- generic casts normally have to be exact, but we make an exception for
                    -- unresolved method parameters
                    def result := coercionCostUnresolvedParameters(type, target)
                    if result !== null {
                        return Pair<Type, Int>(type, result)
                    }
                    return null
                }
                -- FIXME super hacky
                if type.typeKind = Type.Kind.TUPLE &
                        target.subtypes[0].name = "frost.core.Equatable" &
                        target.subtypes[1] = type &
                        getClass(type).name.startsWith("frost.core.EquatableTuple") |
                        getClass(type).name.startsWith("frost.core.KeyTuple") {
                    return Pair<Type, Int>(type, 0)
                }
                if type.typeKind = Type.Kind.TUPLE &
                        target.subtypes[0].name = "frost.collections.Key" &
                        target.subtypes[1] = type &
                        getClass(type).name.startsWith("frost.core.KeyTuple") {
                    return Pair<Type, Int>(type, 0)
                }
            }
        }
        if type.isMethod {
            if target.isMethod {
                if type.subtypes.count != target.subtypes.count {
                    return null
                }
                var total := 0
                def srcFunction:Bit
                def srcMutable:Bit
                match type.typeKind {
                    when Type.Kind.METHOD {
                        srcFunction := false
                        srcMutable := true
                    }
                    when Type.Kind.FUNCTION {
                        srcFunction := true
                        srcMutable := true
                    }
                    when Type.Kind.IMMUTABLE_METHOD {
                        srcFunction := false
                        srcMutable := false
                    }
                    when Type.Kind.IMMUTABLE_FUNCTION {
                        srcFunction := true
                        srcMutable := false
                    }
                }
                def targetFunction:Bit
                def targetMutable:Bit
                match target.typeKind {
                    when Type.Kind.METHOD {
                        targetFunction := false
                        targetMutable := true
                    }
                    when Type.Kind.FUNCTION {
                        targetFunction := true
                        targetMutable := true
                    }
                    when Type.Kind.IMMUTABLE_METHOD {
                        targetFunction := false
                        targetMutable := false
                    }
                    when Type.Kind.IMMUTABLE_FUNCTION {
                        targetFunction := true
                        targetMutable := false
                    }
                }
                if targetFunction & !srcFunction {
                    return null
                }
                if !targetMutable & srcMutable {
                    return null
                }
                if targetFunction != srcFunction {
                    total += 1
                }
                if targetMutable != srcMutable {
                    total += 1
                }
                for i in 0 .. type.parameterCount {
                    def cost := coercionCost(target.subtypes[i], type.subtypes[i])
                    if cost == null {
                        return null
                    }
                    total += cost.second
                }
                def cost := coercionCost(type.returnType, target.returnType)
                if cost == null {
                    return null
                }
                total += cost.second
                return Pair<Type, Int>(target, total)
            }
            if type.typeKind = Type.Kind.IMMUTABLE_METHOD |
                    type.typeKind = Type.Kind.IMMUTABLE_FUNCTION {
                def result := coercionCost(Type.Method(), target)
                if result !== null {
                    return result
                }
            }
            return coercionCost(Type.MutableMethod(), target)
        }
        match type.typeKind {
            when Type.Kind.BUILTIN_BIT {
                return coercionCost(Type.Bit(), target)
            }
            when Type.Kind.GENERIC_CLASS_PARAMETER {
                return coercionCost(type.genericClassParameter.bound, target)
            }
            when Type.Kind.GENERIC_METHOD_PARAMETER {
                return coercionCost(type.genericMethodParameter.bound, target)
            }
            when Type.Kind.TUPLE {
                if target.name = "frost.core.Tuple\{type.subtypes.count}" |
                        target.name = "frost.core.KeyTuple\{type.subtypes.count}" |
                        target.name = "frost.core.EquatableTuple\{type.subtypes.count}" {
                    return Pair<Type, Int>(target, 1)
                }
            }
        }
        if !target.isClass {
            return null
        }
        def targetCl := getClass(target)
        if targetCl == null {
            return null
        }
        for m in targetCl.methods {
            if m.annotations.isImplicit & m.parameters.count = 1 {
                resolve(m)
                if type = m.parameters[0].type {
                    -- FIXME I don't remember where this 6 came from. Figure this out, and if it's
                    -- necessary figure out what the right value is for it and use a named constant.
                    return Pair<Type, Int>(target, 6 - m.priority)
                }
            }
        }
        if !type.isClass {
            return null
        }
        def cl := getClass(type)
        if cl == null {
            return null
        }
        resolve(cl)
        if cl.resolved != Resolution.RESOLVED_WITH_ERRORS {
            if cl.rawSuper !== null {
                def cost := coercionCost(remapType(type, remapType(type, cl.rawSuper)), target)
                if cost !== null {
                    return Pair<Type, Int>(cost.first, cost.second + 1)
                }
            }
            for intf in cl.rawInterfaces {
                def cost := coercionCost(remapType(type, remapType(type, intf)), target)
                if cost !== null {
                    return Pair<Type, Int>(cost.first, cost.second + 1)
                }
            }
        }
        return null
    }

    method coercionCost(type:Type, target:TypeContext):Pair<Type, Int>? {
        match target {
            when TypeContext.UNSPECIFIED {
                return Pair<Type, Int>(type, 0)
            }
            when TypeContext.NON_VOID {
                if type = Type.Void() {
                    return null
                }
                return Pair<Type, Int>(type, 0)
            }
            when TypeContext.IMMUTABLE {
                if isImmutable(type) {
                    return Pair<Type, Int>(type, 0)
                }
                return null
            }
            when TypeContext.TYPE(t, _) {
                return coercionCost(type, t)
            }
        }
        unreachable
    }

    method coercionCost(types:CollectionView<Type>, target:Type):Pair<Type, Int>? {
        def best := Pair<Type, Int>(Type.Void(), Int.MAX)
        for t in types {
            def cost := coercionCost(t, target)
            if cost !== null & cost.second < best.second {
                best := cost
            }
        }
        if best.second != Int.MAX {
            return best
        }
        return null
    }

    method possibleMatches(methodTypes:CollectionView<Type>, args:ListView<ASTNode>,
            type:TypeContext):Pair<CollectionView<Type>, Int>? {
        var bestCost := Int.MAX
        def best := Array<Type>()
        outer: for raw in methodTypes {
            var m := raw.nonnullable()
            if m.methodRef !== null & m.methodRef.value.genericParameters !== null {
                def inferred := Call.performTypeInference(self, m.methodRef, args)
                m := Type(inferred)
            }
            if m.typeKind != Type.Kind.METHOD &
                    m.typeKind != Type.Kind.FUNCTION &
                    m.typeKind != Type.Kind.IMMUTABLE_METHOD &
                    m.typeKind != Type.Kind.IMMUTABLE_FUNCTION {
                continue
            }
            if m.subtypes.count != args.count + 1 {
                continue
            }
            var cost := -m.priority
            for i in 0 .. args.count {
                def argCost := coercionCost(args[i], m.subtypes[i])
                if argCost == null {
                    continue outer
                }
                cost += argCost.second
            }
            def returnType := m.returnType
            match type {
                when TypeContext.IMMUTABLE {
                    if returnType = Type.Void() | !isImmutable(returnType) {
                        continue
                    }
                }
                when TypeContext.TYPE(t, _) {
                    def returnCost := coercionCost(returnType, t)
                    if returnCost == null {
                        continue
                    }
                    cost += returnCost.second
                }
                when TypeContext.NON_VOID {
                    if returnType = Type.Void() {
                        continue
                    }
                }
            }
            if cost < bestCost {
                bestCost := cost
                best.clear()
            }
            if cost = bestCost {
                best.add(m)
            }
        }
        if best.count = 0 {
            return null
        }
        return Pair<CollectionView<Type>, Int>(best, bestCost)
    }

    method callCost(methodTypes:CollectionView<Type>, args:ListView<ASTNode>,
            type:TypeContext):Pair<Type, Int>? {
        def result := possibleMatches(methodTypes, args, type)
        if result !== null {
            -- we still might not actually be able to successfully perform the coercion, in the
            -- event that it's ambiguous, but for error reporting purposes we act like it's going to
            -- be ok right now
            return Pair<Type, Int>(result.first.iterator.next().returnType, result.second)
        }
        return null
    }

    function isClassContext():Bit {
        return currentMethod[0].annotations.isClass
    }

    function symbolType(target:Type?, s:Symbol):ListView<Type>? {
        return symbolType(target, s, null)
    }

    function symbolType(target:Type?, s:Symbol,
            genericArguments:ListView<ASTNode>?):ListView<Type>? {
        def result := Array<Type>()
        def resolvedArguments:Array<Type>?
        if genericArguments !== null {
            resolvedArguments := Array<Type>()
            for p in genericArguments {
                def resolved := resolve(scanner.convertType(p))
                if resolved == null {
                    return null
                }
                resolvedArguments.add(resolved)
            }
        }
        match s.kind {
            when Symbol.Kind.ALIAS {
                result.add(Type.ClassLiteral(resolve(s->Alias.type)))
            }
            when Symbol.Kind.CHOICE_CASE {
                def cc := s->ChoiceCase
                if cc.fields.count > 0 {
                    result.add(Type.methodType(s.position, Type.Kind.IMMUTABLE_FUNCTION, cc.fields,
                            cc.owner.type, 0))
                }
                else {
                    result.add(cc.owner.type)
                }
            }
            when Symbol.Kind.FIELD {
                def f := s->FieldDecl
                if resolve(f) {
                    def type:Type
                    if f.annotations.isWeak {
                        type := f.type.subtypes[1]
                    }
                    else {
                        type := f.type
                    }
                    if target !== null {
                        def found := findType(target, f.owner)
                        result.add(remapType(found, type))
                    }
                    else {
                        result.add(type)
                    }
                }
                else {
                    return null
                }
            }
            when Symbol.Kind.METHOD {
                def m := s->MethodDecl
                if !resolve(m) {
                    return null
                }
                if target !== null {
                    result.add(Type(MethodRef(self, target, m, resolvedArguments)))
                }
                else {
                    def implicitTarget:Type
                    if isClassContext() {
                        implicitTarget := Type.ClassLiteral(currentClass[0].type)
                    }
                    else {
                        implicitTarget := currentClass[0].type
                    }
                    result.add(Type(MethodRef(self, implicitTarget, m, resolvedArguments)))
                }
            }
            when Symbol.Kind.METHODS {
                for m in s->Methods.methods { -- FIXME use map
                    if resolve(m) {
                        if m.annotations.isClass {
                            result.add(Type(MethodRef(self, Type.ClassLiteral(m.owner.type), m,
                                    resolvedArguments)))
                        }
                        else if target !== null {
                            result.add(Type(MethodRef(self, target, m, resolvedArguments)))
                        }
                        else {
                            def implicitTarget:Type
                            if isClassContext() {
                                implicitTarget := Type.ClassLiteral(currentClass[0].type)
                            }
                            else {
                                implicitTarget := currentClass[0].type
                            }
                            result.add(Type(MethodRef(self, implicitTarget, m,
                                    resolvedArguments)))
                        }
                    }
                }
            }
            when Symbol.Kind.VARIABLE {
                result.add(s->Variable.type)
            }
            otherwise {
                unreachable
            }
        }
        return result    
    }

    method dotTypes(base:Type, name:String):ListView<Type>? {
        return dotTypes(base, name, null)
    }

    method dotTypes(base:Type, name:String, genericArguments:ListView<ASTNode>?):ListView<Type>? {
        if base.isClass {
            def cl:ClassDecl
            def isClass := base.isClassLiteral
            if isClass {
                -- class literal, grab the class itself rather than frost.core.Class
                cl := getClass(base.subtypes[1])
            }
            else {
                cl := getClass(base)
            }
            if cl == null {
                return null
            }
            def symbol := getSymbolTable(cl)[name]
            if symbol == null {
                return null
            }
            return symbolType(base, symbol, genericArguments)
        }
        return null
    }

    method identifierType(name:String):ListView<Type>? {
        return identifierType(name, null)
    }

    method identifierType(name:String, genericArguments:ListView<ASTNode>?):ListView<Type>? {
        def s := symbolTable[name]
        if s !== null {
            return symbolType(null, s, genericArguments)
        }
        def cl := tryResolveClass(name)
        if cl !== null {
            def result := Array<Type>()
            result.add(Type.ClassLiteral(cl.type))
            return result
        }
        return null
    }

    method getText(value:ASTNode):String? {
        match value {
            when ASTNode.DOT(_, base, name) {
                def baseText := getText(base)
                if baseText == null {
                    return null
                }
                return "\{baseText}.\{name}"
            }
            when ASTNode.IDENTIFIER(_, name) {
                return name
            }
            otherwise {
                return null
            }
        }
    }

    ================================================================================================
    If `value` represents a valid type, returns the corresponding [Type]. Otherwise returns `null`
    without reporting an error.
    ================================================================================================
    method tryResolveType(value:ASTNode):Type? {
        return tryResolveType(value, true)
    }

    ================================================================================================
    As [tryResolveType(ASTNode)], but allows the validity check for generic arguments to be
    disabled.
    ================================================================================================
    @post(errorCount = @pre(errorCount))
    method tryResolveType(value:ASTNode, checkGenericArguments:Bit):Type? {
        match value {
            when ASTNode.IDENTIFIER(position, text) {
                return tryResolveType(ASTNode.TYPE(position, text), checkGenericArguments)
            }
            when ASTNode.DOT(position, base, name) {
                def text := getText(base)
                if text !== null {
                    return tryResolveType(ASTNode.TYPE(position, "\{text}.\{name}"),
                            checkGenericArguments)
                }
                return null
            }
            when ASTNode.DOT_GENERICS(position, base, name, types) {
                def text := getText(base)
                if text !== null {
                    return tryResolveType(ASTNode.GENERIC_TYPE(position, "\{text}.\{name}", types),
                            checkGenericArguments)
                }
                return null
            }
        }
        def old := reportErrors
        reportErrors := false
        def result := resolve(scanner.convertType(value), checkGenericArguments)
        reportErrors := old
        return result
    }

    method rangePreferredType(start:ASTNode?, end:ASTNode?, step:ASTNode?):Type? {
        if step !== null {
            def pref := preferredType(step)
            if pref == null {
                return null
            }
            if pref.isReal {
                if start !== null & end !== null {
                    return Type.SteppedRangeOf(pref, pref)
                }
                return Type.SteppedRangeOf(pref.nullable(), pref)
            }
        }
        var endpointType:Type? := null
        if start !== null {
            def endpointType:Type
            def pref1:Type?
            match start {
                when ASTNode.STRING {
                    -- must be a char literal
                    if end !== null {
                        -- not sure if it's 8, 16, or 32 bits - try to match the type of the
                        -- other endpoint
                        def pref2 := preferredType(end)
                        if pref2 !== null & pref2.isChar {
                            pref1 := pref2
                        }
                        else {
                            pref1 := Type.Char32()
                        }
                    }
                    else {
                        pref1 := Type.Char32()
                    }
                }
                otherwise {
                    pref1 := preferredType(start)
                }
            }
            if pref1 == null {
                return null
            }
            if end !== null {
                def pref2:Type?
                match end {
                    when ASTNode.STRING {
                        if pref1.isChar {
                            -- not sure if it's 8, 16, or 32 bits - try to match the type of the
                            -- other endpoint
                            pref2 := pref1
                        }
                        else {
                            pref2 := Type.Char32()
                        }
                    }
                    otherwise {
                        pref2 := preferredType(end)
                    }
                }
                if pref2 == null {
                    return null
                }
                endpointType := pref1.union(self, pref2)
            }
            else {
                endpointType := pref1.nullable()
            }
            if step !== null {
                return Type.SteppedRangeOf(endpointType)
            }
            return Type.RangeOf(endpointType)
        }
        else if end !== null {
            def pref:Type
            match end {
                when ASTNode.STRING {
                    pref := Type.Char32()
                }
                otherwise {
                    pref := preferredType(end)
                }
            }
            if pref == null {
                return null
            }
            if step !== null {
                return Type.SteppedRangeOf(pref)
            }
            return Type.RangeOf(pref)
        }
        if step !== null {
            return Type.SteppedRangeOf(Type.Int64().nullable())
        }
        return Type.RangeOf(Type.Int64().nullable())
    }

    ================================================================================================
    Returns the size in bits of the smallest Char type that can this codepoint.
    ================================================================================================
    function smallestCharSize(char:Char32):Int {
        def v := char.asInt32
        if v <= 255 {
            return 8
        }
        if v <= 65535 {
            return 16
        }
        return 32
    }

    function isTuple(cl:ClassDecl):Bit {
        return cl.name.startsWith("frost.core.Tuple") | cl.name.startsWith("frost.core.KeyTuple") |
                cl.name.startsWith("frost.core.EquatableTuple")
    }

    function computeBinaryType(left:ASTNode, op:Binary.Operator, right:ASTNode):ListView<Type>? {
        match op {
            when Binary.Operator.CAST {
                def rawTarget := scanner.convertType(right)
                def index := rawTarget.name.lastIndexOf(".")
                if rawTarget.typeKind = Type.Kind.CLASS & index !== null {
                    -- we have a dotted name which might not be entirely a type - for example we
                    -- might have 'o->String.length'. This is obviously meant to be a cast to String
                    -- followed by a call to get_length(), but syntactically it could just as easily
                    -- be a cast to a class named String.length. We need to disambiguate these cases
                    -- here.
                    def old := reportErrors
                    reportErrors := false
                    def type := resolve(rawTarget)
                    reportErrors := old
                    if type == null {
                        def base := computeBinaryType(left, op,
                                ASTNode.TYPE(rawTarget.position, rawTarget.name[..index]))
                        if base == null {
                            return null
                        }
                        def result := Array<Type>()
                        for t in base {
                            def types := dotTypes(t, rawTarget.name[rawTarget.name.next(index)..])
                            if types !== null {
                                result.addAll(types)
                            }
                        }
                        if result.count = 0 {
                            return null
                        }
                        return result
                    }
                }
                def target := tryResolveType(right)
                if target == null {
                    return null
                }
                def types := possibleTypes(left)
                if types == null {
                    return null
                }
                var found := false
                for t in types {
                    if canCast(t, target) {
                        found := true
                        break
                    }
                }
                if !found {
                    if target.isBuiltinNumber {
                        def preferred := preferredType(left)
                        if preferred == null | !preferred.isBuiltinNumber {
                            return null
                        }
                    }
                    else {
                        return null
                    }
                }
                return [target]
            }
            when Binary.Operator.IDENTITY, Binary.Operator.NIDENTITY {
                return [Type.Bit()]
            }
            otherwise {
                def matches := Binary.findOverloadedOperator(self, left, op, right,
                        TypeContext.NON_VOID)
                if matches !== null {
                    if op = Binary.Operator.INDEX & matches.first.count = 1 &
                            isTuple(matches.first[0].value.owner) {
                        return [Tuple.indexType(self, matches.first[0].target, right)]
                    }
                    def result := Array<Type>()
                    for m in matches.first { -- FIXME map
                        result.add(m.returnType)
                    }
                    return result
                }
                def type := preferredType(left)
                if type == null {
                    return null
                }
                if coercionCost(right, type) == null {
                    return null
                }
                if type = Type.BuiltinBit() {
                    match op {
                        when Binary.Operator.AND, Binary.Operator.OR, Binary.Operator.XOR,
                                Binary.Operator.EQ, Binary.Operator.NEQ {
                            return [Type.BuiltinBit()]
                        }
                    }
                }
                -- this is a bit sloppy and allows for illegal operations like Real32 << Real32,
                -- but since nobody outside of the compiler itself should be using builtin
                -- types, it's not a big deal
                if type.isBuiltinNumber {
                    match op {
                        when Binary.Operator.ADD, Binary.Operator.SUB, Binary.Operator.MUL,
                                Binary.Operator.DIV, Binary.Operator.INTDIV, Binary.Operator.REM,
                                Binary.Operator.BITWISEOR, Binary.Operator.BITWISEAND,
                                Binary.Operator.BITWISEXOR, Binary.Operator.SHIFTLEFT,
                                Binary.Operator.SHIFTRIGHT {
                            return [type]
                        }
                        when Binary.Operator.EQ, Binary.Operator.NEQ, Binary.Operator.GT,
                                Binary.Operator.LT, Binary.Operator.GTEQ, Binary.Operator.LTEQ {
                            return [Type.BuiltinBit()]
                        }
                    }
                }
                return null
            }
        }
    }

    function binaryType(position:Position, left:ASTNode, op:Binary.Operator,
            right:ASTNode):ListView<Type>? {
        def key := BinaryKey(left, op, right)
        if binaryTypes.contains(key) {
            return binaryTypes[key]
        }
        def result := computeBinaryType(left, op, right)
        binaryTypes[key] := result
        return result
    }

    ================================================================================================
    Returns the types we should consider this expression to potentially be when evaluating method
    calls and field accesses against it. This is not always (nor could it reasonably be) an
    exhaustive list.

    This method does not generate errors for the expression in question, but may generate other
    one-time errors (for instance, it may be unable to load a class or resolve a field).
    ================================================================================================
    method possibleTypes(value:ASTNode):CollectionView<Type>? {
        match value {
            when ASTNode.ARRAY(_, elements) {
                def result := Array<Type>()
                if elements.count != 0 {
                    var union := preferredType(elements[0])
                    if union !== null {
                        for i in 1 .. elements.count {
                            def type := preferredType(elements[i])
                            if type == null {
                                result.add(Type.ArrayOf(Type.Any()))
                                return result
                            }
                            union := union.union(self, type)
                        }
                        result.add(Type.ArrayOf(union))
                        return result
                    }
                }
                result.add(Type.ArrayOf(Type.Any()))
                return result
            }
            when ASTNode.AT_PRE(_, expr) {
                return possibleTypes(expr)
            }
            when ASTNode.AT_RETURN {
                return [currentMethod[0].returnType]
            }
            when ASTNode.BINARY(position, left, op, right) {
                return binaryType(position, left, op, right)
            }
            when ASTNode.BIT {
                return [Type.Bit(), Type.BuiltinBit()]
            }
            when ASTNode.CALL(_, m, args) {
                def methodTypes := possibleTypes(m)
                if methodTypes == null {
                    return null
                }
                if methodTypes.count = 1 {
                    def t := methodTypes.iterator.next()
                    if t.isClass {
                        def cl := getClass(t)
                        if cl !== null & cl.classKind = ClassDecl.Kind.CHOICE {
                            -- choice case
                            return [t]
                        }
                    }
                    if t.typeKind = Type.Kind.GENERIC & t.subtypes[0] = Type.Class() {
                        -- calling a class literal, this is actually object construction
                        return [t.subtypes[1]]
                    }
                }
                def result := possibleMatches(methodTypes, args, TypeContext.NON_VOID)
                if result !== null {
                    def resultTypes := HashSet<Type>()
                    for m in result.first {
                        resultTypes.add(m.returnType)
                    }
                    return resultTypes
                }
                return null
            }
            when ASTNode.DOT(position, base, name) {
                def type := tryResolveType(value)
                if type !== null {
                    def result := Array<Type>() -- FIXME literal
                    result.add(Type.ClassLiteral(type))
                    return result
                }
                def result:Array<Type>? := null
                def baseTypes := possibleTypes(base)
                if baseTypes == null {
                    return null
                }
                for t in baseTypes {
                    def list := dotTypes(t, name)
                    if list !== null {
                        if result == null {
                            result := Array<Type>()
                        }
                        result.addAll(list)
                    }
                }
                return result
            }
            when ASTNode.DOT_GENERICS(position, base, name, genericArguments) {
                def t := tryResolveType(value)
                if t !== null {
                    return [Type.ClassLiteral(t)]
                }
                def result:Array<Type>? := null
                def baseTypes := possibleTypes(base)
                if baseTypes == null {
                    return null
                }
                for t in baseTypes {
                    def list := dotTypes(t, name, genericArguments)
                    if list !== null {
                        if result == null {
                            result := Array<Type>()
                        }
                        result.addAll(list)
                    }
                }
                return result
            }
            when ASTNode.GENERIC_TYPE(position, name, types) {
                def resolved := tryResolveType(value)
                if resolved !== null {
                    assert !resolved.isClassLiteral
                    return [Type.ClassLiteral(resolved)]
                }
                -- not a type, might be a function call with explicit generics
                def components := name.split(".")
                var effective:ASTNode
                if components.count = 1 {
                    effective := ASTNode.IDENTIFIER_GENERICS(position, name, types)
                }
                else {
                    effective := ASTNode.IDENTIFIER(position, components[0])
                    for i in 1 .. components.count - 1 {
                        effective := ASTNode.DOT(position, effective, components[i])
                    }
                    effective := ASTNode.DOT_GENERICS(position, effective,
                            components[components.count - 1], types)
                }
                return possibleTypes(effective)
            }
            when ASTNode.IDENTIFIER(_, name) {
                return identifierType(name)
            }
            when ASTNode.IDENTIFIER_GENERICS(_, name, types) {
                return identifierType(name, types)
            }
            when ASTNode.INT(_, value) {
                def result := Array<Type>()
                def signedValue := value.asInt64
                if signedValue >= Int8.MIN.asInt64 & signedValue <= Int8.MAX.asInt64 {
                    result.add(Type.BuiltinInt8())
                    result.add(Type.Int8())
                }
                if signedValue >= Int16.MIN.asInt64 & signedValue <= Int16.MAX.asInt64 {
                    result.add(Type.BuiltinInt16())
                    result.add(Type.Int16())
                }
                if signedValue >= Int32.MIN.asInt64 & signedValue <= Int32.MAX.asInt64 {
                    result.add(Type.BuiltinInt32())
                    result.add(Type.Int32())
                }
                result.add(Type.BuiltinInt64())
                result.add(Type.Int64())
                if value >= UInt8.MIN.asUInt64 & value <= UInt8.MAX.asUInt64 {
                    result.add(Type.BuiltinUInt8())
                    result.add(Type.UInt8())
                }
                if value >= UInt16.MIN.asUInt64 & value <= UInt16.MAX.asUInt64 {
                    result.add(Type.BuiltinUInt16())
                    result.add(Type.UInt16())
                }
                if value >= UInt32.MIN.asUInt64 & value <= UInt32.MAX.asUInt64 {
                    result.add(Type.BuiltinUInt32())
                    result.add(Type.UInt32())
                }
                result.add(Type.BuiltinUInt64())
                result.add(Type.UInt64())
                result.add(Type.Real32())
                result.add(Type.Real64())
                return result
            }
            when ASTNode.IR_WRAPPER(_, node) {
                return [node.type()]
            }
            when ASTNode.METHOD {
                return null
            }
            when ASTNode.NULL {
                return [Type.Any()]
            }
            when ASTNode.UNARY(position, op, operand) {
                return possibleTypes(ASTNode.CALL(position,
                        ASTNode.DOT(position, operand, op.asString),
                        FixedArray<ASTNode>()))
            }
            when ASTNode.RANGE(_, start, _, end, step) {
                def result := rangePreferredType(start, end, step)
                if result == null {
                    return null
                }
                return [result]
            }
            when ASTNode.REAL {
                return [Type.BuiltinFloat32(), Type.BuiltinFloat64(), Type.Real32(), Type.Real64()]
            }
            when ASTNode.REGEX {
                return [Type.RegularExpression()]
            }
            when ASTNode.SELF {
                var s := symbolTable[CAPTURED_SELF_NAME]
                if s == null {
                    s := symbolTable[SELF_NAME]
                }
                if s == null {
                    return null
                }
                return symbolType(null, s)
            }
            when ASTNode.SUPER {
                var s := symbolTable[CAPTURED_SELF_NAME]
                if s == null {
                    s := symbolTable[SELF_NAME]
                }
                if s == null {
                    return null
                }
                def result := Array<Type>()
                def type:Type
                match s.kind {
                    when Symbol.Kind.VARIABLE {
                        type := s->Variable.type
                    }
                    when Symbol.Kind.FIELD {
                        type := s->FieldDecl.type
                    }
                    otherwise {
                        unreachable
                    }
                }
                def cl := getClass(type)
                if !resolve(cl) {
                    return null
                }
                result.add(remapType(type, cl.rawSuper))
                return result
            }
            when ASTNode.STRING(_, text) {
                def result := Array<Type>()
                result.add(Type.StringType())
                if text.length = 1 {
                    def size := smallestCharSize(text[0])
                    if size = 8 {
                        result.add(Type.Char8())
                    }
                    if size <= 16 {
                        result.add(Type.Char16())
                    }
                    result.add(Type.Char32())
                }
                return result
            }
            when ASTNode.TUPLE(_, args) {
                return Tuple.possibleTypes(self, args)
            }
            when ASTNode.TYPE {
                def resolved := tryResolveType(value)
                if resolved !== null {
                    assert !resolved.isClassLiteral
                    return [Type.ClassLiteral(resolved)]
                }
                return null
            }
            when ASTNode.TYPED_LAMBDA(position, parameters, body) {
                def parameterTypes := Array<Type>()
                for p in parameters {
                    match p {
                        when ASTNode.PARAMETER(_, _, type) {
                            def resolved := tryResolveType(type)
                            if resolved == null {
                                return null
                            }
                            parameterTypes.add(resolved)
                        }
                    }
                }
                def lambdaType := Closure.typedLambdaType(self, parameters, body,
                        TypeContext.NON_VOID)
                if lambdaType == null {
                    return null
                }
                return [lambdaType]
            }
            when ASTNode.UNTYPED_LAMBDA {
                return null
            }
            otherwise {
                unreachable, "unsupported possibleType: \{value}:\{value.position()}"
            }
        }
        unreachable
    }

    method binaryCost(left:ASTNode, op:Binary.Operator, right:ASTNode,
            type:TypeContext):Pair<Type, Int>? {
        if op = Binary.Operator.CAST {
            def target := tryResolveType(right)
            if target == null {
                return null
            }
            if coercionCost(left, target) == null {
                if target.isBuiltinNumber {
                    def leftType := preferredType(left)
                    if leftType == null | !leftType.isBuiltinNumber {
                        return null
                    }
                }
                else {
                    return null
                }
            }
            return coercionCost(target, type)
        }
        def result := Binary.findOverloadedOperator(self, left, op, right, type)
        if result !== null {
            return Pair<Type, Int>(result.first[0].returnType, result.second)
        }
        def preferred := preferredType(ASTNode.BINARY(left.position(), left, op, right))
        if preferred !== null {
            return coercionCost(preferred, type)
        }
        return null
    }

    method rangeCoercionCost(start:ASTNode?, end:ASTNode?, step:ASTNode?,
            target:Type):Pair<Type, Int>? {
        if target.typeKind = Type.Kind.NULLABLE {
            def result := rangeCoercionCost(start, end, step, target.nonnullable())
            if result == null {
                return null
            }
            return Pair<Type, Int>(result.first, result.second + 1)
        }
        if target.typeKind = Type.Kind.GENERIC {
            if target.subtypes[0].name = RANGE_NAME & target.subtypes.count = 2 |
                    target.subtypes[0].name = STEPPED_RANGE_NAME & target.subtypes.count = 3 {
                var cost := 0
                if start !== null {
                    def startCost := coercionCost(start, target.subtypes[1])
                    if startCost == null {
                        return null
                    }
                    cost += startCost.second
                }
                else if target.subtypes[1].typeKind != Type.Kind.NULLABLE {
                    return null
                }
                if end !== null {
                    def endCost := coercionCost(end, target.subtypes[1])
                    if endCost == null {
                        return null
                    }
                    cost += endCost.second
                }
                else if target.subtypes[1].typeKind != Type.Kind.NULLABLE {
                    return null
                }
                if target.subtypes[0].name = RANGE_NAME {
                    if step !== null {
                        return null
                    }
                }
                else {
                    if step == null {
                        return null
                    }
                    def stepCost := coercionCost(step, target.subtypes[2])
                    if stepCost == null {
                        return null
                    }
                    cost += stepCost.second
                }
                return Pair<Type, Int>(target, cost)
            }
        }
        def type := preferredType(ASTNode.RANGE(Position(), start, true, end, step))
        if type == null {
            return null
        }
        return coercionCost(type, target)
    }

    method typedLambdaCoercionCost(parameters:ListView<ASTNode>, body:ASTNode,
            target:Type):Pair<Type, Int>? {
        if !target.nonnullable().isMethod {
            return coercionCost(Type.MutableMethod(), target)
        }
        if target.typeKind = Type.Kind.NULLABLE {
            def result := typedLambdaCoercionCost(parameters, body, target.nonnullable())
            if result == null {
                return null
            }
            return Pair<Type, Int>(result.first, result.second + NONNULLABLE_TO_NULLABLE_CAST_COST)
        }
        if target.parameterCount != parameters.count {
            return null
        }
        var cost := 0
        for i in 0 .. parameters.count {
            match parameters[i] {
                when ASTNode.PARAMETER(_, _, type) {
                    def resolved := tryResolveType(type)
                    if resolved == null {
                        return null
                    }
                    def parameterCost := coercionCost(target.parameterType(i), resolved)
                    if parameterCost == null {
                        return null
                    }
                    cost += parameterCost.second
                }
            }
        }
        def type := Closure.typedLambdaType(self, parameters, body, TypeContext.TYPE(target, false))
        if type == null {
            return null
        }
        def returnCost := coercionCost(type.returnType, target.returnType)
        assert returnCost !== null
        cost += returnCost.second
        return Pair<Type, Int>(type, cost)
    }

    method untypedLambdaCoercionCost(parameters:ListView<ASTNode>, body:ASTNode,
            target:Type):Pair<Type, Int>? {
        if !target.nonnullable().isMethod {
            return coercionCost(Type.MutableMethod(), target)
        }
        if target.typeKind = Type.Kind.NULLABLE {
            def result := untypedLambdaCoercionCost(parameters, body, target.nonnullable())
            if result == null {
                return null
            }
            return Pair<Type, Int>(result.first, result.second + NONNULLABLE_TO_NULLABLE_CAST_COST)
        }
        if target.parameterCount != parameters.count {
            return null
        }
        def typedParameters := Array<ASTNode>()
        for i in 0 .. parameters.count {
            match parameters[i] {
                when ASTNode.IDENTIFIER(position, name) {
                    typedParameters.add(ASTNode.PARAMETER(position, name,
                            ASTNode.IR_WRAPPER(position, IR.Value.TYPE(target.parameterType(i)))))
                }
                otherwise {
                    unreachable
                }
            }
        }
        def result := typedLambdaCoercionCost(typedParameters, body, target)
        if result == null {
            var list := lambdaTypes[body]
            if list == null {
                list := HashSet<Type>()
                lambdaTypes[body] := list
            }
            list.add(target)
        }
        return result
    }

    method arrayCoercionCost(position:Position, elements:FixedArray<ASTNode>,
            target:Type):Pair<Type, Int>? {
        def t := getListType(target)
        if t == null {
            def p := preferredType(ASTNode.ARRAY(position, elements))
            if p == null {
                return null
            }
            return coercionCost(p, target)
        }
        if t.first {
            return coercionCost(Type.ArrayOf(t.second), target)
        }
        else {
            return coercionCost(Type.ImmutableArrayOf(t.second), target)
        }
    }

    @pre(target.resolved)
    method computeCoercionCost(expr:ASTNode, target:Type):Pair<Type, Int>? {
        match expr {
            when ASTNode.ARRAY(position, elements) {
                return arrayCoercionCost(position, elements, target)
            }
            when ASTNode.AT_PRE(_, expr) {
                return coercionCost(expr, target)
            }
            when ASTNode.AT_RETURN {
                return coercionCost(currentMethod[0].returnType, target)
            }
            when ASTNode.BINARY(_, left, op, right) {
                match op {
                    when Binary.Operator.CAST {
                        def types := possibleTypes(expr)
                        if types == null {
                            return null
                        }
                        return coercionCost(types, target)
                    }
                    when Binary.Operator.IDENTITY, Binary.Operator.NIDENTITY {
                        return coercionCost(Type.Bit(), target)
                    }
                    otherwise {
                        return binaryCost(left, op, right, TypeContext.TYPE(target, false))
                    }
                }
            }
            when ASTNode.BIT {
                def result := coercionCost(Type.Bit(), target)
                if result !== null {
                    return result
                }
                return coercionCost(Type.BuiltinBit(), target)
            }
            when ASTNode.CALL(_, m, args) {
                var methodTypes := possibleTypes(m)
                if methodTypes == null {
                    return null
                }
                if methodTypes.count = 1 {
                    def t := methodTypes.iterator.next()
                    if t.isClassLiteral {
                        def resultCost := coercionCost(t.subtypes[1], target)
                        if resultCost == null {
                            return null
                        }
                        methodTypes := possibleTypes(ASTNode.DOT(m.position(), m, "init"))
                        if methodTypes == null {
                            return null
                        }
                        def callCost := callCost(methodTypes, args, TypeContext.UNSPECIFIED)
                        if callCost == null {
                            return null
                        }
                        return Pair<Type, Int>(resultCost.first, callCost.second +
                                resultCost.second)
                    }
                }
                return callCost(methodTypes, args, TypeContext.TYPE(target, false))
            }
            when ASTNode.DOT, ASTNode.DOT_GENERICS {
                def types := possibleTypes(expr)
                if types == null {
                    return null
                }
                return coercionCost(types, target)
            }
            when ASTNode.IDENTIFIER(_, name) {
                def types := identifierType(name)
                if types == null {
                    return null
                }
                return coercionCost(types, target)
            }
            when ASTNode.IDENTIFIER_GENERICS(_, name, genericArguments) {
                def types := identifierType(name, genericArguments)
                if types == null {
                    return null
                }
                return coercionCost(types, target)
            }
            when ASTNode.INT(_, value) {
                if (target.typeKind = Type.Kind.BUILTIN_INT &
                        IntLiteral.requiredSize(value.asInt64) <= target.size) |
                        (target.typeKind = Type.Kind.BUILTIN_UINT &
                        IntLiteral.requiredSize(value) <= target.size) {
                    return Pair<Type, Int>(target, 0)
                }
                if target.typeKind = Type.Kind.BUILTIN_FLOAT {
                    return Pair<Type, Int>(target, 1)
                }
                if target.isNumber {
                    def cl := getClass(target)
                    assert cl !== null
                    def initMethod := cl.methods[0]
                    assert initMethod.methodKind = MethodDecl.Kind.INIT
                    assert initMethod.annotations.isImplicit
                    -- FIXME figure out where this 2 came from and whether it's the right value,
                    -- make it a constant if it's necessarys
                    return Pair<Type, Int>(target, 2 - initMethod.priority)
                }
                def preferred := preferredType(expr)
                assert preferred !== null
                return coercionCost(preferred, target)
            }
            when ASTNode.IR_WRAPPER(_, ir) {
                return coercionCost(ir.type(), target)
            }
            when ASTNode.METHOD(position, _, _, kind, _, _, parameters, returnType, _) {
                def paramTypes := Array<Type>()
                for p in parameters { -- FIXME map
                    match p {
                        when ASTNode.PARAMETER(_, _, type) {
                            def resolved := tryResolveType(type)
                            if resolved == null {
                                return null
                            }
                            paramTypes.add(resolved)
                        }
                        otherwise {
                            unreachable
                        }
                    }
                }
                def resolvedReturnType:Type
                if returnType !== null {
                    resolvedReturnType := tryResolveType(returnType)
                    if resolvedReturnType == null {
                        return null
                    }
                }
                else {
                    resolvedReturnType := Type.Void()
                }
                def typeKind:Type.Kind
                -- we don't actually know whether the method has any captures yet (it might turn
                -- out to be mutable), but we assume it's immutable here and let it error later if
                -- that turns out to be a problem
                if kind = MethodDecl.Kind.FUNCTION {
                    typeKind := Type.Kind.IMMUTABLE_FUNCTION
                }
                else {
                    assert kind = MethodDecl.Kind.METHOD
                    typeKind := Type.Kind.IMMUTABLE_METHOD
                }
                return coercionCost(Type.methodType(position, typeKind, paramTypes,
                        resolvedReturnType, 0), target)
            }
            when ASTNode.NULL {
                if target.typeKind = Type.Kind.NULLABLE {
                    return Pair<Type, Int>(target, 0)
                }
                return null
            }
            when ASTNode.RANGE(_, start, _, end, step) {
                return rangeCoercionCost(start, end, step, target)
            }
            when ASTNode.REAL {
                if (target.typeKind = Type.Kind.BUILTIN_FLOAT) {
                    return Pair<Type, Int>(target, 0)
                }
                if target.isReal {
                    return Pair<Type, Int>(target, 1)
                }
                def preferred := preferredType(expr)
                assert preferred !== null
                return coercionCost(preferred, target)
            }
            when ASTNode.REGEX {
                return coercionCost(Type.RegularExpression(), target)
            }
            when ASTNode.SELF {
                return coercionCost(currentClass[0].typeWithParameters(), target)
            }
            when ASTNode.STRING(_, text) {
                if target.isChar & text.length = 1 {
                    def size := smallestCharSize(text[0])
                    def targetSize:Int
                    match target {
                        when Type.Char8()  { targetSize := 8 }
                        when Type.Char16() { targetSize := 16 }
                        when Type.Char32() { targetSize := 32 }
                    }
                    if targetSize >= size {
                        return Pair<Type, Int>(target, 1)
                    }
                    return null
                }
                if target == Type.Value() & text.length = 1 {
                    return Pair<Type, Int>(target, 1)
                }
                return coercionCost(Type.StringType(), target)
            }
            when ASTNode.TUPLE(_, args) {
                return Tuple.coercionCost(self, args, target)
            }
            when ASTNode.TYPED_LAMBDA(_, parameters, body) {
                return typedLambdaCoercionCost(parameters, body, target)
            }
            when ASTNode.UNARY(position, op, operand) {
                -- need to special-case things like -128, which can fit into an Int8 despite 128 not
                -- doing so
                if op = Unary.Operator.NEGATE {
                    match operand {
                        when ASTNode.INT(_, value) {
                            if value = 128 {
                                return coercionCost(Type.BuiltinInt8(), target)
                            }
                            if value = 32768 {
                                return coercionCost(Type.BuiltinInt16(), target)
                            }
                            if value = 2147483648 {
                                return coercionCost(Type.BuiltinInt32(), target)
                            }
                        }
                    }
                }
                def preferred := preferredType(operand)
                if preferred !== null & (preferred = Type.BuiltinBit() |
                        preferred.isBuiltinNumber) {
                    return coercionCost(preferred, target)
                }
                return coercionCost(ASTNode.CALL(position,
                        ASTNode.DOT(position, operand, op.asString),
                            FixedArray<ASTNode>()),
                        target)
            }
            when ASTNode.UNTYPED_LAMBDA(_, parameters, body) {
                return untypedLambdaCoercionCost(parameters, body, target)
            }
            otherwise {
                unreachable
            }
        }
    }

    ================================================================================================
    Returns the cost of coercing the expression to the specified type, along with the actual type
    that will result (which is generally `target`, but may be a different type if `target` had
    unspecified method generic parameters).
    ================================================================================================
    @pre(target.resolved)
    method coercionCost(expr:ASTNode, target:Type):Pair<Type, Int>? {
        def key := CoercionKey(expr, target)
        var cached := coercionCosts[key]
        if cached !== null {
            if cached.second = -1 {
                return null
            }
            return cached
        }
        def result := computeCoercionCost(expr, target)
        if result == null {
            coercionCosts[key] := Pair<Type, Int>(Type.Void(), -1)
        }
        return result
    }

    method coercionCost(expr:ASTNode, target:TypeContext):Pair<Type, Int>? {
        match target {
            when TypeContext.UNSPECIFIED, TypeContext.NON_VOID {
                return coercionCost(expr, Type.Any())
            }
            when TypeContext.TYPE(type, _) {
                return coercionCost(expr, type)
            }
            when TypeContext.IMMUTABLE {
                return coercionCost(expr, Type.Immutable())
            }
            otherwise {
                unreachable
            }
        }
    }

    method canCast(type:Type, target:Type):Bit {
        if type.isPointer & (target.isPointer | target.nonnullable().isMethod) {
            return true
        }
        if coercionCost(type, target) !== null {
            return true
        }
        if type.isBuiltinNumber & target.isBuiltinNumber {
            return true
        }
        if type.typeKind = Type.Kind.GENERIC_CLASS_PARAMETER {
            return canCast(type.genericClassParameter.bound, target)
        }
        if type.typeKind = Type.Kind.GENERIC_METHOD_PARAMETER {
            return canCast(type.genericMethodParameter.bound, target)
        }
        if type.typeKind = Type.Kind.INVALID {
            return false
        }
        return coercionCost(target, type) !== null
    }

    -- FIXME figure out how to handle list comparisons
    function equal(a:ListView<Type>, b:ListView<Type>):Bit {
        if a.count != b.count {
            return false
        }
        for i in 0 .. a.count {
            if a[i] != b[i] {
                return false
            }
        }
        return true
    }

    method createChoiceCaseInit(entry:ChoiceCase) {
        def cl := entry.owner
        assert entry.resolved != Resolution.UNRESOLVED
        if entry.resolved != Resolution.RESOLVED {
            return
        }
        outer: for m in cl.methods {
            if m.methodKind != MethodDecl.Kind.INIT |
                    m.parameters.count != entry.fields.count + 1 {
                continue
            }
            assert m.parameters[0].type = Type.Int64()
            for i in 0 .. entry.fields.count {
                if entry.fields[i] != m.parameters[i + 1].type {
                    continue outer
                }
            }
            entry.initMethod := m
            return
        }
        -- need a synthetic init for this particular combination of parameters
        def parameters := Array<MethodDecl.Parameter>()
        parameters.add(MethodDecl.Parameter("rv", Type.Int64()))
        def statements := Array<ASTNode>()
        statements.add(ASTNode.BINARY(cl.position,
                ASTNode.IDENTIFIER(cl.position, ClassDecl.RAW_VALUE_NAME),
                Binary.Operator.ASSIGNMENT, ASTNode.IDENTIFIER(cl.position, "rv")))
        for i in 0 .. entry.fields.count {
            parameters.add(MethodDecl.Parameter("f\{i}", entry.fields[i]))
            statements.add(ASTNode.BINARY(cl.position,
                    ASTNode.CHOICE_FIELD_REFERENCE(cl.position,
                        ASTNode.SELF(cl.position),
                        entry,
                        i),
                    Binary.Operator.ASSIGNMENT,
                    ASTNode.IDENTIFIER(cl.position, "f\{i}")))
        }
        def synthetic := MethodDecl(cl, cl.position, null, Annotations(Annotations.Flag.SYNTHETIC),
                MethodDecl.Kind.INIT, "init", null, parameters, Type.Void(),
                FixedArray<ASTNode>.from(statements))
        entry.initMethod := synthetic
        cl.methods.add(synthetic)
        cl.symbolTable.add(synthetic)
    }

    function declaredType(m:MethodDecl):Type {
        resolve(m)
        def parameters := Array<Type>() -- FIXME use map
        for p in m.parameters {
            parameters.add(p.type)
        }
        def immutable := m.annotations.isClass | isImmutable(m.owner)
        def kind:Type.Kind
        if m.methodKind = MethodDecl.Kind.FUNCTION {
            if immutable {
                kind := Type.Kind.IMMUTABLE_FUNCTION
            }
            else {
                kind := Type.Kind.FUNCTION
            }
        }
        else {
            if immutable {
                kind := Type.Kind.IMMUTABLE_METHOD
            }
            else {
                kind := Type.Kind.METHOD
            }
        }
        return Type.methodType(m.position, kind, parameters, m.returnType, m.priority)
    }

    function declaredTypeWithSelf(m:MethodDecl, selfType:Type, forceImmutable:Bit):Type {
        resolve(m)
        def parameters := Array<Type>()
        parameters.add(selfType)
        for p in m.parameters {
            parameters.add(p.type)
        }
        def immutable := forceImmutable | m.annotations.isClass | isImmutable(m.owner)
        def kind:Type.Kind
        if m.methodKind = MethodDecl.Kind.FUNCTION {
            if immutable {
                kind := Type.Kind.IMMUTABLE_FUNCTION
            }
            else {
                kind := Type.Kind.FUNCTION
            }
        }
        else {
            if immutable {
                kind := Type.Kind.IMMUTABLE_METHOD
            }
            else {
                kind := Type.Kind.METHOD
            }
        }
        return Type.methodType(m.position, kind, parameters, m.returnType, m.priority)
    }

    function inheritedType(m:MethodDecl):Type {
        def inherited := getOverriddenMethod(m)
        if inherited == null {
            return declaredType(m)
        }
        return inheritedType(inherited)
    }

    function inheritedTypeWithSelf(m:MethodDecl):Type {
        return inheritedTypeWithSelf(m, m.owner.type)
    }

    function inheritedTypeWithSelf(m:MethodDecl, selfType:Type):Type {
        def inherited := getOverriddenMethod(m)
        if inherited == null {
            return declaredTypeWithSelf(m, selfType, false)
        }
        return inheritedTypeWithSelf(inherited, selfType)
    }

    method createChoiceCleanup(m:MethodDecl) {
        def cl := m.owner
        def statements := Array<ASTNode>()
        def value := ASTNode.SELF(cl.position)
        def whens := Array<ASTNode>()
        for e in cl.choiceCases {
            resolve(e)
            if errorCount != 0 {
                return
            }
            def tests := Array<ASTNode>()
            def fields := Array<ASTNode>()
            for i in 0 .. e.fields.count {
                fields.add(ASTNode.IDENTIFIER(cl.position, "_f\{i}"))
            }
            tests.add(ASTNode.CALL(cl.position, ASTNode.IDENTIFIER(cl.position, e.name),
                    FixedArray<ASTNode>.from(fields)))
            def unrefs := Array<ASTNode>()
            for i in 0 .. e.fields.count {
                if isRefCounted(e.fields[i]) {
                    def p := Position()
                    def unref := ASTNode.DOT(p, ASTNode.DOT(p, ASTNode.DOT(p,
                            ASTNode.IDENTIFIER(p, "frost"), "core"), "Frost"), "unref")
                    unrefs.add(ASTNode.CALL(Position(), unref,
                            FixedArray<ASTNode>.from([fields[i]])))
                }
            }
            whens.add(ASTNode.WHEN(cl.position, FixedArray<ASTNode>.from(tests),
                    FixedArray<ASTNode>.from(unrefs)))
        }
        statements.add(ASTNode.MATCH(cl.position, value, FixedArray<ASTNode>.from(whens),
                null))
        m.body := FixedArray<ASTNode>.from(statements)
    }

    method checkAccessModifierCount(position:Position, a:Annotations) {
        var count := 0
        if a.flags && Annotations.Flag.PRIVATE != 0 {
            count += 1
        }
        if a.flags && Annotations.Flag.PROTECTED != 0 {
            count += 1
        }
        if a.flags && Annotations.Flag.PACKAGE != 0 {
            count += 1
        }
        if count > 1 {
            error(position, "conflicting access modifier annotations")
        }
    }

    method checkAnnotations(m:MethodDecl) {
        method disallow(compiler:Compiler -* FIXME capture this *-, m:MethodDecl -* FIXME capture this *-, flag:Int, name:String) {
            if m.annotations.flags && flag != 0 {
                compiler.error(m.position, "methods may not be annotated with '\{name}'")
            }
        }
        disallow(self, m, Annotations.Flag.SPECIALIZE,       "@specialize")
        disallow(self, m, Annotations.Flag.WEAK,             "@weak")
        disallow(self, m, Annotations.Flag.UNSAFE_IMMUTABLE, "@unsafeImmutable")
        if m.methodKind = MethodDecl.Kind.INIT {
            if m.annotations.flags && Annotations.Flag.EXTERNAL != 0 {
                error(m.position, "init methods may not be annotated with '@external'")
            }
            if m.annotations.flags && Annotations.Flag.CLASS != 0 {
                error(m.position, "init methods may not be annotated with '@class'")
            }
            if m.annotations.flags && Annotations.Flag.ABSTRACT != 0 {
                error(m.position, "init methods may not be annotated with '@abstract'")
            }
            if m.annotations.flags && Annotations.Flag.OVERRIDE != 0 {
                error(m.position, "init methods may not be annotated with '@override'")
            }
        }
        if m.annotations.flags && Annotations.Flag.EXTERNAL != 0 & m.body !== null {
            error(m.position, "methods annotated with '@external' may not have a body")
        }
        if m.annotations.flags && Annotations.Flag.ABSTRACT != 0 & m.body !== null {
            error(m.position, "methods annotated with '@abstract' may not have a body")
        }
        if m.annotations.flags && Annotations.Flag.OVERRIDE != 0 &
                m.annotations.flags && Annotations.Flag.CLASS != 0 {
            error(m.position, "class methods may not be annotated with '@override'")
        }
        if !m.owner.annotations.isStub {
            if m.annotations.flags && Annotations.Flag.ABSTRACT = 0 &
                    m.annotations.flags && Annotations.Flag.EXTERNAL = 0 &
                    m.body == null {
                error(m.position, "expected non-abstract method '\{m.name}' to have a body")
            }
            if m.annotations.flags && Annotations.Flag.DEFAULT != 0 {
                if m.owner.classKind != ClassDecl.Kind.INTERFACE {
                    error(m.position, "annotation '@default' may only appear on interface methods")
                }
                if m.body == null {
                    error(m.position, "expected '@default' method '\{m.name}' to have a body")
                }
            }
            else if m.methodKind != MethodDecl.Kind.INIT &
                    m.owner.classKind = ClassDecl.Kind.INTERFACE &
                    !m.annotations.isClass & m.body !== null {
                error(m.position, "non-abstract interface method '\{m.name}' must be annotated " +
                        "with '@default'")
                m.annotations += Annotations.Flag.DEFAULT
            }
        }
        checkAccessModifierCount(m.position, m.annotations)
    }

    method getIndex(f:FieldDecl):Int {
        def fields := instanceFields(f.owner)
        for i in 0 .. fields.count {
            if fields[i] == f {
                return i
            }
        }
        unreachable
    }

    method capture(position:Position, v:Variable) {
        if v.name = SELF_NAME {
            for c in captures {
                c.second[SELF_NAME] := Capture.SELF
                if !c.first.annotations.isCapture {
                    return
                }
            }
        }
        for c in captures {
            if v.varKind = Variable.Kind.VAR {
                error(position, "closure cannot capture 'var \{v}'; use 'def' instead")
                break
            }
            c.second[v.name] := Capture.VARIABLE(v)
            if v.owner == c.first {
                break
            }
        }
    }

    method capture(position:Position, f:FieldDecl) {
        for c in captures {
            c.second[f.name] := Capture.FIELD(f)
            if f.owner == c.first.owner {
                break
            }
        }
    }

    @post(@return !== null | errorCount > 0 | !reportErrors)
    method symbolRef(position:Position, target:IR.Value?, s:Symbol):IR.Value? {
        match s.kind {
            when Symbol.Kind.ALIAS {
                def type := resolve(s->Alias.type)
                if type !== null {
                    return IR.Value.TYPE(type)
                }
                return null
            }
            when Symbol.Kind.METHOD {
                return IR.Value.METHOD(target, s->MethodDecl)
            }
            when Symbol.Kind.METHODS {
                return IR.Value.METHODS(target, s->Methods.methods)
            }
            when Symbol.Kind.VARIABLE {
                def v := s->Variable
                if v.owner !== null & v.owner !== currentMethod[0] {
                    capture(position, v)
                }
                match v.storage {
                    when Variable.Storage.LOCAL(slot) {
                        def result := ir.add(IR.Statement.LOAD(position,
                                IR.Value.LOCAL(slot, v.type)))
                        return IR.Value.REF(result, v.type)
                    }
                    when Variable.Storage.PARAMETER(index) {
                        assert s->Variable.type.resolved
                        return IR.Value.PARAMETER(index, s->Variable.type)
                    }
                    otherwise {
                        unreachable
                    }
                }
            }
            when Symbol.Kind.FIELD {
                def f := s->FieldDecl
                if resolve(f) {
                    if f.annotations.isCapture {
                        capture(position, f)
                    }
                    return FieldLValue(self, position, target, f).compileLoad()
                }
                return null
            }
            when Symbol.Kind.CHOICE_CASE {
                -- this handles the zero-argument case; choice cases with arguments are handled in
                -- Call.compile()
                def cc := s->ChoiceCase
                if cc.fields.count > 0 {
                    error(position, "choice '\{s}' requires \{cc.fields.count} " +
                            "argument\{cc.fields.count = 1:|s}, but found 0")
                    return null
                }
                resolve(cc)
                def inits := getSymbolTable(cc.owner)["init"]
                assert inits !== null
                resolve(inits->MethodDecl)
                def args := [ASTNode.INT(position, cc.rawValue.asUInt64)]
                if isValue(cc.owner) {
                    return Call.compile(self, position, symbolRef(position, null, inits), args,
                            TypeContext.UNSPECIFIED)
                }
                else {
                    def construct := ir.add(IR.Statement.CONSTRUCT(position, cc.owner))
                    def constructRef := IR.Value.REF(construct, cc.owner.type)
                    enclosingContexts.push(EnclosingContext.VALUE_SCOPE(constructRef))
                    Call.compile(self, position, symbolRef(position, constructRef, inits), args,
                            TypeContext.UNSPECIFIED)
                    return constructRef
                }
            }
            when Symbol.Kind.GENERIC_CLASS_PARAMETER, Symbol.Kind.GENERIC_METHOD_PARAMETER {
                error(position, "generic parameter '\{s.name}' is not an expression")
                return null
            }
            otherwise {
                unreachable, "unsupported symbol kind: \{s}"
            }
        }
        unreachable
    }

    method isValueInit(m:MethodDecl):Bit {
        return m.methodKind = MethodDecl.Kind.INIT & isValue(m.owner)
    }

    method implicitInit(position:Position, value:IR.Value, m:MethodDecl):IR.Value {
        def cl := m.owner
        assert isValue(cl)
        def coerced := coerce(position, value, m.parameters[0].type)
        assert coerced !== null
        def result := ir.add(IR.Statement.STATIC_CALL(position, m,
                FixedArray<IR.Value>.from([coerced])))
        return IR.Value.REF(result, m.owner.type)
    }

    ================================================================================================
    Creates an object which represents a method reference, such as `Int.+` (which has a `null`
    `target`) or 1.+ (which has a `target` of `1`).
    ================================================================================================
    method createMethodObject(position:Position, target:IR.Value?, m:MethodDecl):IR.Value? {
        if !resolve(m) {
            return null
        }
        def effectiveType:Type
        def irType:Type
        if target !== null & !target.type().isClassLiteral {
            -- we're taking a reference which has a fixed 'self' parameter, as in '1.+'. Easiest way
            -- to do this is compile the closure 'x => 1.+(x)'. (Well, it's not actually a lambda,
            -- because it can be a method and return void, but you get the point)
            assert !m.annotations.isClass
            def old := enclosingContexts
            -- keep TRY_SCOPE from affecting effective return type
            enclosingContexts := Stack<EnclosingContext>()
            effectiveType := MethodRef(self, target.type(), m).effectiveType
            enclosingContexts := old
            closureCount += 1
            def dummyName := "$dummy\{closureCount}"
            compileDeclaration(position, ASTNode.IDENTIFIER(position, dummyName),
                    ASTNode.IR_WRAPPER(position, target), Variable.Kind.DEF)
            def parameters := Array<ASTNode>()
            def arguments := Array<ASTNode>()
            for i in 0 .. m.parameters.count {
                def name := "param\{i}"
                parameters.add(ASTNode.PARAMETER(position, name,
                    ASTNode.IR_WRAPPER(m.position, IR.Value.TYPE(effectiveType.parameterType(i)))))
                arguments.add(ASTNode.IDENTIFIER(position, name))
            }
            def call := ASTNode.CALL(position,
                    ASTNode.DOT(position, ASTNode.IDENTIFIER(position, dummyName), m.name),
                    FixedArray<ASTNode>.from(arguments))
            def statement:ASTNode
            if effectiveType.returnType != Type.Void() {
                statement := ASTNode.RETURN(position, call)
            }
            else {
                statement := call
            }
            return Closure.compile(self, position, m.methodKind,
                    FixedArray<ASTNode>.from(parameters),
                    ASTNode.IR_WRAPPER(position, IR.Value.TYPE(effectiveType.returnType)),
                    [statement]->FixedArray<ASTNode>, TypeContext.UNSPECIFIED)
        }
        else {
            if m.annotations.isClass {
                effectiveType := m.type
                irType := Type.pointerTo(m.type)
            }
            else {
                effectiveType := declaredTypeWithSelf(m, m.owner.type, isClassContext())
                irType := Type.pointerTo(declaredTypeWithSelf(m, m.owner.type, false))
            }
        }
        def args := Array<ASTNode>()
        args.add(ASTNode.IR_WRAPPER(position, cast(position, IR.Value.METHOD_POINTER(m, irType),
                Type.pointerTo(Type.Int8()))))
        args.add(ASTNode.NULL(position))
        return cast(position, Call.compile(self, position, IR.Value.TYPE(Type.Method()), args,
                TypeContext.UNSPECIFIED), effectiveType)
    }

    function explainCoerceFailure(m:MethodRef, target:Type):String {
        if m.parameterCount != target.parameterCount {
            return "wrong parameter count"
        }
        for i in 0 .. m.parameterCount {
            if coercionCost(target.parameterType(i), m.parameterType(i)) == null {
                return "parameter \{i + 1} cannot be converted from '\{target.parameterType(i)}' " +
                        "to '\{m.parameterType(i)}'"
            }
        }
        if coercionCost(m.returnType, target.returnType) == null {
            return "return type '\{m.returnType}' cannot be converted to '\{target.returnType}'"
        }
        if m.value.methodKind = MethodDecl.Kind.METHOD & (target.typeKind = Type.Kind.FUNCTION |
                target.typeKind = Type.Kind.IMMUTABLE_FUNCTION) {
            return "cannot use a method where a function is expected"
        }
        return "<internal error>"
    }

    @pre(value.type().isMethod & target.isMethod)
    method methodCast(position:Position, value:IR.Value, target:Type, explicit:Bit):IR.Value? {
        def src := value.type()
        if src = target {
            return value
        }
        assert src.subtypes.count = target.subtypes.count
        var diff := false
        for i in 0 .. src.subtypes.count {
            if isValue(src.subtypes[i]) != isValue(target.subtypes[i]) {
                diff := true
                break
            }
        }
        if !diff {
            return IR.Value.REF(ir.add(IR.Statement.CAST(position, value, target, explicit)),
                    target)
        }
        def kind:MethodDecl.Kind
        match target.typeKind {
            when Type.Kind.IMMUTABLE_FUNCTION, Type.Kind.FUNCTION {
                kind := MethodDecl.Kind.FUNCTION
            }
            otherwise {
                kind := MethodDecl.Kind.METHOD
            }
        }
        def rawParams := Array<ASTNode>()
        def callParams := Array<ASTNode>()
        for i in 0 .. src.parameterCount {
            def name := "param\{i}"
            rawParams.add(ASTNode.PARAMETER(position, name, ASTNode.IR_WRAPPER(position,
                    IR.Value.TYPE(target.subtypes[i]))))
            callParams.add(ASTNode.BINARY(position, ASTNode.IDENTIFIER(position, name),
                    Binary.Operator.CAST, ASTNode.IR_WRAPPER(position,
                        IR.Value.TYPE(src.subtypes[i]))))
        }
        closureCount += 1
        def methodCapture := ASTNode.IDENTIFIER(position, "$method\{closureCount}")
        compileDeclaration(position, methodCapture, ASTNode.IR_WRAPPER(position, value),
                Variable.Kind.DEF)
        def c := ASTNode.CALL(position, methodCapture, FixedArray<ASTNode>.from(callParams))
        def body:Array<ASTNode>
        if target.returnType != Type.Void() {
            body := [ASTNode.RETURN(position, ASTNode.BINARY(position, c, Binary.Operator.CAST,
                    ASTNode.IR_WRAPPER(position, IR.Value.TYPE(target.returnType))))]
        }
        else {
            body := [c]
        }
        return Closure.compile(self, position, kind, FixedArray<ASTNode>.from(rawParams),
                ASTNode.IR_WRAPPER(position, IR.Value.TYPE(target.returnType)),
                FixedArray<ASTNode>.from(body), TypeContext.TYPE(target, false))
    }

    @pre(target != Type.Void())
    method coerce(position:Position, value:IR.Value?, target:Type):IR.Value? {
        return coerce(position, value, target, false)
    }

    ================================================================================================
    Coerces a value to a different type, returning a new value representing the converted type (or
    report an error and return `null` if no such coercion is possible). "Coerce", in Frost's
    lexicon, means to perform a typecast which can be performed implicitly, without being explicitly
    specified by the user. This includes things like widenining conversions or converting a literal
    to any of the types it can legally represent.
    ================================================================================================
    @pre(target != Type.Void())
    method coerce(position:Position, value:IR.Value?, target:Type, explicit:Bit):IR.Value? {
        if value == null {
            return null
        }
        def srcType := value.type()
        if srcType = target {
            return value
        }
        match value {
            when IR.Value.METHOD(targetObj, m) {
                def result := createMethodObject(position, targetObj, m)
                if coercionCost(result.type(), target) == null {
                    error(position, "expected '\{target}', but found '\{result.type()}'")
                    return null
                }
                return coerce(position, result, target, explicit)
            }
            when IR.Value.METHODS(targetObj, methods) {
                def best := Array<MethodDecl>()
                var bestCost := Int.MAX
                for m in methods {
                    if resolve(m) {
                        def ref := MethodRef(self, targetObj.type(), m)
                        def cost := coercionCost(ref.effectiveType, target)
                        if cost !== null {
                            if cost.second < bestCost {
                                best.clear()
                                bestCost := cost.second
                            }
                            if cost.second = bestCost {
                                best.add(m)
                            }
                        }
                    }
                }
                if best.count = 1 {
                    return coerce(position, IR.Value.METHOD(targetObj, best[0]), target, explicit)
                }
                if best.count > 1 {
                    error(position, "ambiguous method reference")
                    return null
                }
                def msg := MutableString("reference to method '\{methods[0].name}' cannot be " +
                        "used as type '\{target}'. None of the following methods match this type:")
                for m in methods {
                    def ref := MethodRef(self, targetObj.type(), m)
                    msg.append("\n    \{m.declaration}:\{m.position} (" +
                            explainCoerceFailure(ref, target) + ")")
                }
                error(position, msg.finish())
                return null
            }
        }
        if coercionCost(srcType, target) !== null {
            if target.isMethod & srcType.isMethod {
                return methodCast(position, value, target, explicit)
            }
            def cl := getClass(target)
            if cl == null {
                return null
            }
            def inits := getSymbolTable(cl)["init"]
            assert inits !== null
            match inits.kind {
                when Symbol.Kind.METHOD {
                    def m := inits->MethodDecl
                    if m.annotations.isImplicit {
                        if resolve(m) & coercionCost(srcType, m.parameters[0].type) !== null {
                            return implicitInit(position, value, m)
                        }
                    }
                }
                when Symbol.Kind.METHODS {
                    def methods := inits->Methods.methods.filter(m => m.annotations.isImplicit)
                    if methods.count > 0 {
                        def args := Array<ASTNode>()
                        args.add(ASTNode.IR_WRAPPER(position, value))
                        def best := Call.findBestMethod(self, position, null, methods, args,
                                TypeContext.UNSPECIFIED)
                        if best !== null {
                            if best.first.count = 1 {
                                return implicitInit(position, value, best.first[0].value)
                            }
                            unreachable, "ambiguous implicit init"
                        }
                    }
                }
            }
            assert srcType.isClass
-*            if value.type().isNullable & !target.isNullable &
                    target.typeKind != Type.Kind.GENERIC_CLASS_PARAMETER &
                    target.typeKind != Type.Kind.GENERIC_METHOD_PARAMETER {
                -- FIXME remove this when compile-time nullability checks are in
                Assert.compile(self, position, ASTNode.BINARY(position,
                        ASTNode.IR_WRAPPER(position, value), Binary.Operator.NIDENTITY,
                        ASTNode.NULL(position)), ASTNode.STRING(position,
                                "unexpected null reference casting \{value.type()} to \{target}"))
            }*-
            def result := IR.Value.REF(ir.add(IR.Statement.CAST(position, value, target, explicit)),
                    target)
            if !isRefCounted(srcType) & isRefCounted(target) {
                enclosingContexts.push(EnclosingContext.VALUE_SCOPE(result))
            }
            return result
        }
        error(position, "expected '\{target}', but found '\{srcType}'")
        return null
    }

    method coerce(position:Position, value:IR.Value?, type:TypeContext):IR.Value? {
        if value == null {
            return value
        }
        match type {
            when TypeContext.UNSPECIFIED, TypeContext.NON_VOID {
                return value
            }
            when TypeContext.IMMUTABLE {
                if isImmutable(value.type()) {
                    return value
                }
                error(position, "expected 'frost.core.Immutable', but found '\{value.type()}'")
                return null
            }
            when TypeContext.TYPE(t, explicit) {
                return coerce(position, value, t, explicit)
            }
            otherwise {
                unreachable
            }
        }
    }

    ================================================================================================
    Casts a value to a different type, returning a new value representing the converted type (or
    report an error and return `null` if no such cast is possible). "Cast", in Frost's lexicon,
    means to perform a typecast which has been explicitly specified by the user, as in the
    expression `object->String`.
    ================================================================================================
    @pre(target != Type.Void() & target.resolved)
    method cast(position:Position, value:IR.Value?, target:Type):IR.Value? {
        if value == null {
            return null
        }
        def valueType := value.type()
        if valueType = target {
            return value
        }
        if coercionCost(value.type(), target) !== null {
            return coerce(Position(), value, TypeContext.TYPE(target, true))
        }
        if target.isMethod {
            if valueType.isMethod {
                return methodCast(position, value, target, true)
            } 
            if valueType.name != "frost.core.Method" &
                    valueType.name != "frost.core.MutableMethod" {
                error(position, "non-method objects may not be cast to methods")
            }
        }
        -- FIXME error on impossible casts
        def result := IR.Value.REF(ir.add(IR.Statement.CAST(position, value, target, true)), target)
        if !isRefCounted(value.type()) & isRefCounted(target) {
            enclosingContexts.push(EnclosingContext.VALUE_SCOPE(result))
        }
        return result
    }

    ================================================================================================
    Converts an object to a different type using the appropriate `as` property. Reports an error and
    returns `null` if no such conversion is possible.
    ================================================================================================
    method convert(value:IR.Value?, target:Type):IR.Value? {
        if value == null {
            return value
        }
        if value.type() = target {
            return value
        }
        def simpleName := target.name[target.name.next(target.name.lastIndexOf("."))..]
        return Call.compile(self, Position(), value, "get_as\{simpleName}", [],
                TypeContext.TYPE(target, false))
    }

    method getVTableIndex(m:MethodDecl):Int {
        def vtable := getVTable(m.owner)
        for i in 0 .. vtable.count {
            if vtable[i] == m {
                return i
            }
        }
        unreachable, "could not find \{m.declaration} in vtable for \{m.owner.name}"
    }

    @pre(isRefCounted(v.type()))
    method compileRef(v:IR.Value) {
        def args := Array<ASTNode>()
        args.add(ASTNode.IR_WRAPPER(Position(), v))
        Call.compile(self, Position(), IR.Value.TYPE(Type.Frost()), "ref", args,
                TypeContext.UNSPECIFIED)
    }

    @pre(isRefCounted(v.type()))
    method compileUnref(v:IR.Value) {
        def args := Array<ASTNode>()
        args.add(ASTNode.IR_WRAPPER(Position(), v))
        Call.compile(self, Position(), IR.Value.TYPE(Type.Frost()), "unref", args,
                TypeContext.UNSPECIFIED)
    }

    @pre(type.isNumber)
    function numberSize(type:Type):Int {
        def cl := getClass(type)
        assert cl !== null
        def value := cl.fields.filter(f => f.name = "value")[0]
        resolve(value)
        assert value.type.isBuiltinNumber
        return value.type.size
    }

    function binaryType(leftType:Type, rightType:Type, signMatters:Bit, promote32:Bit):Type {
        def leftSize := numberSize(leftType)
        def rightSize := numberSize(rightType)
        if leftType.isReal | rightType.isReal {
            if leftSize = 64 | rightSize = 64 {
                return Type.Real64()
            }
            return Type.Real32()
        }
        if leftType.isSigned = rightType.isSigned | !signMatters {
            def leftPromoted:Type
            def rightPromoted:Type
            if promote32 {
--                leftPromoted := max32(leftType)
--                rightPromoted := max32(rightType)
                unreachable
            }
            else {
                leftPromoted := leftType
                rightPromoted := rightType
            }
            if leftPromoted = rightPromoted {
                return leftPromoted
            }
            if numberSize(leftPromoted) > numberSize(rightPromoted) {
                return leftPromoted
            }
            return rightPromoted
        }
        else if leftSize = 8 & rightSize = 8 {
            if promote32 {
                return Type.Int32()
            }
            else {
                return Type.Int16()
            }
        }
        else if leftSize <= 16 & rightSize <= 16 {
            return Type.Int32()
        }
        else if leftSize <= 32 & rightSize <= 32 {
            return Type.Int64()
        }
        else {
            unreachable
        }
    }

    @pre(methods.count > 1)
    method reportAmbiguousMatch(position:Position, methods:ListView<MethodRef>,
            args:ListView<ASTNode>, type:TypeContext) {
        def msg := MutableString("call to '\{methods[0].value.name}' is ambiguous. The following " +
                "methods are equally good matches:")
        for m in methods.sort((a, b) => a.value.position > b.value.position) {
            msg.append("\n    \{m.value.declaration} (\{m.value.owner.source.name}:" +
                    "\{m.value.position})")
        }
        error(position, msg.finish())
    }

    ================================================================================================
    Returns the type under which a particular class was inherited. For instance,
    `HashMap<String, File>` inherits `MapView` under the type `MapView<String, File>`.
    ================================================================================================
    method findType(start:Type, target:ClassDecl):Type? {
        if !start.isClass {
            return null
        }
        if start.typeKind = Type.Kind.GENERIC_CLASS_PARAMETER {
            return findType(start.genericClassParameter.bound, target)
        }
        def startClass := getClass(start)
        if startClass == null {
            return null
        }
        if startClass == target {
            return start.nonnullable()
        }
        assert startClass.name != target.name, "duplicate class: \{startClass.name}"
        if startClass.rawSuper !== null {
            def result := findType(remapType(start, startClass.rawSuper),
                    target)
            if result !== null {
                return result
            }
        }
        for intf in startClass.rawInterfaces {
            def result := findType(remapType(start, intf), target)
            if result !== null {
                return result
            }
        }
        return null
    }

    function findType(start:CollectionView<Type>, target:ClassDecl):Type? {
        for t in start {
            def result := findType(t, target)
            if result !== null {
                return result
            }
        }
        return null
    }

    ================================================================================================
    If `t` is a type to which an array literal can be coerced, returns whether or not the resulting
    collection should be mutable and the element type.
    ================================================================================================
    function getListType(t:Type):Pair<Bit, Type>? {
        if t.typeKind = Type.Kind.NULLABLE {
            return getListType(t.subtypes[0])
        }
        if t.typeKind = Type.Kind.GENERIC {
            if t.subtypes.count != 2 {
                return null
            }
            def mutable:Bit
            match t.subtypes[0].name {
                when "frost.collections.Array" {
                    mutable := true
                }
                when "frost.collections.List" {
                    mutable := !isImmutable(t.subtypes[1])
                }
                when "frost.collections.ListView" {
                    mutable := !isImmutable(t.subtypes[1])
                }
                when "frost.collections.ListWriter" {
                    mutable :=!isImmutable(t.subtypes[1])
                }
                when "frost.collections.Collection" {
                    mutable := !isImmutable(t.subtypes[1])
                }
                when "frost.collections.CollectionView" {
                    mutable := !isImmutable(t.subtypes[1])
                }
                when "frost.collections.CollectionWriter" {
                    mutable := true
                }
                when "frost.collections.ImmutableArray" {
                    mutable := false
                }
                when "frost.collections.Iterable" {
                    mutable := !isImmutable(t.subtypes[1])
                }
                otherwise {
                    return null
                }
            }
            return Pair<Bit, Type>(mutable, t.subtypes[1])
        }
        match t.name {
            when "frost.core.Object", "frost.core.Immutable" {
                return Pair<Bit, Type>(false, Type.Any())
            }
            otherwise {
                return null
            }
        }
    }

    method compileChoiceCaseReference(position:Position, owner:Type, cc:ChoiceCase,
            args:FixedArray<ASTNode>, type:TypeContext):IR.Value? {
        resolve(cc)
        def initMethod := cc.initMethod
        if initMethod == null {
            return null
        }
        resolve(initMethod)
        if args.count != cc.fields.count {
            error(position, "'\{cc}' expected \{cc.fields.count} argument" +
                    "\{cc.fields.count = 1:|s}, but found \{args.count}")
            return null
        }
        def finalArgs := Array<ASTNode>()
        finalArgs.add(ASTNode.INT(position, cc.rawValue.asUInt64))
        finalArgs.addAll(args)
        if isValue(cc.owner) {
            return coerce(position, Call.compile(self, position,
                    symbolRef(position, null, initMethod), finalArgs, TypeContext.UNSPECIFIED),
                    type)
        }
        else {
            def construct := ir.add(IR.Statement.CONSTRUCT(position, cc.owner))
            def constructRef := IR.Value.REF(construct, owner)
            enclosingContexts.push(EnclosingContext.VALUE_SCOPE(constructRef))
            Call.compile(self, position, symbolRef(position, constructRef, initMethod), finalArgs,
                    TypeContext.UNSPECIFIED)
            return coerce(position, constructRef, type)
        }
    }

    ================================================================================================
    If `node` is a reference to a [ChoiceCase], returns it. Otherwise, returns `null` without
    reporting an error.
    ================================================================================================
    method getChoiceCase(node:ASTNode):Pair<Type, ChoiceCase>? {
        match node {
            when ASTNode.IDENTIFIER(_, text) {
                if currentClass[0].classKind = ClassDecl.Kind.CHOICE {
                    def s := getSymbolTable(currentClass[0])[text]
                    if s !== null & s.kind = Symbol.Kind.CHOICE_CASE {
                        return Pair<Type, ChoiceCase>(currentClass[0].type, s->ChoiceCase)
                    }
                }
            }
            when ASTNode.DOT(_, base, text) {
                def baseType := preferredType(base)
                if baseType !== null & baseType.isClassLiteral {
                    def cl := getClass(baseType.subtypes[1])
                    if cl !== null & cl.classKind = ClassDecl.Kind.CHOICE {
                        def s := getSymbolTable(cl)[text]
                        if s !== null & s.kind = Symbol.Kind.CHOICE_CASE {
                            return Pair<Type, ChoiceCase>(baseType.subtypes[1], s->ChoiceCase)
                        }
                    }
                }
            }
        }
        return null
    }

    method compileCast(position:Position, value:ASTNode, rawTarget:Type):IR.Value? {
        def index := rawTarget.name.lastIndexOf(".")
        if rawTarget.typeKind = Type.Kind.CLASS & index !== null {
            -- we have a dotted name which might not be entirely a type - for example we might have
            -- 'o->String.length'. This is obviously meant to be a cast to String followed by a
            -- call to get_length(), but syntactically it could just as easily be a cast to a class
            -- named String.length. We need to disambiguate these cases here.
            def old := reportErrors
            reportErrors := false
            def type := resolve(rawTarget)
            reportErrors := old
            if type == null {
                def base := compileCast(position, value,
                        Type(rawTarget.name[..index], Type.Kind.CLASS, position))
                if base == null {
                    return null
                }
                return Dot.compile(self, position, base,
                        rawTarget.name[rawTarget.name.next(index)..])
            }
        }
        def target := resolve(rawTarget)
        if target == null {
            return null
        }
        if coercionCost(value, target) !== null {
            return compileExpression(value, TypeContext.TYPE(target, true))
        }
        return cast(position, compileExpression(value, TypeContext.NON_VOID), target)
    }

    function isNull(v:IR.Value):Bit {
        match v {
            when IR.Value.NULL {
                return true
            }
        }
        return false
    }

    @pre(op = Binary.Operator.IDENTITY | op = Binary.Operator.NIDENTITY)
    method compileIdentityComparison(position:Position, left:ASTNode, op:Binary.Operator,
            right:ASTNode, type:TypeContext):IR.Value? {
        def compiledLeft := compileExpression(left, TypeContext.NON_VOID)
        if compiledLeft == null {
            return null
        }
        def compiledRight := compileExpression(right, TypeContext.NON_VOID)
        if compiledRight == null {
            return null
        }
        if compiledLeft.type().typeKind != Type.Kind.NULLABLE & isNull(compiledRight) {
            if op = Binary.Operator.IDENTITY {
                return coerce(position, coerce(position, IR.Value.BIT(false),
                        TypeContext.TYPE(Type.Bit(), false)), type)
            }
            return coerce(position, coerce(position, IR.Value.BIT(true),
                    TypeContext.TYPE(Type.Bit(), false)), type)
        }
        if compiledRight.type().typeKind != Type.Kind.NULLABLE & isNull(compiledLeft) {
            if op = Binary.Operator.IDENTITY {
                return coerce(position, coerce(position, IR.Value.BIT(false),
                        TypeContext.TYPE(Type.Bit(), false)), type)
            }
            return coerce(position, coerce(position, IR.Value.BIT(true),
                    TypeContext.TYPE(Type.Bit(), false)), type)
        }
        if coercionCost(compiledLeft.type(), compiledRight.type()) == null &
                coercionCost(compiledRight.type(), compiledLeft.type()) == null {
            error(position, "'\{op.asString}' cannot compare dissimilar types " +
                    "'\{compiledLeft.type()}' and '\{compiledRight.type()}'")
            return null
        }
        if isValue(compiledLeft.type()) & !isNull(compiledRight) |
                isValue(compiledRight.type()) & !isNull(compiledLeft) {
            error(position, "'\{op.asString}' cannot operate on value types")
            return null
        }
        def builtinBit := ir.add(IR.Statement.BINARY(position, compiledLeft, op, compiledRight,
                Type.BuiltinBit()))
        def bit := coerce(position, IR.Value.REF(builtinBit, Type.BuiltinBit()),
                TypeContext.TYPE(Type.Bit(), false))
        return coerce(position, bit, type)
    }

    method compileNull(position:Position, type:TypeContext):IR.Value? {
        match type {
            when TypeContext.TYPE(t, _) {
                if t.typeKind != Type.Kind.NULLABLE {
                    error(position, "expected '\{t}', but found 'null'")
                }
                return IR.Value.NULL(t)
            }
            otherwise {
                return IR.Value.NULL(Type.Any())
            }
        }
    }

    method compileRange(position:Position, start:ASTNode?, inclusive:Bit, end:ASTNode?,
            step:ASTNode?, type:TypeContext):IR.Value? {
        var endpointContext := TypeContext.NON_VOID
        var endpointType:Type? := null
        var stepContext := TypeContext.NON_VOID
        match type {
            when TypeContext.TYPE(t, explicit) {
                if t.typeKind = Type.Kind.GENERIC & t.subtypes.count = 2 &
                        t.subtypes[0].name = RANGE_NAME {
                    if step !== null {
                        error(position, "expected '\{t}', but found '\{STEPPED_RANGE_NAME}'")
                        return null
                    }
                    endpointContext := TypeContext.TYPE(t.subtypes[1], explicit)
                    endpointType := t.subtypes[1]
                }
                else if t.typeKind = Type.Kind.GENERIC & t.subtypes.count = 3 &
                        t.subtypes[0].name = STEPPED_RANGE_NAME {
                    if step == null {
                        error(position, "expected '\{t}', but found '\{RANGE_NAME}'")
                        return null
                    }
                    endpointContext := TypeContext.TYPE(t.subtypes[1], explicit)
                    endpointType := t.subtypes[1]
                    stepContext := TypeContext.TYPE(t.subtypes[2], explicit)
                }
            }
        }
        if endpointContext = TypeContext.NON_VOID {
            if start !== null {
                match start {
                    when ASTNode.STRING {
                        endpointContext := TypeContext.TYPE(Type.Char32(), false)
                    }
                }
            }
            if end !== null {
                match end {
                    when ASTNode.STRING {
                        endpointContext := TypeContext.TYPE(Type.Char32(), false)
                    }
                }
            }
        }
        def compiledStart:IR.Value?
        if start !== null {
            compiledStart := compileExpression(start, endpointContext)
            if compiledStart == null {
                return null
            }
        }
        else {
            compiledStart := null
        }
        def compiledEnd:IR.Value?
        if end !== null {
            compiledEnd := compileExpression(end, endpointContext)
            if compiledEnd == null {
                return null
            }
        }
        else {
            compiledEnd := null
        }
        if endpointType == null {
            if compiledStart !== null {
                if compiledEnd !== null {
                    endpointType := compiledStart.type().union(self, compiledEnd.type())
                    if endpointType.name = "frost.core.Value" {
                        error(position, "range endpoint type mismatch: '\{compiledStart}', " +
                                "'\{compiledEnd}'")
                    }
                }
                else {
                    endpointType := compiledStart.type().nullable()
                }
            }
            else if compiledEnd !== null {
                endpointType := compiledEnd.type().nullable()
            }
            else {
                endpointType := Type.Int64().nullable()
            }
        }
        def cl := getClass(endpointType)
        if cl == null {
            return null
        }
        if !isValue(cl) {
            error(position, "range endpoints must be value types, but found '\{endpointType}'")
            return null
        }
        if compiledStart == null {
            if !endpointType.isNullable {
                error(position, "non-nullable range requires both endpoints to be specified")
                return null
            }
            compiledStart := IR.Value.NULL(endpointType)
        }
        if compiledEnd == null {
            if !endpointType.isNullable {
                error(position, "non-nullable range requires both endpoints to be specified")
                return null
            }
            compiledEnd := IR.Value.NULL(endpointType)
        }
        if step !== null {
            if stepContext = TypeContext.NON_VOID & endpointType.isNumber {
                def p := possibleTypes(step)
                if p !== null {
                    for t in p {
                        if t = endpointType {
                            stepContext := TypeContext.TYPE(endpointType, false)
                            break
                        }
                    }
                }
            }
            def compiledStep := compileExpression(step, stepContext)
            if compiledStep == null {
                return null
            }
            def args := Array<ASTNode>()
            args.add(ASTNode.IR_WRAPPER(position, compiledStart))
            args.add(ASTNode.IR_WRAPPER(position, compiledEnd))
            args.add(ASTNode.IR_WRAPPER(step.position(), compiledStep))
            args.add(ASTNode.BIT(position, inclusive))
            return Call.compile(self, position, IR.Value.TYPE(Type.SteppedRangeOf(endpointType,
                    compiledStep.type())), args, type)
        }
        else {
            def args := Array<ASTNode>()
            args.add(ASTNode.IR_WRAPPER(position, compiledStart))
            args.add(ASTNode.IR_WRAPPER(position, compiledEnd))
            args.add(ASTNode.BIT(position, inclusive))
            return Call.compile(self, position, IR.Value.TYPE(Type.RangeOf(endpointType)), args,
                    type)
        }
    }

    method compileReal(position:Position, value:Real64, type:TypeContext):IR.Value? {
        match type {
            when TypeContext.TYPE(t, _) {
                if t.typeKind = Type.Kind.BUILTIN_FLOAT {
                    return IR.Value.REAL(value, t)
                }
                if t.isReal {
                    def args := Array<ASTNode>()
                    args.add(ASTNode.REAL(position, value))
                    return Call.compile(self, position, IR.Value.TYPE(t), args, type)
                }
            }
        }
        return coerce(position, compileReal(position, value,
                TypeContext.TYPE(Type.Real64(), false)), type)
    }

    method compileRegex(position:Position, text:String):IR.Value? {
        return Call.compile(self, position, IR.Value.TYPE(Type.RegularExpression()),
                [ASTNode.STRING(position, text)],
                TypeContext.UNSPECIFIED)
    }

    method compileSelf(position:Position, explicit:Bit):IR.Value? {
        if captures.count > 0 {
            for c in captures {
                c.second[SELF_NAME] := Capture.SELF
            }
            var cl := captures[0].first.owner
            while cl.annotations.isSynthetic {
                assert cl.owner !== null
                cl := cl.owner
            }
            return IR.Value.REF(IR.Statement.ID(-1), cl.type)
        }
        if explicit {
            def s := symbolTable[CAPTURED_SELF_NAME]
            if s !== null {
                def actualSelf := symbolTable[SELF_NAME]
                assert actualSelf !== null, "no 'self' in symboltable"
                return symbolRef(position, symbolRef(position, null, actualSelf), s)
            }
        }
        if currentMethod[0].annotations.isClass {
            error(position, "cannot reference 'self' from a @class context")
            return null
        }
        def s := symbolTable[SELF_NAME]
        assert s !== null, "no 'self' in symboltable at \{position}"
        return symbolRef(position, null, s)
    }

    method typeMatch(value:IR.Value?, type:TypeContext):Bit {
        if value == null {
            return true
        }
        match type {
            when TypeContext.UNSPECIFIED, TypeContext.NON_VOID {
                return true
            }
            when TypeContext.IMMUTABLE {
                return isImmutable(value.type())
            }
            when TypeContext.TYPE(t, _) {
                return value.type() = t
            }
            otherwise {
                unreachable
            }
        }
    }

    method genericMethodRef(raw:IR.Value, rawTypes:FixedArray<ASTNode>):IR.Value? {
        def resolvedTypes := Array<Type>()
        for t in rawTypes {
            def resolved := resolve(scanner.convertType(t))
            if resolved == null {
                return null
            }
            resolvedTypes.add(resolved)
        }
        match raw {
            when IR.Value.METHOD(target, m) {
                return IR.Value.GENERIC_METHOD(target, m, FixedArray<Type>.from(resolvedTypes))
            }
            when IR.Value.METHODS(target, m) {
                return IR.Value.GENERIC_METHODS(target, m, FixedArray<Type>.from(resolvedTypes))
            }
        }
        return raw
    }

    ================================================================================================
    Compiles an expression without fully resolving method references. That is,
    `compileMethodExpression` on `Console.printLine` returns an IR.Value.METHOD, whereas fully
    resolving this expression using `compileExpression` will result in an actual `ImmutableMethod`
    object constructor.
    ================================================================================================
    @post(typeMatch(@return, type) & (@return !== null | errorCount > 0 | !reportErrors))
    method compileMethodExpression(expr:ASTNode, type:TypeContext):IR.Value? {
        match expr {
            when ASTNode.ARRAY(position, elements) {
                return ArrayLiteral.compile(self, position, elements, type)
            }
            when ASTNode.AT_PRE(position, expr) {
                return AtPre.compile(self, position, expr, type)
            }
            when ASTNode.AT_RETURN(position) {
                return AtReturn.compile(self, position, type)
            }
            when ASTNode.BINARY(position, left, op, right) {
                return Binary.compile(self, position, left, op, right, type)
            }
            when ASTNode.BIT(_, value) {
                match type {
                    when TypeContext.TYPE(t, _) {
                        if t = Type.BuiltinBit() {
                            return IR.Value.BIT(value)
                        }
                    }
                }
                return coerce(expr.position(),
                        coerce(expr.position(), IR.Value.BIT(value), Type.Bit()),
                        type)
            }
            when ASTNode.CALL(position, m, args) {
                return Call.compile(self, position, m, args, false, type)
            }
            when ASTNode.DOT(position, base, name) {
                def t := tryResolveType(expr)
                if t !== null {
                    return coerce(expr.position(), IR.Value.TYPE(t), type)
                }
                return coerce(expr.position(), Dot.compile(self, position, base, name), type)
            }
            when ASTNode.DOT_GENERICS(position, base, name, types) {
                def t := tryResolveType(expr)
                if t !== null {
                    return coerce(expr.position(), IR.Value.TYPE(t), type)
                }
                def dot := Dot.compile(self, position, base, name)
                if dot == null {
                    return null
                }
                return coerce(expr.position(), genericMethodRef(dot, types), type)
            }
            when ASTNode.IDENTIFIER(position, name) {
                return coerce(expr.position(), Identifier.compile(self, position, name), type)
            }
            when ASTNode.IDENTIFIER_GENERICS(position, name, types) {
                def identifier := Identifier.compile(self, position, name)
                if identifier == null {
                    return null
                }
                return coerce(expr.position(), genericMethodRef(identifier, types), type)
            }
            when ASTNode.INT(position, value) {
                return IntLiteral.compile(self, position, value, type)
            }
            when ASTNode.IR_WRAPPER(_, value) {
                return coerce(expr.position(), value, type)
            }
            when ASTNode.METHOD(position, _, _, kind, _, _, parameters, returnType, body) {
                return Closure.compile(self, position, kind, parameters, returnType, body, type)
            }
            when ASTNode.NULL(position) {
                return compileNull(position, type)
            }
            when ASTNode.UNARY(position, op, operand) {
                return Unary.compile(self, position, op, operand, type)
            }
            when ASTNode.RANGE(position, start, inclusive, end, step) {
                return compileRange(position, start, inclusive, end, step, type)
            }
            when ASTNode.REAL(position, value) {
                return compileReal(position, value, type)
            }
            when ASTNode.REGEX(position, text) {
                return compileRegex(position, text)
            }
            when ASTNode.SELF(position) {
                return coerce(position, compileSelf(position, true), type)
            }
            when ASTNode.SUPER(position) {
                error(position, "'super' may not appear in this context")
                return null
            }
            when ASTNode.STRING(position, text) {
                match type {
                    when TypeContext.TYPE(t, _) {
                        if text.length = 1 {
                            if t.isChar {
                                return compileExpression(ASTNode.CALL(position,
                                        ASTNode.IR_WRAPPER(position, IR.Value.TYPE(t)),
                                        FixedArray<ASTNode>.from([ASTNode.INT(position,
                                            text[0].asUInt64)])))
                            }
                            if t = Type.Value() {
                                return coerce(position, compileExpression(ASTNode.CALL(position,
                                        ASTNode.IR_WRAPPER(position, IR.Value.TYPE(Type.Char32())),
                                        FixedArray<ASTNode>.from([ASTNode.INT(position,
                                            text[0].asUInt64)]))), t)
                            }
                        }
                    }
                }
                return coerce(expr.position(), IR.Value.STRING(text), type)
            }
            when ASTNode.TUPLE(position, args) {
                return Tuple.compile(self, position, args, type)
            }
            when ASTNode.TYPE, ASTNode.GENERIC_TYPE {
                def type := resolve(scanner.convertType(expr))
                if type == null {
                    return null
                }
                return IR.Value.TYPE(type)
            }
            when ASTNode.TYPED_LAMBDA(position, parameters, body) {
                return Closure.compileTypedLambda(self, position, parameters, body, type)
            }
            when ASTNode.UNTYPED_LAMBDA(position, parameters, body) {
                return Closure.compileUntypedLambda(self, position, parameters, body, type)
            }
            otherwise {
                unreachable
            }
        }
    }

    @post(typeMatch(@return, type) & (@return !== null | errorCount > 0 | !reportErrors))
    method compileExpression(expr:ASTNode, type:TypeContext):IR.Value? {
        def unresolved := compileMethodExpression(expr, type)
        if unresolved == null {
            return null
        }
        match unresolved {
            when IR.Value.METHOD(target, m) {
                return coerce(expr.position(), createMethodObject(expr.position(), target, m), type)
            }
            when IR.Value.METHODS(target, methods) {
                match type {
                    when TypeContext.TYPE(t, _) {
                        if !t.nonnullable().isMethod {
                            error(expr.position(), "unresolved method reference cannot possibly " +
                                    "be an instance of '\{t}'")
                        }
                        def best := Array<MethodDecl>()
                        var bestCost := Int.MAX
                        for m in methods {
                            if resolve(m) {
                                def cost := coercionCost(m.type, t)
                                if cost !== null {
                                    if cost.second < bestCost {
                                        bestCost := cost.second
                                        best.clear()
                                    }
                                    if cost.second = bestCost {
                                        best.add(m)
                                    }
                                }
                            }
                        }
                        if best.count = 1 {
                            return compileExpression(ASTNode.IR_WRAPPER(expr.position(),
                                    IR.Value.METHOD(target, best[0])), type)
                        }
                        if best.count = 0 {
                            error(expr.position(), "no method '\{methods[0].name}' matching " +
                                    "expected type '\{t}'")
                            return null
                        }
                    }
                }
                def msg := MutableString("ambiguous reference to method '\{methods[0].name}'. " +
                        "The following methods are equally good matches:")
                for m in methods.sort((a, b) => a.position > b.position) {
                    msg.append("\n    \{m.declaration} (\{m.owner.source.name}:\{m.position})")
                }
                error(expr.position(), msg.finish())
                return null
            }
            otherwise {
                return unresolved
            }
        }
    }

    method compileExpression(expr:ASTNode):IR.Value? {
        return compileExpression(expr, TypeContext.UNSPECIFIED)
    }

    ================================================================================================
    Logically equivalent to evaluating test and then compiling `branch test, ifTrue, ifFalse`, but
    handles AND and OR expressions in fashion which is both simpler and more amenable to analysis.
    ================================================================================================
    method compileConditionalBranch(test:ASTNode, ifTrue:IR.Block.ID, ifFalse:IR.Block.ID) {
        match test {
            when ASTNode.BINARY(position, left, op, right) {
                if coercionCost(left, Type.Bit()) !== null {
                    match op {
                        when Binary.Operator.AND {
                            And.compileConditionalBranch(self, position, left, right, ifTrue,
                                    ifFalse)
                            return
                        }
                        when Binary.Operator.OR {
                            Or.compileConditionalBranch(self, position, left, right, ifTrue,
                                    ifFalse)
                            return
                        }
                    }
                }
            }
        }
        def testBit:IR.Value
        {
            def unrefs := AutoUnrefs(self)
            def compiledTest := compileExpression(test, TypeContext.TYPE(Type.Bit(), false))
            if compiledTest == null {
                return
            }
            testBit := extractBuiltinBit(test.position(), compiledTest)
        }
        ir.add(IR.Statement.CONDITIONAL_BRANCH(test.position(), testBit, ifTrue, ifFalse))
    }

    @pre(owner.name = context.name & owner.parameters.count = context.parameters.count)
    method compileConditionalBranchInContext(expr:ASTNode, ifTrue:IR.Block.ID, ifFalse:IR.Block.ID,
            owner:MethodDecl, context:MethodDecl) {
        def symbols := AutoScope(self)
        for i in 0 .. owner.parameters.count {
            symbolTable.add(symbols.oldSymbolTable[context.parameters[i].name],
                    owner.parameters[i].name)
        }
        compileConditionalBranch(expr, ifTrue, ifFalse)
    }

    method findAndLeaveToLoopScope(position:Position, label:String?):EnclosingContext? {
        for c in enclosingContexts {
            match c {
                when EnclosingContext.LOOP(loopLabel, _, _) {
                    if label == null | loopLabel !== null & label = loopLabel {
                        return c
                    }
                }
            }
            leaveScope(c)
        }
        if label == null {
            error(position, "not in a loop")
        }
        else {
            error(position, "not in a loop labeled '\{label}'")
        }
        return null
    }

    function getTryScope():Pair<IR.Block.ID?, Variable?>? {
        for c in enclosingContexts {
            match c {
                when EnclosingContext.TRY_SCOPE(failBlock, errorVar) {
                    return Pair<IR.Block.ID?, Variable?>(failBlock, errorVar)
                }
            }
        }
        return null
    }

    method leaveTryScope() {
        for c in enclosingContexts {
            match c {
                when EnclosingContext.TRY_SCOPE {
                    return
                }
            }
            leaveScope(c)
        }
        unreachable
    }

    @pre(bit.type() = Type.Bit())
    method extractBuiltinBit(position:Position, bit:IR.Value):IR.Value {
        def result := ir.add(IR.Statement.EXTRACT_FIELD(position, bit,
                getSymbolTable(getClass(Type.Bit()))["value"]->FieldDecl))
        return IR.Value.REF(result, Type.BuiltinBit())
    }

    method extractBuiltinInt(position:Position, int:IR.Value):IR.Value {
        def field := getSymbolTable(getClass(int.type()))["value"]->FieldDecl
        assert field !== null
        resolve(field)
        def result := ir.add(IR.Statement.EXTRACT_FIELD(position, int, field))
        return IR.Value.REF(result, field.type)
    }

    method compileTarget(t:ASTNode, kind:Variable.Kind,
            rawValue:ASTNode?, valueType:Type?):Target? {
        match t {
            when ASTNode.IDENTIFIER(position, name) {
                -- no type, infer from value
                def value:IR.Value?
                def type:Type
                if rawValue !== null {
                    var preferred := preferredType(rawValue)
                    if preferred == null {
                        value := compileExpression(rawValue, TypeContext.NON_VOID)
                        if value == null {
                            return null
                        }
                        preferred := value.type()
                    }
                    else {
                        value := compileExpression(rawValue, TypeContext.TYPE(preferred, false))
                    }
                    if value == null {
                        return null
                    }
                    type := value.type()
                }
                else if valueType !== null {
                    type := valueType
                }
                else {
                    error(position, "declaration has neither a type nor a value")
                    return null
                }
                def v := Variable(position, kind, name, type,
                        Variable.Storage.LOCAL(ir.locals.count))
                v.owner := currentMethod[0]
                if isRefCounted(v.type) {
                    ir.add(IR.Statement.STORE(position, IR.Value.NULL(v.type.nullable()),
                            IR.Value.LOCAL(ir.locals.count, v.type)))
                }
                ir.locals.add(v.type)
                symbolTable.add(v)
                return Target.VARIABLE(v, value)
            }
            when ASTNode.TUPLE_TARGET(_, targets) {
                def finalType:Type? := null
                def compiledTuple:IR.Value?
                if rawValue !== null {
                    compiledTuple := compileExpression(rawValue, TypeContext.NON_VOID)
                    finalType := compiledTuple.type()
                }
                else if valueType !== null {
                    finalType := valueType
                }
                if finalType !== null & finalType.nonnullable().typeKind = Type.Kind.TUPLE {
                    def result := Array<Target>()
                    def valueTypes := finalType.nonnullable().subtypes
                    if valueTypes.count != targets.count {
                        error(t.position(), "cannot assign \{targets.count}-element tuple to " +
                                "\{valueTypes.count}-element target")
                        return null
                    }
                    for i in 0 .. targets.count {
                        def target:Target?
                        if compiledTuple !== null {
                            def position := rawValue.position()
                            def field := ASTNode.IR_WRAPPER(position, cast(position, 
                                    Dot.compile(self, position, compiledTuple, "f\{i}"),
                                    compiledTuple.type().subtypes[i]))
                            assert field !== null
                            target := compileTarget(targets[i], kind, field, null)
                        }
                        else {
                            target := compileTarget(targets[i], kind, null, valueType.subtypes[i])
                        }
                        if target == null {
                            return null
                        }
                        result.add(target)
                    }
                    return Target.TUPLE(FixedArray<Target>.from(result))
                }
                error(t.position(), "cannot use a tuple target without a tuple value")
                return null
            }
            when ASTNode.TYPED_IDENTIFIER(position, name, rawType) {
                def type := resolve(scanner.convertType(rawType))
                if type == null {
                    return null
                }
                def value:IR.Value?
                if rawValue !== null {
                    value := compileExpression(rawValue, TypeContext.TYPE(type, false))
                    if value == null {
                        return null
                    }
                }
                else {
                    value := null
                }
                def v := Variable(position, kind, name, type,
                        Variable.Storage.LOCAL(ir.locals.count))
                v.owner := currentMethod[0]
                if isRefCounted(v.type) {
                    ir.add(IR.Statement.STORE(position, IR.Value.NULL(v.type.nullable()),
                            IR.Value.LOCAL(ir.locals.count, v.type)))
                }
                ir.locals.add(v.type)
                symbolTable.add(v)
                return Target.VARIABLE(v, value)
            }
            otherwise {
                unreachable
            }
        }
    }

    method createScopes(target:Target) {
        match target {
            when Target.VARIABLE(v, _) {
                if isRefCounted(v.type) {
                    enclosingContexts.push(EnclosingContext.VARIABLE_SCOPE(v))
                }
            }
            when Target.TUPLE(targets) {
                targets.apply(self.initializeTarget)
            }
            otherwise {
                assert false
            }
        }
    }

    method initializeTarget(target:Target) {
        match target {
            when Target.VARIABLE(v, value) {
                if value !== null {
                    VariableLValue(self, v.position, v).compileStore(value)
                }
            }
            when Target.TUPLE(targets) {
                targets.apply(self.initializeTarget)
            }
            otherwise {
                assert false
            }
        }
    }

    method compileStore(position:Position, target:Target, value:IR.Value) {
        match target {
            when Target.VARIABLE(v, _) {
                VariableLValue(self, v.position, v).compileStore(value)
            }
            when Target.TUPLE(targets) {
                def type := value.type().nonnullable()
                if type.typeKind = Type.Kind.TUPLE & type.subtypes.count = targets.count {
                    for i in 0 .. targets.count {
                        compileStore(position, targets[i], cast(position, Dot.compile(self,
                                position, value, "f\{i}"), type.subtypes[i]))
                    }
                }
                else {
                    error(position, "cannot store '\{value.type()}' into a tuple with " +
                            "\{targets.count} elements")
                }
            }
            otherwise {
                assert false
            }
        }
    }

    method compileDeclaration(position:Position, target:ASTNode, value:ASTNode?,
            varKind:Variable.Kind) {
        def compiledTarget:Target?
        {
            def unrefs := AutoUnrefs(self)
            compiledTarget := compileTarget(target, varKind, value, null)
            if compiledTarget == null {
                return
            }
            initializeTarget(compiledTarget)
        }
        createScopes(compiledTarget)
    }

    method leaveScope(c:EnclosingContext) {
        if ir.currentBlockFinished {
            -- we've already left the scope by other means; cleanup will have happened there
            return
        }
        match c {
            when EnclosingContext.VARIABLE_SCOPE(v) {
                def ref := symbolRef(v.position, null, v)
                assert ref !== null
                compileUnref(ref)
                match v.storage {
                    when Variable.Storage.LOCAL(slot) {
                        ir.add(IR.Statement.STORE(v.position,
                                IR.Value.NULL(v.type.nullable()),
                                IR.Value.LOCAL(slot, v.type.nullable())))
                    }
                    otherwise {
                        unreachable
                    }
                }
            }
            when EnclosingContext.VALUE_SCOPE(v) {
                compileUnref(v)
            }
        }
    }

    method leaveAllScopes() {
        for c in enclosingContexts {
            leaveScope(c)
        }
    }

    @post(symbolTable == @pre(symbolTable))
    method compileStatement(s:ASTNode) {
        match s {
            when ASTNode.UNREACHABLE {
            }
            otherwise {
                ir.currentBlock.containsExplicitCode := true
            }
        }
        ir.add(IR.Statement.COMMENT(s.position(), "line \{s.position().line}"))
        def unrefs := AutoUnrefs(self)
        match s {
            when ASTNode.ASSERT(position, test, msg) {
                Assert.compile(self, position, test, msg)
            }
            when ASTNode.BINARY(position, left, op, right) {
                Assignment.compile(self, position, left, op, right)
            }
            when ASTNode.BLOCK(position, statements) {
                def symbols := AutoScope(self)
                for stmt in statements {
                    compileStatement(stmt)
                }
            }
            when ASTNode.BREAK(position, label) {
                Break.compile(self, position, label)
            }
            when ASTNode.CALL(position, m, args) {
                Call.compile(self, position, m, args, true, TypeContext.UNSPECIFIED)
            }
            when ASTNode.CONTINUE(position, label) {
                Continue.compile(self, position, label)
            }
            when ASTNode.DO(position, label, statements, test) {
                Do.compile(self, position, label, statements, test)
            }
            when ASTNode.FOR(position, label, target, list, statements) {
                For.compile(self, position, label, target, list, statements)
            }
            when ASTNode.IDENTIFIER(position, _) {
                error(position, "expected a statement")
            }
            when ASTNode.IF(position, test, ifTrue, ifFalse) {
                If.compile(self, position, test, ifTrue, ifFalse)
            }
            when ASTNode.LOOP(position, label, statements) {
                Loop.compile(self, position, label, statements)
            }
            when ASTNode.MATCH(position, value, whens, other) {
                Match.compile(self, position, value, whens, other)
            }
            when ASTNode.METHOD(position, _, _, kind, name, _, parameters, returnType, body) {
                InnerMethod.compile(self, position, kind, name, parameters, returnType, body)
            }
            when ASTNode.RETURN(position, value) {
                Return.compile(self, position, value)
            }
            when ASTNode.UNREACHABLE(position, message) {
                Assert.compileFail(self, position, message)
            }
            when ASTNode.TRY(position, block, error, failBlock) {
                Try.compile(self, position, block, error, failBlock)
            }
            when ASTNode.VAR(position, kind, decls) {
                Var.compile(self, position, kind, decls)
            }
            when ASTNode.WHILE(position, label, test, statements) {
                While.compile(self, position, label, test, statements)
            }
            otherwise {
                unreachable
            }
        }
    }

    method hasSelfParam(m:MethodDecl):Bit {
        if m.annotations.isClass {
            return false
        }
        if m.methodKind != MethodDecl.Kind.INIT {
            return true
        }
        return !isValue(m.owner)
    }

    function callsSelfInit(body:FixedArray<ASTNode>):Bit {
        if body.count = 0 {
            return false
        }
        for s in body {
            match s {
                when ASTNode.CALL(_, target, _) {
                    match target {
                        when ASTNode.IDENTIFIER(_, text) {
                            if text = "init" {
                                return true
                            }
                        }
                        when ASTNode.DOT(_, base, text) {
                            if text = "init" {
                                match base {
                                    when ASTNode.SELF {
                                        return true
                                    }
                                }
                            }
                        }
                    }
                }
            }
        }
        return false
    }

    function callsSuperInit(body:FixedArray<ASTNode>):Bit {
        if body.count = 0 {
            return false
        }
        for s in body {
            match s {
                when ASTNode.CALL(_, target, _) {
                    match target {
                        when ASTNode.DOT(_, base, text) {
                            if text = "init" {
                                match base {
                                    when ASTNode.SUPER {
                                        return true
                                    }
                                }
                            }
                        }
                    }
                }
            }
        }
        return false

    }

    ================================================================================================
    Compiles an expression (which was found attached to `owner`) for use within `context`. The
    expression may reference parameters of `owner`, and these references will be interpreted as if
    they refer to the corresponding parameters of `context`. For instance, if we have two methods:

        @pre(param.count() > 0)
        method check(param:Array<Object>)

    and:

        @override
        method check(arr:Array<Object>)

    where the second method overrides the first, we need to attach the precondition expression to
    both methods. Since the second `check` method does not have a parameter named `param`, we need
    to use `compileExpressionInContext` to be able to compile the expression correctly.
    ================================================================================================
    @pre(owner.name = context.name & owner.parameters.count = context.parameters.count)
    method compileExpressionInContext(expr:ASTNode, type:TypeContext, owner:MethodDecl,
            context:MethodDecl):IR.Value? {
        def symbols := AutoScope(self)
        for i in 0 .. owner.parameters.count {
            symbolTable.add(symbols.oldSymbolTable[context.parameters[i].name],
                    owner.parameters[i].name)
        }
        return compileExpression(expr, type)
    }

    method compilePreconditions() {
        def m := currentMethod[0]
        var start:IR.Block.ID? := null
        var failBlock:IR.Block.ID? := null
        var current := m
        loop {
            var havePre := false
            if current.annotations.expressions !== null {
                for ann in current.annotations.expressions {
                    match ann {
                        when Annotations.Expression.PRE(_, expr) {
                            if current == m {
                                if m.overridden !== null {
                                    error(expr.position(), "cannot use '@pre' in a method which " +
                                            "overrides another method; did you mean '@preOr'?")
                                }
                                if havePre {
                                    error(expr.position(), "found more than one precondition")
                                }
                            }
                            havePre := true
                            if start == null {
                                start := ir.newBlock("@pre success")
                            }
                            failBlock := ir.newBlock("@pre fail")
                            compileConditionalBranchInContext(expr, start, failBlock, current, m)
                            ir.setCurrentBlock(failBlock)
                        }
                        when Annotations.Expression.PRE_OR(_, expr) {
                            if current == m {
                                if m.overridden == null {
                                    error(expr.position(), "cannot use '@preOr' in a method " +
                                            "which does not override another method; did you " +
                                            "mean '@pre'?")
                                }
                                if havePre {
                                    error(expr.position(), "found more than one precondition")
                                }
                            }
                            havePre := true
                            if start == null {
                                start := ir.newBlock("@preOr success")
                            }
                            failBlock := ir.newBlock("@preOr fail")
                            compileConditionalBranchInContext(expr, start, failBlock, current, m)
                            ir.setCurrentBlock(failBlock)
                        }
                    }
                }
            }
            if current.overridden == null {
                break
            }
            current := current.overridden
        }
        if failBlock !== null {
            Assert.compileFail(self, m.position, ASTNode.STRING(m.position,
                    "precondition failure for \{m.declaration}"))
            assert start !== null
            ir.setCurrentBlock(start)
        }
    }

    method compilePostcondition(compiling:MethodDecl, postconditionOwner:MethodDecl,
            expr:ASTNode, successFail:Array<IR.Block.ID?>) {
        if postconditionEntryBlock == null {
            postconditionEntryBlock := ir.newBlock("postcondition entry")
            postconditionCurrentBlock := postconditionEntryBlock
        }
        if returnVar == null & compiling.returnType != Type.Void()  {
            returnVar := Variable(compiling.position, Variable.Kind.DEF, "$return",
                    compiling.returnType, Variable.Storage.LOCAL(ir.locals.count))
            ir.locals.add(returnVar.type)
        }
        ir.setCurrentBlock(postconditionCurrentBlock)
        def value := compileExpressionInContext(expr,
                TypeContext.TYPE(Type.Bit(), false), postconditionOwner, compiling)
        if value == null {
            return
        }
        successFail[0] := ir.newBlock("postcondition success")
        if successFail[1] == null {
            successFail[1] := ir.newBlock("postcondition fail")
            def old := ir.currentBlock.id
            ir.setCurrentBlock(successFail[1])
            Assert.compileFail(self, compiling.position, ASTNode.STRING(compiling.position,
                    "postcondition failure for \{compiling.declaration}"))
            ir.setCurrentBlock(old)
        }
        ir.add(IR.Statement.CONDITIONAL_BRANCH(compiling.position,
                extractBuiltinBit(compiling.position, value), successFail[0], successFail[1]))
        ir.setCurrentBlock(successFail[0])
        postconditionCurrentBlock := ir.currentBlock.id
    }

    method compilePostconditions() {
        def m := currentMethod[0]
        atPreBlock := ir.currentBlock.id
        def successFail:Array<IR.Block.ID?> := [null, null]
        var current := m
        var havePost := false
        loop {
            if current.annotations.expressions !== null {
                for ann in current.annotations.expressions {
                    match ann {
                        when Annotations.Expression.POST(_, expr) {
                            if current == m {
                                if m.overridden !== null {
                                    error(expr.position(), "cannot use '@post' in a method which " +
                                            "overrides another method; did you mean '@postAnd'?")
                                }
                                if havePost {
                                    error(expr.position(), "found more than one postcondition")
                                }
                            }
                            havePost := true
                            compilePostcondition(m, current, expr, successFail)
                        }
                        when Annotations.Expression.POST_AND(_, expr) {
                            assert !ir.currentBlockFinished
                            if current == m {
                                if m.overridden == null {
                                    error(expr.position(), "cannot use '@postAnd' in a method " +
                                            "which does not override another method; did you " +
                                            "mean '@post'?")
                                }
                                if havePost {
                                    error(expr.position(), "found more than one postcondition")
                                }
                            }
                            havePost := true
                            compilePostcondition(m, current, expr, successFail)
                        }
                    }
                }
            }
            if current.overridden == null {
                break
            }
            current := current.overridden
        }
        if havePost {
            def returnValue:IR.Value?
            if returnVar !== null {
                def returnSlot:Int
                match returnVar.storage {
                    when Variable.Storage.LOCAL(slot) {
                        returnSlot := slot
                    }
                }
                returnValue := IR.Value.REF(ir.add(IR.Statement.LOAD(m.position,
                        IR.Value.LOCAL(returnSlot, returnVar.type))),
                        returnVar.type)
            }
            ir.add(IR.Statement.RETURN(m.position, returnValue))
            ir.setCurrentBlock(atPreBlock)        
        }
        atPreBlock := null
    }

    -- to avoid calling super.init for a few common classes we know for sure will never do anything
    -- interesting in their init methods. This is especially important for Value classes, which
    -- would have to be wrapped in order to perform super.init calls.
    function hasTrivialInit(cl:ClassDecl?):Bit {
        -- FIXME should be able to roll this into match below
        if cl == null {
            return true
        }
        match cl.name {
            when "frost.core.Object", "frost.core.Immutable", "frost.core.Value" {
                return true
            }
            otherwise {
                return false
            }
        }
    }

    method compile(m:MethodDecl) {
        compile(m, null)
    }

    function hasPostconditions(m:MethodDecl):Bit {
        if m.annotations.expressions !== null {
            for ann in m.annotations.expressions {
                match ann {
                    when Annotations.Expression.POST, Annotations.Expression.POST_AND {
                        return true
                    }
                }
            }
        }
        return false
    }

    method compile(m:MethodDecl, enclosingContext:SymbolTable?) {
        if !resolve(m) {
            return
        }
        coercionCosts.clear()
        binaryTypes.clear()
        currentMethod.push(m)
        checkAnnotations(m)
        if m.owner.classKind = ClassDecl.Kind.CHOICE & m.name = "cleanup" {
            createChoiceCleanup(m)
        }
        if m.body !== null {
            def oldAtPreBlock := atPreBlock
            def oldPostconditionEntryBlock := postconditionEntryBlock
            def oldPostconditionCurrentBlock := postconditionCurrentBlock
            def oldIR := ir
            ir := IR()
            atPreBlock := ir.currentBlock.id
            postconditionEntryBlock := null
            postconditionCurrentBlock := null
            returnVar := null
            {
                def auto := AutoScope(self)
                methodSymbolTable := symbolTable
                if enclosingContext !== null {
                    symbolTable.parents.add(enclosingContext)
                }
                if m.genericParameters !== null {
                    m.genericParameters.apply(symbolTable.add)
                }
                if m.name = "main" {
                    if m.methodKind != MethodDecl.Kind.METHOD {
                        error(m.position, "'main' must be a method")
                    }
                    if m.returnType != Type.Void() {
                        error(m.position, "'main' must not have a return type")
                    }
                    if !m.annotations.isClass {
                        error(m.position, "'main' must be declared @class")
                    }
                    def required := "frost.collections.ListView<frost.core.String>"
                    if m.parameters.count > 1 |
                            (m.parameters.count = 1 & m.parameters[0].type.name != required) {
                        error(m.position, "'main' must have either zero parameters or one " +
                                "parameter of type '\{required}'")
                    }
                }
                var index := 0
                if hasSelfParam(m) {
                    def selfParam := Variable(m.position, Variable.Kind.DEF, SELF_NAME,
                            m.owner.typeWithParameters(), Variable.Storage.PARAMETER(index))
                    index += 1
                    selfParam.owner := m
                    symbolTable.add(selfParam)
                }
                else if !m.annotations.isClass {
                    def selfVar := Variable(m.position, Variable.Kind.DEF, SELF_NAME,
                            m.owner.typeWithParameters(), Variable.Storage.LOCAL(0))
                    selfVar.owner := m
                    ir.locals.add(selfVar.type)
                    symbolTable.add(selfVar)
                }
                if m.methodKind = MethodDecl.Kind.INIT {
                    if !callsSelfInit(m.body) {
                        def unrefs := AutoUnrefs(self)
                        for f in m.owner.fields {
                            if f.rawValue !== null & !f.annotations.isClass {
                                def p := f.rawValue.position()
                                compileStatement(ASTNode.BINARY(p,
                                        ASTNode.DOT(p, ASTNode.SELF(p), f.name),
                                        Binary.Operator.ASSIGNMENT, f.rawValue))
                            }
                        }
                        if !callsSuperInit(m.body) & m.owner.rawSuper !== null &
                                !hasTrivialInit(getClass(m.owner.rawSuper)) {
                            def p := m.position
                            compileStatement(ASTNode.CALL(p, ASTNode.DOT(p, ASTNode.SUPER(p),
                                    "init"), FixedArray<ASTNode>() -* FIXME literal *-))
                        }
                    }
                }
                for p in m.parameters {
                    def v := Variable(m.position, Variable.Kind.DEF, p.name, p.type,
                            Variable.Storage.PARAMETER(index))
                    v.owner := m
                    symbolTable.add(v)
                    index += 1
                }
                compilePreconditions()
                compilePostconditions()
                for s in m.body {
                    compileStatement(s)
                }
                if !ir.currentBlockFinished {
                    if m.returnType = Type.Void() | m.methodKind = MethodDecl.Kind.INIT {
                        Return.compile(self, m.position, null)
                    }
                    else {
                        def endBlock := ir.newBlock("end")
                        ir.add(IR.Statement.BRANCH(m.position, endBlock))
                        ir.setCurrentBlock(endBlock)
                        ir.add(IR.Statement.END)
                    }
                }
            }
            if writeCode & errorCount = 0 {
                Analyzer(self, m, ir).analyze()
                codeGenerator.write(m, ir)
            }
            ir := oldIR
        }
        else {
            codeGenerator.writeDeclaration(m)
        }
        currentMethod.pop()
    }

    method markNonExternal(cl:ClassDecl) {
        cl.external := false
        for inner in cl.classes {
            markNonExternal(inner)
        }
    }

    method checkImmutable(cl:ClassDecl) {
        if !cl.annotations.isUnsafeImmutable & isImmutable(cl) {
            for f in cl.fields {
                resolve(f)
                if f.fieldKind = FieldDecl.Kind.VAR {
                    error(f.position, "immutable class '\{cl.name}' cannot contain a 'var'")
                }
                else if !isImmutable(f.type) & f.fieldKind != FieldDecl.Kind.PROPERTY {
                    error(f.position, "immutable class '\{cl.name}' cannot contain mutable field " +
                            "'\{f.name}' of type '\{f.type}'")
                }
            }
        }
    }

    method checkValue(cl:ClassDecl) {
        if false & isValue(cl) {
            for f in cl.fields {
                resolve(f)
                if f.type.isClass {
                    if !isValue(getClass(f.type)) {
                        error(f.position, "value class '\{cl.name}' cannot contain non-value " +
                                "field '\{f.name}' of type '\{f.type}'")
                    }
                }
            }
        }
    }

    method checkAnnotations(cl:ClassDecl) {
        method disallow(flag:Int, name:String) {
            if cl.annotations.flags && flag != 0 {
                self.error(cl.position, "classes may not be annotated with '\{name}'")
            }
        }
        disallow(Annotations.Flag.PROTECTED, "@protected")
        disallow(Annotations.Flag.CLASS,     "@class")
        disallow(Annotations.Flag.OVERRIDE,  "@override")
        disallow(Annotations.Flag.EXTERNAL,  "@external")
        disallow(Annotations.Flag.IMPLICIT,  "@implicit")
        disallow(Annotations.Flag.INLINE,    "@inline")
        disallow(Annotations.Flag.WEAK,      "@weak")
        disallow(Annotations.Flag.DEFAULT,   "@default")
        if cl.annotations.expressions !== null {
            for expr in cl.annotations.expressions {
                match expr {
                    when Annotations.Expression.PRE {
                        error(cl.position, "classes may not be annotated with '@pre'")
                    }
                    when Annotations.Expression.POST {
                        error(cl.position, "classes may not be annotated with '@post'")
                    }
                    when Annotations.Expression.PRE_OR {
                        error(cl.position, "classes may not be annotated with '@preOr'")
                    }
                    when Annotations.Expression.POST_AND {
                        error(cl.position, "classes may not be annotated with '@postAnd'")
                    }
                }
            }
        }
        checkAccessModifierCount(cl.position, cl.annotations)
    }

    method checkAnnotations(f:FieldDecl) {
        method disallow(flag:Int, name:String) {
            if f.annotations.flags && flag != 0 {
                self.error(f.position, "fields may not be annotated with '\{name}'")
            }
        }
        disallow(Annotations.Flag.OVERRIDE,         "@override")
        disallow(Annotations.Flag.EXTERNAL,         "@external")
        disallow(Annotations.Flag.IMPLICIT,         "@implicit")
        disallow(Annotations.Flag.ABSTRACT,         "@abstract")
        disallow(Annotations.Flag.INLINE,           "@inline")
        disallow(Annotations.Flag.SPECIALIZE,       "@specialize")
        disallow(Annotations.Flag.UNSAFE_IMMUTABLE, "@unsafeImmutable")
        disallow(Annotations.Flag.DEFAULT,          "@default")
        if f.annotations.expressions !== null {
            for expr in f.annotations.expressions {
                match expr {
                    when Annotations.Expression.PRE {
                        error(f.position, "fields may not be annotated with '@pre'")
                    }
                    when Annotations.Expression.POST {
                        error(f.position, "fields may not be annotated with '@post'")
                    }
                    when Annotations.Expression.PRE_OR {
                        error(f.position, "fields may not be annotated with '@preOr'")
                    }
                    when Annotations.Expression.POST_AND {
                        error(f.position, "fields may not be annotated with '@postAnd'")
                    }
                }
            }
        }
        if f.resolved = Resolution.RESOLVED {
            if f.annotations.isClass & !isImmutable(f.type) {
                error(f.position, "only immutable fields may be annotated with '@class'")
            }
            if f.annotations.isClass & f.fieldKind = FieldDecl.Kind.VAR {
                error(f.position, "'var' fields may not be annotated with '@class'")
            }
        }
        checkAccessModifierCount(f.position, f.annotations)
    }

    @post(currentClass.count = @pre(currentClass.count))
    method compile(cl:ClassDecl) {
        currentClass.push(cl)
        checkAnnotations(cl)
        resolve(cl)
        if cl.resolved != Resolution.RESOLVED {
            currentClass.pop()
            return
        }
        if cl.annotations.isSpecialize {
            codeGenerator.start(cl)
            codeGenerator.end(cl)
            currentClass.pop()
            return
        }
        def auto := AutoScope(self, getSymbolTable(cl))
        checkImmutable(cl)
        checkValue(cl)
        checkInterfaceMethods()
        var started := false
        for f in cl.fields {
            resolve(f)
            checkAnnotations(f)
        }
        for m in cl.methods {
            resolve(m)
        }
        if errorCount = 0 {
            codeGenerator.start(cl)
            started := true
        }
        for m in cl.methods {
            compile(m)
        }
        if started {
            codeGenerator.end(cl)
        }
        currentClass.pop()

        if compilationQueue.count > 0 {
            def next := compilationQueue[0]
            compilationQueue.removeIndex(0)
            compile(next)
        }
        assert compilationQueue.count = 0
    }

    method scan(raw:File):ListView<ClassDecl> {
        def file := raw.absolute().get()
        var result := scans[file]
        if result == null {
            try {
                parser.start(file, file.readFully())
                def parsed := parser.file()
                if parsed !== null {
                    result := scanner.scan(file, parsed)
                    for cl in result {
                        classes[cl.name] := cl
                    }
                }
                else {
                    result := Array<ClassDecl>()
                }
            }
            fail(err) {
                error(raw, Position(1, 1), err.message)
            }
            scans[file] := result
        }
        return result
    }

    method compile(file:File) {
        for cl in scan(file) {
            compile(cl)
        }
    }

    method error(position:Position, msg:String) {
        error(currentClass[0].source, position, msg)
    }

    method error(file:File, pos:Position, msg:String) {
        if reportErrors {
            errorCount += 1
            errorQueue.post(Message.ERROR(file, pos, msg))
        }
    }

    method warn(position:Position, msg:String) {
        warn(currentClass[0].source, position, msg)
    }

    method warn(file:File, pos:Position, msg:String) {
        if reportErrors {
            errorQueue.post(Message.WARNING(file, pos, msg))
        }
    }

    method finish() {
        while pendingClasses.count > 0 {
            def cl := pendingClasses.removeIndex(pendingClasses.count - 1)
            compile(cl)
        }
        codeGenerator.finish()
    }
}
