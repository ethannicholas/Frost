package org.frostlang.frostc

uses org.frostlang.frostc.frostdoc.FrostDoc
uses org.frostlang.frostc.parser.Lexer
uses org.frostlang.frostc.parser.Parser
uses org.frostlang.frostc.parser.TokenKind

@final
class Main {
    choice Format {
        LLVM
        EXECUTABLE
        OBJECT
        C
        HTML
        STUB
        RUN
    }

    var clang:File
    def frostHome:File

    init() {
        frostHome := File(Config.frostSourceDir())
    }

    class Arguments {
        @private
        def args:ListView<String>

        @private
        def index := 1

        property done:Bit

        init(args:ListView<String>) {
            self.args := args
        }

        function get_done():Bit {
            return index = args.count
        }

        method next():String {
            assert !done
            index += 1
            return args[index - 1]
        }

        method next(label:String):String {
            if done {
                Console.printErrorLine("expected \{label} after '\{args[args.count - 1]}'")
                System.exit(1)
            }
            return next()
        }
    }

    method toObject(llvm:File, dest:File, preserveTemporaries:Bit,
            settings:Compiler.Settings):File {
        def args := Array<String>() -- FIXME literal
        args.add(llvm.path)
        args.add("-m64")
        args.add("-fPIC")
        args.add("-c")
        if settings.debug {
            args.add("-g")
        }
        args.add("-O\{settings.optimizationLevel}")
        args.add("-o")
        args.add(dest.path)
        def p:System.Process
        try {
            p := System.exec(clang.path, args)
            -- FIXME shouldn't have to use unsafeStart here
            def t1 := Thread.unsafeStart(method() {
                try {
                    p.standardOutput().sendTo(Console.outputStream())
                }
                fail(error) {
                    Console.printLine(error)
                    System.exit(1)
                }
            })
            def t2 := Thread.unsafeStart(method() {
                try {
                    p.standardError().sendTo(Console.errorStream())
                }
                fail(error) {
                    Console.printLine(error)
                    System.exit(1)
                }
            })
            t1.waitFor()
            t2.waitFor()
        }
        fail(error) {
            Console.printErrorLine(error)
            System.exit(1)
        }
        def exitCode := p.waitFor()
        if !preserveTemporaries {
            try {
                llvm.delete()
            }
            fail(error) {
                Console.printErrorLine(error)
                System.exit(1)
            }
        }
        if exitCode != 0 {
            System.exit(1)
        }
        return dest
    }

    method toExecutable(libraryPaths:Array<File>, libraries:Array<String>, llvm:File, dest:File,
            preserveTemporaries:Bit, settings:Compiler.Settings):File {
        def args := Array<String>() -- FIXME literal
        args.add(llvm.path)
        args.add("-L\{Config.frostLibDir()}")
        args.add("-lfrost")
        args.add("-lm")
        args.add("-lpthread")
        args.addAll(libraryPaths.map(p => "-L" + p))
        args.addAll(libraries.map(l => "-l" + l))
        def icuLibs := Config.icuLibraries().split(";")
        for lib in icuLibs {
            def libFile := File(lib)
            args.add("-L" + libFile.parent!)
            var simpleName := libFile.simpleName
            assert simpleName.startsWith("lib")
            simpleName := simpleName[3..]
            args.add("-l" + simpleName)
        }
        args.add("-m64")
        args.add("-fPIC")
        if settings.debug {
            args.add("-g")
        }
        args.add("-O\{settings.optimizationLevel}")
        args.add("-Wno-override-module")
        args.add("-o")
        args.add(dest.path)
        def p:System.Process
        try {
            p := System.exec(clang.path, args)
            Console.printError(p.standardOutput().readFully())
            Console.printError(p.standardError().readFully())
        }
        fail(error) {
            Console.printErrorLine(error)
            System.exit(1)
        }
        def exitCode := p.waitFor()
        if !preserveTemporaries {
            try {
                llvm.delete()
            }
            fail(error) {
                Console.printErrorLine(error)
                System.exit(1)
            }
        }
        if exitCode != 0 {
            System.exit(1)
        }
        return dest
    }

    method printUsage(out:OutputStream) {
        try {
            out.printLine("Usage: frostc [options] <sources>")
            out.printLine()
            out.printLine("Source filenames must end in '.frost'.")
            out.printLine()
            out.printLine("Options:")
            out.printLine("  -o <path>    output path")
        }
        fail(error) {
            unreachable
        }
    }

    method run(rawArgs:ListView<String>) {
        def args := Arguments(rawArgs)
        def sources := Array<File>()
        def imports := Array<File>()
        def libraryPaths := Array<File>()
        def libraries := Array<String>()
        var outFile:File? := null
        var optimizationLevel := 3
        var safetyLevel := 3
        var format:Format? := null
        var root:String? := null
        var preserveTemporaries := true
        var debug := true
        while !args.done {
            def a := args.next()
            match a {
                when "--fuzz" {
                    try {
                        def path := File("/tmp/fuzz.frost")
                        Console.inputStream().sendTo(path.openOutputStream())
                        sources.add(path)
                    }
                    fail(error) {
                        Console.printErrorLine(error)
                        System.exit(1)
                    }
                }
                when "-o" {
                    if outFile !== null {
                        Console.printErrorLine("'-o' may only be specified once")
                        System.exit(1)
                    }
                    outFile := File(args.next("a filename"))
                    try {
                        outFile.parent!.createDirectories()
                    }
                    fail(error) {
                        Console.printErrorLine(error)
                        System.exit(1)
                    }
                }
                when "-O" {
                    def level := args.next("a number from 0-3")
                    var parsed := level.asInt
                    if parsed == null | parsed > 3 | parsed < 0 {
                        Console.printErrorLine("expected a number from 0-3 after '-O'")
                        System.exit(1)
                    }
                    optimizationLevel := parsed
                }
                when "-S" {
                    def level := args.next("a number from 0-3")
                    def parsed := level.asInt
                    if parsed == null | parsed > 3 | parsed < 0 {
                        Console.printErrorLine("expected a number from 0-3 after '-S'")
                        System.exit(1)
                    }
                    safetyLevel := parsed
                }
                when "-f" {
                    if format !== null {
                        Console.printErrorLine("'-f' may only be specified once")
                        System.exit(1)
                    }
                    def f := args.next("an output format")
                    match f {
                        when "exe"  { format := Format.EXECUTABLE }
                        when "o"    { format := Format.OBJECT }
                        when "ll"   { format := Format.LLVM }
                        when "c"    { format := Format.C }
                        when "html" { format := Format.HTML }
                        when "stub" { format := Format.STUB }
                        when "run"  { format := Format.RUN }
                        otherwise {
                            Console.printErrorLine("unsupported output format '\{f}'")
                            System.exit(1)
                        }
                    }
                }
                when "-I" {
                    imports.add(File(args.next("a path to an import directory")))
                }
                when "-L" {
                    libraryPaths.add(File(args.next("a path to a library directory")))
                }
                when "-l" {
                    libraries.add(args.next("a library name"))
                }
                when "--root" {
                    root := args.next("a path")
                }
                otherwise {
                    if a.endsWith(".frost") {
                        def f := File(a)
                        sources.add(f)
                    }
                    else {
                        Console.printErrorLine("unrecognized argument '\{a}'")
                        System.exit(1)
                    }
                }
            }
        }
        if format == null | format != Format.STUB {
            imports.add(File(Config.frostLibDir()).resolve("stubs"))
        }
        imports.add(frostHome)
        def llvmDir := File(Config.llvmDir())
        clang := File("/usr/bin/clang")
        if sources.count = 0 {
            Console.printErrorLine("no input files specified")
            System.exit(1)
        }
        if format == null {
            format := Format.EXECUTABLE
        }
        if outFile == null & format != Format.RUN {
            if sources.count = 1 {
                def extension:String
                match format {
                    when Format.EXECUTABLE { extension := "" }
                    when Format.OBJECT     { extension := ".o" }
                    when Format.LLVM       { extension := ".ll" }
                    when Format.C          { extension := ".c" }
                    when Format.HTML       { extension := ".html" }
                    when Format.STUB       { extension := ".stub" }
                    otherwise {
                        Console.printErrorLine("output format requires a '-o' output to be " +
                                "specified")
                        System.exit(1)
                    }
                }
                outFile := sources[0].withExtension(extension)
            }
            else if format = Format.HTML {
                Console.printErrorLine("format 'html' requires exactly one input file")
                System.exit(1)
            }
            else {
                Console.printErrorLine("multiple input files specified, must use '-o' to specify " +
                        "output file")
                System.exit(1)
            }
        }
        var errorCount := 0
        var warningCount := 0
        def settings := Compiler.Settings(frostHome, imports, optimizationLevel, safetyLevel,
                debug)
        {
            def backend:Backend? := null
            try {
                match format {
                    when Format.LLVM {
                        backend := LLVMBackend(Config.llvmTriple(), outFile.openOutputStream())
                    }
                    when Format.EXECUTABLE, Format.OBJECT {
                        backend := LLVMBackend(Config.llvmTriple(),
                                outFile.withExtension(".ll").openOutputStream())
                    }
                    when Format.C {
                        backend := CBackend(outFile.openOutputStream())
                    }
                    when Format.STUB {
                        backend := StubBackend(outFile.openOutputStream())
                    }
                    when Format.RUN {
                        backend := Interpreter()
                    }
                }
            }
            fail(error) {
                Console.printErrorLine(error)
                System.exit(1)
            }
            def errorQueue := MessageQueue<Compiler.Message>()
            def compiler := Compiler(errorQueue, backend, settings)
            if format = Format.RUN {
                compiler.cg.allClassConstants := true
            }
            if format = Format.HTML {
                if root == null {
                    root := "."
                }
                HTMLProcessor(compiler).process(sources[0], outFile, root)
                return
            }
            if root !== null {
                Console.printErrorLine("--root requires 'html' output format")
                System.exit(1)
            }
            for s in sources {
                for cl in compiler.scan(s) {
                    compiler.markNonExternal(cl)
                }
            }
            for s in sources {
                compiler.compile(s)
            }
            compiler.finish()
            if format = Format.RUN {
                backend->Interpreter.run()
                return
            }
            while errorQueue.hasMessage() {
                def error := errorQueue.getMessage()
                -- FIXME stderr
                match error {
                    when Compiler.Message.ERROR(file, line, column, message) {
                        errorCount += 1
                        Console.printLine("\{file}:\{line}:\{column}: error: \{message}")
                    }
                    when Compiler.Message.WARNING(file, line, column, message) {
                        warningCount += 1
                        Console.printLine("\{file}:\{line}:\{column}: warning: \{message}")
                    }
                }
            }
        }
        if warningCount = 1 {
            -- FIXME stderr
            Console.printLine("1 warning")
        }
        else if warningCount > 0 {
            -- FIXME stderr
            Console.printLine("\{warningCount} warnings")
        }
        if errorCount = 0 {
            match format {
                when Format.EXECUTABLE {
                    toExecutable(libraryPaths, libraries, outFile.withExtension(".ll"), outFile,
                            preserveTemporaries, settings)
                }
                when Format.OBJECT {
                    toObject(outFile.withExtension(".ll"), outFile, preserveTemporaries, settings)
                }
            }
        }
        else {
            if errorCount = 1 {
                -- FIXME stderr
                Console.printLine("1 error")
            }
            else {
                -- FIXME stderr
                Console.printLine("\{errorCount} errors")
            }
            System.exit(1)
        }
    }
    
    @class
    method main(args:ListView<String>) {
        if args.count > 1 & args[1] = "--repeat" {
            loop {
                Main().run(args[1..])
            }
        }
        if args.count = 2 & args[1] = "--bench" {
            Bench().run()
            return
        }
        Main().run(args)
    }
}
