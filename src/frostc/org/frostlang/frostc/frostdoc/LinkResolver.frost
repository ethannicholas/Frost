package org.frostlang.frostc.frostdoc

uses org.frostlang.frostc.ClassDecl
uses org.frostlang.frostc.Compiler
uses org.frostlang.frostc.FieldDecl
uses org.frostlang.frostc.MethodDecl
uses org.frostlang.frostc.Methods
uses org.frostlang.frostc.Symbol
uses org.frostlang.frostc.Type
uses org.frostlang.frostc.parser.Token

class LinkResolver {
    @private
    def compiler:Compiler

    @private
    def docPath:File

    @private
    def contextClass:ClassDecl?

    @private
    def contextPackage:String?

    init(compiler:Compiler, docPath:File, context:ClassDecl?) {
        self.compiler := compiler
        self.docPath := docPath
        self.contextClass := context
    }

    init(compiler:Compiler, docPath:File, context:String?) {
        self.compiler := compiler
        self.docPath := docPath
        self.contextPackage := context
    }

    function matches(m:MethodDecl, parameters:ListView<Type>):Bit {
        if m.parameters.count != parameters.count {
            return false
        }
        for i in 0 .. parameters.count {
            if m.parameters[i].type != parameters[i] {
                return false
            }
        }
        return true
    }

    function getAPIPath():String {
        def base:String
        if contextClass !== null {
            return "../" * contextClass.name.find(".").count()
        }
        else {
            assert contextPackage !== null
            return "../" * (contextPackage.find(".").count() + 1)
        }
    }

    function linkTo(cl:ClassDecl):String {
        return getAPIPath() + cl.name.replace(".", "/") + ".html"
    }

    function linkTo(f:FieldDecl):String? {
        return linkTo(f.owner) + "#\{f.name}"
    }

    function linkTo(m:MethodDecl):String? {
        compiler.resolve(m)
        def result := MutableString(linkTo(m.owner))
        result.append("#")
        result.append(m.name)
        result.append("(")
        var separator := ""
        for p in m.parameters {
            result.append(separator)
            result.append(p.type)
            separator := ","
        }
        result.append(")")
        if m.returnType.name != "void" {
            result.append(":")
            result.append(m.returnType)
        }
        result.replace("&", "&amp;")
        result.replace("<", "&lt;")
        return result.finish()
    }

    function linkTo(s:Symbol):String? {
        match s.kind {
            when Symbol.Kind.FIELD {
                return linkTo(s->FieldDecl)
            }
            when Symbol.Kind.METHOD {
                return linkTo(s->MethodDecl)
            }
            otherwise {
                return null
            }
        }
    }

    method resolve(link:String):String? {
        def hash := link.indexOf("#")
        if hash !== null {
            def result := resolve(link[..hash])
            if result == null {
                return null
            }
            return result + link[hash..]
        }
        if link.startsWith("http") | link.endsWith(".html") {
            return link
        }
        if link.startsWith("example:") {
            return getAPIPath() + "../try.html?\{link['example:'.length..]}"
        }
        if link.endsWith(".md") {
            if docPath.resolve(link).exists() {
                return link.replace(".md", ".html")
            }
            return null
        }
        var cl := compiler.tryResolveClass(link)
        if cl !== null {
            return linkTo(cl)
        }
        if contextClass !== null & link.matches(/\w+/) {
            def s := compiler.getSymbolTable(contextClass)[link]
            if s !== null {
                return linkTo(s)
            }
        }
        if link.matches(/\w+(?:\.\w+)*/) {
            def index := link.lastIndexOf(".")
            if index !== null {
                cl := compiler.tryResolveClass(link[..index])
                if cl !== null {
                    def s := compiler.getSymbolTable(cl)[link[link.next(index)..]]
                    if s == null {
                        Console.printLine("could not resolve: \{link}")
                        return null
                    }
                    return linkTo(s)
                }
            }
        }
        def parsed := link.parse(/(\w+(?:\.\w+)*)\((.*)\)/)
        if parsed !== null {
            def parameters := Array<Type>()
            if parsed[1].trimmed != "" {
                def src := File(parsed[1])
                compiler.parser.start(src, compiler.files.count, parsed[1])
                compiler.files.add(src)
                loop {
                    def type := compiler.parser.type()
                    if type == null {
                        Console.printLine("could not parse: \{parsed[1]}")
                        return null
                    }
                    def converted := compiler.scanner.convertType(type)
                    def resolved := compiler.resolve(converted)
                    if resolved == null {
                        Console.printLine("could not resolve: \{type}")
                        return null
                    }
                    parameters.add(resolved)
                    if compiler.parser.checkNext(Token.Kind.COMMA) == null {
                        break
                    }
                }
            }
            def name := parsed[0]
            def index := name.lastIndexOf(".")
            def symbolName:String
            if index !== null {
                cl := compiler.tryResolveClass(name[..index])
                symbolName := name[name.next(index)..]
            }
            else {
                cl := contextClass
                symbolName := name
            }
            if cl !== null {
                def s := compiler.getSymbolTable(cl)[symbolName]
                if s == null {
                    return null
                }
                match s.kind {
                    when Symbol.Kind.METHOD {
                        if matches(s->MethodDecl, parameters) {
                            return linkTo(s)
                        }
                    }
                    when Symbol.Kind.METHODS {
                        for m in s->Methods.methods {
                            if matches(m, parameters) {
                                return linkTo(m)
                            }
                        }
                    }
                }
                return null
            }
        }
        return null
    }
}