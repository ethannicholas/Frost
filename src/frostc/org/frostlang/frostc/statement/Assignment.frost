package org.frostlang.frostc.statement

uses org.frostlang.frostc.ASTNode
uses org.frostlang.frostc.Compiler
uses org.frostlang.frostc.Compiler.TypeContext
uses org.frostlang.frostc.IR
uses org.frostlang.frostc.MethodPosition
uses org.frostlang.frostc.expression.Binary
uses org.frostlang.frostc.expression.Call
uses org.frostlang.frostc.lvalue.LValue

class Assignment {
    @class
    method compile(compiler:Compiler, position:MethodPosition, rawLeft:ASTNode, op:Binary.Operator,
            rawRight:ASTNode) {
        if !op.isAssignment {
            compiler.error(position, "not a statement")
            return
        }
        if op = Binary.Operator.ASSIGNMENT {
            match rawLeft {
                when ASTNode.BINARY(position, base, op, index) {
                    if op = Binary.Operator.INDEX {
                        def args := Array<ASTNode>()
                        def compiledBase := compiler.compileExpression(base, TypeContext.NON_VOID)
                        if compiledBase == null {
                            return
                        }
                        args.add(index)
                        args.add(rawRight)
                        Call.compile(compiler, MethodPosition(position,
                                compiler.currentMethodIndex), compiledBase, "[]:=", args,
                                TypeContext.UNSPECIFIED)
                        return
                    }
                }
            }
        }
        def left := LValue.compile(compiler, rawLeft)
        if left == null {
            return
        }
        def right:IR.Value?
        if op = Binary.Operator.ASSIGNMENT {
            right := compiler.compileExpression(rawRight, TypeContext.TYPE(left.type(), false))
        }
        else {
            def load := left.compileLoad()
            if load == null {
                return
            }
            right := Binary.compile(compiler, position,
                    ASTNode.IR_WRAPPER(position.asPosition, load), op.removeAssignment(), rawRight,
                    TypeContext.TYPE(left.type(), false))
        }
        if right == null {
            return
        }
        left.compileStore(right)
    }
}