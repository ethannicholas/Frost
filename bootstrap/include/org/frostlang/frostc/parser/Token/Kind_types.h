#pragma once
#include "frost_c.h"
#include "frost/core/Int_types.h"
typedef struct frost$core$String frost$core$String;
typedef struct frost$core$Class frost$core$Class;
#include "org/frostlang/frostc/parser/Token/Kind_types.h"

typedef struct org$frostlang$frostc$parser$Token$Kind {
    frost$core$Int $rawValue;
    union {
        struct {
        } $EOF;
        struct {
        } $SHIFTRIGHT;
        struct {
        } $REGEX;
        struct {
        } $DECIMAL;
        struct {
        } $BINARY;
        struct {
        } $HEX;
        struct {
        } $REAL;
        struct {
        } $SINGLE_QUOTE;
        struct {
        } $DOUBLE_QUOTE;
        struct {
        } $LINE_COMMENT;
        struct {
        } $BLOCK_COMMENT_START;
        struct {
        } $BLOCK_COMMENT_END;
        struct {
        } $DOC_COMMENT;
        struct {
        } $WHITESPACE;
        struct {
        } $ANNOTATION;
        struct {
        } $PACKAGE;
        struct {
        } $USES;
        struct {
        } $AS;
        struct {
        } $CLASS;
        struct {
        } $INTERFACE;
        struct {
        } $CHOICE;
        struct {
        } $FUNCTION;
        struct {
        } $METHOD;
        struct {
        } $INIT;
        struct {
        } $VAR;
        struct {
        } $DEF;
        struct {
        } $PROPERTY;
        struct {
        } $CONSTANT;
        struct {
        } $RETURN;
        struct {
        } $BREAK;
        struct {
        } $CONTINUE;
        struct {
        } $DO;
        struct {
        } $WHILE;
        struct {
        } $FOR;
        struct {
        } $BY;
        struct {
        } $IN;
        struct {
        } $LOOP;
        struct {
        } $IF;
        struct {
        } $ELSE;
        struct {
        } $MATCH;
        struct {
        } $WHEN;
        struct {
        } $OTHERWISE;
        struct {
        } $TRUE;
        struct {
        } $FALSE;
        struct {
        } $NULL;
        struct {
        } $ASSERT;
        struct {
        } $UNREACHABLE;
        struct {
        } $TRY;
        struct {
        } $FAIL;
        struct {
        } $SELF;
        struct {
        } $SUPER;
        struct {
        } $LAZY;
        struct {
        } $MODULE;
        struct {
        } $SPECIALIZATION;
        struct {
        } $IDENTIFIER;
        struct {
        } $NOT;
        struct {
        } $BITWISENOT;
        struct {
        } $ADD;
        struct {
        } $SUB;
        struct {
        } $MUL;
        struct {
        } $DIV;
        struct {
        } $INTDIV;
        struct {
        } $REM;
        struct {
        } $POW;
        struct {
        } $EQ;
        struct {
        } $NEQ;
        struct {
        } $IDENTITY;
        struct {
        } $NIDENTITY;
        struct {
        } $LT;
        struct {
        } $GT;
        struct {
        } $LTEQ;
        struct {
        } $GTEQ;
        struct {
        } $AND;
        struct {
        } $BITWISEAND;
        struct {
        } $OR;
        struct {
        } $BITWISEOR;
        struct {
        } $XOR;
        struct {
        } $BITWISEXOR;
        struct {
        } $SHIFTLEFT;
        struct {
        } $ASSIGNMENT;
        struct {
        } $ADDEQ;
        struct {
        } $SUBEQ;
        struct {
        } $MULEQ;
        struct {
        } $DIVEQ;
        struct {
        } $REMEQ;
        struct {
        } $INTDIVEQ;
        struct {
        } $POWEQ;
        struct {
        } $OREQ;
        struct {
        } $BITWISEOREQ;
        struct {
        } $ANDEQ;
        struct {
        } $BITWISEANDEQ;
        struct {
        } $XOREQ;
        struct {
        } $BITWISEXOREQ;
        struct {
        } $SHIFTLEFTEQ;
        struct {
        } $SHIFTRIGHTEQ;
        struct {
        } $CAST;
        struct {
        } $YIELDS;
        struct {
        } $YIELDS_METHOD;
        struct {
        } $YIELDS_IMMUTABLE;
        struct {
        } $YIELDS_METHOD_IMMUTABLE;
        struct {
        } $QUESTION;
        struct {
        } $COLON;
        struct {
        } $ELLIPSIS;
        struct {
        } $DOTDOT;
        struct {
        } $DOT;
        struct {
        } $LBRACE;
        struct {
        } $RBRACE;
        struct {
        } $LBRACKET;
        struct {
        } $RBRACKET;
        struct {
        } $LPAREN;
        struct {
        } $RPAREN;
        struct {
        } $COMMA;
        struct {
        } $BACKSLASH;
        struct {
        } $INVALID;
    } $data;
} org$frostlang$frostc$parser$Token$Kind;
#include "frost/core/Class.h"
typedef struct { frost$core$Class* cl; int32_t refCount; uint8_t flags;frost$core$String* name; frost$core$Class* super; ITable* itable; void* vtable[5]; } org$frostlang$frostc$parser$Token$Kind$class_type;
extern org$frostlang$frostc$parser$Token$Kind$class_type org$frostlang$frostc$parser$Token$Kind$class;
typedef struct org$frostlang$frostc$parser$Token$Kind$wrapper {
    frost$core$Class* cl;
    int32_t refCount;
    uint8_t flags;
    org$frostlang$frostc$parser$Token$Kind value;
} org$frostlang$frostc$parser$Token$Kind$wrapper;
typedef struct org$frostlang$frostc$parser$Token$Kind$nullable {
    org$frostlang$frostc$parser$Token$Kind value;
    bool nonnull;
} org$frostlang$frostc$parser$Token$Kind$nullable;
typedef struct { frost$core$Class* cl; int32_t refCount; uint8_t flags; frost$core$String* name; frost$core$Class* super; ITable* itable; void* vtable[2]; } org$frostlang$frostc$parser$Token$Kind$wrapperclass_type;
extern org$frostlang$frostc$parser$Token$Kind$wrapperclass_type org$frostlang$frostc$parser$Token$Kind$wrapperclass;

