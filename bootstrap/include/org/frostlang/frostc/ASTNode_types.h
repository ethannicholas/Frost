#pragma once
#include "frost_c.h"
typedef struct frost$core$Class frost$core$Class;
#include "frost/core/Int32_types.h"
#include "frost/core/UInt8_types.h"
#include "frost/core/Int_types.h"
#include "org/frostlang/frostc/Position_types.h"
typedef struct frost$core$String frost$core$String;
typedef struct org$frostlang$frostc$ASTNode org$frostlang$frostc$ASTNode;
typedef struct org$frostlang$frostc$FixedArray org$frostlang$frostc$FixedArray;
#include "org/frostlang/frostc/expression/Binary/Operator_types.h"
#include "frost/core/Bit_types.h"
typedef struct org$frostlang$frostc$ChoiceCase org$frostlang$frostc$ChoiceCase;
#include "org/frostlang/frostc/ClassDecl/Kind_types.h"
#include "frost/core/UInt64_types.h"
typedef struct org$frostlang$frostc$IR$Value org$frostlang$frostc$IR$Value;
#include "org/frostlang/frostc/MethodDecl/Kind_types.h"
#include "org/frostlang/frostc/parser/Token/Kind_types.h"
#include "frost/core/Real64_types.h"
#include "org/frostlang/frostc/expression/Unary/Operator_types.h"
#include "org/frostlang/frostc/Variable/Kind_types.h"

typedef struct org$frostlang$frostc$ASTNode {
    frost$core$Class* $class;
    frost$core$Int32 refCount;
    frost$core$UInt8 $flags;
    frost$core$Int $rawValue;
    union {
        struct {
            org$frostlang$frostc$Position field0;
            frost$core$String* field1;
            frost$core$String* field2;
            org$frostlang$frostc$ASTNode* field3;
        } $ANNOTATION;
        struct {
            org$frostlang$frostc$Position field0;
            org$frostlang$frostc$FixedArray* field1;
        } $ARRAY;
        struct {
            org$frostlang$frostc$Position field0;
            org$frostlang$frostc$ASTNode* field1;
            org$frostlang$frostc$ASTNode* field2;
        } $ASSERT;
        struct {
            org$frostlang$frostc$Position field0;
            org$frostlang$frostc$ASTNode* field1;
        } $AT_PRE;
        struct {
            org$frostlang$frostc$Position field0;
        } $AT_RETURN;
        struct {
            org$frostlang$frostc$Position field0;
            org$frostlang$frostc$ASTNode* field1;
            org$frostlang$frostc$expression$Binary$Operator field2;
            org$frostlang$frostc$ASTNode* field3;
        } $BINARY;
        struct {
            org$frostlang$frostc$Position field0;
            frost$core$Bit field1;
        } $BIT;
        struct {
            org$frostlang$frostc$Position field0;
            org$frostlang$frostc$FixedArray* field1;
        } $BLOCK;
        struct {
            org$frostlang$frostc$Position field0;
            frost$core$String* field1;
        } $BREAK;
        struct {
            org$frostlang$frostc$Position field0;
            org$frostlang$frostc$ASTNode* field1;
            org$frostlang$frostc$FixedArray* field2;
        } $CALL;
        struct {
            org$frostlang$frostc$Position field0;
            org$frostlang$frostc$ASTNode* field1;
            frost$core$String* field2;
            org$frostlang$frostc$FixedArray* field3;
        } $CHOICE_CASE;
        struct {
            org$frostlang$frostc$Position field0;
            org$frostlang$frostc$ASTNode* field1;
            org$frostlang$frostc$ChoiceCase* field2;
            frost$core$Int field3;
        } $CHOICE_FIELD_REFERENCE;
        struct {
            org$frostlang$frostc$Position field0;
            org$frostlang$frostc$ASTNode* field1;
            org$frostlang$frostc$FixedArray* field2;
            org$frostlang$frostc$ClassDecl$Kind field3;
            frost$core$String* field4;
            org$frostlang$frostc$FixedArray* field5;
            org$frostlang$frostc$FixedArray* field6;
            org$frostlang$frostc$FixedArray* field7;
        } $CLASS;
        struct {
            org$frostlang$frostc$Position field0;
            frost$core$String* field1;
        } $CONTINUE;
        struct {
            org$frostlang$frostc$Position field0;
            org$frostlang$frostc$ASTNode* field1;
            org$frostlang$frostc$ASTNode* field2;
        } $DECLARATION;
        struct {
            org$frostlang$frostc$Position field0;
            frost$core$String* field1;
            org$frostlang$frostc$FixedArray* field2;
            org$frostlang$frostc$ASTNode* field3;
        } $DO;
        struct {
            org$frostlang$frostc$Position field0;
            org$frostlang$frostc$ASTNode* field1;
            frost$core$String* field2;
        } $DOT;
        struct {
            org$frostlang$frostc$Position field0;
            org$frostlang$frostc$ASTNode* field1;
            frost$core$String* field2;
            org$frostlang$frostc$FixedArray* field3;
        } $DOT_GENERICS;
        struct {
            org$frostlang$frostc$Position field0;
            org$frostlang$frostc$ASTNode* field1;
            org$frostlang$frostc$FixedArray* field2;
            org$frostlang$frostc$ASTNode* field3;
        } $FIELD;
        struct {
            org$frostlang$frostc$FixedArray* field0;
        } $FILE;
        struct {
            org$frostlang$frostc$Position field0;
            frost$core$String* field1;
            org$frostlang$frostc$ASTNode* field2;
            org$frostlang$frostc$ASTNode* field3;
            org$frostlang$frostc$FixedArray* field4;
        } $FOR;
        struct {
            org$frostlang$frostc$Position field0;
            frost$core$String* field1;
            org$frostlang$frostc$FixedArray* field2;
        } $GENERIC_TYPE;
        struct {
            org$frostlang$frostc$Position field0;
            frost$core$String* field1;
        } $IDENTIFIER;
        struct {
            org$frostlang$frostc$Position field0;
            frost$core$String* field1;
            org$frostlang$frostc$FixedArray* field2;
        } $IDENTIFIER_GENERICS;
        struct {
            org$frostlang$frostc$Position field0;
            org$frostlang$frostc$ASTNode* field1;
            org$frostlang$frostc$FixedArray* field2;
            org$frostlang$frostc$ASTNode* field3;
        } $IF;
        struct {
            org$frostlang$frostc$Position field0;
            frost$core$UInt64 field1;
        } $INT;
        struct {
            org$frostlang$frostc$Position field0;
            org$frostlang$frostc$IR$Value* field1;
        } $IR_WRAPPER;
        struct {
            org$frostlang$frostc$Position field0;
            frost$core$String* field1;
            org$frostlang$frostc$FixedArray* field2;
        } $LOOP;
        struct {
            org$frostlang$frostc$Position field0;
            org$frostlang$frostc$ASTNode* field1;
            org$frostlang$frostc$FixedArray* field2;
            org$frostlang$frostc$FixedArray* field3;
        } $MATCH;
        struct {
            org$frostlang$frostc$Position field0;
            org$frostlang$frostc$ASTNode* field1;
            org$frostlang$frostc$FixedArray* field2;
            org$frostlang$frostc$MethodDecl$Kind field3;
            frost$core$String* field4;
            org$frostlang$frostc$FixedArray* field5;
            org$frostlang$frostc$FixedArray* field6;
            org$frostlang$frostc$ASTNode* field7;
            org$frostlang$frostc$FixedArray* field8;
        } $METHOD;
        struct {
            org$frostlang$frostc$Position field0;
            org$frostlang$frostc$parser$Token$Kind field1;
            org$frostlang$frostc$FixedArray* field2;
            org$frostlang$frostc$ASTNode* field3;
        } $METHOD_TYPE;
        struct {
            org$frostlang$frostc$Position field0;
        } $NULL;
        struct {
            org$frostlang$frostc$Position field0;
            org$frostlang$frostc$ASTNode* field1;
        } $NULLABLE_TYPE;
        struct {
            org$frostlang$frostc$Position field0;
            frost$core$String* field1;
        } $PACKAGE;
        struct {
            org$frostlang$frostc$Position field0;
            frost$core$String* field1;
            org$frostlang$frostc$ASTNode* field2;
        } $PARAMETER;
        struct {
            org$frostlang$frostc$Position field0;
            org$frostlang$frostc$ASTNode* field1;
            frost$core$Bit field2;
            org$frostlang$frostc$ASTNode* field3;
            org$frostlang$frostc$ASTNode* field4;
        } $RANGE;
        struct {
            org$frostlang$frostc$Position field0;
            frost$core$Real64 field1;
        } $REAL;
        struct {
            org$frostlang$frostc$Position field0;
            frost$core$String* field1;
        } $REGEX;
        struct {
            org$frostlang$frostc$Position field0;
            org$frostlang$frostc$ASTNode* field1;
        } $RETURN;
        struct {
            org$frostlang$frostc$Position field0;
        } $SELF;
        struct {
            org$frostlang$frostc$Position field0;
            frost$core$String* field1;
        } $STRING;
        struct {
            org$frostlang$frostc$Position field0;
        } $SUPER;
        struct {
            org$frostlang$frostc$Position field0;
            org$frostlang$frostc$FixedArray* field1;
            org$frostlang$frostc$ASTNode* field2;
            org$frostlang$frostc$FixedArray* field3;
        } $TRY;
        struct {
            org$frostlang$frostc$Position field0;
            org$frostlang$frostc$FixedArray* field1;
        } $TUPLE;
        struct {
            org$frostlang$frostc$Position field0;
            org$frostlang$frostc$FixedArray* field1;
        } $TUPLE_TARGET;
        struct {
            org$frostlang$frostc$Position field0;
            org$frostlang$frostc$FixedArray* field1;
        } $TUPLE_TYPE;
        struct {
            org$frostlang$frostc$Position field0;
            frost$core$String* field1;
        } $TYPE;
        struct {
            org$frostlang$frostc$Position field0;
            org$frostlang$frostc$FixedArray* field1;
            org$frostlang$frostc$ASTNode* field2;
        } $TYPED_LAMBDA;
        struct {
            org$frostlang$frostc$Position field0;
            frost$core$String* field1;
            org$frostlang$frostc$ASTNode* field2;
        } $TYPED_IDENTIFIER;
        struct {
            org$frostlang$frostc$Position field0;
            org$frostlang$frostc$expression$Unary$Operator field1;
            org$frostlang$frostc$ASTNode* field2;
        } $UNARY;
        struct {
            org$frostlang$frostc$Position field0;
            org$frostlang$frostc$ASTNode* field1;
        } $UNREACHABLE;
        struct {
            org$frostlang$frostc$Position field0;
            org$frostlang$frostc$FixedArray* field1;
            org$frostlang$frostc$ASTNode* field2;
        } $UNTYPED_LAMBDA;
        struct {
            org$frostlang$frostc$Position field0;
            frost$core$String* field1;
        } $USES;
        struct {
            org$frostlang$frostc$Position field0;
            org$frostlang$frostc$Variable$Kind field1;
            org$frostlang$frostc$FixedArray* field2;
        } $VAR;
        struct {
            org$frostlang$frostc$Position field0;
            org$frostlang$frostc$FixedArray* field1;
            org$frostlang$frostc$FixedArray* field2;
        } $WHEN;
        struct {
            org$frostlang$frostc$Position field0;
            frost$core$String* field1;
            org$frostlang$frostc$ASTNode* field2;
            org$frostlang$frostc$FixedArray* field3;
        } $WHILE;
    } $data;
} org$frostlang$frostc$ASTNode;
#include "frost/core/Class.h"
typedef struct { frost$core$Class* cl; int32_t refCount; uint8_t flags;frost$core$String* name; frost$core$Class* super; ITable* itable; void* vtable[3]; } org$frostlang$frostc$ASTNode$class_type;
extern org$frostlang$frostc$ASTNode$class_type org$frostlang$frostc$ASTNode$class;

